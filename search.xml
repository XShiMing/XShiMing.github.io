<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hexo+阿里云ECS服务器</title>
      <link href="blog/e1316ade/"/>
      <url>blog/e1316ade/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="安装nginx，git，node-js"><a href="#安装nginx，git，node-js" class="headerlink" title="安装nginx，git，node.js"></a>安装nginx，git，node.js</h2><p>安装git，nodejs</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装Git</span></span><br><span class="line">yum install git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装Node</span></span><br><span class="line">curl -sL https://rpm.nodesource.com/setup_10.x | bash -</span><br><span class="line">yum install -y nodejs</span><br></pre></td></tr></table></figure><blockquote><p>nginx安装参考<a href="https://www.shiming.online/blog/58122/">nginx安装</a></p></blockquote><p>安装完成后修改nginx配置：<br>在nginx文件夹中创建vhost文件夹，然后在<code>vhost</code>中创建博客的配置<code>blog.conf</code>，最后将<code>blog.conf</code>添加到<code>nginx.conf</code>中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nginx文件夹中创建vhost</span></span><br><span class="line">mkdir vhost</span><br><span class="line"><span class="comment"># 创建博客配置文件</span></span><br><span class="line">vim vhost/blog.conf</span><br></pre></td></tr></table></figure><p>内容如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">        <span class="comment"># 监听443端口https请求</span></span><br><span class="line">        listen 443 ssl;</span><br><span class="line">        <span class="comment"># 域名：通过shiming.online和www.shiming.online都能访问</span></span><br><span class="line">        server_name shiming.online www.shiming.online;</span><br><span class="line"></span><br><span class="line">        charset utf-8;</span><br><span class="line">        <span class="comment"># 如果域名不为 www.shiming.online 统一跳转到 https://www.shiming.online/</span></span><br><span class="line">        <span class="keyword">if</span> ( <span class="variable">$host</span> != <span class="string">&#x27;www.shiming.online&#x27;</span>  ) &#123;</span><br><span class="line"></span><br><span class="line">                rewrite ^/(.*) http://www.shiming.online/<span class="variable">$1</span> permanent;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># ssl设置</span></span><br><span class="line">        ssl_certificate /usr/<span class="built_in">local</span>/nginx/1_shiming.online_bundle.crt;</span><br><span class="line">        ssl_certificate_key /usr/<span class="built_in">local</span>/nginx/2_shiming.online.key;</span><br><span class="line">        ssl_session_timeout 5m;</span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 博客位置，稍后创建</span></span><br><span class="line">        location / &#123;</span><br><span class="line">                root /var/www/hexo;</span><br><span class="line">                index index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        <span class="comment"># 监听80端口http请求，并最后统一为：https://www.shiming.online/</span></span><br><span class="line">        listen 80;</span><br><span class="line">        server_name shiming.online www.shiming.online;</span><br><span class="line">        server_name shiming.online www.shiming.online;</span><br><span class="line"></span><br><span class="line">        rewrite ^/(.*) https://www.shiming.online/<span class="variable">$1</span> permanent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在<code>nginx.conf</code>中导入<code>blog.conf</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在#gzip  on;注释后添加</span></span><br><span class="line">include /usr/<span class="built_in">local</span>/nginx/vhost/*.conf;</span><br></pre></td></tr></table></figure><p>建立博客目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var</span><br><span class="line">mkdir www</span><br><span class="line">mkdir www/hexo</span><br></pre></td></tr></table></figure><h2 id="创建git用户"><a href="#创建git用户" class="headerlink" title="创建git用户"></a>创建git用户</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加git用户</span></span><br><span class="line">adduser git</span><br><span class="line"><span class="comment"># 修改文件权限</span></span><br><span class="line">chmod 740 /etc/sudoers</span><br><span class="line"><span class="comment"># 打开文件</span></span><br><span class="line">vim /etc/sudoers</span><br></pre></td></tr></table></figure><p>进入后按i键由命令模式切换到编辑模式。找到 root ALL=(ALL) ALL，在下面添加一行 git ALL=(ALL) ALL。（使用tab对对齐）。修改完成后，先按Esc由编辑模式切换到命令模式，再输入:wq命令保存并退出编辑器。</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/2020-11-15/20201115115155.png-img" alt="20201115115155"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保存退出后改回权限</span></span><br><span class="line">chmod 400 /etc/sudoers</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置git用户密码</span></span><br><span class="line">sudo passwd git</span><br></pre></td></tr></table></figure><p>设置自己的密码，这样就可以使用git用户远程登录云服务器了。</p><h3 id="git用户配置ssh免密"><a href="#git用户配置ssh免密" class="headerlink" title="git用户配置ssh免密"></a>git用户配置ssh免密</h3><h4 id="本地生成密钥"><a href="#本地生成密钥" class="headerlink" title="本地生成密钥"></a>本地生成密钥</h4><p>打开本地git.bash程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成密钥，一路回车就行</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;your_email@example.com&quot;</span></span><br></pre></td></tr></table></figure><p>生成ssh 密钥后，可以到~/.ssh目录下查看相关文件，一般来说ssh 密钥会包含id_rsa和id_rsa.pub两个文件，分别表示生成的私钥和公钥。</p><ul><li>在git等源代码管理中，使用cat ~/.ssh/id_rsa.pub命令，打印并将相应内容复制到源代码管理服务器即可实现git的无密码管理</li><li>也可以直接打开本地文件夹<code>C:\Users\你的用户名\.ssh</code>，复制id_rsa.pub文件内容</li></ul><h4 id="服务器存放公钥"><a href="#服务器存放公钥" class="headerlink" title="服务器存放公钥"></a>服务器存放公钥</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换git用户。不切换的话就是给当前登录用户设置ssh免密了。</span></span><br><span class="line">su git</span><br><span class="line"><span class="comment"># 创建~/.ssh/authorized_keys文件</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">mkdir .ssh</span><br><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br><span class="line">vim authorized_keys</span><br><span class="line"><span class="comment"># 将刚才复制的本地公钥添加到authorized_keys中</span></span><br><span class="line"><span class="comment"># 如果后面需要添加其他机器，也是将他们的公钥添加到这个文件中</span></span><br></pre></td></tr></table></figure><p>设置文件权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 600 ~/.ssh/authorized_keys</span><br><span class="line">chmod 700 ~/.ssh</span><br></pre></td></tr></table></figure><p>输入<code>exit</code>退出。</p><p>在本地计算机上使用git用户连接云服务器将不提示输入密码</p><p>尝试使用ssh方式登录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh git@服务器公网ip</span><br></pre></td></tr></table></figure><h4 id="修改git用户权限（可选0"><a href="#修改git用户权限（可选0" class="headerlink" title="修改git用户权限（可选0"></a>修改git用户权限（可选0</h4><p>为了安全起见，使git用户只能推送和拉取，而不能使用ssh登录，修改用户权限。</p><p>修改/etc/passwd文件中git用户权限为git-shell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/passwd</span><br></pre></td></tr></table></figure><p>将<code>git:x:1002:1002::/home/git:/bin/bash</code>      改为：       <code>git:x:1002:1002::/home/git:/usr/bin/git-shell</code></p><p>例：</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/2020-11-15/20201115121227.png-img" alt="20201115121227"></p><h2 id="创建git仓库"><a href="#创建git仓库" class="headerlink" title="创建git仓库"></a>创建git仓库</h2><p>使用root用户登录后切换到git仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var/repo</span><br><span class="line">git init --bare blog.git</span><br><span class="line">vim /var/repo/blog.git/hooks/post-receive</span><br></pre></td></tr></table></figure><p>文件内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git --work-tree=/var/www/hexo --git-dir=/var/repo/blog.git checkout -f</span><br><span class="line"><span class="comment"># work-tree为博客地址，git-dir为git仓库地址，根据自己的文件位置修改</span></span><br></pre></td></tr></table></figure><p>保存并退出</p><p>修改权限</p><p><code>chmod +x ~/blog.git/hooks/post-receive</code></p><p>修改blog.git的拥有者为git</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R git /var/repo/blog.git</span><br></pre></td></tr></table></figure><p>修改博客存放目录权限，使任何人可写</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R 777 /var/www</span><br></pre></td></tr></table></figure><h2 id="Hexo配置"><a href="#Hexo配置" class="headerlink" title="Hexo配置"></a>Hexo配置</h2><p>用github相同，修改_config.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git@github.com:XShiMing/XShiMing.github.io.git</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git@服务器ip:/var/repo/blog.git</span></span><br><span class="line">  <span class="comment"># - git@gitee.com:xshiming/shiming.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br><span class="line"><span class="comment"># 发布博客，然后就可以在nginx设置的域名中访问网站了。</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx配置SSL</title>
      <link href="blog/1d917cf3/"/>
      <url>blog/1d917cf3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>nginx如果使用https访问就需要配置SSL证书，而本文主要记录nginx如果配置SSL证书。</p><h2 id="nginx安装ssl模块"><a href="#nginx安装ssl模块" class="headerlink" title="nginx安装ssl模块"></a>nginx安装ssl模块</h2><p>检测是否安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/nginx/nginx -V</span><br></pre></td></tr></table></figure><p>如果出现 <code>configure arguments: –with-http_ssl_module</code>, 则已安装（下面的步骤可以跳过，进入 nginx.conf 配置）。</p><p>进入nginx解压目录，添加ssl模块</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入你自己的nginx解压位置</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/nginx-1.10.1</span><br><span class="line"></span><br><span class="line">./configure --with-http_ssl_module</span><br></pre></td></tr></table></figure><blockquote><p>执行以上一条命令出现（./configure：错误：SSL 模块需要 OpenSSL 库。），原因是因为缺少了 OpenSSL，那我们再来安装一个即可执行：yum -y install openssl openssl-devel  等待 OpenSSL 的安装完成后，再执行./configure</p></blockquote><p>执行make命令重新编译（（使用 make install 会重新安装 nginx），此时当前目录会出现 objs 文件夹。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译</span></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line"><span class="comment"># 备份原程序，再用新nginx覆盖原程序</span></span><br><span class="line">cp /usr/<span class="built_in">local</span>/nginx/nginx /usr/<span class="built_in">local</span>/nginx/nginx.bak //备份，不备份则不用执行</span><br><span class="line"></span><br><span class="line">cp objs/nginx /usr/<span class="built_in">local</span>/nginx/nginx</span><br></pre></td></tr></table></figure><p>再次查看安装的模块（configure arguments: –with-http_ssl_module 说明 ssl 模块已安装）。</p><h2 id="修改nginx配置文件"><a href="#修改nginx配置文件" class="headerlink" title="修改nginx配置文件"></a>修改nginx配置文件</h2><p>在下载的SSL证书文件有一个nginx文件夹，里面有两个文件。</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/2020-11-15/20201115133555.png" alt="20201115133555"></p><p>这两个文件都需要用到</p><p>然后找到nginx的配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep nginx</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/2020-11-15/20201115133717.png" alt="20201115133717"></p><p>得知nginx目录为<code>/usr/local/nginx</code></p><p>修改nginx目录下的nginx.conf文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加server节点</span></span><br><span class="line">server&#123;</span><br><span class="line">        <span class="comment"># 监听443端口</span></span><br><span class="line">        listen 443 ssl;</span><br><span class="line">        <span class="comment"># 对应域名</span></span><br><span class="line">        server_name shiming.online www.shiming.online;</span><br><span class="line"></span><br><span class="line">        charset utf-8;</span><br><span class="line">        <span class="comment"># 统一为https://www.shiming.online/</span></span><br><span class="line">        <span class="keyword">if</span> ( <span class="variable">$host</span> != <span class="string">&#x27;www.shiming.online&#x27;</span>  ) &#123;</span><br><span class="line">                rewrite ^/(.*) http://www.shiming.online/<span class="variable">$1</span> permanent;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 证书第一个文件路径</span></span><br><span class="line">        ssl_certificate /usr/<span class="built_in">local</span>/nginx/1_shiming.online_bundle.crt;</span><br><span class="line">        <span class="comment"># 证书第二个文件路径</span></span><br><span class="line">        ssl_certificate_key /usr/<span class="built_in">local</span>/nginx/2_shiming.online.key;</span><br><span class="line">        ssl_session_timeout 5m;</span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line">        <span class="comment"># 网页访问地址</span></span><br><span class="line">        location / &#123;</span><br><span class="line">                root /var/www/hexo;</span><br><span class="line">                index index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name shiming.online www.shiming.online;</span><br><span class="line">        <span class="comment"># 统一为https://www.shiming.online/</span></span><br><span class="line">        rewrite ^/(.*) https://www.shiming.online/<span class="variable">$1</span> permanent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试配置文件修改是否正常</span></span><br><span class="line">/usr/<span class="built_in">local</span>/nginx/nginx -t</span><br><span class="line"><span class="comment"># 重新加载</span></span><br><span class="line">/usr/<span class="built_in">local</span>/nginx/nginx -s reload</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> nginx </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo进阶</title>
      <link href="blog/4530c0eb/"/>
      <url>blog/4530c0eb/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="主题-ButterFly"><a href="#主题-ButterFly" class="headerlink" title="主题: ButterFly"></a>主题: ButterFly</h2><blockquote><p><a href="https://butterfly.js.org/">ButterFly博客</a></p></blockquote><h2 id="唯一文章链接：hexo-abbrlink"><a href="#唯一文章链接：hexo-abbrlink" class="headerlink" title="唯一文章链接：hexo-abbrlink"></a>唯一文章链接：hexo-abbrlink</h2><blockquote><p><a href="https://github.com/Rozbo/hexo-abbrlink">Hexo-abbrlink</a></p></blockquote><p>hexo默认的链接中，会将中文链接转换为一长串字符，而abbrlink可以为每一篇文章生成唯一的uri链接</p><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><p>修改hexo配置文件<code>config.yml</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:abbrlink.html</span>  <span class="comment"># 此处可以自己设置，也可以直接使用 :/abbrlink</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">    <span class="attr">alg:</span> <span class="string">crc32</span>   <span class="comment">#算法： crc16(default) and crc32</span></span><br><span class="line">    <span class="attr">rep:</span> <span class="string">hex</span>     <span class="comment">#进制： dec(default) and hex</span></span><br></pre></td></tr></table></figure><h2 id="本地搜索：hexo-generator-search"><a href="#本地搜索：hexo-generator-search" class="headerlink" title="本地搜索：hexo-generator-search"></a>本地搜索：hexo-generator-search</h2><blockquote><p><a href="https://github.com/wzpan/hexo-generator-search">hexo-generator-search</a></p></blockquote><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><p>修改配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">content:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="音乐：hexo-tag-aplayer"><a href="#音乐：hexo-tag-aplayer" class="headerlink" title="音乐：hexo-tag-aplayer"></a>音乐：hexo-tag-aplayer</h2><blockquote><p><a href="https://github.com/MoePlayer/hexo-tag-aplayer">hexo-tag-aplayer</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-tag-aplayer</span><br></pre></td></tr></table></figure><h2 id="RSS订阅：hexo-generator-feed"><a href="#RSS订阅：hexo-generator-feed" class="headerlink" title="RSS订阅：hexo-generator-feed"></a>RSS订阅：hexo-generator-feed</h2><blockquote><p><a href="https://github.com/hexojs/hexo-generator-feed">hexo-generator-feed</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure><h2 id="字数统计：Hexo-WordCount"><a href="#字数统计：Hexo-WordCount" class="headerlink" title="字数统计：Hexo-WordCount"></a>字数统计：Hexo-WordCount</h2><blockquote><p><a href="https://github.com/willin/hexo-wordcount">Hexo-WordCount</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save hexo-wordcount</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL练习</title>
      <link href="blog/f37f1f3f/"/>
      <url>blog/f37f1f3f/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>1 查询” 01 “课程比 “ 02 “课程成绩高的学生的信息及课程分数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  A.*,</span><br><span class="line">  B.cid,</span><br><span class="line">  B.score</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  ( <span class="keyword">SELECT</span> <span class="keyword">sid</span>, cid, score <span class="keyword">FROM</span> sc <span class="keyword">WHERE</span> cid = <span class="string">&quot;01&quot;</span> ) A</span><br><span class="line">  <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> ( <span class="keyword">SELECT</span> <span class="keyword">sid</span>, cid, score <span class="keyword">FROM</span> sc <span class="keyword">WHERE</span> cid = <span class="string">&quot;02&quot;</span> ) B <span class="keyword">ON</span> A.sid = B.sid</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  A.score &gt; B.score</span><br></pre></td></tr></table></figure><p>1.1 查询同时存在” 01 “课程和” 02 “课程的情况</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  A.*,</span><br><span class="line">  B.cid,</span><br><span class="line">  B.score</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  ( <span class="keyword">SELECT</span> <span class="keyword">sid</span>, cid, score <span class="keyword">FROM</span> sc <span class="keyword">WHERE</span> cid = <span class="string">&quot;01&quot;</span> ) A</span><br><span class="line">  <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> ( <span class="keyword">SELECT</span> <span class="keyword">sid</span>, cid, score <span class="keyword">FROM</span> sc <span class="keyword">WHERE</span> cid = <span class="string">&quot;02&quot;</span> ) B <span class="keyword">ON</span> A.sid = B.sid</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  b.sid <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br></pre></td></tr></table></figure><p>1.2 查询存在” 01 “课程但可能不存在” 02 “课程的情况(不存在时显示为null)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  A.*,</span><br><span class="line">  B.cid,</span><br><span class="line">  B.score</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  ( <span class="keyword">SELECT</span> <span class="keyword">sid</span>, cid, score <span class="keyword">FROM</span> sc <span class="keyword">WHERE</span> cid = <span class="string">&quot;01&quot;</span> ) A</span><br><span class="line">  <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> ( <span class="keyword">SELECT</span> <span class="keyword">sid</span>, cid, score <span class="keyword">FROM</span> sc <span class="keyword">WHERE</span> cid = <span class="string">&quot;02&quot;</span> ) B <span class="keyword">ON</span> A.sid = B.sid</span><br></pre></td></tr></table></figure><p>1.3 查询不存在” 01 “课程但存在” 02 “课程的情况</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  <span class="keyword">sid</span>,</span><br><span class="line">  cid,</span><br><span class="line">  score</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  sc</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  cid = <span class="string">&#x27;02&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> <span class="keyword">sid</span> <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">  <span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">sid</span></span><br><span class="line">  <span class="keyword">FROM</span></span><br><span class="line">    sc</span><br><span class="line">  <span class="keyword">WHERE</span></span><br><span class="line">    cid = <span class="string">&#x27;01&#x27;</span>)</span><br></pre></td></tr></table></figure><p>2 查询平均成绩大于等于 60 分的同学的学生编号和学生姓名和平均成绩</p>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>行为型模式</title>
      <link href="blog/e55dcfb0/"/>
      <url>blog/e55dcfb0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note warning flat"><p>本博客大部分内容来于<a href="https://refactoringguru.cn/design-patterns">免费在线学习设计模式</a></p></div><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>迭代器模式是一种行为设计模式， 让你能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。</p><h3 id="迭代器模式问题"><a href="#迭代器模式问题" class="headerlink" title="迭代器模式问题"></a>迭代器模式问题</h3><p>在现实生活以及程序设计中，经常要访问一个聚合对象中的各个元素，如“数据结构”中的链表遍历，通常的做法是将链表的创建和遍历都放在同一个类中，但这种方式不利于程序的扩展，如果要更换遍历方法就必须修改程序源代码，这违背了 “开闭原则”。而且不断向集合中添加遍历算法会模糊其 “高效存储数据” 的主要职责。 此外， 有些算法可能是根据特定应用订制的， 将其加入泛型集合类中会显得非常奇怪。</p><p>另一方面， 使用多种集合的客户端代码可能并不关心存储数据的方式。 不过由于集合提供不同的元素访问方式， 你的代码将不得不与特定集合类进行耦合。</p><p>既然将遍历方法封装在聚合类中不可取，那么聚合类中不提供遍历方法，将遍历方法由用户自己实现是否可行呢？答案是同样不可取，因为这种方式会存在两个缺点：</p><ol><li>暴露了聚合类的内部表示，使其数据不安全；</li><li>增加了客户的负担。</li></ol><h3 id="迭代器模式解决方案"><a href="#迭代器模式解决方案" class="headerlink" title="迭代器模式解决方案"></a>迭代器模式解决方案</h3><p>迭代器模式的主要思想是将集合的遍历行为抽取为单独的迭代器对象。</p><p>所有迭代器必须实现相同的接口。 这样一来， 只要有合适的迭代器， 客户端代码就能兼容任何类型的集合或遍历算法。 如果你需要采用特殊方式来遍历集合， 只需创建一个新的迭代器类即可， 无需对集合或客户端进行修改。</p><h3 id="迭代器模式结构"><a href="#迭代器模式结构" class="headerlink" title="迭代器模式结构"></a>迭代器模式结构</h3><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200830122622.png" alt="20200830122622"></p><ol><li><strong>迭代器</strong> （Iterator） 接口声明了遍历集合所需的操作： 获取下一个元素、 获取当前位置和重新开始迭代等。</li><li><strong>具体迭代器</strong> （Concrete Iterators） 实现遍历集合的一种特定算法。 迭代器对象必须跟踪自身遍历的进度。 这使得多个迭代器可以相互独立地遍历同一集合。</li><li><strong>集合</strong> （Collection） 接口声明一个或多个方法来获取与集合兼容的迭代器。 请注意， 返回方法的类型必须被声明为迭代器接口， 因此具体集合可以返回各种不同种类的迭代器。</li><li><strong>具体集合</strong> （Concrete Collections） 会在客户端请求迭代器时返回一个特定的具体迭代器类实体。 你可能会琢磨， 剩下的集合代码在什么地方呢？ 不用担心， 它也会在同一个类中。 只是这些细节对于实际模式来说并不重要， 所以我们将其省略了而已。</li><li><strong>客户端</strong> （Client） 通过集合和迭代器的接口与两者进行交互。 这样一来客户端无需与具体类进行耦合， 允许同一客户端代码使用各种不同的集合和迭代器。<br>客户端通常不会自行创建迭代器， 而是会从集合中获取。 但在特定情况下， 客户端可以直接创建一个迭代器 （例如当客户端需要自定义特殊迭代器时）。</li></ol><p>示例见<a href="https://www.shiming.online/blog/4509351/#%E8%BF%AD%E4%BB%A3%E5%99%A8">Java集合-迭代器</a></p><h3 id="迭代器适用场景"><a href="#迭代器适用场景" class="headerlink" title="迭代器适用场景"></a>迭代器适用场景</h3><ol><li>当集合背后为复杂的数据结构， 且你希望对客户端隐藏其复杂性时 （出于使用便利性或安全性的考虑）， 可以使用迭代器模式。</li><li>使用该模式可以减少程序中重复的遍历代码。</li><li>如果你希望代码能够遍历不同的甚至是无法预知的数据结构， 可以使用迭代器模式。</li></ol><h3 id="迭代器优缺点"><a href="#迭代器优缺点" class="headerlink" title="迭代器优缺点"></a>迭代器优缺点</h3><table><thead><tr><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">单一职责原则。 通过将体积庞大的遍历算法代码抽取为独立的类， 你可对客户端代码和集合进行整理。</td><td align="center">如果你的程序只与简单的集合进行交互， 应用该模式可能会矫枉过正。</td></tr><tr><td align="center">开闭原则。 你可实现新型的集合和迭代器并将其传递给现有代码， 无需修改现有代码。</td><td align="center">对于某些特殊集合， 使用迭代器可能比直接遍历的效率低。</td></tr><tr><td align="center">你可以并行遍历同一集合， 因为每个迭代器对象都包含其自身的遍历状态。</td><td align="center"></td></tr><tr><td align="center">相似的， 你可以暂停遍历并在需要时继续。</td><td align="center"></td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ul><li><a href="https://refactoringguru.cn/design-patterns">免费在线学习设计模式</a></li><li><a href="http://c.biancheng.net/design_pattern/">C语言中文网-设计模式</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创造型模式</title>
      <link href="blog/8f9f2030/"/>
      <url>blog/8f9f2030/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note warning flat"><p>本博客大部分内容来于<a href="https://refactoringguru.cn/design-patterns">免费在线学习设计模式</a></p></div><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>工厂方法模式是一种创建型设计模式，其在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。</p><p>定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。</p><p>我们把<strong>被创建的对象称为“产品”</strong>，把<strong>创建产品的对象称为“工厂”</strong>。如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”，它不属于 GoF 的 23 种经典设计模式，它的缺点是增加新产品时会违背“开闭原则”。</p><p>而工厂方法模式是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。</p><h3 id="工厂方法模式问题"><a href="#工厂方法模式问题" class="headerlink" title="工厂方法模式问题"></a>工厂方法模式问题</h3><p>如果你开发了一款物流管理引用。初始版本只支持一种运输方案：卡车，于是大部分代码都在卡车类中。</p><p>后来你需要增加另外一种运输方案：轮船。代码部分该怎么处理呢？目前，大部分代码都与卡车类相关。在程序中添加轮船类需要修改全部代码。更糟糕的是，如果你以后需要在程序中支持另外一种运输方式，很可能需要再次对这些代码进行大幅修改。</p><p>最后，你将不得不编写繁复的代码，根据不同的运输对象类，在应用中进行不同的处理。</p><h3 id="工厂方法模式解决方案"><a href="#工厂方法模式解决方案" class="headerlink" title="工厂方法模式解决方案"></a>工厂方法模式解决方案</h3><p>工厂方法模式建议使用特殊的工厂方法代替对于对象构造函数的直接调用 （即使用 new运算符）。<br>对象仍将通过 new运算符创建，只是该运算符改在工厂方法中调用。工厂方法返回的对象通常被称作 “产品”。</p><div class="note warning flat"><p>注意：仅当这些产品具有共同的基类或者接口时，子类才能返回不同类型的产品，同时基类中的工厂方法还应将其返回类型声明为这一共有接口。</p></div><p>现在你可以在子类中重写工厂方法，从而改变其创建产品的类型。</p><p>例：卡车类和轮船类都必须实现运输接口，该接口声明了一个名为交付的方法。然后每个类都将以不同的方式实现该方法：卡车走陆路交付货物，轮船走海路交付货物。​<br>陆路运输Road­Logistics类中的工厂方法返回卡车对象，而海路运输Sea­Logistics类则返回轮船对象。</p><h3 id="工厂方法模式结构"><a href="#工厂方法模式结构" class="headerlink" title="工厂方法模式结构"></a>工厂方法模式结构</h3><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200816183704.png" alt="20200816183704"></p><ol><li><p><strong>产品</strong> （Product） 将会对接口进行声明。对于所有由创建者及其子类构建的对象，这些接口都是通用的。</p></li><li><p><strong>具体产品</strong> （Concrete Products） 是产品接口的不同实现。</p></li><li><p><strong>创建者</strong> （Creator） 类声明返回产品对象的工厂方法。该方法的返回对象类型必须与产品接口相匹配。</p><p> 你可以将工厂方法声明为抽象方法，强制要求每个子类以不同方式实现该方法。或者，你也可以在基础工厂方法中返回默认产品类型。</p><p> 注意，尽管它的名字是创建者，但他最主要的职责并不是创建产品。一般来说，创建者类包含一些与产品相关的核心业务逻辑。工厂方法将这些逻辑处理从具体产品类中分离出来。打个比方，大型软件开发公司拥有程序员培训部门。但是，这些公司的主要工作还是编写代码，而非生产程序员。</p></li><li><p><strong>具体创建者</strong> （Concrete Creators） 将会重写基础工厂方法，使其返回不同类型的产品。</p><p> 注意，并不一定每次调用工厂方法都会创建新的实例。工厂方法也可以返回缓存、 对象池或其他来源的已有对象。</p></li></ol><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象产品：水果接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">fruit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品1：苹果，实现抽象产品中的抽象方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">fruit</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品2：梨，实现抽象产品中的抽象方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pear</span> <span class="keyword">implements</span> <span class="title">fruit</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;pear&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象工厂：工厂接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">fruit <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂1：苹果工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleFactory</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> fruit <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AppleFactory:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Apple();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂2：梨工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PearFactory</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> fruit <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;PearFactory:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过苹果工厂生产苹果对象并调用方法</span></span><br><span class="line">        <span class="keyword">new</span> AppleFactory().create().display();</span><br><span class="line">        <span class="comment">// 通过梨工厂生产梨对象并调用方法</span></span><br><span class="line">        <span class="keyword">new</span> PearFactory().create().display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在创建对象简单时，也许直接new一个对象更简单。但是如果生产一个苹果需要很多步骤，那么很明显工厂模式更简单，创建者无需知道苹果的生产细节，当生产过程需要修改时也不需要修改调用端。</p><h3 id="工厂方法模式适用场景"><a href="#工厂方法模式适用场景" class="headerlink" title="工厂方法模式适用场景"></a>工厂方法模式适用场景</h3><ol><li>当你在编写代码的过程中，如果无法预知对象确切类别及其依赖关系时，可使用工厂方法。<ul><li>工厂方法将创建产品的代码与实际使用产品的代码分离，从而能在不影响其他代码的情况下扩展产品创建部分代码。</li></ul></li><li>如果你希望用户能扩展你软件库或框架的内部组件，可使用工厂方法。</li><li>如果你希望复用现有对象来节省系统资源，而不是每次都重新创建对象，可使用工厂方法。</li></ol><h3 id="工厂方法模式优缺点"><a href="#工厂方法模式优缺点" class="headerlink" title="工厂方法模式优缺点"></a>工厂方法模式优缺点</h3><table><thead><tr><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">你可以避免创建者和具体产品之间的紧密耦合。</td><td align="center">应用工厂方法模式需要引入许多新的子类，代码可能会因此变得更复杂。最好的情况是将该模式引入创建者类的现有层次结构中。</td></tr><tr><td align="center">单一职责原则。你可以将产品创建代码放在程序的单一位置，从而使得代码更容易维护。</td><td align="center"></td></tr><tr><td align="center">开闭原则。无需更改现有客户端代码，你就可以在程序中引入新的产品类型。</td><td align="center"></td></tr></tbody></table><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>抽象工厂（AbstractFactory）模式是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。</p><h3 id="抽象工厂模式问题"><a href="#抽象工厂模式问题" class="headerlink" title="抽象工厂模式问题"></a>抽象工厂模式问题</h3><p>工厂方法模式考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机、计算机软件学院只培养计算机软件专业的学生等。</p><p>但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如农场里既养动物又种植物，电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。</p><p>而抽象工厂模式将考虑多等级产品的生产。将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，</p><h3 id="抽象工厂模式解决方案"><a href="#抽象工厂模式解决方案" class="headerlink" title="抽象工厂模式解决方案"></a>抽象工厂模式解决方案</h3><p>首先，抽象工厂模式建议为系列中的每件产品明确声明接口。然后确保所有产品变体都继承这些接口，例如（所有品牌的电视机都继承电视机接口，所有品牌的空调都继承空调接口）</p><p>然后声明抽象工厂–包含系列中所有产品构造方法的接口。例如：createWasher(创建洗衣机)，createTV(创建电视机)…<br>这些方法必须返回抽象产品类型，即我们之前抽取的那些接口。</p><p>对于系列产品的每个变体，我们都将基于抽象工厂接口创建不同的工厂类。每个工厂类都只能返回特定类别的产品，例如，海尔只能创建海尔空调；格力只能创建格力空调。</p><p>客户端代码可以通过相应的抽象接口调用工厂和产品类。你无需修改实际客户端代码，就能更改传递给客户端的工厂类，也能更改客户端代码接收的产品变体。</p><h3 id="抽象工厂模式结构"><a href="#抽象工厂模式结构" class="headerlink" title="抽象工厂模式结构"></a>抽象工厂模式结构</h3><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200816195948.png" alt="20200816195948"></p><ol><li><strong>抽象产品</strong> （Abstract Product） 为构成系列产品的一组不同但相关的产品声明接口。</li><li><strong>具体产品</strong> （Concrete Product） 是抽象产品的多种不同类型实现。所有变体 （海尔/格力） 都必须实现相应的抽象产品 （洗衣机/电视机）。</li><li><strong>抽象工厂</strong> （Abstract Factory） 接口声明了一组创建各种抽象产品的方法。</li><li><strong>具体工厂</strong> （Concrete Factory） 实现抽象工厂的构建方法。每个具体工厂都对应特定产品变体，且仅创建此种产品变体。</li><li>尽管具体工厂会对具体产品进行初始化，其构建方法签名必须返回相应的抽象产品。这样，使用工厂类的客户端代码就不会与工厂创建的特定产品变体耦合。客户端 （Client） 只需通过抽象接口调用工厂和产品对象，就能与任何具体工厂/产品变体交互。</li></ol><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象产品接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品1：洗衣机</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Washer</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;洗衣服&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品2：电视机</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TV</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;看电视&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象工厂接口：包含所有产品的创建方法</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Product <span class="title">createWasher</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Product <span class="title">createTV</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂1：海尔</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HaierFactory</span> <span class="keyword">implements</span> <span class="title">AbstractFactory1</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createWasher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;海尔洗衣机&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Washer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createTV</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;海尔电视机&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TV();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂2：格力</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreeFactory</span> <span class="keyword">implements</span> <span class="title">AbstractFactory1</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createWasher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;格力洗衣机&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Washer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createTV</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;格力电视机&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TV();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建海尔品牌电视机，洗衣机</span></span><br><span class="line">        HaierFactory haierFactory = <span class="keyword">new</span> HaierFactory();</span><br><span class="line">        haierFactory.createTV().display();</span><br><span class="line">        haierFactory.createWasher().display();</span><br><span class="line">        <span class="comment">// 创建格力品牌电视机，洗衣机</span></span><br><span class="line">        GreeFactory greeFactory = <span class="keyword">new</span> GreeFactory();</span><br><span class="line">        greeFactory.createTV().display();</span><br><span class="line">        greeFactory.createWasher().display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象工厂模式适用场景"><a href="#抽象工厂模式适用场景" class="headerlink" title="抽象工厂模式适用场景"></a>抽象工厂模式适用场景</h3><ol><li>如果代码需要与多个不同系列的相关产品交互，但是由于无法提前获取相关信息，或者出于对未来扩展性的考虑，你不希望代码基于产品的具体类进行构建，在这种情况下，你可以使用抽象工厂。</li><li>如果你有一个基于一组抽象方法的类，且其主要功能因此变得不明确，那么在这种情况下可以考虑使用抽象工厂模式。</li></ol><h3 id="抽象工厂模式优缺点"><a href="#抽象工厂模式优缺点" class="headerlink" title="抽象工厂模式优缺点"></a>抽象工厂模式优缺点</h3><table><thead><tr><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">你可以确保同一工厂生成的产品相互匹配。</td><td align="center">由于采用该模式需要向应用中引入众多接口和类，代码可能会比之前更加复杂。</td></tr><tr><td align="center">你可以避免客户端和具体产品代码的耦合。</td><td align="center">添加新产品需要修改全部工厂代码</td></tr><tr><td align="center">单一职责原则。你可以将产品生成代码抽取到同一位置，使得代码易于维护。</td><td align="center"></td></tr><tr><td align="center">开闭原则。向应用程序中引入新产品变体时，你无需修改客户端代码。</td><td align="center"></td></tr></tbody></table><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>建造者模式是一种创建型设计模式，使你能够分步骤创建复杂对象。该模式允许你使用相同的创建代码生成不同类型和形式的对象。</p><h3 id="建造者模式问题"><a href="#建造者模式问题" class="headerlink" title="建造者模式问题"></a>建造者模式问题</h3><p>在软件开发过程中有时需要创建一个复杂的对象，这个复杂对象通常由多个子部件按一定的步骤组合而成。<br>例如，计算机是由 OPU、主板、内存、硬盘、显卡、机箱、显示器、键盘、鼠标等部件组装而成的，采购员不可能自己去组装计算机，而是将计算机的配置要求告诉计算机销售公司，计算机销售公司安排技术人员去组装计算机，然后再交给要买计算机的采购员。<br>生活中这样的例子很多，如游戏中的不同角色，其性别、个性、能力、脸型、体型、服装、发型等特性都有所差异；还有汽车中的方向盘、发动机、车架、轮胎等部件也多种多样；每封电子邮件的发件人、收件人、主题、内容、附件等内容也各不相同。</p><p>解决这些问题最简单的方法是扩展基类，然后创建一系列覆盖所有参数组合的子类。但最终你将面对相当数量的子类。任何新增的参数都会让这个层次结构更加复杂。</p><p>另一种方法则无需生成子类。你可以在房屋基类中创建一个包括所有可能参数的超级构造函数，并用它来控制房屋对象。这种方法确实可以避免生成子类，但它却会造成另外一个问题：通常情况下，绝大部分的参数都没有使用，这使得对于构造函数的调用十分不简洁。</p><h3 id="建造者模式解决方案"><a href="#建造者模式解决方案" class="headerlink" title="建造者模式解决方案"></a>建造者模式解决方案</h3><p>建造者模式建议将对象构造代码从产品类中抽取出来，并将其放在一个名为生成器的独立对象中。例如将构建一座房屋的过程分解为：创建墙壁，创建房门，创建窗户等。每次创建对象时，你都需要通过生成器对象执行一系列步骤。重点在于你无需调用所有步骤，而只需调用创建特定对象配置所需的那些步骤即可。例如，假设第一个建造者使用木头和玻璃制造房屋，第二个建造者使用石头和钢铁，而第三个建造者使用黄金和钻石。 在调用同一组步骤后，第一个建造者会给你一栋普通房屋，第二个会给你一座小城堡，而第三个则会给你一座宫殿。 但是，只有在调用构造步骤的客户端代码可以通过通用接口与建造者进行交互时，这样的调用才能返回需要的房屋。</p><p><strong>主管</strong>：你可以进一步将用于创建产品的一系列生成器步骤调用抽取成为单独的主管类。 主管类可定义创建步骤的执行顺序，而生成器则提供这些步骤的实现。（主管不是必须的，但是主管适合放入各种构造流程，以便在程序中重复调用）。</p><h3 id="建造模式结构"><a href="#建造模式结构" class="headerlink" title="建造模式结构"></a>建造模式结构</h3><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200827093106.png" alt="20200827093106"></p><ol><li><strong>生成器</strong> （Builder） 接口声明在所有类型生成器中通用的产品构造步骤。</li><li><strong>具体生成器</strong> （Concrete Builders） 提供构造过程的不同实现。 具体生成器也可以构造不遵循通用接口的产品。</li><li><strong>产品</strong> （Products） 是最终生成的对象。 由不同生成器构造的产品无需属于同一类层次结构或接口。</li><li><strong>主管</strong> （Director） 类定义调用构造步骤的顺序，这样你就可以创建和复用特定的产品配置。</li><li><strong>客户端</strong> （Client） 必须将某个生成器对象与主管类关联。 一般情况下，你只需通过主管类构造函数的参数进行一次性关联即可。 此后主管类就能使用生成器对象完成后续所有的构造任务。 但在客户端将生成器对象传递给主管类制造方法时还有另一种方式。 在这种情况下，你在使用主管类生产产品时每次都可以使用不同的生成器。</li></ol><p>代码示例：  生成不同类型的汽车产品</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端代码会创建生成器对象并将其传递给主管，然后执行构造过程。最终结果将需要从生成器对象中获取。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuilderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成第一种车辆</span></span><br><span class="line">        CarBuilder carBuilder = <span class="keyword">new</span> CarBuilder();</span><br><span class="line">        Director director = <span class="keyword">new</span> Director(carBuilder);</span><br><span class="line">        director.constructSportsCar();</span><br><span class="line">        Car product1 = carBuilder.getProduct();</span><br><span class="line">        product1.show();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成第二种车辆</span></span><br><span class="line">        director.constructSUV();</span><br><span class="line">        Car product2 = carBuilder.getProduct();</span><br><span class="line">        product2.show();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按第二种车辆的构造器生成并修改</span></span><br><span class="line">        director.constructSUV();</span><br><span class="line">        carBuilder.setName(<span class="string">&quot;车辆3&quot;</span>);</span><br><span class="line">        carBuilder.setSeats(<span class="string">&quot;座位6&quot;</span>);</span><br><span class="line">        Car product3 = carBuilder.getProduct();</span><br><span class="line">        product3.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有当产品较为复杂且需要详细配置时，使用建造者模式才有意义。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一辆汽车可以有不同名称，座位，引擎，导航系统等等。</span></span><br><span class="line">    String name;</span><br><span class="line">    String seats;</span><br><span class="line">    String engine;</span><br><span class="line">    String GPS;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, seats=&#x27;&quot;</span> + seats + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, engine=&#x27;&quot;</span> + engine + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, GPS=&#x27;&quot;</span> + GPS + <span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建造者接口声明了创建产品对象不同部件的方法</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setSeats</span><span class="params">(String seats)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setEngine</span><span class="params">(String engine)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setGPS</span><span class="params">(String GPS)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体建造者类将遵循建造者接口并提供生成步骤的具体实现。你的程序中可能会有多个以不同方式实现的建造者变体。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarBuilder</span> <span class="keyword">implements</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Car car;</span><br><span class="line"></span><br><span class="line">    CarBuilder() &#123;</span><br><span class="line">        <span class="keyword">this</span>.reset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reset() 方法重置正在生成的对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.car = <span class="keyword">new</span> Car();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置汽车名称</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.car.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置汽车座位</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSeats</span><span class="params">(String seats)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.car.seats = seats;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置汽车引擎</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEngine</span><span class="params">(String engine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.car.engine = engine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置GPS</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGPS</span><span class="params">(String GPS)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.car.GPS = GPS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体建造者需要自行提供获取结果的方法。这是因为不同类型的建造者可能会创建不遵循相同接口的、完全不同的产品。</span></span><br><span class="line">    <span class="comment">// 所以也就无法在生成器接口中声明这些方法（至少在静态类型的编程语言中是这样的）。</span></span><br><span class="line">    <span class="comment">// 通常在建造者例将结果返回给客户端后，它们应该做好生成另一个产品的准备。</span></span><br><span class="line">    <span class="comment">// 因此建造者实例通常会在 `getProduct（获取产品）`方法主体末尾</span></span><br><span class="line">    <span class="comment">// 调用重置方法。但是该行为并不是必需的，你也可让生成器等待客户端明确调用重置方法后再去处理之前的结果。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Car product = <span class="keyword">this</span>.car;</span><br><span class="line">        <span class="keyword">this</span>.reset();</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主管只负责按照特定顺序执行生成步骤。其在根据特定步骤或配置来生成产品时会很有帮助。</span></span><br><span class="line"><span class="comment">// 由于客户端可以直接控制生成器，所以严格意义上来说，主管类并不是必需的。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Builder builder;</span><br><span class="line"></span><br><span class="line">    Director(Builder builder) &#123;</span><br><span class="line">        <span class="keyword">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主管可使用同样的生成步骤创建多个产品变体。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">constructSportsCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        builder.reset();</span><br><span class="line">        builder.setName(<span class="string">&quot;车辆1&quot;</span>);</span><br><span class="line">        builder.setSeats(<span class="string">&quot;座位2&quot;</span>);</span><br><span class="line">        builder.setEngine(<span class="string">&quot;引擎1&quot;</span>);</span><br><span class="line">        builder.setGPS(<span class="string">&quot;北斗&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">constructSUV</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        builder.reset();</span><br><span class="line">        builder.setName(<span class="string">&quot;车辆2&quot;</span>);</span><br><span class="line">        builder.setSeats(<span class="string">&quot;座位4&quot;</span>);</span><br><span class="line">        builder.setEngine(<span class="string">&quot;引擎2&quot;</span>);</span><br><span class="line">        builder.setGPS(<span class="string">&quot;GPS&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="建造者模式适用场景"><a href="#建造者模式适用场景" class="headerlink" title="建造者模式适用场景"></a>建造者模式适用场景</h3><ol><li>使用生成器模式可避免 “重叠构造函数 （telescopic constructor）” 的出现。</li><li>当你希望使用代码创建不同形式的产品 （例如跑车和拖拉机） 时，可使用生成器模式。</li><li>使用生成器构造组合树或其他复杂对象。</li></ol><h3 id="建造者模式优缺点"><a href="#建造者模式优缺点" class="headerlink" title="建造者模式优缺点"></a>建造者模式优缺点</h3><table><thead><tr><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">由于该模式需要新增多个类，因此代码整体复杂程度会有所增加。</td><td align="center">由于该模式需要新增多个类，因此代码整体复杂程度会有所增加。</td></tr><tr><td align="center">生成不同形式的产品时，你可以复用相同的制造代码。</td><td align="center"></td></tr><tr><td align="center">单一职责原则。 你可以将复杂构造代码从产品的业务逻辑中分离出来。</td><td align="center"></td></tr></tbody></table><div class="note info flat"><p><strong>工厂模式和建造者模式的区别：</strong></p><p>建造者重点关注如何分步生成单个复杂对象。 工厂模式专门用于生产一系列相关对象。 工厂会马上返回产品，生成器则允许你在获取产品前执行一些额外构造步骤。</p></div><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>原型模式是一种创建型设计模式，使你能够复制已有对象，而又无需使代码依赖它们所属的类。</p><h3 id="原型模式问题"><a href="#原型模式问题" class="headerlink" title="原型模式问题"></a>原型模式问题</h3><p>如果你有一个对象，并希望生成与其完全相同的一个复制品，你该如何实现呢？首先，你必须新建一个属于相同类的对象。然后，你必须遍历原始对象的所有成员变量，并将成员变量值复制到新对象中。</p><p>但是并非所有对象都能通过这种方式进行复制， 因为有些对象可能拥有私有成员变量， 它们在对象本身以外是不可见的。</p><h3 id="原型模式解决方法"><a href="#原型模式解决方法" class="headerlink" title="原型模式解决方法"></a>原型模式解决方法</h3><p>用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节。例如，Windows 操作系统的安装通常较耗时，如果复制就快了很多。在生活中复制的例子非常多，这里不一一列举了。</p><h3 id="原型模式解决方案"><a href="#原型模式解决方案" class="headerlink" title="原型模式解决方案"></a>原型模式解决方案</h3><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200828102545.png" alt="20200828102545"></p><ol><li>原型 （Prototype） 接口将对克隆方法进行声明。 在绝大多数情况下， 其中只会有一个名为 clone克隆的方法。****</li><li>具体原型 （Concrete Prototype） 类将实现克隆方法。 除了将原始对象的数据复制到克隆体中之外， 该方法有时还需处理克隆过程中的极端情况， 例如克隆关联对象和梳理递归依赖等等。</li><li>客户端 （Client） 可以复制实现了原型接口的任何对象。</li></ol><p>由于 Java 提供了对象的 clone() 方法，所以用 Java 实现原型模式很简单。</p><p>代码参考<a href="shiming.ontline/blog/ed7a5ab9/">对象克隆</a></p><h3 id="原型模式适用场景"><a href="#原型模式适用场景" class="headerlink" title="原型模式适用场景"></a>原型模式适用场景</h3><ol><li>如果你需要复制一些对象， 同时又希望代码独立于这些对象所属的具体类， 可以使用原型模式。</li><li>如果子类的区别仅在于其对象的初始化方式， 那么你可以使用该模式来减少子类的数量。 别人创建这些子类的目的可能是为了创建特定类型的对象。</li></ol><h3 id="原型模式优缺点"><a href="#原型模式优缺点" class="headerlink" title="原型模式优缺点"></a>原型模式优缺点</h3><table><thead><tr><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">你可以克隆对象， 而无需与它们所属的具体类相耦合。</td><td align="center">克隆包含循环引用的复杂对象可能会非常麻烦。</td></tr><tr><td align="center">你可以克隆预生成原型， 避免反复运行初始化代码。</td><td align="center"></td></tr><tr><td align="center">你可以更方便地生成复杂对象。</td><td align="center"></td></tr><tr><td align="center">你可以用继承以外的方式来处理复杂对象的不同配置。</td><td align="center"></td></tr></tbody></table><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式是一种创建型设计模式，让你能够保证一个类只有一个实例，并提供一个访问该实例的全局节点。</p><h3 id="单例模式问题"><a href="#单例模式问题" class="headerlink" title="单例模式问题"></a>单例模式问题</h3><p>单例模式同时解决了两个问题。所以违反了单一职责原则。</p><ol><li>保证一个类只有一个实例。（eg：控制某些共享资源 （例如数据库或文件） 的访问权限。）</li><li>为该实例提供一个全局访问节点。<br>例如存储重要对象的全局变量，它们在使用上十分方便，但同时也非常不安全，因为任何代码都有可能覆盖掉那些变量的内容，从而引发程序崩溃。</li></ol><p>例：一个国家只有一个政府，不管身份是什么，而”某政府“就像全局访问节点一样。</p><h3 id="单理模式结构"><a href="#单理模式结构" class="headerlink" title="单理模式结构"></a>单理模式结构</h3><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200816190308.png" alt="20200816190308"></p><ol><li><strong>单例</strong> （Singleton） 类声明了一个名为 get­Instance获取实例的静态方法来返回其所属类的一个相同实例。</li></ol><div class="note warning flat"><p>单例的构造函数必须对客户端 （Client） 代码隐藏。调用 获取实例方法必须是获取单例对象的唯一方式。</p></div><p>代码示例：</p><p>单例模式有两种创建方法：</p><ol><li><p>懒汉式单例：类加载时没有生成单例，只有当第一次调用 getlnstance 方法时才去创建这个单例。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 保证 instance 在所有线程中同步</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance=<span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// private 避免类在外部被实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// getInstance 方法前加同步</span></span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            instance=<span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>volatile</code> 和 <code>synchronized</code>关键字用于保证多线程中的线程安全。但是这样会使得每次访问都要同步，影响性能且消耗更多资源</p></li><li><p>饿汉式单例：类一旦加载就创建一个单例，保证在调用 getInstance 方法之前单例已经存在了。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HungrySingleton instance=<span class="keyword">new</span> HungrySingleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 饿汉式单例在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以是线程安全的，可以直接用于多线程而不会出现问题。</p></li></ol><h3 id="单例模式适用场景"><a href="#单例模式适用场景" class="headerlink" title="单例模式适用场景"></a>单例模式适用场景</h3><ol><li>如果程序中的某个类对于所有客户端只有一个可用的实例，可以使用单例模式。</li><li>如果需要更加严格地控制全局变量，可以使用单例模式。</li></ol><h3 id="单例模式优缺点"><a href="#单例模式优缺点" class="headerlink" title="单例模式优缺点"></a>单例模式优缺点</h3><table><thead><tr><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">你可以保证一个类只有一个实例。</td><td align="center">违反了单一职责原则。该模式同时解决了两个问题。</td></tr><tr><td align="center">你获得了一个指向该实例的全局访问节点。</td><td align="center">单例模式可能掩盖不良设计，比如程序各组件之间相互了解过多等。</td></tr><tr><td align="center">仅在首次请求单例对象时对其进行初始化。</td><td align="center">该模式在多线程环境下需要进行特殊处理，避免多个线程多次创建单例对象。</td></tr><tr><td align="center"></td><td align="center">单例的客户端代码单元测试可能会比较困难，因为许多测试框架以基于继承的方式创建模拟对象。</td></tr></tbody></table><p>由于单例类的构造函数是私有的，而且绝大部分语言无法重写静态方法，所以你需要想出仔细考虑模拟单例的方法。要么干脆不编写测试代码，或者不使用单例模式。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ul><li><a href="https://refactoringguru.cn/design-patterns">免费在线学习设计模式</a></li><li><a href="http://c.biancheng.net/design_pattern/">C语言中文网-设计模式</a></li></ul></blockquote><a class="btn-beautify button--animated block blue right" href="https://www.shiming.online/blog/620ff0b5/"   title="设计模式-结构型模式"><i class="far fa-hand-point-right fa-fw"></i><span>设计模式-结构型模式</span></a>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结构型模式</title>
      <link href="blog/620ff0b5/"/>
      <url>blog/620ff0b5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note warning flat"><p>本博客大部分内容来于<a href="https://refactoringguru.cn/design-patterns">免费在线学习设计模式</a></p></div><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>适配器模式是一种结构型设计模式，它能使接口不兼容的对象能够相互合作。它结合了两个独立接口的功能。</p><p>这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200819154420.png" alt="20200819154420"></p><h3 id="适配器模式问题"><a href="#适配器模式问题" class="headerlink" title="适配器模式问题"></a>适配器模式问题</h3><p>例如你开发了一个程序，能从不同来源获取xml格式信息。在开发过程中，你决定整合一个第三方分析库，但是第三方分析库只兼容json格式。<br>你可以修改程序库来支持json，但是这需要修改很多代码，甚至你无法修改程序库。</p><h3 id="适配器模式解决方案"><a href="#适配器模式解决方案" class="headerlink" title="适配器模式解决方案"></a>适配器模式解决方案</h3><p>你创建一个适配器。这是一个特殊的对象，能够转换对象接口，使其能与其他对象进行交互。</p><p>适配器模式通过封装对象将复杂的转换过程隐藏于幕后。被封装的对象甚至察觉不到适配器的存在。</p><p>适配器不仅可以转换不同格式的数据，其还有助于采用不同接口的对象之间的合作。它的运作方式如下：</p><ol><li>适配器实现与其中一个现有对象兼容的接口。</li><li>现有对象可以使用该接口安全地调用适配器方法。</li><li>适配器方法被调用后将以另一个对象兼容的格式和顺序将请求传递给该对象。</li></ol><p>有时候你还可以写一个双向适配器来实现双向转换调用</p><p>例：出国旅行时，不同国家的电源插头和插座标准不同。同时提供中国标准和欧洲标准插头的适配器能解决问题。</p><h3 id="适配器模式结构"><a href="#适配器模式结构" class="headerlink" title="适配器模式结构"></a>适配器模式结构</h3><h4 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h4><p>实现时使用了构成原则： 适配器实现了其中一个对象的接口，并对另一个对象进行封装。所有流行的编程语言都可以实现适配器。</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200819155218.png" alt="20200819155218"></p><ol><li><strong>客户端</strong> （Client） 是包含当前程序业务逻辑的类。</li><li><strong>客户端接口</strong> （Client Interface） 描述了其他类与客户端代码合作时必须遵循的协议。</li><li><strong>客户端</strong> （Client） 是包含当前程序业务逻辑的类。客户端接口 （Client Interface） 描述了其他类与客户端代码合作时必须遵循的协议。服务 （Service） 中有一些功能类 （通常来自第三方或遗留系统）。客户端与其接口不兼容，因此无法直接调用其功能。</li><li><strong>适配器</strong> （Adapter） 是一个可以同时与客户端和服务交互的类： 它在实现客户端接口的同时封装了服务对象。适配器接受客户端通过适配器接口发起的调用，并将其转换为适用于被封装服务对象的调用。</li><li>客户端代码只需<strong>通过接口与适配器交互</strong>即可，无需与具体的适配器类耦合。因此，你可以向程序中添加新类型的适配器而无需修改已有代码。这在服务类的接口被更改或替换时很有用： 你无需修改客户端代码就可以创建新的适配器类。</li></ol><p>代码示例：</p><p>“方钉”和“圆孔”<br>适配器假扮成一个圆钉 （Round­Peg），其半径等于方钉 （Square­Peg） 横截面对角线的一半 （即能够容纳方钉的最小外接圆的半径）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 圆孔</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoundHole</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RoundHole</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回孔的半径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getRadius</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">fits</span><span class="params">(RoundPeg roundPeg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getRadius() &gt;= roundPeg.getRadius();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 圆钉：和圆孔兼容</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoundPeg</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RoundPeg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回圆钉半径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RoundPeg</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getRadius</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方钉：和圆孔不兼容</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquarePeg</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SquarePeg</span><span class="params">(<span class="keyword">double</span> width)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回方钉宽度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适配器类让你能够将方钉放入圆孔中。它会对 RoundPeg 类进行扩展，以接收适配器对象作为圆钉。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquarePegAdapter</span> <span class="keyword">extends</span> <span class="title">RoundPeg</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方钉实例</span></span><br><span class="line">    <span class="keyword">private</span> SquarePeg squarePeg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SquarePegAdapter</span><span class="params">(SquarePeg squarePeg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.squarePeg = squarePeg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getRadius</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 适配器会假扮为一个圆钉，其半径刚好能与适配器实际封装的方钉搭配起来。</span></span><br><span class="line">        <span class="keyword">return</span> squarePeg.getWidth() * Math.sqrt(<span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RoundHole roundHole = <span class="keyword">new</span> RoundHole(<span class="number">5</span>);</span><br><span class="line">        RoundPeg roundPeg = <span class="keyword">new</span> RoundPeg(<span class="number">5</span>);</span><br><span class="line">        System.out.println(roundHole.fits(roundPeg));</span><br><span class="line">        <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        SquarePeg smallSqPeg = <span class="keyword">new</span> SquarePeg(<span class="number">5</span>);</span><br><span class="line">        SquarePeg largeSqPeg = <span class="keyword">new</span> SquarePeg(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// roundHole.fits(smallSqPeg);</span></span><br><span class="line">        <span class="comment">// 上诉代码无法编译</span></span><br><span class="line"></span><br><span class="line">        SquarePegAdapter smallSqPegAdapter = <span class="keyword">new</span> SquarePegAdapter(smallSqPeg);</span><br><span class="line">        SquarePegAdapter largeSqPegAdapter = <span class="keyword">new</span> SquarePegAdapter(largeSqPeg);</span><br><span class="line">        System.out.println(roundHole.fits(smallSqPegAdapter));</span><br><span class="line">        <span class="comment">// true</span></span><br><span class="line">        System.out.println(roundHole.fits(largeSqPegAdapter));</span><br><span class="line">        <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="适配器模式适用场景"><a href="#适配器模式适用场景" class="headerlink" title="适配器模式适用场景"></a>适配器模式适用场景</h3><ol><li>当你希望使用某个类，但是其接口与其他代码不兼容时，可以使用适配器类。</li><li>如果您需要复用这样一些类，他们处于同一个继承体系，并且他们又有了额外的一些共同的方法，但是这些共同的方法不是所有在这一继承体系中的子类所具有的共性。</li></ol><h3 id="适配器模式优缺点"><a href="#适配器模式优缺点" class="headerlink" title="适配器模式优缺点"></a>适配器模式优缺点</h3><table><thead><tr><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">_单一职责原则_你可以将接口或数据转换代码从程序主要业务逻辑中分离。</td><td align="center">代码整体复杂度增加，因为你需要新增一系列接口和类。有时直接更改服务类使其与其他代码兼容会更简单。</td></tr><tr><td align="center">开闭原则。只要客户端代码通过客户端接口与适配器进行交互，你就能在不修改现有客户端代码的情况下在程序中添加新类型的适配器。</td><td align="center">由于java的继承机制，    至多只能适配一个适配器类</td></tr><tr><td align="center">提高类的复用</td><td align="center"></td></tr><tr><td align="center">灵活度高</td><td align="center"></td></tr></tbody></table><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>桥接模式是一种结构型设计模式， 可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构， 从而能在开发时分别使用。</p><h3 id="桥接模式问题"><a href="#桥接模式问题" class="headerlink" title="桥接模式问题"></a>桥接模式问题</h3><p>在现实生活中，某些类具有两个或多个维度的变化，如图形既可按形状分，又可按颜色分。如何设计类似于 Photoshop 这样的软件，能画不同形状和不同颜色的图形呢？如果用继承方式，m 种形状和 n 种颜色的图形就有 m×n 种，不但对应的子类很多，而且扩展困难。</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200830100724.png" alt="20200830100724"></p><h3 id="桥接模式解决方案"><a href="#桥接模式解决方案" class="headerlink" title="桥接模式解决方案"></a>桥接模式解决方案</h3><p>问题的根本原因是我们试图在两个独立的维度——形状与颜色——上扩展形状类。这在处理类继承时是很常见的问题。</p><p>桥接模式通过将<strong>继承改为组合</strong>的方式来解决这个问题。具体来说，就是抽取其中一个维度并使之成为独立的类层次， 这样就可以在初始类中引用这个新层次的对象， 从而使得一个类不必拥有所有的状态和行为。</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200830101028.png" alt="20200830101028"></p><p>将颜色相关的代码抽取到拥有红色和蓝色两个子类的颜色类中，然后在形状类中添加一个指向某一颜色对象的引用成员变量。现在，形状类可以将所有与颜色相关的工作委派给连入的颜色对象。 这样的引用就成为了形状和颜色之间的桥梁。 此后，新增颜色将不再需要修改形状的类层次，反之亦然。</p><h3 id="桥接模式结构"><a href="#桥接模式结构" class="headerlink" title="桥接模式结构"></a>桥接模式结构</h3><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200830101235.png" alt="20200830101235"></p><ol><li><strong>抽象部分</strong> （Abstraction） 提供高层控制逻辑， 依赖于完成底层实际工作的实现对象。</li><li><strong>实现部分</strong> （Implementation） 为所有具体实现声明通用接口。 抽象部分仅能通过在这里声明的方法与实现对象交互。<br> 抽象部分可以列出和实现部分一样的方法， 但是抽象部分通常声明一些复杂行为， 这些行为依赖于多种由实现部分声明的原语操作</li><li><strong>具体实现</strong> （Concrete Implementations） 中包括特定于平台的代码。</li><li><strong>精确抽象</strong> （Refined Abstraction） 提供控制逻辑的变体。 与其父类一样， 它们通过通用实现接口与不同的实现进行交互。</li><li>通常情况下， <strong>客户端</strong> （Client） 仅关心如何与抽象部分合作。 但是， 客户端需要将抽象对象与一个实现对象连接起来。</li></ol><p>代码示例：</p><p>实现形状和颜色的自由组合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 红蓝</span></span><br><span class="line">        Color red = <span class="keyword">new</span> Red();</span><br><span class="line">        Color blue = <span class="keyword">new</span> Blue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 圆方</span></span><br><span class="line">        Shape round = <span class="keyword">new</span> Round();</span><br><span class="line">        Shape square = <span class="keyword">new</span> Square();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 红色圆形</span></span><br><span class="line">        round.setColor(red);</span><br><span class="line">        System.out.println(round.getShape());</span><br><span class="line">        <span class="comment">// 蓝色圆形</span></span><br><span class="line">        round.setColor(blue);</span><br><span class="line">        System.out.println(round.getShape());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 红色方形</span></span><br><span class="line">        square.setColor(red);</span><br><span class="line">        System.out.println(square.getShape());</span><br><span class="line">        <span class="comment">// 蓝色方形</span></span><br><span class="line">        square.setColor(blue);</span><br><span class="line">        System.out.println(square.getShape());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现部分：颜色</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getColor</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现：红色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Red</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;红色&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现：蓝色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blue</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;蓝色&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象部分：形状</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Color color;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(Color color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getShape</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 精确抽象：圆形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Round</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getShape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color.getColor() + <span class="string">&quot;圆形&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 精确抽象：方形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getShape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color.getColor() + <span class="string">&quot;方形&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="桥接模式适用场景"><a href="#桥接模式适用场景" class="headerlink" title="桥接模式适用场景"></a>桥接模式适用场景</h3><ol><li>如果你想要拆分或重组一个具有多重功能的庞杂类 （例如能与多个数据库服务器进行交互的类）， 可以使用桥接模式。</li><li>如果你希望在几个独立维度上扩展一个类，可使用该模式。</li><li>如果你需要在运行时切换不同实现方法，可使用桥接模式。</li></ol><h3 id="桥接模式优缺点"><a href="#桥接模式优缺点" class="headerlink" title="桥接模式优缺点"></a>桥接模式优缺点</h3><table><thead><tr><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">你可以创建与平台无关的类和程序。</td><td align="center">对高内聚的类使用该模式可能会让代码更加复杂。</td></tr><tr><td align="center">客户端代码仅与高层抽象部分进行互动， 不会接触到平台的详细信息。</td><td align="center"></td></tr><tr><td align="center">开闭原则。 你可以新增抽象部分和实现部分， 且它们之间不会相互影响。</td><td align="center"></td></tr></tbody></table><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p><strong>组合模式</strong>是一种结构型设计模式，又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象，你可以使用它将对象组合成树状结构，并且能像使用独立对象一样使用它们。</p><h3 id="组合模式问题"><a href="#组合模式问题" class="headerlink" title="组合模式问题"></a>组合模式问题</h3><p>如果应用的核心模型能用树状结构表示，在应用中使用组合模式才有价值。</p><p>例如，你有两类对象：<em>产品</em>和<em>盒子</em>。一个盒子中可以包含多个产品或者几个较小的盒子。这些小盒子中同样可以包含一些产品或更小的盒子，以此类推。</p><p>在这些类的基础上你需要开发一个订单系统。订单中可以包含无包装的简单产品，也可以包含装满产品的盒子……以及其他盒子。如何计算订单的总价呢？</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200831120109.png" alt="20200831120109"></p><p>在现实生活中，可以直接拆开盒子，直接计算每个产品的价格。而在程序中，你必须知道所有产品和盒子的细节，知道盒子的嵌套层数以及其他详细信息，才能计算出总价。因此直接计算是不可行。</p><p>在现实生活中，存在很多“部分-整体”的关系，例如，大学中的部门与学院、总公司中的部门与分公司、学习用品中的书与书包、生活用品中的衣服与衣柜以及厨房中的锅碗瓢盆等。在软件开发中也是这样，例如，文件系统中的文件与文件夹、窗体程序中的简单控件与容器控件等。对这些简单对象与复合对象的处理，如果用组合模式来实现会很方便。</p><h3 id="组合模式解决方案"><a href="#组合模式解决方案" class="headerlink" title="组合模式解决方案"></a>组合模式解决方案</h3><p>组合模式建议使用一个通用接口来与产品和盒子进行交互， 并且在该接口中声明一个计算总价的方法。</p><p>例如：对于一个产品，该方法直接返回其价格；对于一个盒子，该方法遍历盒子中的所有项目，询问每个项目的价格，然后返回该盒子的总价格。如果其中某个项目是小一号的盒子，那么当前盒子也会遍历其中的所有项目，以此类推，直到计算出所有内部组成部分的价格。还可以在盒子的最终价格中增加额外费用，作为该盒子的包装费用。</p><p>该方式的最大优点在于客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象。只需调用通用接口以相同的方式对其进行处理即可。当你调用该方法后，对象会将请求沿着树结构传递下去。</p><h3 id="组合模式结构"><a href="#组合模式结构" class="headerlink" title="组合模式结构"></a>组合模式结构</h3><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200831120959.png" alt="20200831120959"></p><ol><li><strong>组件</strong> （Component） 接口描述了树中简单项目和复杂项目所共有的操作。</li><li><strong>叶节点</strong> （Leaf） 是树的基本结构， 它不包含子项目。<br> 一般情况下， 叶节点最终会完成大部分的实际工作， 因为它们无法将工作指派给其他部分。</li><li><strong>容器</strong> （Container）——又名 “组合 （Composite）”——是包含叶节点或其他容器等子项目的单位。 容器不知道其子项目所属的具体类， 它只通过通用的组件接口与其子项目交互。<br> 容器接收到请求后会将工作分配给自己的子项目， 处理中间结果， 然后将最终结果返回给客户端。</li><li><strong>客户端</strong> （Client） 通过组件接口与所有项目交互。 因此， 客户端能以相同方式与树状结构中的简单或复杂项目交互。</li></ol><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端：通过组件和叶节点，容器交互</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        Box bigBox, mediumBox, smallRedBox, smallWhiteBox;</span><br><span class="line">        Good good;</span><br><span class="line">        bigBox = <span class="keyword">new</span> Box(<span class="string">&quot;大盒子&quot;</span>);</span><br><span class="line">        mediumBox = <span class="keyword">new</span> Box(<span class="string">&quot;中等盒子&quot;</span>);</span><br><span class="line">        smallRedBox = <span class="keyword">new</span> Box(<span class="string">&quot;小红盒子&quot;</span>);</span><br><span class="line">        smallWhiteBox = <span class="keyword">new</span> Box(<span class="string">&quot;小白盒子&quot;</span>);</span><br><span class="line"></span><br><span class="line">        good = <span class="keyword">new</span> Good(<span class="string">&quot;耳机&quot;</span>, <span class="number">1</span>, <span class="number">200</span>);</span><br><span class="line">        smallWhiteBox.add(good);</span><br><span class="line"></span><br><span class="line">        good = <span class="keyword">new</span> Good(<span class="string">&quot;充电线&quot;</span>, <span class="number">2</span>, <span class="number">100</span>);</span><br><span class="line">        smallRedBox.add(good);</span><br><span class="line"></span><br><span class="line">        good = <span class="keyword">new</span> Good(<span class="string">&quot;手机&quot;</span>, <span class="number">1</span>, <span class="number">4000</span>);</span><br><span class="line">        mediumBox.add(good);</span><br><span class="line">        mediumBox.add(smallRedBox);</span><br><span class="line">        mediumBox.add(smallWhiteBox);</span><br><span class="line"></span><br><span class="line">        good = <span class="keyword">new</span> Good(<span class="string">&quot;钢化膜&quot;</span>, <span class="number">5</span>, <span class="number">20</span>);</span><br><span class="line">        bigBox.add(good);</span><br><span class="line">        bigBox.add(mediumBox);</span><br><span class="line"></span><br><span class="line">        bigBox.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件：计算总价</span></span><br><span class="line"><span class="comment">// 组件接口会声明组合中简单和复杂对象的通用操作。</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Article</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">calculate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 叶节点：商品</span></span><br><span class="line"><span class="comment">// 叶节点类代表组合的终端对象。叶节点对象中不能包含任何子对象。</span></span><br><span class="line"><span class="comment">// 叶节点对象通常会完成实际的工作，组合对象则仅会将工作委派给自己的子部件。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Good</span> <span class="keyword">implements</span> <span class="title">Article</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 商品名称</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 商品数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="comment">// 商品单价</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Good</span><span class="params">(String name, <span class="keyword">int</span> number, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算商品总价</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number * price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 展示商品细节</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name: &quot;</span> + name + <span class="string">&quot; number: &quot;</span> + number + <span class="string">&quot; price: &quot;</span> + price + <span class="string">&quot; 总价: &quot;</span> + calculate());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 容器：盒子</span></span><br><span class="line"><span class="comment">// 组合类表示可能包含子项目的复杂组件。组合对象通常会将实际工作委派给子项目，然后“汇总”结果。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> <span class="keyword">implements</span> <span class="title">Article</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 盒子名称</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 包含的叶节点或容器</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Article&gt; articles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Box</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加商品或盒子</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Article article)</span> </span>&#123;</span><br><span class="line">        articles.add(article);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Article article)</span> </span>&#123;</span><br><span class="line">        articles.remove(article);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算盒子总价</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 访问每个组件，如果是商品直接计算，是盒子遍历所有项目</span></span><br><span class="line">        <span class="keyword">for</span> (Object obj : articles) &#123;</span><br><span class="line">            sum += ((Article) obj).calculate();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 盒子展示</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;盒子： &quot;</span> + name + <span class="string">&quot; 总价：&quot;</span> + calculate());</span><br><span class="line">        <span class="comment">// 访问每个组件，如果是商品直接展示，是盒子遍历所有项目</span></span><br><span class="line">        <span class="keyword">for</span> (Object obj : articles) &#123;</span><br><span class="line">            ((Article) obj).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出如下：</span></span><br><span class="line"><span class="comment">// 盒子： 大盒子 总价：4500.0</span></span><br><span class="line"><span class="comment">// name: 钢化膜 number: 5 price: 20.0 总价: 100.0</span></span><br><span class="line"><span class="comment">// 盒子： 中等盒子 总价：4400.0</span></span><br><span class="line"><span class="comment">// name: 手机 number: 1 price: 4000.0 总价: 4000.0</span></span><br><span class="line"><span class="comment">// 盒子： 小红盒子 总价：200.0</span></span><br><span class="line"><span class="comment">// name: 充电线 number: 2 price: 100.0 总价: 200.0</span></span><br><span class="line"><span class="comment">// 盒子： 小白盒子 总价：200.0</span></span><br><span class="line"><span class="comment">// name: 耳机 number: 1 price: 200.0 总价: 200.0</span></span><br></pre></td></tr></table></figure><h3 id="组合模式适用场景"><a href="#组合模式适用场景" class="headerlink" title="组合模式适用场景"></a>组合模式适用场景</h3><ol><li>如果你需要实现树状对象结构， 可以使用组合模式。</li><li>如果你希望客户端代码以相同方式处理简单和复杂元素， 可以使用该模式。</li></ol><h3 id="组合模式优缺点"><a href="#组合模式优缺点" class="headerlink" title="组合模式优缺点"></a>组合模式优缺点</h3><table><thead><tr><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">你可以利用多态和递归机制更方便地使用复杂树结构。</td><td align="center">对于功能差异较大的类， 提供公共接口或许会有困难。 在特定情况下， 你需要过度一般化组件接口， 使其变得令人难以理解。</td></tr><tr><td align="center">开闭原则。 无需更改现有代码， 你就可以在应用中添加新元素， 使其成为对象树的一部分。</td><td align="center"></td></tr></tbody></table><h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><p>装饰模式是一种结构型设计模式，允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。即在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）。</p><h3 id="装饰模式问题"><a href="#装饰模式问题" class="headerlink" title="装饰模式问题"></a>装饰模式问题</h3><p>假设你正在开发一个提供通知功能的库，其他程序可使用它向用户发送关于重要事件的通知。</p><p>库的最初版本基于通知器(Notifier)类，其中只有很少的几个成员变量，一个构造函数和一个send发送方法。该方法可以接收来自客户端的消息参数，并将该消息发送给一系列的邮箱，邮箱列表则是通过构造函数传递给通知器的。作为客户端的第三方程序仅会创建和配置通知器对象一次，然后在有重要事件发生时对其进行调用。</p><p>在不断发展后，有些用户希望使用微信通知，使用QQ通知，又或者使用短信通知。最简单的方法是： 扩展通知器类，然后在新的子类中加入额外的通知方法。现在客户端要对所需通知形式的对应类进行初始化，然后使用该类发送后续所有的通知消息。</p><p>但如果用户希望组合不同的方式，如果创建特殊子类来整合的话，代码量会迅速膨胀。而且不仅是程序库，客户端也是如此。</p><h3 id="装饰模式解决方案"><a href="#装饰模式解决方案" class="headerlink" title="装饰模式解决方案"></a>装饰模式解决方案</h3><p>使用扩展当前类来增加功能有以下两个问题：</p><ul><li>继承是静态的。你无法在运行时更改已有对象的行为，只能使用由不同子类创建的对象来替代当前的整个对象。</li><li>子类只能有一个父类。大部分编程语言不允许一个类同时继承多个类的行为。</li></ul><p>另一种方法是使用聚合或组合，而不是继承。两者的工作方式几乎一模一样： 一个对象包含指向另一个对象的引用，并将部分工作委派给引用对象； 继承中的对象则继承了父类的行为，它们自己能够完成这些工作。</p><blockquote><p>聚合组合是许多设计模式背后的关键原则 （包括装饰在内）。</p><ul><li>聚合：对象A包含对象B；对象B可以独立存在而不依赖A。</li><li>组合：对象A由对象B组成；A负责管理B的生命周期。B无法独立于A存在。</li></ul></blockquote><p>封装器是装饰模式的别称，这个称谓明确地表达了该模式的主要思想。​ “封装器” 是一个能与其他 “目标” 对象连接的对象。封装器包含与目标对象相同的一系列方法，它会将所有接收到的请求委派给目标对象。但是，封装器可以在将请求委派给目标前后对其进行处理，所以可能会改变最终结果。</p><p>例如将邮件通知放在基类中，将其他所有通知方法放在装饰中。</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200816170420.png" alt="20200816170420"></p><p>客户端代码必须将基础通知器放入一系列自己所需的装饰中。因此最后的对象将形成一个栈结构。</p><p>例如衣服是装饰，人是基类。你可以通过组合衣服获得不同效果。觉得冷时，你可以穿一件毛衣。如果穿毛衣还觉得冷 你可以再套上一件夹克。如果遇到下雨，你还可以再穿一件雨衣。所有这些衣物都 “扩展” 了你的基本行为，但它们并不是你的一部分，如果你不再需要某件衣物，可以方便地随时脱掉。</p><h3 id="装饰模式结构"><a href="#装饰模式结构" class="headerlink" title="装饰模式结构"></a>装饰模式结构</h3><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200816170621.png" alt="20200816170621"></p><ol><li><strong>部件</strong> （Component） 声明封装器和被封装对象的公用接口。</li><li><strong>具体部件</strong> （Concrete Component） 类是被封装对象所属的类。它定义了基础行为，但装饰类可以改变这些行为。</li><li><strong>基础装饰</strong> （Base Decorator） 类拥有一个指向被封装对象的引用成员变量。该变量的类型应当被声明为通用部件接口，这样它就可以引用具体的部件和装饰。装饰基类会将所有操作委派给被封装的对象。</li><li><strong>具体装饰类</strong> （Concrete Decorators） 定义了可动态添加到部件的额外行为。具体装饰类会重写装饰基类的方法，并在调用父类方法之前或之后进行额外的行为。</li><li><strong>客户端</strong> （Client） 可以使用多层装饰来封装部件，只要它能使用通用接口与所有对象互动即可。</li></ol><p>代码示例：</p><p>基本功能：文件的下载和读取。在此基础上，可以选择对文件进行加密或者压缩。又或者添加两个功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端（Client）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用核心功能</span></span><br><span class="line">        FileDataSource fileDataSource = <span class="keyword">new</span> FileDataSource();</span><br><span class="line">        <span class="comment">// 上一步的基础上添加加密和解密</span></span><br><span class="line">        Encrypt encrypt = <span class="keyword">new</span> Encrypt(fileDataSource);</span><br><span class="line">        System.out.println(<span class="string">&quot;---添加加密和解密功能---&quot;</span>);</span><br><span class="line">        encrypt.writeData();</span><br><span class="line">        encrypt.readData();</span><br><span class="line">        <span class="comment">// 上一步的基础上添加压缩和解压</span></span><br><span class="line">        Compression compression = <span class="keyword">new</span> Compression(encrypt);</span><br><span class="line">        System.out.println(<span class="string">&quot;---加密基础上添加压缩功能---&quot;</span>);</span><br><span class="line">        compression.writeData();</span><br><span class="line">        compression.readData();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部件（Component）公共接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DataSource</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeData</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readData</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体部件（Concrete Component）基础行为：写入，读取</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileDataSource</span> <span class="keyword">implements</span> <span class="title">DataSource</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;写入数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;读取数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基础装饰（Base Decorator）封装器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataSourceDecorator</span> <span class="keyword">implements</span> <span class="title">DataSource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DataSourceDecorator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DataSourceDecorator</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体装饰类1：加密（Concrete Decorators）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Encrypt</span> <span class="keyword">extends</span> <span class="title">DataSourceDecorator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Encrypt</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数据加密&quot;</span>);</span><br><span class="line">        dataSource.writeData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数据解密&quot;</span>);</span><br><span class="line">        dataSource.readData();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体装饰类2：压缩（Concrete Decorators）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compression</span> <span class="keyword">extends</span> <span class="title">DataSourceDecorator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Compression</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数据压缩&quot;</span>);</span><br><span class="line">        dataSource.writeData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数据解压&quot;</span>);</span><br><span class="line">        dataSource.readData();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ---添加加密和解密功能---</span></span><br><span class="line"><span class="comment">// 数据加密</span></span><br><span class="line"><span class="comment">// 写入数据</span></span><br><span class="line"><span class="comment">// 数据解密</span></span><br><span class="line"><span class="comment">// 读取数据</span></span><br><span class="line"><span class="comment">// ---加密基础上添加压缩功能---</span></span><br><span class="line"><span class="comment">// 数据压缩</span></span><br><span class="line"><span class="comment">// 数据加密</span></span><br><span class="line"><span class="comment">// 写入数据</span></span><br><span class="line"><span class="comment">// 数据解压</span></span><br><span class="line"><span class="comment">// 数据解密</span></span><br><span class="line"><span class="comment">// 读取数据</span></span><br></pre></td></tr></table></figure><p>可以看出，在基础功能上可以自由组合功能。</p><h3 id="装饰模式适用场景"><a href="#装饰模式适用场景" class="headerlink" title="装饰模式适用场景"></a>装饰模式适用场景</h3><ol><li>在无需修改代码的情况下使用对象，且希望在运行时为对象新增额外的行为<ul><li>装饰能将业务逻辑组织为层次结构，你可为各层创建一个装饰，在运行时将各种不同逻辑组合成对象。由于这些对象都遵循通用接口，客户端代码能以相同的方式使用这些对象。</li></ul></li><li>用继承来扩展对象行为的方案难以实现或者根本不可行<ul><li>许多编程语言使用 final最终关键字来限制对某个类的进一步扩展。复用最终类已有行为的唯一方法是使用装饰模式： 用封装器对其进行封装。</li></ul></li></ol><h3 id="装饰模式优缺点"><a href="#装饰模式优缺点" class="headerlink" title="装饰模式优缺点"></a>装饰模式优缺点</h3><table><thead><tr><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">你无需创建新子类即可扩展对象的行为。</td><td align="center">在封装器栈中删除特定封装器比较困难。</td></tr><tr><td align="center">你可以在运行时添加或删除对象的功能。</td><td align="center">实现行为不受装饰栈顺序影响的装饰比较困难。</td></tr><tr><td align="center">你可以用多个装饰封装对象来组合几种行为。</td><td align="center">各层的初始化配置代码看上去可能会很糟糕。</td></tr><tr><td align="center">单一职责原则。你可以将实现了许多不同行为的一个大类拆分为多个较小的类。</td><td align="center"></td></tr></tbody></table><div class="note warning flat"><p>装饰和代理有着相似的结构，但是其意图却非常不同。这两个模式的构建都基于组合原则，也就是说一个对象应该将部分工作委托给另一个对象。两者之间的不同之处在于代理通常自行管理其服务对象的生命周期和功能的扩展，而装饰的生成则总是由客户端进行控制。</p></div><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p><strong>外观模式</strong>是一种结构型设计模式， 能为程序库、 框架或其他复杂类提供一个简单的接口。</p><h3 id="外观模式问题"><a href="#外观模式问题" class="headerlink" title="外观模式问题"></a>外观模式问题</h3><p>在现实生活中，常常存在办事较复杂的例子，例如申请一些东西，有时要同多个部门联系，这时要是有一个综合部门能解决一切手续问题就好了。</p><p>在程序设计中，当一个系统的功能越来越强，子系统会越来越多，客户对系统的访问也变得越来越复杂。这时如果系统内部发生改变，客户端也要跟着改变，这违背了“开闭原则”，也违背了“迪米特法则”，所以有必要为多个子系统提供一个统一的接口，从而降低系统的耦合度，这就是外观模式的目标。</p><h3 id="外观模式解决方案"><a href="#外观模式解决方案" class="headerlink" title="外观模式解决方案"></a>外观模式解决方案</h3><p>外观类为包含许多活动部件的复杂子系统提供一个简单的接口。 与直接调用子系统相比， 外观提供的功能可能比较有限， 但它却包含了客户端真正关心的功能。</p><p>例如：在淘宝下单后，商店包装，快递揽收，送达，这是一系列复杂的流程，但是你只需要下单就完成了这一系列流程的调用。</p><h3 id="外观模式结构"><a href="#外观模式结构" class="headerlink" title="外观模式结构"></a>外观模式结构</h3><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200901141820.png" alt="20200901141820"></p><ol><li><strong>外观</strong> （Facade） 提供了一种访问特定子系统功能的便捷方式， 其了解如何重定向客户端请求， 知晓如何操作一切活动部件。</li><li><strong>创建附加外观</strong> （Additional Facade） 类可以避免多种不相关的功能污染单一外观， 使其变成又一个复杂结构。 客户端和其他外观都可使用附加外观。</li><li><strong>复杂子系统</strong> （Complex Subsystem） 由数十个不同对象构成。 如果要用这些对象完成有意义的工作， 你必须深入了解子系统的实现细节， 比如按照正确顺序初始化对象和为其提供正确格式的数据。<br> 子系统类不会意识到外观的存在， 它们在系统内运作并且相互之间可直接进行交互。</li><li><strong>客户端</strong> （Client） 使用外观代替对子系统对象的直接调用。</li></ol><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FacadeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Buy buy = <span class="keyword">new</span> Buy();</span><br><span class="line">        buy.buy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 复杂子系统</span></span><br><span class="line"><span class="comment">// 付款</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pay</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;付款&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出库</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shop</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;商家出库&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 揽收</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collect</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;快递揽收&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运输</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transport</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;快递运输&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派送</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deliver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;快递派送&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 签收</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;快递签收&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对外接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Buy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Pay().show();</span><br><span class="line">        <span class="keyword">new</span> Shop().show();</span><br><span class="line">        <span class="keyword">new</span> Collect().show();</span><br><span class="line">        <span class="keyword">new</span> Transport().show();</span><br><span class="line">        <span class="keyword">new</span> Deliver().show();</span><br><span class="line">        <span class="keyword">new</span> User().show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，为复杂子系统提供一个对外接口，客户端只需要简单的调用接口即可。</p><h3 id="外观模式适用场景"><a href="#外观模式适用场景" class="headerlink" title="外观模式适用场景"></a>外观模式适用场景</h3><ol><li>如果你需要一个指向复杂子系统的直接接口， 且该接口的功能有限， 则可以使用外观模式。</li><li>如果需要将子系统组织为多层结构， 可以使用外观。</li></ol><h3 id="外观模式优缺点"><a href="#外观模式优缺点" class="headerlink" title="外观模式优缺点"></a>外观模式优缺点</h3><table><thead><tr><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">你可以让自己的代码独立于复杂子系统。</td><td align="center">外观可能成为与程序中所有类都耦合的上帝对象。</td></tr></tbody></table><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p><strong>享元模式</strong>是一种结构型设计模式， 它摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象。</p><h3 id="享元模式问题"><a href="#享元模式问题" class="headerlink" title="享元模式问题"></a>享元模式问题</h3><p>在面向对象程序设计过程中，有时会面临要创建大量相同或相似对象实例的问题。创建那么多的对象将会耗费很多的系统资源，它是系统性能提高的一个瓶颈。例如，围棋和五子棋中的黑白棋子，图像中的坐标点或颜色，局域网中的路由器、交换机和集线器，教室里的桌子和凳子等。这些对象有很多相似的地方，如果能把它们相同的部分提取出来共享，则能节省大量的系统资源，这就是享元模式的产生背景。</p><h3 id="享元模式解决方案"><a href="#享元模式解决方案" class="headerlink" title="享元模式解决方案"></a>享元模式解决方案</h3><p>在黑白棋子，坐标点这些类中，你会发现一些成员变量储存的值是相同的，而每个粒子的另一些状态（坐标，颜色等）是不同的。</p><p>对象的常量数据通常被称为<strong>内在状态</strong>（即不会随着环境的改变而改变的可共享部分）， 其位于对象中，其他对象只能读取但不能修改其数值。而对象的其他状态常常能被其他对象 “从外部” 改变，因此被称为<strong>外在状态</strong>（随环境改变而改变的不可以共享的部分）。</p><p>享元模式建议不在对象中存储外在状态，而是将其传递给依赖于它的一个特殊方法。程序只在对象中保存内在状态，以方便在不同情景下重用。这些对象的区别仅在于其内在状态（与外在状态相比，内在状态的变体要少很多），因此你所需的对象数量会大大削减。</p><h3 id="享元工厂"><a href="#享元工厂" class="headerlink" title="享元工厂"></a>享元工厂</h3><p>为了能更方便地访问各种享元， 你可以创建一个工厂方法来管理已有享元对象的缓存池。 工厂方法从客户端处接收目标享元对象的内在状态作为参数， 如果它能在缓存池中找到所需享元， 则将其返回给客户端； 如果没有找到， 它就会新建一个享元， 并将其添加到缓存池中。</p><h3 id="享元模式结构"><a href="#享元模式结构" class="headerlink" title="享元模式结构"></a>享元模式结构</h3><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200902103014.png" alt="20200902103014"></p><ol><li><strong>享元模式</strong>只是一种优化。 在应用该模式之前， 你要确定程序中存在与大量类似对象同时占用内存相关的内存消耗问题， 并且确保该问题无法使用其他更好的方式来解决。</li><li><strong>享元</strong> （Flyweight） 类包含原始对象中部分能在多个对象中共享的状态。 同一享元对象可在许多不同情景中使用。 享元中存储的状态被称为 “内在状态”。 传递给享元方法的状态被称为 “外在状态”。</li><li><strong>情景</strong> （Context） 类包含原始对象中各不相同的外在状态。 情景与享元对象组合在一起就能表示原始对象的全部状态。</li><li>通常情况下， 原始对象的行为会保留在享元类中。 因此调用享元方法必须提供部分外在状态作为参数。 但你也可将行为移动到情景类中， 然后将连入的享元作为单纯的数据对象。</li><li><strong>客户端</strong> （Client） 负责计算或存储享元的外在状态。 在客户端看来， 享元是一种可在运行时进行配置的模板对象， 具体的配置方式为向其方法中传入一些情景数据参数。</li><li><strong>享元工厂</strong> （Flyweight Factory） 会对已有享元的缓存池进行管理。 有了工厂后， 客户端就无需直接创建享元， 它们只需调用工厂并向其传递目标享元的一些内在状态即可。 工厂会根据参数在之前已创建的享元中进行查找， 如果找到满足条件的享元就将其返回； 如果没有找到就根据参数新建享元。</li></ol><p>代码示例：</p><p>模拟黑白棋子的创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简化下棋</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyweightTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            ChessFactory chessFactory = <span class="keyword">new</span> ChessFactory();</span><br><span class="line">            Chessman w = chessFactory.getChess(<span class="string">&quot;w&quot;</span>);</span><br><span class="line">            w.down(i, i);</span><br><span class="line">            Chessman b = chessFactory.getChess(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">            b.down(i + <span class="number">10</span>, i + <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象享元角色：棋子</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Chessman</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体享元角色：白棋</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WhiteChess</span> <span class="keyword">implements</span> <span class="title">Chessman</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        color = <span class="string">&quot;white&quot;</span>;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">        show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(color + <span class="string">&quot; &quot;</span> + x + <span class="string">&quot; : &quot;</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体享元角色：黑棋</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlackChess</span> <span class="keyword">implements</span> <span class="title">Chessman</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        color = <span class="string">&quot;black&quot;</span>;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">        show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(color + <span class="string">&quot; &quot;</span> + x + <span class="string">&quot; : &quot;</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 享元工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChessFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Chessman&gt; list;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String WHITE = <span class="string">&quot;w&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String BLACK = <span class="string">&quot;b&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChessFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Chessman whiteChess = <span class="keyword">new</span> WhiteChess();</span><br><span class="line">        list.add(whiteChess);</span><br><span class="line">        Chessman blackChess = <span class="keyword">new</span> BlackChess();</span><br><span class="line">        list.add(blackChess);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Chessman <span class="title">getChess</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (WHITE.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (BLACK.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> list.get(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="享元模式适用场景"><a href="#享元模式适用场景" class="headerlink" title="享元模式适用场景"></a>享元模式适用场景</h3><ol><li>仅在程序必须支持大量对象且没有足够的内存容量时使用享元模式。</li></ol><h3 id="享元模式优缺点"><a href="#享元模式优缺点" class="headerlink" title="享元模式优缺点"></a>享元模式优缺点</h3><table><thead><tr><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">如果程序中有很多相似对象， 那么你将可以节省大量内存。</td><td align="center">你可能需要牺牲执行速度来换取内存， 因为他人每次调用享元方法时都需要重新计算部分情景数据。</td></tr><tr><td align="center"></td><td align="center">代码会变得更加复杂。 团队中的新成员总是会问： ​ “为什么要像这样拆分一个实体的状态？”。</td></tr></tbody></table><h2 id="代理模式-Proxy"><a href="#代理模式-Proxy" class="headerlink" title="代理模式(Proxy)"></a>代理模式(Proxy)</h2><p>代理模式是一种结构型设计模式，让你能够提供对象的替代品或其占位符。代理控制着对于目标对象的访问，并允许在将请求提交给对象前后进行一些处理。</p><h3 id="代理模式问题"><a href="#代理模式问题" class="headerlink" title="代理模式问题"></a>代理模式问题</h3><p>为什么要控制对于某个对象的访问呢？举个例子：有这样一个消耗大量系统资源的巨型对象，你只是偶尔需要使用它，并非总是需要。</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200816161130.png" alt="20200816161130"></p><p>或者给对象添加功能：在理想情况下，我们希望将代码直接放入对象的类中进行修改，但这并非总是能实现：比如类可能是第三方封闭库的一部分。所以我们也需要代理对象来添加功能</p><h3 id="代理模式解决方案"><a href="#代理模式解决方案" class="headerlink" title="代理模式解决方案"></a>代理模式解决方案</h3><p>代理模式建议新建一个与原目标对象接口相同的代理类，然后更新应用以将代理对象传递给所有原始对象客户端。代理类接收到客户端请求后会创建实际的目标对象，并将所有工作委派给它。</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200816161157.png" alt="20200816161157"></p><p>这有什么好处呢？</p><ul><li>如果需要在类的主要业务逻辑前后执行一些工作，你无需修改类就能完成这项工作。</li><li>由于代理实现的接口与原类相同，因此你可将其传递给任何一个使用实际服务对象的客户端。</li></ul><p>例：</p><p>信用卡是银行账户的代理，银行账户则是一大捆现金的代理。它们都实现了同样的接口，均可用于进行支付。<br>你通过信用卡操作银行帐户，然后进行转账等操作完成支付。不需要携带一大笔现金来完成支付。<br>又例如支付完成后，银行发的通知短信，这是对现金操作添加的额外功能。</p><h3 id="代理模式结构"><a href="#代理模式结构" class="headerlink" title="代理模式结构"></a>代理模式结构</h3><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200816161253.png" alt="20200816161253"></p><ol><li><strong>服务接口</strong>（Service Interface）声明了服务接口。代理必须遵循该接口才能伪装成服务对象。</li><li><strong>服务</strong>（Service）类提供了一些实用的业务逻辑。</li><li><strong>代理</strong>（Proxy）类包含一个指向服务对象的引用成员变量。代理完成其任务（例如延迟初始化、记录日志、访问控制和缓存等）后会将请求传递给服务对象。通常情况下，代理会对其服务对象的整个生命周期进行管理。</li><li><strong>客户端</strong>（Client）能通过同一接口与服务或代理进行交互，所以你可在一切需要服务对象的代码中使用代理。</li></ol><blockquote><p><a href="https://shiming.online/blog/7b510e10/">代码示例</a></p></blockquote><h3 id="代理模式适用场景"><a href="#代理模式适用场景" class="headerlink" title="代理模式适用场景"></a>代理模式适用场景</h3><ol><li>延迟初始化（虚拟代理）。如果你有一个偶尔使用的重量级服务对象，一直保持该对象运行会消耗系统资源时，可使用代理模式。<ul><li>你无需在程序启动时就创建该对象，可将对象的初始化延迟到真正有需要的时候。</li></ul></li><li>访问控制（保护代理）。如果你只希望特定客户端使用服务对象，这里的对象可以是操作系统中非常重要的部分，而客户端则是各种已启动的程序（包括恶意程序），此时可使用代理模式。<ul><li>代理可仅在客户端凭据满足要求时将请求传递给服务对象。</li></ul></li><li>本地执行远程服务（远程代理）。适用于服务对象位于远程服务器上的情形。<ul><li>在这种情形中，代理通过网络传递客户端请求，负责处理所有与网络相关的复杂细节。</li></ul></li><li>记录日志请求（日志记录代理）。适用于当你需要保存对于服务对象的请求历史记录时。代理可以在向服务传递请求前进行记录。</li><li>缓存请求结果 （缓存代理）。适用于需要缓存客户请求结果并对缓存生命周期进行管理时，特别是当返回结果的体积非常大时。<ul><li>代理可对重复请求所需的相同结果进行缓存，还可使用请求参数作为索引缓存的键值。</li></ul></li><li>智能引用。可以使用某个重量级对象时立即销毁该对象。<ul><li>代理会将所有获取了指向服务对象或其结果的客户端记录在案。代理会时不时地遍历各个客户端，检查它们是否仍在运行。如果相应的客户端列表为空，代理就会销毁该服务对象，释放底层系统资源。</li><li>代理还可以记录客户端是否修改了服务对象。其他客户端还可以复用未修改的对象。</li></ul></li></ol><h3 id="代理模式优缺点"><a href="#代理模式优缺点" class="headerlink" title="代理模式优缺点"></a>代理模式优缺点</h3><table><thead><tr><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">在客户端毫无察觉的情况下控制服务对象。</td><td align="center">代码可能会变得复杂，因为需要新建许多类。</td></tr><tr><td align="center">如果客户端对服务对象的生命周期没有特殊要求，你可以对生命周期进行管理。</td><td align="center">服务响应可能会延迟。</td></tr><tr><td align="center">即使服务对象还未准备好或不存在，代理也可以正常工作。</td><td align="center"></td></tr><tr><td align="center">开闭原则。你可以在不对服务或客户端做出修改的情况下创建新代理。</td><td align="center"></td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ul><li><a href="https://refactoringguru.cn/design-patterns">免费在线学习设计模式</a></li><li><a href="http://c.biancheng.net/design_pattern/">C语言中文网-设计模式</a></li></ul></blockquote><a class="btn-beautify button--animated block blue right" href="https://www.shiming.online/blog/e55dcfb0/"   title="设计模式-行为型模式"><i class="far fa-hand-point-right fa-fw"></i><span>设计模式-行为型模式</span></a>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP和HTTPS的区别</title>
      <link href="blog/4c5df410/"/>
      <url>blog/4c5df410/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>HTTP是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。</p></blockquote><p>HTTP（超文本传输协议）被用于在Web浏览器和网站服务器之间，以明文方式传递信息，不提供任何方式的数据加密，因此使用HTTP协议传输隐私信息（如：银行卡号、密码等支付信息）非常不安全。</p><p>为了解决这一安全缺陷，网景公司设计了SSL（Secure Sockets Layer）协议，在HTTP的基础上加入了SSL（Secure Sockets Layer）协议，SSL依靠SSL证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。从而诞生了HTTPS（安全套接字层超文本传输协议）。</p><p>简单来说，**HTTPS协议=”SSL/TSL+HTTP协议”**构建的可进行加密传输、身份认证的网络协议，是HTTP的安全版。</p><h2 id="SSL-TSL"><a href="#SSL-TSL" class="headerlink" title="SSL/TSL"></a>SSL/TSL</h2><blockquote><p>SSL(Secure Sockets Layer 安全套接字协议),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层与应用层之间对网络连接进行加密。</p><p>SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。SSL协议可分为两层： SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</p></blockquote><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul><li>密码学(cryptography)：目的是通过将信息编码使其不可读，从而达到安全性。</li><li>明文(plain text)：发送人、接受人和任何访问消息的人都能理解的消息。</li><li>密文(cipher text)：明文消息经过某种编码后，得到密文消息。</li><li>加密(encryption)：将明文消息变成密文消息。</li><li>解密(decryption)：将密文消息变成明文消息。</li><li>算法：取一个输入文本，产生一个输出文本。</li><li>加密算法：发送方进行加密的算法。</li><li>解密算法：接收方进行解密的算法。</li><li>密钥(key)：只有发送方和接收方理解的消息</li><li>对称密钥加密(Symmetric Key Cryptography)：加密与解密使用相同密钥。</li><li>非对称密钥加密(Asymmetric Key Cryptography)：加密与解密使用不同密钥。</li></ul><h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200828212000.png" alt="20200828212000"></p><p>在对称加密中，发送端和接收端使用相同的密钥进行通信。发送端使用共享的密钥发送报文，然后将密文发送到接收端。接收端使用相同密钥解密密文，恢复原始数据。</p><h4 id="非对称密钥加密"><a href="#非对称密钥加密" class="headerlink" title="非对称密钥加密"></a>非对称密钥加密</h4><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200828212012.png" alt="20200828212012"></p><p>非对称加密也称为公开密钥加密技术，就是使用不同密钥进行通信的加密技术。</p><p>非对称加密技术使用了不同的密钥进行通信，在发送端使用公钥对报文进行加密（公钥就是所用人都可以获取到的密钥），然后在接收端使用私钥对加密的密文进行解密。常见的非对称加密技术是RSA技术。</p><h4 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h4><p>数字签名是附加在报文上的特殊加密校验码。数字签名可以防止报文被篡改，如果有恶意攻击在传输过程在篡改了报文，那么校验的时候校验和就不再匹配，因此可以确认报文被篡改了。</p><p>数字签名的加解密过程：</p><ul><li>发送端将报文通过算法（比如通过HASH函数）提取为定长的摘要；</li><li>发送端将摘要应用签名算法，以私有密钥作为参数生成一个签名；</li><li>计算得出签名后，将签名附加在报文末端发送给接收方；</li><li>接收端收到报文后，对签名进行检查。接收端通过公开密钥解码签名。然后比对报文生成的摘要是否与签名一致便可判断报文是否被篡改。</li></ul><h4 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h4><p>数字证书是由权威机构给某网站颁发的一种认可凭证。它主要包含一些认证信息，比如：对象的名称（服务器、组织、个人等）、过期时间、证书颁发者、来自证书发布者的数字签名。</p><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><h3 id="HTTP工作流程"><a href="#HTTP工作流程" class="headerlink" title="HTTP工作流程"></a>HTTP工作流程</h3><ol><li>客户端的浏览器首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的，一般 TCP 连接的端口号是80。 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和许可内容。</li><li>服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。</li></ol><h3 id="HTTPS工作流程"><a href="#HTTPS工作流程" class="headerlink" title="HTTPS工作流程"></a>HTTPS工作流程</h3><ul><li>TCP 三次同步握手</li><li>客户端验证服务器数字证书</li><li>DH 算法协商对称加密算法的密钥、hash 算法的密钥</li><li>SSL 安全加密隧道协商完成</li><li>网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。</li></ul><h2 id="HTTPS原理"><a href="#HTTPS原理" class="headerlink" title="HTTPS原理"></a>HTTPS原理</h2><blockquote><p>图片来自<a href="https://www.runoob.com/w3cnote/http-vs-https.html">HTTP 与 HTTPS 的区别</a><br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200828165603.png" alt="20200828165603"></p></blockquote><p>步骤如下：</p><h3 id="1-客户端发起HTTPS请求"><a href="#1-客户端发起HTTPS请求" class="headerlink" title="1. 客户端发起HTTPS请求"></a>1. 客户端发起HTTPS请求</h3><p>输入网址，然后连接到server的443端口</p><h3 id="2-服务端的配置"><a href="#2-服务端的配置" class="headerlink" title="2. 服务端的配置"></a>2. 服务端的配置</h3><p><strong>采用HTTPS协议的服务器必须要有一套数字证书</strong>，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。<br>这套证书其实就是一对公钥和私钥，可以这么理解，公钥就是一把锁头，私钥就是这把锁的钥匙，锁头可以给别人对某个东西进行加锁，但是加锁完毕之后，只有持有这把锁的钥匙才可以解锁看到加锁的内容。</p><h3 id="3-传送证书"><a href="#3-传送证书" class="headerlink" title="3. 传送证书"></a>3. 传送证书</h3><p>这个证书其实就是<strong>公钥</strong>，只是包含了很多信息，如证书的颁发机构，过期时间等等。</p><h3 id="4-客户端解析证书"><a href="#4-客户端解析证书" class="headerlink" title="4. 客户端解析证书"></a>4. 客户端解析证书</h3><p>这部分工作是由<strong>客户端的TLS来完成</strong>的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就<strong>生成一个随机值。然后用证书对该随机值进行加密。</strong>就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。</p><h3 id="5-传送加密信息"><a href="#5-传送加密信息" class="headerlink" title="5. 传送加密信息"></a>5. 传送加密信息</h3><p>这部分传送的是用<strong>证书加密后的随机值</strong>，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</p><h3 id="6-服务段解密信息"><a href="#6-服务段解密信息" class="headerlink" title="6. 服务段解密信息"></a>6. 服务段解密信息</h3><p>服务端用<strong>私钥解密</strong>后，得到了客户端传过来的随机值（<strong>非对称加密</strong>，服务端和客户端利用非对称加密实现了身份认证和密钥协商。），然后把<strong>内容通过该值进行对称加密</strong>。所谓对称加密就是，将信息和随机值通过某种算法混合在一起，这样除非知道随机值，不然无法获取内容，而正好客户端和服务端都知道这个随机值，所以只要加密算法够彪悍，随机值够复杂，数据就够安全。</p><h3 id="7-传输加密后的信息"><a href="#7-传输加密后的信息" class="headerlink" title="7. 传输加密后的信息"></a>7. 传输加密后的信息</h3><p>这部分信息是服务段用随机值加密后的信息，可以在客户端被还原</p><h3 id="8-客户端解密信息"><a href="#8-客户端解密信息" class="headerlink" title="8. 客户端解密信息"></a>8. 客户端解密信息</h3><p>客户端用之前生成的随机值解密服务段传过来的信息，于是获取了解密后的内容（<strong>对称加密</strong>，用于传输数据）。整个过程第三方即使监听到了数据，也束手无策。</p><p>这里有两个问题</p><ol><li>如何保证公钥不被篡改。<br>将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。</li><li>为什么不用公钥加密？<br>公钥加密计算量太大，耗用时间太多。而每一次对话（session），客户端和服务器端都生成一个”对话密钥”（session key），用它来加密信息。由于”对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”对话密钥”本身，这样就减少了加密运算的消耗时间。</li></ol><h2 id="相同之处"><a href="#相同之处" class="headerlink" title="相同之处"></a>相同之处</h2><p>大多情况下，HTTP和HTTPS是相同的，因为都是采用同一个基础的协议，作为HTTP或HTTPS客户端（浏览器），设立一个连接到Web服务器指定的端口。当服务器接收到请求，它会返回一个状态码以及消息，这个回应可能是请求信息、或者指示某个错误发送的错误信息。<br>系统使用统一资源定位器 URI 模式，因此资源可以被唯一指定。整个过程中，唯一不同的只是一个协议头(HTTPS)的说明，其他都是一样的。</p><h2 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h2><p>HTTPS和HTTP的区别主要如下：</p><ul><li><strong>连接端口</strong>：HTTP标准端口是80，而HTTPS的标准端口是443。</li><li><strong>传输方式</strong>：HTTP是超文本传输协议，信息是明文传输，而HTTPS是SSL加密传输协议。</li><li><strong>工作耗时</strong>：HTTP耗时=TCP握手，而HTTPS耗时=TCP握手+SSL握手。</li><li><strong>显示形式</strong>：HTTP的URL以<code>http://</code>开头，而HTTPS的URL以<code>https://</code>开头。</li><li><strong>费用</strong>：HTTP无需费用，而HTTPS需要到CA申请证书。</li><li><strong>安全性</strong>：HTTP的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ul><li><a href="https://help.trustasia.com/http-vs-https/">HTTP和HTTPS的区别?</a></li><li><a href="https://blog.csdn.net/sean_cd/article/details/6966130">https工作原理</a></li><li><a href="https://blog.csdn.net/programerxiaoer/article/details/99713731">HTTPS工作原理</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>打开一个网站发生了什么？</title>
      <link href="blog/84a7ac10/"/>
      <url>blog/84a7ac10/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>从大致上讲：</p><p>客户端获取URL - &gt; DNS解析 - &gt; TCP连接 - &gt;发送HTTP请求 - &gt;服务器处理请求 - &gt;返回报文 - &gt;浏览器解析渲染页面 - &gt; TCP断开连接。</p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><h3 id="浏览器根据域名查询域名对应的服务器的IP地址"><a href="#浏览器根据域名查询域名对应的服务器的IP地址" class="headerlink" title="浏览器根据域名查询域名对应的服务器的IP地址"></a>浏览器根据域名查询域名对应的服务器的IP地址</h3><p>查找顺序如下：浏览器DNS缓存 - &gt; 操作系统DNS缓存 - &gt; 路由器缓存 - &gt; 本地（ISP）域名服务器缓存 - &gt; 根域名服务器。</p><ul><li>浏览器缓存：首先是查找浏览器缓存,浏览器会缓存DNS记录一段时间，不同浏览器保存的时常不等（2分钟到30分钟不等）。</li><li>系统缓存：如果在浏览器缓存里没有找到需要的记录，浏览器会做一个系统调用来查找这个网址的对应DNS信息。</li><li>路由器缓存：如果在系统缓存里没有找到找到对应的IP，请求会发向路由器，它一般会有自己的DNS缓存。</li><li>ISP DNS服务器：如果在路由器缓存里还是没有对应的IP，请求会被发送到ISP。</li><li>根域名服务器：如果还是没有，请求将发向根域名服务器进行搜索。找不到就说明此域名不存在。</li></ul><h3 id="浏览器主机根据IP地址与服务器建立TCP连接"><a href="#浏览器主机根据IP地址与服务器建立TCP连接" class="headerlink" title="浏览器主机根据IP地址与服务器建立TCP连接"></a>浏览器主机根据IP地址与服务器建立TCP连接</h3><p>建立TCP连接需要进行三次握手：<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200828141923.png" alt="20200828141923">、</p><ol><li>浏览器主机 - &gt; 服务器：SYN = 1，seq = x；<br>主机发出连接请求报文段，报文首部中的同步位：SYN = 1，初始序号 seq = x。SYN报文段<strong>不能携带数据</strong>，但是要<strong>消耗一个序号</strong>。</li><li>服务器 - &gt; 浏览器主机：SYN = 1，ACK = 1，seq = y，ack = x+1;<br>服务器接收后，如果确认连接，向浏览器发送确认报文。确认报文中的 SYN 和 ACK 都为 1。确认号 ack = x + 1，自己的初始序号 seq = y。这个报文段也不能携带数据，但同样要消耗一个序号。</li><li>浏览器主机 -&gt; 服务器：ACK = 1，seq = x+1，ack = y+1。<br>客户端接收到服务端的确认后，再给服务端给出确认。确认报文段的ACK为1，确认号 ack = y + 1，而自己的序号为 x + 1。ACK报文段可以携带数据，但<strong>如果不携带数据则不消耗序号</strong>。</li></ol><p>通俗的说法：</p><ol><li><p>Client：嘿，Server，是我，听到了吗？</p></li><li><p>Server：我听到了，你能听到我的吗?</p></li><li><p>Client：好的，我们互相都能听到对方的话，我们的通信可以开始了。</p></li></ol><div class="note warning flat"><p>三次握手其实是在一次握手过程中交换了三个报文（就像两个人第一次见面进行一次握手时，手上下摇晃了三次，而并非是进行了三次握手。在 《计算机网络》-谢希仁 第7版中使用<strong>三报文握手</strong>代替三次握手。</p></div><h4 id="为什么需要三次握手"><a href="#为什么需要三次握手" class="headerlink" title="为什么需要三次握手"></a>为什么需要三次握手</h4><p>在这本书中也提到了为什么需要三次握手？主要是为了<strong>防止已失效的连接请求报文段突然又传送到了B，因而产生错误</strong>。</p><p>举例如下：<br>client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。<br>本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。<br>由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。</p><h3 id="浏览器将访问请求封装为一个HTTP请求报文，通过TCP协议发送给服务器"><a href="#浏览器将访问请求封装为一个HTTP请求报文，通过TCP协议发送给服务器" class="headerlink" title="浏览器将访问请求封装为一个HTTP请求报文，通过TCP协议发送给服务器"></a>浏览器将访问请求封装为一个HTTP请求报文，通过TCP协议发送给服务器</h3><p>请求报文由请求行（request line）、请求头（header）、请求体三个部分组成。<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200828145018.png" alt="20200828145018"></p><p>参考<a href="shiming.online/blog/8564">HTTP协议</a></p><h3 id="服务器处理请求并返回-HTTP-报文"><a href="#服务器处理请求并返回-HTTP-报文" class="headerlink" title="服务器处理请求并返回 HTTP 报文"></a>服务器处理请求并返回 HTTP 报文</h3><p>即MVC后台处理+HTTP响应报文</p><h3 id="浏览器解析渲染页面"><a href="#浏览器解析渲染页面" class="headerlink" title="浏览器解析渲染页面"></a>浏览器解析渲染页面</h3><p>在浏览器没有完整接受全部HTML文档时，它就已经开始显示这个页面了，如果是个静态的页面，拿到此就基本结束了。如果是是动态的，那么在浏览器显示HTML时，会获取嵌入在HTML中的对象，浏览器会发送获取请求来重新获得这些文件。这些请求都要经历一个和HTML读取类似的过程。</p><p>对于静态的页面内容，浏览器通常会进行缓存，而对于动态的内容，浏览器通常不会进行缓存。</p><h3 id="浏览器异步请求其他资源"><a href="#浏览器异步请求其他资源" class="headerlink" title="浏览器异步请求其他资源"></a>浏览器异步请求其他资源</h3><p>在分析HTML时，若发现网页引用了其他资源，例如：css、图片等，浏览器则发起HTTP请求，得到响应资源。</p><h3 id="断开连接"><a href="#断开连接" class="headerlink" title="断开连接"></a>断开连接</h3><p>当数据传送完毕，需要断开 tcp 连接，此时发起 tcp 四次挥手。<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200828150219.png" alt="20200828150219"></p><p>建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由TCP的<strong>半关闭</strong>（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p><p>TCP 连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务端均可主动发起挥手动作。</p><p>刚开始双方都处于<strong>ESTABLISHED</strong> 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：</p><ul><li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 <strong>FIN_WAIT1</strong> 状态。<br>即发出连接释放报文段（FIN=1，序号seq=u），并<strong>停止再发送数据</strong>，<strong>主动关闭TCP连接</strong>，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。</li><li>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 <strong>CLOSE_WAIT</strong> 状态。<br>即服务端收到连接释放报文段后即发出<strong>确认报文段</strong>（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入<strong>FIN_WAIT2</strong>（终止等待2）状态，等待服务端发出的连接释放报文段。</li><li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 <strong>LAST_ACK</strong> 的状态。<br>即服务端没有要向客户端发出的数据，服务端发出<strong>连接释放报文段</strong>（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。</li><li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 <strong>TIME_WAIT</strong> 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 <strong>CLOSED</strong> 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 <strong>CLOSED</strong> 状态。<br>即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。</li></ul><p>收到一个FIN只意味着在这一方向上没有数据流动。客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。</p><p>通俗的说法</p><ol><li><p>Client：我所有东西都说完了</p></li><li><p>Server：我已经全部听到了，但是等等我，我还没说完</p></li><li><p>Server：好了，我已经说完了</p></li><li><p>Client：好的，那我们的通信结束</p></li></ol><h4 id="为什么需要四次挥手"><a href="#为什么需要四次挥手" class="headerlink" title="为什么需要四次挥手"></a>为什么需要四次挥手</h4><p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。</p><h4 id="四次挥手释放连接时，等待2MSL的意义"><a href="#四次挥手释放连接时，等待2MSL的意义" class="headerlink" title="四次挥手释放连接时，等待2MSL的意义"></a>四次挥手释放连接时，等待2MSL的意义</h4><blockquote><p>MSL:最长报文段寿命</p></blockquote><p>为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。</p><p>两个理由：</p><ol><li>保证客户端发送的最后一个ACK报文段能够到达服务端。<br>这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。</li><li>防止“已失效的连接请求报文段”出现在本连接中。<br>客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ul><li>《计算机网络》-谢希仁</li><li><a href="https://blog.csdn.net/guoweimelon/article/details/50880391">在浏览器输入一个网址，如http://www.taobao.com，按回车之后发生了什么？</a></li><li><a href="https://blog.csdn.net/hyg0811/article/details/102366854?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight">面试官，不要再问我三次握手和四次挥手</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap和Hashtable的区别</title>
      <link href="blog/425444d1/"/>
      <url>blog/425444d1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>转自：<a href="https://blog.csdn.net/wangxing233/article/details/79452946">HashMap 与HashTable的区别</a>并加以修改</p></blockquote><h2 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h2><p>Hashtable：<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200824224834.png" alt="20200824224834"><br>HashMap：<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200824224857.png" alt="20200824224857"></p><p>HashMap比Hashtable多了一个并发大神：Doug Lea。</p><h2 id="产生时间"><a href="#产生时间" class="headerlink" title="产生时间"></a>产生时间</h2><p>Hashtable是java一开始发布时就提供的键值映射的数据结构，而HashMap产生于JDK1.2。虽然Hashtable比HashMap出现的早一些，但是现在Hashtable基本上已经被弃用了。而HashMap已经成为应用最为广泛的一种数据类型了。</p><h2 id="继承父类"><a href="#继承父类" class="headerlink" title="继承父类"></a>继承父类</h2><p>HashMap是继承自<code>AbstractMap</code>类，而Hashtable是继承自<code>Dictionary</code>类。不过它们都实现了同时实现了<code>map</code>、<code>Cloneable</code>（可复制）、<code>Serializable</code>（可序列化）这三个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在Dictionary源码中你能看到这么一行注释：</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200824215949.png" alt="20200824215949"></p><p>翻译如下：此类已过时。新的实现应实现Map接口，而不是扩展此类。</p><p>父类都过时了，Hashtable怎么样就不用说了。</p><h2 id="对外提供的接口"><a href="#对外提供的接口" class="headerlink" title="对外提供的接口"></a>对外提供的接口</h2><p>Hashtable比HashMap多提供了elments() 和contains() 两个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Enumeration&lt;V&gt; <span class="title">elements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.&lt;V&gt;getEnumeration(VALUES);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>elments() 方法继承自Hashtable的父类Dictionnary。elements() 方法用于返回此Hashtable中的value的枚举。</li><li>contains()方法判断该Hashtable是否包含传入的value。它的作用与containsValue()一致。实际上，Hashtable的containsValue方法就是调用了contains方法<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200824221856.png" alt="20200824221856"><br>hashMap 去掉了 contains 方法，使用 containsValue和 containsKey方法。</li></ul><h2 id="对Null-key-和Null-value的支持"><a href="#对Null-key-和Null-value的支持" class="headerlink" title="对Null key 和Null value的支持"></a>对Null key 和Null value的支持</h2><ul><li>Hashtable既不支持Null key也不支持Null value。<br>当key为Null时，调用put() 方法，运行到下面这一步就会抛出空指针异常。因为拿一个Null值去调用方法了。<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200824223143.png" alt="20200824223143"><br>而且方法开头就是对value的限制<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200824223102.png" alt="20200824223102"></li><li>HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，可能是 HashMap中没有该键，也可能使该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。</li></ul><h2 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h2><ul><li>Hashtable是线程安全的，它的每个方法中都加入了Synchronize方法。在多线程并发的环境下，可以直接使用Hashtable，不需要自己为它的方法实现同步</li><li>HashMap不是线程安全的，在多线程并发的环境下，可能会产生死锁等问题。使用HashMap时就必须要自己增加同步处理，</li></ul><p>虽然HashMap不是线程安全的，但是它的效率会比Hashtable要好很多。这样设计是合理的。在我们的日常使用当中，大部分时间是单线程操作的。HashMap把这部分操作解放出来了。</p><h2 id="遍历方式的内部实现"><a href="#遍历方式的内部实现" class="headerlink" title="遍历方式的内部实现"></a>遍历方式的内部实现</h2><p>Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。</p><p>HashMap的Iterator是fail-fast迭代器。当有其它线程改变了HashMap的结构（增加，删除，修改元素），将会抛出ConcurrentModificationException。不过，通过Iterator的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。</p><p>JDK8之前的版本中，Hashtable是没有fast-fail机制的。在JDK8及以后的版本中 ，Hashtable也是使用fast-fail的， 源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    <span class="keyword">return</span> nextElement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>modCount的使用类似于并发编程中的CAS（Compare and Swap）技术。在Hashtable中，每次在发生增删改的时候都会出现modCount++的动作。而modcount可以理解为是当前hashtable的状态。每发生一次操作，状态就向前走一步。设置这个状态，主要是由于hashtable等容器类在迭代时，判断数据是否过时时使用的。<br>尽管hashtable采用了原生的同步锁来保护数据安全。但是在出现迭代数据的时候，则无法保证边迭代，边正确操作。于是使用这个值来标记状态。一旦在迭代的过程中状态发生了改变，则会快速抛出一个异常，终止迭代行为。</p><h2 id="初始容量大小和每次扩充容量大小"><a href="#初始容量大小和每次扩充容量大小" class="headerlink" title="初始容量大小和每次扩充容量大小"></a>初始容量大小和每次扩充容量大小</h2><p>Hashtable默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。</p><p>创建时，如果给定了容量初始值，那么Hashtable会直接使用你给定的大小，而HashMap会将其扩充为2的幂次方大小。也就是说Hashtable会尽量使用素数、奇数。而HashMap则总是使用2的幂作为哈希表的大小。</p><p>之所以会有这样的不同，是因为Hashtable和HashMap设计时的侧重点不同。Hashtable的侧重点是哈希的结果更加均匀，使得哈希冲突减少。当哈希表的大小为素数时，简单的取模哈希的结果会更加均匀。而HashMap则更加关注hash的计算效率问题。在取模计算时，如果模数是2的幂，那么我们可以直接使用位运算来得到结果，效率要大大高于做除法。HashMap为了加快hash的速度，将哈希表的大小固定为了2的幂。当然这引入了哈希分布不均匀的问题，所以HashMap为解决这问题，又对hash算法做了一些改动。这从而导致了Hashtable和HashMap的计算hash值的方法不同</p><h2 id="计算hash值的方法"><a href="#计算hash值的方法" class="headerlink" title="计算hash值的方法"></a>计算hash值的方法</h2><p>为了得到元素的位置，首先需要根据元素的 KEY计算出一个hash值，然后再用这个hash值来计算得到最终的位置。</p><p>Hashtable直接使用对象的hashCode。hashCode是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值。然后再使用除留余数发来获得最终的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hashtable</span></span><br><span class="line"><span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line"><span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br></pre></td></tr></table></figure><p>Hashtable在计算元素的位置时需要进行一次除法运算，而除法运算是比较耗时的。<br>HashMap为了提高计算效率，将哈希表的大小固定为了2的幂，这样在取模预算时，不需要做除法，只需要做位运算。位运算比除法的效率要高很多。</p><p>HashMap的效率虽然提高了，但是hash冲突却也增加了。因为它得出的hash值的低位相同的概率比较高，而计算位运算</p><p>为了解决这个问题，HashMap重新根据hashcode计算hash值后，又对hash值做了一些运算来打散数据。使得取得的位置更加分散，从而减少了hash冲突。当然了，为了高效，HashMap只做了一些简单的位处理。从而不至于把使用2 的幂次方带来的效率提升给抵消掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashMap</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a class="btn-beautify button--animated block blue right" href="https://www.shiming.online/blog/4876/"   title="异常"><i class="far fa-hand-point-right fa-fw"></i><span>异常</span></a>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
          <category> 集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis-Plus</title>
      <link href="blog/1276cc28/"/>
      <url>blog/1276cc28/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Mybatis-Plus简介"><a href="#Mybatis-Plus简介" class="headerlink" title="Mybatis-Plus简介"></a>Mybatis-Plus简介</h2><blockquote><p><a href="https://baomidou.com/">官网文档</a></p></blockquote><p><a href="https://github.com/baomidou/mybatis-plus">MyBatis-Plus</a>（简称 MP）是一个 <a href="http://www.mybatis.org/mybatis-3/">MyBatis</a> 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p><p>特性：</p><ul><li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li><li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li><li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li><li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li><li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li><li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li><li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li><li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li><li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li><li><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li><li><strong>内置性能分析插件</strong>：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li><li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li></ul><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><blockquote><p>本模块来自官方文档，使用SpringBoot完成</p></blockquote><h3 id="创建表和添加数据"><a href="#创建表和添加数据" class="headerlink" title="创建表和添加数据"></a>创建表和添加数据</h3><p><code>User</code>表结构如下：</p><table><thead><tr><th align="center">id</th><th align="center">name</th><th align="center">age</th><th align="center">email</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">Jone</td><td align="center">18</td><td align="center"><a href="mailto:&#x74;&#x65;&#x73;&#x74;&#x31;&#x40;&#98;&#97;&#x6f;&#109;&#x69;&#x64;&#x6f;&#x75;&#x2e;&#99;&#111;&#109;">&#x74;&#x65;&#x73;&#x74;&#x31;&#x40;&#98;&#97;&#x6f;&#109;&#x69;&#x64;&#x6f;&#x75;&#x2e;&#99;&#111;&#109;</a></td></tr><tr><td align="center">2</td><td align="center">Jack</td><td align="center">20</td><td align="center"><a href="mailto:&#x74;&#x65;&#x73;&#x74;&#x32;&#x40;&#98;&#97;&#x6f;&#x6d;&#x69;&#x64;&#x6f;&#x75;&#46;&#x63;&#111;&#109;">&#x74;&#x65;&#x73;&#x74;&#x32;&#x40;&#98;&#97;&#x6f;&#x6d;&#x69;&#x64;&#x6f;&#x75;&#46;&#x63;&#111;&#109;</a></td></tr><tr><td align="center">3</td><td align="center">Tom</td><td align="center">28</td><td align="center"><a href="mailto:&#x74;&#x65;&#115;&#116;&#x33;&#64;&#98;&#97;&#x6f;&#x6d;&#105;&#x64;&#111;&#x75;&#x2e;&#99;&#x6f;&#x6d;">&#x74;&#x65;&#115;&#116;&#x33;&#64;&#98;&#97;&#x6f;&#x6d;&#105;&#x64;&#111;&#x75;&#x2e;&#99;&#x6f;&#x6d;</a></td></tr><tr><td align="center">4</td><td align="center">Sandy</td><td align="center">21</td><td align="center"><a href="mailto:&#x74;&#x65;&#x73;&#116;&#52;&#x40;&#x62;&#97;&#x6f;&#x6d;&#105;&#x64;&#x6f;&#x75;&#46;&#99;&#111;&#x6d;">&#x74;&#x65;&#x73;&#116;&#52;&#x40;&#x62;&#97;&#x6f;&#x6d;&#105;&#x64;&#x6f;&#x75;&#46;&#99;&#111;&#x6d;</a></td></tr><tr><td align="center">5</td><td align="center">Billie</td><td align="center">24</td><td align="center"><a href="mailto:&#116;&#x65;&#115;&#x74;&#53;&#x40;&#98;&#97;&#111;&#109;&#105;&#100;&#111;&#117;&#46;&#99;&#x6f;&#x6d;">&#116;&#x65;&#115;&#x74;&#53;&#x40;&#98;&#97;&#111;&#109;&#105;&#100;&#111;&#117;&#46;&#99;&#x6f;&#x6d;</a></td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span></span><br><span class="line">(</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">  <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">30</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">  age <span class="built_in">INT</span>(<span class="number">11</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">  email <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> (<span class="keyword">id</span>, <span class="keyword">name</span>, age, email) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;Jone&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;test1@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;test2@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;Tom&#x27;</span>, <span class="number">28</span>, <span class="string">&#x27;test3@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="string">&#x27;Sandy&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;test4@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="string">&#x27;Billie&#x27;</span>, <span class="number">24</span>, <span class="string">&#x27;test5@baomidou.com&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="初始化工程"><a href="#初始化工程" class="headerlink" title="初始化工程"></a>初始化工程</h3><div class="note default flat"><p>SpringBoot版本：2.3.3.RELEASE<br>Mybatis-Plus：3.3.2<br>MySQL：8.21</p></div><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mp --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如上，mp只需要添加一个依赖，其余都是常规的依赖。</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>配置数据库连接：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/practice?userUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=GMT%2B8</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure><p>日志查看sql语句（可以不加）：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过slf4j查看，设置mapper接口所在包loggging.level为debug</span></span><br><span class="line"><span class="comment"># logging.level.com.xqm.mybatisplus.mapper=debug</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这种查看方式更详细</span></span><br><span class="line"><span class="meta">mybatis-plus.configuration.log-impl</span>=<span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure><p>在 Spring Boot 启动类中添加 @MapperScan 注解，扫描 Mapper 文件夹（可在mapper.java文件上使用<code>@Mapper</code>代替）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MapperScan(&quot;com.xqm.mybatisplus.mapper&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisPlusApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MybatisPlusApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><p>实例类<code>User.java</code>(此处使用<a href="https://www.projectlombok.org/">lombok</a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Accessors(chain = true)</span></span><br><span class="line"><span class="comment">// 链式编程：setter方法返回一个对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口文件<code>mapper.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="comment">// 使Spring能扫描到，不加也可以，不加Idea最高等级警告会报错，强迫症可以加上</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MybatisPlusApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; users = userMapper.selectList(<span class="keyword">null</span>);</span><br><span class="line">        users.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><p>UserMapper 中的 selectList() 方法的参数为 MP 内置的条件封装器 Wrapper，所以不填写就是无任何条件</p></div><p>控制台输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">User(id=<span class="number">1</span>, name=Jone, age=<span class="number">18</span>, email=test1<span class="meta">@baomidou</span>.com)</span><br><span class="line">User(id=<span class="number">2</span>, name=Jack, age=<span class="number">20</span>, email=test2<span class="meta">@baomidou</span>.com)</span><br><span class="line">User(id=<span class="number">3</span>, name=Tom, age=<span class="number">28</span>, email=test3<span class="meta">@baomidou</span>.com)</span><br><span class="line">User(id=<span class="number">4</span>, name=Sandy, age=<span class="number">21</span>, email=test4<span class="meta">@baomidou</span>.com)</span><br><span class="line">User(id=<span class="number">5</span>, name=Billie, age=<span class="number">24</span>, email=test5<span class="meta">@baomidou</span>.com)</span><br></pre></td></tr></table></figure><h2 id="CRUD扩展"><a href="#CRUD扩展" class="headerlink" title="CRUD扩展"></a>CRUD扩展</h2><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setName(<span class="string">&quot;失铭&quot;</span>).setAge(<span class="number">1</span>).setEmail(<span class="string">&quot;123@qq.com&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> insert = userMapper.insert(user);</span><br><span class="line">    System.out.println(insert);</span><br><span class="line">    <span class="comment">// 影响行数</span></span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="comment">// id自动回填</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="主键策略"><a href="#主键策略" class="headerlink" title="主键策略"></a>主键策略</h3><div class="note info flat"><p><a href="https://www.cnblogs.com/haoxinyue/p/5208136.html">分布式系统唯一ID生成方案汇总</a></p></div><blockquote><p><code>@TableId</code>：主键注解，添加后默认：ASSIGN_UUID 分配UUID</p></blockquote><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">必须指定</th><th align="center">默认值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">value</td><td align="center">String</td><td align="center">否</td><td align="center">“”</td><td align="center">主键字段名</td></tr><tr><td align="center">type</td><td align="center">Enum</td><td align="center">否</td><td align="center">IdType.ASSIGN_UUID</td><td align="center">主键类型</td></tr></tbody></table><h4 id="IdType"><a href="#IdType" class="headerlink" title="IdType"></a>IdType</h4><table><thead><tr><th align="center">值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">AUTO</td><td align="center">数据库ID自增</td></tr><tr><td align="center">NONE</td><td align="center">无状态,该类型为未设置主键类型(注解里等于跟随全局,全局里约等于 INPUT)</td></tr><tr><td align="center">INPUT</td><td align="center">insert前自行set主键值</td></tr><tr><td align="center">ASSIGN_ID</td><td align="center">分配ID(主键类型为Number(Long和Integer)或String)(since 3.3.0),使用接口IdentifierGenerator的方法nextId(默认实现类为DefaultIdentifierGenerator雪花算法)</td></tr><tr><td align="center">ASSIGN_UUID</td><td align="center">分配UUID,主键类型为String(since 3.3.0),使用接口IdentifierGenerator的方法nextUUID(默认default方法)</td></tr><tr><td align="center"><del>ID_WORKER</del></td><td align="center">分布式全局唯一ID 长整型类型(please use ASSIGN_ID)</td></tr><tr><td align="center"><del>UUID</del></td><td align="center">32位UUID字符串(please use ASSIGN_UUID)</td></tr><tr><td align="center"><del>ID_WORKER_STR</del></td><td align="center">分布式全局唯一ID 字符串类型(please use ASSIGN_ID)</td></tr></tbody></table><p><strong>雪花算法</strong>：snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。</p><div class="note danger flat"><p>type设置为IdType.INPUT，需要手动输入，否则id为null</p></div><h4 id="主键自增"><a href="#主键自增" class="headerlink" title="主键自增"></a>主键自增</h4><ol><li>实体类字段上``@TableId(type=IdType.AUTO)</li><li>数据库主键设置自增</li></ol><h3 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    <span class="comment">// 通过条件自动拼接动态sql</span></span><br><span class="line">    user.setId(<span class="number">1L</span>).setAge(<span class="number">10</span>).setEmail(<span class="string">&quot;123@gmail.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：传入参数为对象</span></span><br><span class="line">    <span class="comment">// 源码：int updateById(@Param(&quot;et&quot;) T entity);</span></span><br><span class="line">    <span class="keyword">int</span> i = userMapper.updateById(user);</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自动填充"><a href="#自动填充" class="headerlink" title="自动填充"></a>自动填充</h3><p>创建时间（gmt_create），修改时间（gmt_modified）。自动化完成，不希望手动更新！<br>阿里巴巴java开发手册中规定如下：<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200824084406.png" alt="20200824084406"></p><h4 id="方式一：数据库级别"><a href="#方式一：数据库级别" class="headerlink" title="方式一：数据库级别"></a>方式一：数据库级别</h4><ul><li>数据类型设为：datatime</li><li>默认值：CURRENT_TIMESTAMP</li></ul><p>注意：更新时间需要设置为根据时间戳更新</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200824084821.png" alt="20200824084821"><br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200824084925.png" alt="20200824084925"></p><p>添加字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Date gmtCreate;</span><br><span class="line"><span class="keyword">private</span> Date gmtModified;</span><br></pre></td></tr></table></figure><h4 id="方式二：代码级别"><a href="#方式二：代码级别" class="headerlink" title="方式二：代码级别"></a>方式二：代码级别</h4><p>添加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line"><span class="keyword">private</span> LocalDateTime gmtCreate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line"><span class="keyword">private</span> LocalDateTime gmtModified;</span><br></pre></td></tr></table></figure><p>注意：数据类型使用LocalDateTime，这里有一个小坑，等会说。</p><p>自定义实现类MyMetaObjectHandler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title">MetaObjectHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertFill</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;start insert fill ....&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.strictInsertFill(metaObject, <span class="string">&quot;gmtCreate&quot;</span>, LocalDateTime.class, LocalDateTime.now());</span><br><span class="line">        <span class="keyword">this</span>.strictInsertFill(metaObject, <span class="string">&quot;gmtModified&quot;</span>, LocalDateTime.class, LocalDateTime.now());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFill</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;start update fill ....&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.strictUpdateFill(metaObject, <span class="string">&quot;gmtModified&quot;</span>, LocalDateTime.class, LocalDateTime.now());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新测试插入和更新，可以看到时间填充成功。</p><div class="note warning flat"><p>这里有两个问题：</p><ol><li><strong>时间差8个小时</strong>：这是因为数据库连接语句时区的设置的世界标准时间(UTC)，而北京时间比标准时间快八个小时。所以需要将时间设置为：<code>GMT%2B8</code>。如：<code>serverTimezone=GMT%2B8</code></li><li><strong>LocalDateTime</strong>：<code>LocalDateTime</code>是java8提供的新的日期和时间API，详细了解参考-&gt;<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1303871087444002">廖雪峰的官方网站-LocalDateTime</a>。实体类和实现类的时间类型要一致。例如：我的<code>gmtCreate</code>使用的<code>LocalDateTime</code>类型，那么填充语句中，也要写<code>LocalDateTime.class</code>。实体类定义的是<code>Date</code>类型，填充语句就要写<code>Date.class</code>。</li></ol></div><h4 id="TableField注解（了解）"><a href="#TableField注解（了解）" class="headerlink" title="@TableField注解（了解）"></a><code>@TableField</code>注解（了解）</h4><p><code>@TableField</code>：字段注解(非主键)</p><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">必须指定</th><th align="center">默认值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">value</td><td align="center">String</td><td align="center">否</td><td align="center">“”</td><td align="center">数据库字段名</td></tr><tr><td align="center">el</td><td align="center">String</td><td align="center">否</td><td align="center">“”</td><td align="center">映射为原生 <code>#&#123; ... &#125;</code> 逻辑,相当于写在 xml 里的 <code>#&#123; ... &#125;</code> 部分</td></tr><tr><td align="center">exist</td><td align="center">boolean</td><td align="center">否</td><td align="center">true</td><td align="center">是否为数据库表字段</td></tr><tr><td align="center">condition</td><td align="center">String</td><td align="center">否</td><td align="center">“”</td><td align="center">字段 <code>wher</code>e 实体查询比较条件,有值设置则按设置的值为准,没有则为默认全局的 <code>%s=#&#123;%s&#125;</code>,参考</td></tr><tr><td align="center">update</td><td align="center">String</td><td align="center">否</td><td align="center">“”</td><td align="center">字段 <code>update set</code> 部分注入, 例如：<code>update=&quot;%s+1&quot;</code>：表示更新时会set version=version+1(该属性优先级高于 el 属性)</td></tr><tr><td align="center">insertStrategy</td><td align="center">Enum</td><td align="center">N</td><td align="center">DEFAULT</td><td align="center">举例：NOT_NULL: <code>insert into table_a(&lt;if test=&quot;columnProperty != null&quot;&gt;column&lt;/if&gt;) values (&lt;if test=&quot;columnProperty != null&quot;&gt;#&#123;columnProperty&#125;&lt;/if&gt;)</code></td></tr><tr><td align="center">updateStrategy</td><td align="center">Enum</td><td align="center">N</td><td align="center">DEFAULT</td><td align="center">举例：IGNORED: <code>update table_a set column=#</code>{columnProperty}</td></tr><tr><td align="center">whereStrategy</td><td align="center">Enum</td><td align="center">N</td><td align="center">DEFAULT</td><td align="center">举例：NOT_EMPTY: <code>where &lt;if test=&quot;columnProperty != null and columnProperty!=&#39;&#39;&quot;&gt;column=#&#123;columnProperty&#125;&lt;/if&gt;</code></td></tr><tr><td align="center">fill</td><td align="center">Enum</td><td align="center">否</td><td align="center">FieldFill.DEFAULT</td><td align="center">字段自动填充策略</td></tr><tr><td align="center">select</td><td align="center">boolean</td><td align="center">否</td><td align="center">true</td><td align="center">是否进行 select 查询</td></tr><tr><td align="center">keepGlobalFormat</td><td align="center">boolean</td><td align="center">否</td><td align="center">false</td><td align="center">是否保持使用全局的 format 进行处理</td></tr><tr><td align="center">jdbcType</td><td align="center">JdbcType</td><td align="center">否</td><td align="center">JdbcType.UNDEFINED</td><td align="center">JDBC类型 (该默认值不代表会按照该值生效)</td></tr><tr><td align="center">typeHandler</td><td align="center">Class&lt;? extends TypeHandler&gt;</td><td align="center">否</td><td align="center">UnknownTypeHandler.class</td><td align="center">类型处理器 (该默认值不代表会按照该值生效)</td></tr><tr><td align="center">numericScale</td><td align="center">String</td><td align="center">否</td><td align="center">“”</td><td align="center">指定小数点后保留的位数</td></tr></tbody></table><blockquote><p><strong>关于<code>jdbcType</code>和<code>typeHandler</code>以及<code>numericScale</code>的说明</strong>:<br>numericScale只生效于 update 的sql. jdbcType和typeHandler如果不配合@TableName#autoResultMap = true一起使用,也只生效于 update 的sql.<br>对于typeHandler如果你的字段类型和set进去的类型为equals关系,则只需要让你的typeHandler让Mybatis加载到即可,不需要使用注解</p></blockquote><p><strong>FieldStrategy:</strong></p><table><thead><tr><th align="center">值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">IGNORED</td><td align="center">忽略判断</td></tr><tr><td align="center">NOT_NULL</td><td align="center">非NULL判断</td></tr><tr><td align="center">NOT_EMPTY</td><td align="center">非空判断(只对字符串类型字段,其他类型字段依然为非NULL判断)</td></tr><tr><td align="center">DEFAULT</td><td align="center">追随全局配置</td></tr></tbody></table><p><strong>FieldFill:</strong></p><table><thead><tr><th align="center">值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">DEFAULT</td><td align="center">默认不处理</td></tr><tr><td align="center">INSERT</td><td align="center">插入时填充字段</td></tr><tr><td align="center">UPDATE</td><td align="center">更新时填充字段</td></tr><tr><td align="center">INSERT_UPDATE</td><td align="center">插入和更新时填充字段</td></tr></tbody></table><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><blockquote><ul><li>悲观锁（Pessimistic Lock），顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。</li><li>乐观锁（Optimistic Lock），顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁适用于读多写少的应用场景，这样可以提高吞吐量。</li></ul></blockquote><p><strong>意图：</strong></p><p>当要更新一条记录的时候，希望这条记录没有被别人更新</p><p><strong>乐观锁实现方式：</strong></p><ol><li>取出记录时，获取当前version</li><li>更新时，带上这个version</li><li>执行更新时， set version = newVersion where version = oldVersion</li><li>如果version不对，就更新失败</li></ol><p>乐观锁实现<strong>只需两步</strong></p><h3 id="1-注册组件OptimisticLockerInterceptor"><a href="#1-注册组件OptimisticLockerInterceptor" class="headerlink" title="1. 注册组件OptimisticLockerInterceptor"></a>1. 注册组件OptimisticLockerInterceptor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> OptimisticLockerInterceptor <span class="title">optimisticLockerInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> OptimisticLockerInterceptor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-version字段添加-Version注解"><a href="#2-version字段添加-Version注解" class="headerlink" title="2. version字段添加@Version注解"></a>2. version字段添加@Version注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Version</span></span><br><span class="line"><span class="keyword">private</span> Integer version;</span><br></pre></td></tr></table></figure><div class="note info flat"><p><strong>特别说明:</strong></p><ul><li><strong>支持的数据类型只有:int,Integer,long,Long,Date,Timestamp,LocalDateTime</strong></li><li>整数类型下 newVersion = oldVersion + 1</li><li>newVersion 会回写到 entity 中</li><li>仅支持 updateById(id) 与 update(entity, wrapper) 方法</li><li>在 update(entity, wrapper) 方法下, wrapper 不能复用!!!</li></ul></div><h3 id="乐观锁示例"><a href="#乐观锁示例" class="headerlink" title="乐观锁示例"></a>乐观锁示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 乐观锁成功</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testOptimisticLocker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询用户信息</span></span><br><span class="line">    User user = userMapper.selectById(<span class="number">5L</span>);</span><br><span class="line">    <span class="comment">// 修改用户信息</span></span><br><span class="line">    user.setEmail(<span class="string">&quot;456@gmail.com&quot;</span>).setAge(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新信息</span></span><br><span class="line">    userMapper.updateById(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 乐观锁失败</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testOptimisticLocker2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询用户信息</span></span><br><span class="line">    User user = userMapper.selectById(<span class="number">5L</span>);</span><br><span class="line">    <span class="comment">// 修改用户信息</span></span><br><span class="line">    user.setEmail(<span class="string">&quot;456@gmail.com&quot;</span>).setAge(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟多线程插队</span></span><br><span class="line">    User user2 = userMapper.selectById(<span class="number">5L</span>);</span><br><span class="line">    user2.setEmail(<span class="string">&quot;123456@gmail.com&quot;</span>).setAge(<span class="number">50</span>);</span><br><span class="line">    userMapper.updateById(user2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自旋锁多次提交</span></span><br><span class="line">    <span class="comment">// 如果没有乐观锁会覆盖插队线程的值</span></span><br><span class="line">    userMapper.updateById(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察控制台日志，可以发现：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> <span class="keyword">name</span>=?, age=?, email=?, <span class="keyword">version</span>=?, gmt_create=?, gmt_modified=? <span class="keyword">WHERE</span> <span class="keyword">id</span>=? <span class="keyword">AND</span> <span class="keyword">version</span>=?</span><br></pre></td></tr></table></figure><p>如上，id和version都相同时才更新，很简单的就实现了乐观锁</p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询</span></span><br><span class="line"><span class="comment">// 单个查询</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testSelect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量查询</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testSelectBatchIds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectBatchIds(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    System.out.println(users);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件查询之一：map</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testSelectByMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String, Object&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    hashMap.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jone&quot;</span>);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectByMap(hashMap);</span><br><span class="line">    System.out.println(users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><h4 id="添加插件"><a href="#添加插件" class="headerlink" title="添加插件"></a>添加插件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PaginationInterceptor <span class="title">paginationInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PaginationInterceptor paginationInterceptor = <span class="keyword">new</span> PaginationInterceptor();</span><br><span class="line">    <span class="comment">// 设置请求的页面大于最大页后操作， true调回到首页，false 继续请求  默认false</span></span><br><span class="line">    <span class="comment">// paginationInterceptor.setOverflow(false);</span></span><br><span class="line">    <span class="comment">// 设置最大单页限制数量，默认 500 条，-1 不受限制</span></span><br><span class="line">    <span class="comment">// paginationInterceptor.setLimit(500);</span></span><br><span class="line">    <span class="comment">// 开启 count 的 join 优化,只针对部分 left join</span></span><br><span class="line">    paginationInterceptor.setCountSqlParser(<span class="keyword">new</span> JsqlParserCountOptimize(<span class="keyword">true</span>));</span><br><span class="line">    <span class="keyword">return</span> paginationInterceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以简单一点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PaginationInterceptor <span class="title">paginationInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PaginationInterceptor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分页查询示例"><a href="#分页查询示例" class="headerlink" title="分页查询示例"></a>分页查询示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分页</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参数一：页码</span></span><br><span class="line">    <span class="comment">// 参数二：页面大小</span></span><br><span class="line">    <span class="comment">// 原理：拦截器分页，系统添加limit</span></span><br><span class="line">    Page&lt;User&gt; page = <span class="keyword">new</span> Page&lt;&gt;(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">    userMapper.selectPage(page, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    page.getRecords().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 单个删除</span></span><br><span class="line">    userMapper.deleteById(<span class="number">1297730862471913474L</span>);</span><br><span class="line">    <span class="comment">// 批量删除</span></span><br><span class="line">    userMapper.deleteBatchIds(Arrays.asList(<span class="number">1297730992902164482L</span>, <span class="number">1297731359643713538L</span>));</span><br><span class="line">    <span class="comment">// 条件删除</span></span><br><span class="line">    HashMap&lt;String, Object&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    hashMap.put(<span class="string">&quot;id&quot;</span>,<span class="number">1297731433178230785L</span>);</span><br><span class="line">    userMapper.deleteByMap(hashMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h3><blockquote><ul><li>物理删除：从数据库中直接移除</li><li>逻辑删除：未从数据库中移除，而是通过一个变量让他失效，例：deleted = 0 -&gt; deleted =1</li></ul></blockquote><p><strong>准备工作：</strong></p><p>数据库添加字段：</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200824111900.png" alt="20200824111900"></p><p>默认值为0</p><p>修改实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> deleted;</span><br></pre></td></tr></table></figure><p><strong>实际使用：</strong></p><p>修改配置文件：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 逻辑删除</span></span><br><span class="line"><span class="meta">mybatis-plus.global-config.db-config.logic-delete-field</span>=<span class="string">deleted</span></span><br><span class="line"><span class="comment"># 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)</span></span><br><span class="line"><span class="meta">mybatis-plus.global-config.db-config.logic-delete-value</span>=<span class="string">1</span></span><br><span class="line"><span class="comment"># 逻辑已删除值(默认为 1)</span></span><br><span class="line"><span class="meta">mybatis-plus.global-config.db-config.logic-not-delete-value</span>=<span class="string">0</span></span><br><span class="line"><span class="comment"># 逻辑未删除值(默认为 0)</span></span><br></pre></td></tr></table></figure><p>实体类添加<code>@TableLogic</code>注解：</p><p>如果设置了<code>mybatis-plus.global-config.db-config.logic-delete-field = deleted</code>，那么只需要有deleted这个属性即可，不需要添加注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableLogic</span></span><br><span class="line"><span class="keyword">private</span> Integer deleted;</span><br></pre></td></tr></table></figure><p>修改配置后原来的删除语句就会变为更新语句，例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 单个删除</span></span><br><span class="line">    userMapper.deleteById(<span class="number">2L</span>);</span><br><span class="line">    <span class="comment">// sql语句为：UPDATE user SET deleted=1 WHERE id=2 AND deleted=0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：添加逻辑删除后查询自动添加<code>deleted = 0</code>条件</p><blockquote><p>官方说明如下：</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200824112551.png" alt="20200824112551"></p><h2 id="条件构造器"><a href="#条件构造器" class="headerlink" title="条件构造器"></a>条件构造器</h2><p>十分重要：Wrapper<br>我们写一些复杂的sql就可以使用它来替代！</p><blockquote><p><a href="https://baomidou.com/guide/wrapper.html#abstractwrapper">官方文档</a></p></blockquote><p>1、测试一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 查询name不为空的用户，并且邮箱不为空的用户，年龄大于等于12</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">    wrapper</span><br><span class="line">          .isNotNull(<span class="string">&quot;name&quot;</span>)  </span><br><span class="line">          .isNotNull(<span class="string">&quot;email&quot;</span>)  </span><br><span class="line">          .ge(<span class="string">&quot;age&quot;</span>,<span class="number">12</span>);</span><br><span class="line">    userMapper.selectList(wrapper).forEach(System.out::println);</span><br><span class="line">    <span class="comment">// 和我们刚才学习的map对比一下</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、测试二</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">// 查询名字狂神说</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">    wrapper.eq(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;狂神说&quot;</span>);</span><br><span class="line">    User user = userMapper.selectOne(wrapper); <span class="comment">// 查询一个数据，出现多个结果使用List 或者 Map</span></span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、测试三</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 查询年龄在 20 ~ 30 岁之间的用户</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();  wrapper.between(<span class="string">&quot;age&quot;</span>,<span class="number">20</span>,<span class="number">30</span>); <span class="comment">// 区间</span></span><br><span class="line">    Integer count = userMapper.selectCount(wrapper);<span class="comment">// 查询结果数  System.out.println(count);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、测试四</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模糊查询</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 查询年龄在 20 ~ 30 岁之间的用户</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();  <span class="comment">// 左和右  t%</span></span><br><span class="line">    wrapper</span><br><span class="line">      .notLike(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;e&quot;</span>)</span><br><span class="line">      .likeRight(<span class="string">&quot;email&quot;</span>,<span class="string">&quot;t&quot;</span>);</span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(wrapper);  maps.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、测试五</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模糊查询</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">    <span class="comment">// id 在子查询中查出来</span></span><br><span class="line">    wrapper.inSql(<span class="string">&quot;id&quot;</span>,<span class="string">&quot;select id from user where id&lt;3&quot;</span>);</span><br><span class="line">    List&lt;Object&gt; objects = userMapper.selectObjs(wrapper);  objects.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、测试六</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试六</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();  <span class="comment">// 通过id进行排序</span></span><br><span class="line">    wrapper.orderByAsc(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(wrapper);  users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自动生成代码"><a href="#自动生成代码" class="headerlink" title="自动生成代码"></a>自动生成代码</h2><p>依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.velocity<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>velocity-engine-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.DbType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.FieldFill;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.IdType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.AutoGenerator;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.DataSourceConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.GlobalConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.PackageConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.StrategyConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.po.TableFill;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.rules.DateType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisGenerator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Generator</span><span class="params">(String moduleName, String include)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 代码生成器</span></span><br><span class="line">        AutoGenerator mpg = <span class="keyword">new</span> AutoGenerator();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 全局配置</span></span><br><span class="line">        GlobalConfig gc = <span class="keyword">new</span> GlobalConfig();</span><br><span class="line">        <span class="comment">// 当前目录的/src/main/java目录下</span></span><br><span class="line">        String projectPath = System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">        gc.setOutputDir(projectPath + <span class="string">&quot;/src/main/java&quot;</span>);</span><br><span class="line">        <span class="comment">// 开发人员</span></span><br><span class="line">        gc.setAuthor(<span class="string">&quot;ShiMing&quot;</span>);</span><br><span class="line">        <span class="comment">// 输出目录</span></span><br><span class="line">        gc.setOpen(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 是否覆盖</span></span><br><span class="line">        gc.setFileOverride(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 去掉ServiceI前缀</span></span><br><span class="line">        gc.setServiceName(<span class="string">&quot;%sService&quot;</span>);</span><br><span class="line">        <span class="comment">// 主键策略</span></span><br><span class="line">        gc.setIdType(IdType.ASSIGN_ID);</span><br><span class="line">        <span class="comment">// 时间类型</span></span><br><span class="line">        gc.setDateType(DateType.ONLY_DATE);</span><br><span class="line">        <span class="comment">// Swagger2</span></span><br><span class="line">        gc.setSwagger2(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        mpg.setGlobalConfig(gc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据源配置</span></span><br><span class="line">        DataSourceConfig dsc = <span class="keyword">new</span> DataSourceConfig();</span><br><span class="line">        dsc.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/practice?userUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=GMT%2B8&quot;</span>);</span><br><span class="line">        dsc.setDriverName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        dsc.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dsc.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        dsc.setDbType(DbType.MYSQL);</span><br><span class="line">        mpg.setDataSource(dsc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 包配置</span></span><br><span class="line">        PackageConfig pc = <span class="keyword">new</span> PackageConfig();</span><br><span class="line">        pc.setModuleName(moduleName);</span><br><span class="line">        pc.setParent(<span class="string">&quot;com.xqm&quot;</span>);</span><br><span class="line">        pc.setEntity(<span class="string">&quot;pojo&quot;</span>);</span><br><span class="line">        pc.setMapper(<span class="string">&quot;mapper&quot;</span>);</span><br><span class="line">        pc.setService(<span class="string">&quot;service&quot;</span>);</span><br><span class="line">        pc.setController(<span class="string">&quot;controller&quot;</span>);</span><br><span class="line">        mpg.setPackageInfo(pc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 策略配置</span></span><br><span class="line">        StrategyConfig strategy = <span class="keyword">new</span> StrategyConfig();</span><br><span class="line">        <span class="comment">// 表名</span></span><br><span class="line">        strategy.setInclude(include.split(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">        <span class="comment">// 下划线转驼峰</span></span><br><span class="line">        strategy.setNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        strategy.setColumnNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        <span class="comment">// 自动lombok</span></span><br><span class="line">        strategy.setEntityLombokModel(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 链式编程</span></span><br><span class="line">        strategy.setChainModel(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 自动填充-创建时间，更新时间</span></span><br><span class="line">        TableFill gmtCreate = <span class="keyword">new</span> TableFill(<span class="string">&quot;gmt_create&quot;</span>, FieldFill.INSERT);</span><br><span class="line">        TableFill gmtModified = <span class="keyword">new</span> TableFill(<span class="string">&quot;gmt_modified&quot;</span>, FieldFill.INSERT_UPDATE);</span><br><span class="line">        ArrayList&lt;TableFill&gt; tableFills = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        tableFills.add(gmtCreate);</span><br><span class="line">        tableFills.add(gmtModified);</span><br><span class="line">        strategy.setTableFillList(tableFills);</span><br><span class="line">        <span class="comment">// 逻辑删除</span></span><br><span class="line">        strategy.setLogicDeleteFieldName(<span class="string">&quot;deleted&quot;</span>);</span><br><span class="line">        <span class="comment">// 乐观锁</span></span><br><span class="line">        strategy.setVersionFieldName(<span class="string">&quot;version&quot;</span>);</span><br><span class="line"></span><br><span class="line">        strategy.setRestControllerStyle(<span class="keyword">true</span>);</span><br><span class="line">        strategy.setControllerMappingHyphenStyle(<span class="keyword">true</span>);</span><br><span class="line">        mpg.setStrategy(strategy);</span><br><span class="line"></span><br><span class="line">        mpg.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 模块名</span></span><br><span class="line">        String moduleName = <span class="string">&quot;mybatis&quot;</span>;</span><br><span class="line">        <span class="comment">// 表名,多个表名用&quot;,&quot;分开</span></span><br><span class="line">        String include = <span class="string">&quot;user,student&quot;</span>;</span><br><span class="line">        <span class="comment">// 生成文件</span></span><br><span class="line">        Generator(moduleName, include);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用效果如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200824132645.png" alt="20200824132645"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ul><li><a href="https://www.bilibili.com/video/BV17E411N7KN">【狂神说Java】MyBatisPlus</a></li><li>官方文档<a href="https://baomidou.com/guide/">MyBatis-Plus</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> MyBatis-Plus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis-Plus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="blog/41682/"/>
      <url>blog/41682/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note warning flat"><p>本博客大部分内容来于<a href="https://refactoringguru.cn/design-patterns">免费在线学习设计模式</a></p></div><blockquote><p>本文为<a href="https://refactoringguru.cn/design-patterns">设计模式</a>学习笔记</p></blockquote><h2 id="设计模式概念"><a href="#设计模式概念" class="headerlink" title="设计模式概念"></a>设计模式概念</h2><p>设计模式是软件设计中常见问题的典型解决方案。它们就像能根据需求进行调整的预制蓝图，可用于解决代码中反复出现的设计问题。是解决特定问题的一般性概念。</p><blockquote><p>设计模式可以使面向对象保持结构良好</p></blockquote><ul><li>设计模式是针对软件设计中常见问题的工具箱，其中的工具就是各种经过实践验证的解决方案。即使你从未遇到过这些问题，了解模式仍然非常有用，因为它能指导你如何使用面向对象的设计原则来解决各种问题。</li><li>设计模式定义了一种让你和团队成员能够更高效沟通的通用语言。</li></ul><div class="note info flat"><p>算法和设计模式的区别：<br>算法更像是菜谱： 提供达成目标的明确步骤。而模式更像是蓝图： 你可以看到最终的结果和模式的功能，但需要自己确定实现步骤。</p></div><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>创建型模式提供创建对象的机制，增加已有代码的灵活性和可复用性。</li><li>结构型模式介绍如何将对象和类组装成较大的结构，并同时保持结构的灵活和高效。</li><li>行为模式负责对象间的高效沟通和职责委派。</li></ul><h2 id="六大原则"><a href="#六大原则" class="headerlink" title="六大原则"></a>六大原则</h2><ul><li><strong>开闭原则</strong>：一个软件实体如类、模块和函数应该对修改封闭，对扩展开放。</li><li><strong>单一职责原则</strong>：一个类只做一件事，一个类应该只有一个引起它修改的原因。</li><li><strong>里氏替换原则</strong>：子类应该可以完全替换父类。也就是说在使用继承时，只扩展新功能，而不要破坏父类原有的功能。</li><li><strong>依赖倒置原则</strong>：细节应该依赖于抽象，抽象不应依赖于细节。把抽象层放在程序设计的高层，并保持稳定，程序的细节变化由低层的实现层来完成。</li><li><strong>迪米特法则</strong>：又名「最少知道原则」，一个类不应知道自己操作的类的细节，换言之，只和朋友谈话，不和朋友的朋友谈话。</li><li><strong>接口隔离原则</strong>：客户端不应依赖它不需要的接口。如果一个接口在实现时，部分方法由于冗余被客户端空实现，则应该将接口拆分，让实现类只需依赖自己需要的接口方法。</li></ul><h2 id="设计模式目录"><a href="#设计模式目录" class="headerlink" title="设计模式目录"></a>设计模式目录</h2><h3 id="创造型模式"><a href="#创造型模式" class="headerlink" title="创造型模式"></a>创造型模式</h3><ul><li><a href="https://www.shiming.online/blog/8f9f2030/#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F">工厂方法模式</a></li><li><a href="https://www.shiming.online/blog/8f9f2030/#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F">抽象工厂模式</a></li><li><a href="https://www.shiming.online/blog/8f9f2030/#%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F">建造者模式</a></li><li><a href="https://www.shiming.online/blog/8f9f2030/#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F">原型模式</a></li><li><a href="https://www.shiming.online/blog/8f9f2030/#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">单例模式</a></li></ul><h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><ul><li><a href="https://www.shiming.online/blog/620ff0b5/#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F">适配器模式</a></li><li><a href="https://www.shiming.online/blog/620ff0b5/#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F">桥接模式</a></li><li><a href="https://www.shiming.online/blog/620ff0b5/#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F">组合模式</a></li><li><a href="https://www.shiming.online/blog/620ff0b5/#%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F">装饰模式</a></li><li><a href="https://www.shiming.online/blog/620ff0b5/#%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F">外观模式</a></li><li><a href="https://www.shiming.online/blog/620ff0b5/#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F">享元模式</a></li><li><a href="https://www.shiming.online/blog/620ff0b5/#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-Proxy">代理模式</a></li></ul><h3 id="行为模式"><a href="#行为模式" class="headerlink" title="行为模式"></a>行为模式</h3><!-- - [责任链模式]() --><ul><li>责任链模式<!-- - [命令模式]() --></li><li>命令模式</li><li><a href="https://www.shiming.online/blog/e55dcfb0/#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F">迭代器模式</a></li><li>中介者模式<!-- - [中介者模式]() --></li><li>备忘录模式<!-- - [备忘录模式]() --></li><li>观察者模式<!-- - [观察者模式]() --></li><li>状态模式<!-- - [状态模式]() --></li><li>策略模式<!-- - [策略模式]() --></li><li>模板方法模式<!-- - [模板方法模式]() --></li><li>访问者模式<!-- - [访问者模式]() --></li></ul><blockquote><p>部分链接还没学，所以没有</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ul><li><a href="https://refactoringguru.cn/design-patterns">免费在线学习设计模式</a></li><li><a href="http://c.biancheng.net/design_pattern/">C语言中文网-设计模式</a></li></ul></blockquote><a class="btn-beautify button--animated block blue right" href="https://www.shiming.online/blog/8f9f2030/"   title="设计模式-创造型模式"><i class="far fa-hand-point-right fa-fw"></i><span>设计模式-创造型模式</span></a>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POI和EasyExcel</title>
      <link href="blog/88650203/"/>
      <url>blog/88650203/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>本博客代码已上传gitee仓库 <a href="https://gitee.com/xshiming/poi-exercises.git">失铭 / poi练习</a></p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="POI介绍"><a href="#POI介绍" class="headerlink" title="POI介绍"></a>POI介绍</h3><blockquote><p><a href="http://www.apache.org/">apache官网</a><br><a href="https://baike.baidu.com/item/POI/8886826#viewPageContent">百度百科</a>：Apache POI是Apache软件基金会的开放源码函式库，POI提供API给Java程序对Microsoft Office格式档案读和写的功能。</p></blockquote><p>基本功能：</p><p>结构：</p><ul><li>HSSF － 提供读写Microsoft Excel格式档案的功能。</li><li>XSSF － 提供读写Microsoft Excel OOXML格式档案的功能。</li><li>HWPF － 提供读写Microsoft Word格式档案的功能。</li><li>HSLF － 提供读写Microsoft PowerPoint格式档案的功能。</li><li>HDGF － 提供读写Microsoft Visio格式档案的功能。</li></ul><h3 id="EasyExcel介绍"><a href="#EasyExcel介绍" class="headerlink" title="EasyExcel介绍"></a>EasyExcel介绍</h3><blockquote><p><a href="https://www.yuque.com/easyexcel/doc/easyexcel">EasyExcel官网</a></p></blockquote><p>EasyExcel是一个基于Java的简单、省内存的读写Excel的开源项目。在尽可能节约内存的情况下支持读写百M的Excel。<br>github地址:<a href="https://github.com/alibaba/easyexcel">https://github.com/alibaba/easyexcel</a></p><p>Java解析、生成Excel比较有名的框架有Apache poi、jxl。但他们都存在一个严重的问题就是非常的耗内存，poi有一套SAX模式的API可以一定程度的解决一些内存溢出的问题，但POI还是有一些缺陷，比如07版Excel解压缩以及解压后存储都是在内存中完成的，内存消耗依然很大。easyexcel重写了poi对07版Excel的解析，能够原本一个3M的excel用POI sax依然需要100M左右内存降低到几M，并且再大的excel不会出现内存溢出，03版依赖POI的sax模式。在上层做了模型转换的封装，让使用者更加简单方便。</p><h2 id="POI-Excel"><a href="#POI-Excel" class="headerlink" title="POI-Excel"></a>POI-Excel</h2><h3 id="Excel写"><a href="#Excel写" class="headerlink" title="Excel写"></a>Excel写</h3><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--xls(03)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--xlsx(07)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi-ooxml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--日期格式化工具--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>joda-time<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>joda-time<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--测试--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Excel"><a href="#Excel" class="headerlink" title="Excel"></a>Excel</h4><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200823131731.png" alt="20200823131731"></p><p>如上，一个excel文件叫工作簿，工作薄还有多张工作表，然后就是行和单元格。</p><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>先设置一个文件路径：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> String PATH = <span class="string">&quot;G:\\Java\\IDEA\\xqm-poi\\src\\main\\java\\com\\xqm\\excel\\&quot;</span>;</span><br></pre></td></tr></table></figure><p>xls版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeTest03</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个工作薄 excel03:HSSFWorkbook</span></span><br><span class="line">    Workbook workbook = <span class="keyword">new</span> HSSFWorkbook();</span><br><span class="line">    <span class="comment">// 2. 创建一个工作表</span></span><br><span class="line">    Sheet sheet = workbook.createSheet(<span class="string">&quot;测试表1&quot;</span>);</span><br><span class="line">    <span class="comment">// 3. 创建一行</span></span><br><span class="line">    <span class="comment">// 第一行</span></span><br><span class="line">    Row row1 = sheet.createRow(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 4. 创建一个单元格（1，1）</span></span><br><span class="line">    Cell cell11 = row1.createCell(<span class="number">0</span>);</span><br><span class="line">    cell11.setCellValue(<span class="string">&quot;1,1&quot;</span>);</span><br><span class="line">    <span class="comment">// (1,2)</span></span><br><span class="line">    Cell cell12 = row1.createCell(<span class="number">1</span>);</span><br><span class="line">    cell12.setCellValue(<span class="string">&quot;1,2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二行</span></span><br><span class="line">    Row row2 = sheet.createRow(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// （2，1）</span></span><br><span class="line">    Cell cell21 = row2.createCell(<span class="number">0</span>);</span><br><span class="line">    cell21.setCellValue(<span class="string">&quot;2,1：时间测试&quot;</span>);</span><br><span class="line">    <span class="comment">// （2，2）</span></span><br><span class="line">    Cell cell22 = row2.createCell(<span class="number">1</span>);</span><br><span class="line">    String time = <span class="keyword">new</span> DateTime().toString(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    cell22.setCellValue(<span class="string">&quot;2,2：&quot;</span> + time);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成表</span></span><br><span class="line">    FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(PATH + <span class="string">&quot;excel03.xls&quot;</span>);</span><br><span class="line">    workbook.write(fileOutputStream);</span><br><span class="line"></span><br><span class="line">    fileOutputStream.close();</span><br><span class="line">    System.out.println(<span class="string">&quot;excel03生成完毕&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xlsx版本:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeTest07</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个工作薄 excel07:XSSFWorkbook</span></span><br><span class="line">    Workbook workbook = <span class="keyword">new</span> XSSFWorkbook();</span><br><span class="line">    <span class="comment">// 2. 创建一个工作表</span></span><br><span class="line">    Sheet sheet = workbook.createSheet(<span class="string">&quot;测试表1&quot;</span>);</span><br><span class="line">    <span class="comment">// 3. 创建一行</span></span><br><span class="line">    <span class="comment">// 第一行</span></span><br><span class="line">    Row row1 = sheet.createRow(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 4. 创建一个单元格（1，1）</span></span><br><span class="line">    Cell cell11 = row1.createCell(<span class="number">0</span>);</span><br><span class="line">    cell11.setCellValue(<span class="string">&quot;1,1&quot;</span>);</span><br><span class="line">    <span class="comment">// (1,2)</span></span><br><span class="line">    Cell cell12 = row1.createCell(<span class="number">1</span>);</span><br><span class="line">    cell12.setCellValue(<span class="string">&quot;1,2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二行</span></span><br><span class="line">    Row row2 = sheet.createRow(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// （2，1）</span></span><br><span class="line">    Cell cell21 = row2.createCell(<span class="number">0</span>);</span><br><span class="line">    cell21.setCellValue(<span class="string">&quot;2,1：时间测试&quot;</span>);</span><br><span class="line">    <span class="comment">// （2，2）</span></span><br><span class="line">    Cell cell22 = row2.createCell(<span class="number">1</span>);</span><br><span class="line">    String time = <span class="keyword">new</span> DateTime().toString(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    cell22.setCellValue(<span class="string">&quot;2,2：&quot;</span> + time);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成表</span></span><br><span class="line">    FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(PATH + <span class="string">&quot;excel07.xlsx&quot;</span>);</span><br><span class="line">    workbook.write(fileOutputStream);</span><br><span class="line">    fileOutputStream.close();</span><br><span class="line">    System.out.println(<span class="string">&quot;excel07生成完毕&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个版本的区别在于：</p><ol><li>创建对象不同<ul><li>xls：HSSFWorkbook</li><li>xlsx：XSSFWorkbook</li></ul></li><li>生成文件后缀不同<ul><li>xls：<code>.xlx</code></li><li>xlsx：<code>.xlsx</code></li></ul></li></ol><h4 id="Excel大量数据写"><a href="#Excel大量数据写" class="headerlink" title="Excel大量数据写"></a>Excel大量数据写</h4><p>xls：</p><ul><li>缺点：最多只能处理65536行，否则会抛出异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalArgumentException: <span class="function">Invalid row <span class="title">number</span> <span class="params">(<span class="number">65536</span>)</span> outside allowable <span class="title">range</span> <span class="params">(<span class="number">0.</span><span class="number">.65535</span>)</span></span></span><br></pre></td></tr></table></figure><ul><li>优点：过程中写入缓存，不操作磁盘，最后一次性写入磁盘，速度快</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeBigData03</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// 时间</span></span><br><span class="line"><span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建工作簿</span></span><br><span class="line">Workbook workbook = <span class="keyword">new</span> HSSFWorkbook();</span><br><span class="line"><span class="comment">// 创建工作表</span></span><br><span class="line">Sheet sheet = workbook.createSheet();</span><br><span class="line"><span class="comment">// 写入65536行数据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> rowNum = <span class="number">0</span>; rowNum &lt; <span class="number">65536</span>; rowNum++) &#123;</span><br><span class="line"><span class="comment">// 65537行数据</span></span><br><span class="line"><span class="comment">//for (int rowNum = 0; rowNum &lt; 65537; rowNum++) &#123;</span></span><br><span class="line">    Row row = sheet.createRow(rowNum);</span><br><span class="line">    <span class="comment">// 每行10列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> cellNum = <span class="number">0</span>; cellNum &lt; <span class="number">10</span>; cellNum++) &#123;</span><br><span class="line">        Cell cell = row.createCell(cellNum);</span><br><span class="line">        cell.setCellValue(cellNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入文件</span></span><br><span class="line">FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(PATH + <span class="string">&quot;BigData03.xls&quot;</span>);</span><br><span class="line">workbook.write(fileOutputStream);</span><br><span class="line"></span><br><span class="line">fileOutputStream.close();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">System.out.println((<span class="keyword">double</span>) (end - begin) / <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xlsx：</p><ul><li>缺点：写数据时速度很慢，非常耗内存，也会发生内存移除，如100万条</li><li>优点：可以写较大的数据量，如20万条</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeBigData07</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// 时间</span></span><br><span class="line"><span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line"><span class="comment">// 创建工作簿</span></span><br><span class="line">Workbook workbook = <span class="keyword">new</span> XSSFWorkbook();</span><br><span class="line"><span class="comment">// 创建工作表</span></span><br><span class="line">Sheet sheet = workbook.createSheet();</span><br><span class="line"><span class="comment">// 写65536行数据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> rowNum = <span class="number">0</span>; rowNum &lt; <span class="number">65536</span>; rowNum++) &#123;</span><br><span class="line"><span class="comment">// 写10万行数据</span></span><br><span class="line"><span class="comment">//for (int rowNum = 0; rowNum &lt; 100000; rowNum++) &#123;</span></span><br><span class="line">    Row row = sheet.createRow(rowNum);</span><br><span class="line">    <span class="comment">// 每行10列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> cellNum = <span class="number">0</span>; cellNum &lt; <span class="number">10</span>; cellNum++) &#123;</span><br><span class="line">        Cell cell = row.createCell(cellNum);</span><br><span class="line">        cell.setCellValue(cellNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line"><span class="comment">// 写入文件</span></span><br><span class="line">FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(PATH + <span class="string">&quot;BigData07.xlsx&quot;</span>);</span><br><span class="line">workbook.write(fileOutputStream);</span><br><span class="line">fileOutputStream.close();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">System.out.println((<span class="keyword">double</span>) (end - begin) / <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SXSSF：</p><p>xlsx中XSSFWorkbook的升级版：SXSSFWorkbook</p><p>优点：可以写非常大的数据量，如100万条甚至更多，写数据速度快，占用更少的内存</p><p><strong>注意：</strong></p><ul><li>过程中会产生临时文件，需要在结束后清理临时文件：<code>((SXSSFWorkbook)workbook).dispose();</code></li><li>默认有100条记录被保存在内存中，如果超过这个数量，则最前面的数据写入临时文件</li><li>自定义内存中数据数量使用：new SXSSFWorkbook(number)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeBigData07S</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 时间</span></span><br><span class="line">    <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 创建工作簿：SXSSFWorkbook</span></span><br><span class="line">    Workbook workbook = <span class="keyword">new</span> SXSSFWorkbook();</span><br><span class="line">    <span class="comment">// 创建工作表</span></span><br><span class="line">    Sheet sheet = workbook.createSheet();</span><br><span class="line">    <span class="comment">// 65536行</span></span><br><span class="line">    <span class="comment">//for (int rowNum = 0; rowNum &lt; 65536; rowNum++) &#123;</span></span><br><span class="line">    <span class="comment">// 10万行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> rowNum = <span class="number">0</span>; rowNum &lt; <span class="number">100000</span>; rowNum++) &#123;</span><br><span class="line">        Row row = sheet.createRow(rowNum);</span><br><span class="line">        <span class="comment">// 每行10列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> cellNum = <span class="number">0</span>; cellNum &lt; <span class="number">10</span>; cellNum++) &#123;</span><br><span class="line">            Cell cell = row.createCell(cellNum);</span><br><span class="line">            cell.setCellValue(cellNum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">    <span class="comment">// 写入文件</span></span><br><span class="line">    FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(PATH + <span class="string">&quot;BigData07S.xlsx&quot;</span>);</span><br><span class="line">    workbook.write(fileOutputStream);</span><br><span class="line">    fileOutputStream.close();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除临时文件</span></span><br><span class="line">    ((SXSSFWorkbook)workbook).dispose();</span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    System.out.println((<span class="keyword">double</span>) (end - begin) / <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SXSSFWorkbook：实现“BigGridDemo”策略的流式XSSFWorkbook版本。允许写入非常大的文件而不会耗尽内存，因为任何时候只有配置的行部分被保存在内存中。</p><p>请注意：仍然可能会消耗大量内存，这些内存基于您正在使用的功能，例如合并区域，注释…仍然只存储在内存中，可能需要大量内存。</p><h3 id="Excel读"><a href="#Excel读" class="headerlink" title="Excel读"></a>Excel读</h3><p>xls：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRead03</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// 获取文件流</span></span><br><span class="line">FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(PATH+<span class="string">&quot;ExcelRead03.xls&quot;</span>);</span><br><span class="line"><span class="comment">// 创建一个工作簿，能使用Excel的所有操作</span></span><br><span class="line">Workbook workbook = <span class="keyword">new</span> HSSFWorkbook(fileInputStream);</span><br><span class="line"><span class="comment">// 通过下标获取，也可以通过名字获取：Sheet getSheet(String var1);</span></span><br><span class="line">Sheet sheetAt = workbook.getSheetAt(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 第一行</span></span><br><span class="line">Row row = sheetAt.getRow(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 第一行第一列，（1，1）</span></span><br><span class="line">Cell cell = row.getCell(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// getNumericCellValue 数字</span></span><br><span class="line">System.out.println(cell.getNumericCellValue());</span><br><span class="line"><span class="comment">// 注意：数据类型一定要相同，数字就是number，true/false就是boolean，不能使用string。不然会抛出异常：</span></span><br><span class="line"><span class="comment">// java.lang.IllegalStateException: Cannot get a STRING value from a BOOLEAN cell</span></span><br><span class="line">fileInputStream.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xlsx:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRead07</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取文件流: .xlsx</span></span><br><span class="line">    FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(PATH+<span class="string">&quot;ExcelRead07.xlsx&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建一个工作簿，能使用Excel的所有操作 : XSSFWorkbook</span></span><br><span class="line">    Workbook workbook = <span class="keyword">new</span> XSSFWorkbook(fileInputStream);</span><br><span class="line">    <span class="comment">// 通过下标获取，也可以通过名字获取：Sheet getSheet(String var1);</span></span><br><span class="line">    Sheet sheetAt = workbook.getSheetAt(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 第一行</span></span><br><span class="line">    Row row = sheetAt.getRow(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 第一行第一列，（1，1）</span></span><br><span class="line">    Cell cell = row.getCell(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getNumericCellValue 数字</span></span><br><span class="line">    System.out.println(cell.getNumericCellValue());</span><br><span class="line">    <span class="comment">// 注意：数据类型一定要相同，数字就是number，true/false就是boolean，不能使用string。不然会抛出异常：</span></span><br><span class="line">    <span class="comment">// java.lang.IllegalStateException: Cannot get a STRING value from a BOOLEAN cell</span></span><br><span class="line">    fileInputStream.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意获取值的类型</p><p>根据类型自动获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readType</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取文件流</span></span><br><span class="line">    FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(PATH + <span class="string">&quot;ReadType.xlsx&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建一个工作簿，能使用Excel的所有操作</span></span><br><span class="line">    Workbook workbook = <span class="keyword">new</span> XSSFWorkbook(fileInputStream);</span><br><span class="line">    <span class="comment">// 通过下标获取，也可以通过名字获取：Sheet getSheet(String var1);</span></span><br><span class="line">    Sheet sheetAt = workbook.getSheetAt(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 获取标题</span></span><br><span class="line">    Row rowTitle = sheetAt.getRow(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> cellCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (rowTitle != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取列数</span></span><br><span class="line">        cellCount = rowTitle.getPhysicalNumberOfCells();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> cellNumber = <span class="number">0</span>; cellNumber &lt; cellCount; cellNumber++) &#123;</span><br><span class="line">            Cell cell = rowTitle.getCell(cellNumber);</span><br><span class="line">            <span class="keyword">if</span> (cell != <span class="keyword">null</span>) &#123;</span><br><span class="line">                String stringCellValue = cell.getStringCellValue();</span><br><span class="line">                System.out.print(stringCellValue + <span class="string">&quot; | &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取表的内容</span></span><br><span class="line">    <span class="comment">// 获取表的行数</span></span><br><span class="line">    <span class="keyword">int</span> rowCount = sheetAt.getPhysicalNumberOfRows();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> rowNum = <span class="number">1</span>; rowNum &lt; rowCount; rowNum++) &#123;</span><br><span class="line">        Row rowData = sheetAt.getRow(rowNum);</span><br><span class="line">        <span class="keyword">if</span> (rowData != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> cellNumber = <span class="number">0</span>; cellNumber &lt; cellCount; cellNumber++) &#123;</span><br><span class="line">                Cell cell = rowData.getCell(cellNumber);</span><br><span class="line">                <span class="keyword">if</span> (cell != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    System.out.print(<span class="string">&quot;[&quot;</span> + (rowNum + <span class="number">1</span>) + <span class="string">&quot;-&quot;</span> + (cellNumber + <span class="number">1</span>) + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                    CellType cellType = cell.getCellTypeEnum();</span><br><span class="line">                    <span class="comment">// 匹配列的数据类型</span></span><br><span class="line">                    String cellValue = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                    <span class="keyword">switch</span> (cellType) &#123;</span><br><span class="line">                        <span class="comment">// 字符串</span></span><br><span class="line">                        <span class="keyword">case</span> STRING:</span><br><span class="line">                            System.out.print(<span class="string">&quot;【String】&quot;</span>);</span><br><span class="line">                            cellValue = cell.getStringCellValue();</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="comment">// 布尔</span></span><br><span class="line">                        <span class="keyword">case</span> BOOLEAN:</span><br><span class="line">                            System.out.print(<span class="string">&quot;【BOOLEAN】&quot;</span>);</span><br><span class="line">                            cellValue = String.valueOf(cell.getBooleanCellValue());</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="comment">// 空</span></span><br><span class="line">                        <span class="keyword">case</span> BLANK:</span><br><span class="line">                            System.out.print(<span class="string">&quot;【BLANK】&quot;</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="comment">// 数字</span></span><br><span class="line">                        <span class="keyword">case</span> NUMERIC:</span><br><span class="line">                            System.out.print(<span class="string">&quot;【NUMERIC】&quot;</span>);</span><br><span class="line">                            <span class="comment">// 日期</span></span><br><span class="line">                            <span class="keyword">if</span> (DateUtil.isCellDateFormatted(cell)) &#123;</span><br><span class="line">                                System.out.print(<span class="string">&quot;【日期】&quot;</span>);</span><br><span class="line">                                Date date = cell.getDateCellValue();</span><br><span class="line">                                cellValue = <span class="keyword">new</span> DateTime(date).toString();</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">// 不是日期格式，防止数字过长</span></span><br><span class="line">                                System.out.print(<span class="string">&quot;【装换为字符串输出】&quot;</span>);</span><br><span class="line">                                <span class="comment">//cell.setCellType(CellType.STRING);</span></span><br><span class="line">                                cellValue = cell.toString();</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> _NONE:</span><br><span class="line">                            System.out.println(<span class="string">&quot;【未知数据类型】&quot;</span>);</span><br><span class="line">                        <span class="keyword">case</span> ERROR:</span><br><span class="line">                            System.out.print(<span class="string">&quot;【数据类型错误】&quot;</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(cellValue);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：CellType 3.15后为枚举类型，原方法已过时。CellType源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">CellType</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Internal(</span></span><br><span class="line"><span class="meta">        since = &quot;POI 3.15 beta 3&quot;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    _NONE(-<span class="number">1</span>),</span><br><span class="line">    NUMERIC(<span class="number">0</span>),</span><br><span class="line">    STRING(<span class="number">1</span>),</span><br><span class="line">    FORMULA(<span class="number">2</span>),</span><br><span class="line">    BLANK(<span class="number">3</span>),</span><br><span class="line">    BOOLEAN(<span class="number">4</span>),</span><br><span class="line">    ERROR(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和以前相比，改动如下：</p><ol><li>获取单元格类型<ul><li>以前：<code>getCellType</code></li><li>现在：<code>getCellTypeEnum</code></li></ul></li><li>类型判断，例：<ul><li>以前：<code>case HSSFCell.CELL_TYPE_STRING:</code></li><li>现在：<code>case STRING:</code></li></ul></li><li>不需要将其他类型使用<code>setCellType</code>方法转换为String类型。可以直接使用toString()输出，例：</li><li>数字转时间中：HSSFDateUtil已过时，使用DateUtil替换</li></ol><p>公式计算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">formulaTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(PATH + <span class="string">&quot;Formula.xlsx&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建一个工作簿，能使用Excel的所有操作</span></span><br><span class="line">    Workbook workbook = <span class="keyword">new</span> XSSFWorkbook(fileInputStream);</span><br><span class="line">    <span class="comment">// 通过下标获取，也可以通过名字获取：Sheet getSheet(String var1);</span></span><br><span class="line">    Sheet sheetAt = workbook.getSheetAt(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 获取公式</span></span><br><span class="line">    Row row = sheetAt.getRow(<span class="number">3</span>);</span><br><span class="line">    Cell cell = row.getCell(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到计算公式</span></span><br><span class="line"></span><br><span class="line">    FormulaEvaluator formulaEvaluator = <span class="keyword">new</span> XSSFFormulaEvaluator((XSSFWorkbook) workbook);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入单元格内容</span></span><br><span class="line">    CellType cellType = cell.getCellTypeEnum();</span><br><span class="line">    <span class="keyword">switch</span> (cellType) &#123;</span><br><span class="line">        <span class="comment">// 公式</span></span><br><span class="line">        <span class="keyword">case</span> FORMULA:</span><br><span class="line">            String cellFormula = cell.getCellFormula();</span><br><span class="line">            System.out.println(cellFormula);<span class="comment">// SUM(A1:A3)</span></span><br><span class="line"></span><br><span class="line">            CellValue evaluate = formulaEvaluator.evaluate(cell);</span><br><span class="line">            String cellValue = evaluate.formatAsString();</span><br><span class="line">            System.out.println(cellValue); <span class="comment">// 1368.0</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="EasyExcel"><a href="#EasyExcel" class="headerlink" title="EasyExcel"></a>EasyExcel</h2><blockquote><p>以下内容来自官网：<a href="https://github.com/alibaba/easyexcel/blob/master/abouteasyexcel.md">EasyExcel软件相关</a></p></blockquote><p>EasyExcel解决的问题：</p><ol><li>Excel读写时候内存溢出</li><li>其他开源框架使用复杂</li><li>其他开源框架存在一些BUG修复不及时</li></ol><h3 id="Excel格式分析"><a href="#Excel格式分析" class="headerlink" title="Excel格式分析"></a>Excel格式分析</h3><ul><li>xls是Microsoft Excel2007前excel的文件存储格式，实现原理是基于微软的ole db是微软com组件的一种实现，本质上也是一个微型数据库，由于微软的东西很多不开源，另外也已经被淘汰，了解它的细节意义不大，底层的编程都是基于微软的com组件去开发的。</li><li>xlsx是Microsoft Excel2007后excel的文件存储格式，实现是基于openXml和zip技术。这种存储简单，安全传输方便，同时处理数据也变的简单。</li><li>csv 我们可以理解为纯文本文件，可以被excel打开。他的格式非常简单，解析起来和解析文本文件一样</li></ul><h3 id="EasyExcel核心原理"><a href="#EasyExcel核心原理" class="headerlink" title="EasyExcel核心原理"></a>EasyExcel核心原理</h3><p>写有大量数据的xlsx文件时，POI为我们提供了SXSSFWorkBook类来处理，这个类的处理机制是当内存中的数据条数达到一个极限数量的时候就flush这部分数据，再依次处理余下的数据，这个在大多数场景能够满足需求。 读有大量数据的文件时，使用WorkBook处理就不行了，因为POI对文件是先将文件中的cell读入内存，生成一个树的结构（针对Excel中的每个sheet，使用TreeMap存储sheet中的行）。如果数据量比较大，则同样会产生java.lang.OutOfMemoryError: Java heap space错误。POI官方推荐使用“XSSF and SAX（event API）”方式来解决。 分析清楚POI后要解决OOM有3个关键。</p><h4 id="1-文件解压文件读取通过文件形式"><a href="#1-文件解压文件读取通过文件形式" class="headerlink" title="1. 文件解压文件读取通过文件形式"></a>1. 文件解压文件读取通过文件形式</h4><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200823120156.png" alt="20200823120156"></p><h4 id="2-避免将全部全部数据一次加载到内存"><a href="#2-避免将全部全部数据一次加载到内存" class="headerlink" title="2. 避免将全部全部数据一次加载到内存"></a>2. 避免将全部全部数据一次加载到内存</h4><p>采用sax模式一行一行解析，并将一行的解析结果以观察者的模式通知处理。<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200823120240.png" alt="20200823120240"></p><h4 id="3-抛弃不重要的数据"><a href="#3-抛弃不重要的数据" class="headerlink" title="3.抛弃不重要的数据"></a>3.抛弃不重要的数据</h4><p>Excel解析时候会包含样式，字体，宽度等数据，但这些数据是我们不关心的，如果将这部分数据抛弃可以大大降低内存使用。Excel中数据如下Style占了相当大的空间。</p><h3 id="EasyExcel使用"><a href="#EasyExcel使用" class="headerlink" title="EasyExcel使用"></a>EasyExcel使用</h3><blockquote><p>官方网站写的很详细，使用时可以直接参考着使用-&gt;<a href="https://www.yuque.com/easyexcel/doc/easyexcel">EasyExcel</a></p></blockquote><p>这里示范一下简单读写。</p><p>依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easyexcel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.71<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>设置路径：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> String PATH = <span class="string">&quot;G:\\Java\\IDEA\\xqm-poi\\src\\main\\java\\com\\xqm\\poi\\&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="读"><a href="#读" class="headerlink" title="读"></a>读</h4><p>创建表格数据对应的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoData</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;字符串标题&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String string;</span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;日期标题&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;数字标题&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Double doubleData;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 忽略这个字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExcelIgnore</span></span><br><span class="line">    <span class="keyword">private</span> String ignore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;DemoData&gt; <span class="title">data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;DemoData&gt; list = <span class="keyword">new</span> ArrayList&lt;DemoData&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        DemoData data = <span class="keyword">new</span> DemoData();</span><br><span class="line">        data.setString(<span class="string">&quot;字符串&quot;</span> + i);</span><br><span class="line">        data.setDate(<span class="keyword">new</span> Date());</span><br><span class="line">        data.setDoubleData(<span class="number">0.56</span>);</span><br><span class="line">        list.add(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 最简单的写</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;1. 创建excel对应的实体对象 参照&#123;<span class="doctag">@link</span> DemoData&#125;</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;2. 直接写即可</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">simpleWrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 写法1</span></span><br><span class="line">    String fileName = PATH + <span class="string">&quot;simpleWrite&quot;</span> + <span class="string">&quot;1.xlsx&quot;</span>;</span><br><span class="line">    <span class="comment">// 这里 需要指定写用哪个class去写，然后写到第一个sheet，名字为模板 然后文件流会自动关闭</span></span><br><span class="line">    <span class="comment">// 如果这里想使用03 则 传入excelType参数即可</span></span><br><span class="line">    <span class="comment">// write（filename,格式类）</span></span><br><span class="line">    <span class="comment">// sheet （表名）</span></span><br><span class="line">    <span class="comment">// doWrite （数据）</span></span><br><span class="line">    EasyExcel.write(fileName, DemoData.class).sheet(<span class="string">&quot;模板&quot;</span>).doWrite(data());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写法2</span></span><br><span class="line">    fileName = PATH + <span class="string">&quot;simpleWrite&quot;</span> + <span class="string">&quot;2.xlsx&quot;</span>;</span><br><span class="line">    <span class="comment">// 这里 需要指定写用哪个class去写</span></span><br><span class="line">    ExcelWriter excelWriter = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        excelWriter = EasyExcel.write(fileName, DemoData.class).build();</span><br><span class="line">        WriteSheet writeSheet = EasyExcel.writerSheet(<span class="string">&quot;模板&quot;</span>).build();</span><br><span class="line">        excelWriter.write(data(), writeSheet);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 千万别忘记finish 会帮忙关闭流</span></span><br><span class="line">        <span class="keyword">if</span> (excelWriter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            excelWriter.finish();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，最简单的写入数据只需要一行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EasyExcel.write(fileName, DemoData.class).sheet(<span class="string">&quot;模板&quot;</span>).doWrite(data());</span><br></pre></td></tr></table></figure><h4 id="写"><a href="#写" class="headerlink" title="写"></a>写</h4><p>写首先也需要一个表格对应对象，之前传好了，这里就不创了。</p><p>监听器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有个很重要的点 DemoDataListener 不能被spring管理，要每次读取excel都要new,然后里面用到spring可以构造方法传进去</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoDataListener</span> <span class="keyword">extends</span> <span class="title">AnalysisEventListener</span>&lt;<span class="title">DemoData</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(DemoDataListener.class);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每隔5条存储数据库，实际使用中可以3000条，然后清理list ，方便内存回收</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BATCH_COUNT = <span class="number">5</span>;</span><br><span class="line">    List&lt;DemoData&gt; list = <span class="keyword">new</span> ArrayList&lt;DemoData&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 假设这个是一个DAO，当然有业务逻辑这个也可以是一个service。当然如果不用存储这个对象没用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DemoDAO demoDAO;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoDataListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里是demo，所以随便new一个。实际使用如果到了spring,请使用下面的有参构造函数</span></span><br><span class="line">        demoDAO = <span class="keyword">new</span> DemoDAO();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果使用了spring,请使用这个构造方法。每次创建Listener的时候需要把spring管理的类传进来</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> demoDAO 持久化操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoDataListener</span><span class="params">(DemoDAO demoDAO)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.demoDAO = demoDAO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取数据会执行 invoke 方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data    类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context 分析</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(DemoData data, AnalysisContext context)</span> </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;解析到一条数据:&#123;&#125;&quot;</span>, JSON.toJSONString(data));</span><br><span class="line">        list.add(data);</span><br><span class="line">        <span class="comment">// 达到BATCH_COUNT了，需要去存储一次数据库，防止数据几万条数据在内存，容易OOM</span></span><br><span class="line">        <span class="keyword">if</span> (list.size() &gt;= BATCH_COUNT) &#123;</span><br><span class="line">            <span class="comment">// 持久化</span></span><br><span class="line">            saveData();</span><br><span class="line">            <span class="comment">// 存储完成清理 list</span></span><br><span class="line">            list.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有数据解析完成了 都会来调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterAllAnalysed</span><span class="params">(AnalysisContext context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里也要保存数据，确保最后遗留的数据也存储到数据库</span></span><br><span class="line">        saveData();</span><br><span class="line">        LOGGER.info(<span class="string">&quot;所有数据解析完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加上存储数据库</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;&#123;&#125;条数据，开始存储数据库！&quot;</span>, list.size());</span><br><span class="line">        demoDAO.save(list);</span><br><span class="line">        LOGGER.info(<span class="string">&quot;存储数据库成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dao层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 假设这个是你的DAO存储。当然还要这个类让spring管理，当然你不用需要存储，也不需要这个类。</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoDAO</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(List&lt;DemoData&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 持久化操作</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">// 如果是mybatis,尽量别直接调用多次insert,自己写一个mapper里面新增一个方法batchInsert,所有数据一次性插入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 最简单的读</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;1. 创建excel对应的实体对象 参照&#123;<span class="doctag">@link</span> DemoData&#125;</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;2. 由于默认一行行的读取excel，所以需要创建excel一行一行的回调监听器，参照&#123;<span class="doctag">@link</span> DemoDataListener&#125;</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;3. 直接读即可</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">simpleRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 有个很重要的点 DemoDataListener 不能被spring管理，要每次读取excel都要new,然后里面用到spring可以构造方法传进去</span></span><br><span class="line">    <span class="comment">// 写法1：</span></span><br><span class="line">    String fileName = PATH + <span class="string">&quot;simpleWrite&quot;</span> + <span class="string">&quot;1.xlsx&quot;</span>;</span><br><span class="line">    <span class="comment">// 这里 需要指定读用哪个class去读，然后读取第一个sheet 文件流会自动关闭</span></span><br><span class="line">    EasyExcel.read(fileName, DemoData.class, <span class="keyword">new</span> DemoDataListener()).sheet().doRead();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写法2：</span></span><br><span class="line">    fileName = PATH + <span class="string">&quot;simpleWrite&quot;</span> + <span class="string">&quot;2.xlsx&quot;</span>;</span><br><span class="line">    ExcelReader excelReader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        excelReader = EasyExcel.read(fileName, DemoData.class, <span class="keyword">new</span> DemoDataListener()).build();</span><br><span class="line">        ReadSheet readSheet = EasyExcel.readSheet(<span class="number">0</span>).build();</span><br><span class="line">        excelReader.read(readSheet);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (excelReader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里千万别忘记关闭，读的时候会创建临时文件，到时磁盘会崩的</span></span><br><span class="line">            excelReader.finish();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，最简单的读取操作也只需要一行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EasyExcel.read(fileName, DemoData.class, <span class="keyword">new</span> DemoDataListener()).sheet().doRead();</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ul><li><a href="https://www.bilibili.com/video/BV1Ua4y1x7BK?p=7">【狂神说Java】POI及EasyExcel一小时搞定通俗易懂</a></li><li><a href="https://www.yuque.com/easyexcel/doc/easyexcel">EasyExcel</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> POI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> POI </tag>
            
            <tag> EasyExcel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud</title>
      <link href="blog/96a41905/"/>
      <url>blog/96a41905/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>本博客练习项目已上传gitee-&gt;<a href="https://gitee.com/xshiming/spring-cloud-exercise.git">失铭/SpringCloud练习</a></p></blockquote><h2 id="微服务概述"><a href="#微服务概述" class="headerlink" title="微服务概述"></a>微服务概述</h2><h3 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h3><blockquote><p>引用ThoughtWorks 公司的首席科学家 Martin Fowler <a href="https://martinfowler.com/articles/microservices.html">Microservices</a> 文中的介绍</p></blockquote><p>In short, the microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies.</p><p>谷歌翻译如下：</p><p>简而言之，微服务架构样式是一种将单个应用程序开发为一组小服务的方法，每个小服务都在自己的进程中运行并与轻量级机制（通常是HTTP资源API）进行通信。这些服务围绕业务功能构建，并且可以由全自动部署机制独立部署。这些服务的集中管理几乎没有，可以用不同的编程语言编写并使用不同的数据存储技术。</p><p>单体架构和微服务：</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200818212922.png" alt="20200818212922"></p><p>微服务架构风格中以构建一组小型服务的方式来构建应用系统。这些服务除了能被独立地部署和扩展之外，每一个服务还能提供一个稳固的模块边界，甚至能允许使用不同的编程语言来编写不同的服务。这些服务也能被不同的团队来管理。</p><p>每一个功能元素最终都是一个可独立替换和独立升级的软件单元。</p><h3 id="微服务优缺点"><a href="#微服务优缺点" class="headerlink" title="微服务优缺点"></a>微服务优缺点</h3><p><strong>优点：</strong></p><ul><li>每个服务足够内聚，足够小，代码容易理解，能<strong>聚焦</strong>一个指定的业务功能或业务需求。</li><li>开发简单，<strong>开发效率高</strong>，一个服务可能只需要干一件事。</li><li>微服务能够被<strong>小团队</strong>单独开发（2-5人）。</li><li>易与第三方集成，微服务允许容易且灵活的方式集成自动部署</li><li>微服务易于被一个开发人员理解，修改和维护，这样小团队能够更关注自己的工作成果。无需通过合作才能体现价值。</li><li><strong>解耦</strong>：微服务是松耦合的，是有功能意义的服务，无论是在开发阶段还是部署阶段都是独立的</li><li>微服务能适用<strong>不同语言开发</strong></li><li>微服务<strong>只是业务逻辑的代码</strong>，不会和HTML,CSS 或其他界面组件混合。</li><li>每个微服务有<strong>自己的存储能力</strong>，它可以有自己的数据库，也可以有统一的数据库</li></ul><p><strong>缺点：</strong></p><ul><li>分布式部署，调用复杂性<br>单体应用的时候，所有模块之前的调用都是在本地进行的，在微服务中，每个模块都是独立部署的，通过 HTTP 来进行通信，这当中会产生很多问题，比如网络问题、容错问题、调用关系等。</li><li>多服务运维难度</li><li>系统部署依赖</li><li>服务间通信成本</li><li>数据一致性</li><li>系统集成测试</li><li>性能监控</li></ul><h3 id="微服务技术栈"><a href="#微服务技术栈" class="headerlink" title="微服务技术栈"></a>微服务技术栈</h3><table><thead><tr><th align="center">微服务条目</th><th align="center">落地技术</th></tr></thead><tbody><tr><td align="center">服务开发</td><td align="center">SpringBoot、Spring、SpringMVC</td></tr><tr><td align="center">服务配置与管理</td><td align="center">Netflix公司的Archaius、阿里的Diamind等</td></tr><tr><td align="center">服务注册与发现</td><td align="center">Eureka、Consul、Zookeeper等</td></tr><tr><td align="center">服务调用</td><td align="center">Rest、RPC、gRPC</td></tr><tr><td align="center">服务熔断器</td><td align="center">Hystrix、Envoy等</td></tr><tr><td align="center">负载均衡</td><td align="center">Ribbon、Nginx等</td></tr><tr><td align="center">服务接口调用(客户端调用服务的简化工具)</td><td align="center">Feign等</td></tr><tr><td align="center">消息队列</td><td align="center">Kafka、RabbitMQ、ActiveMQ等</td></tr><tr><td align="center">服务配置中心管理</td><td align="center">SpringCloudConfig、Chef等</td></tr><tr><td align="center">服务路由(API网关)</td><td align="center">Zuul等</td></tr><tr><td align="center">服务监控</td><td align="center">Zabbix、Nagios、Metrics、Spectator</td></tr><tr><td align="center">全链路追踪</td><td align="center">Zipkin、Brave、Dapper等</td></tr><tr><td align="center">服务部署</td><td align="center">Docker、OpernStack、Kubernetes</td></tr><tr><td align="center">数据流操作开发包</td><td align="center">SpringCloud Stream(封装与Redis,Rabbit,Kafaka等发送接收消息)</td></tr><tr><td align="center">事件消息总线</td><td align="center">Spring Cloud Bus</td></tr></tbody></table><h2 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h2><blockquote><p>Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如<strong>服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控</strong>等，都可以用Spring Boot的开发风格做到一键启动和部署。<br>Spring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，<strong>最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</strong></p></blockquote><p>SpringCloud是分布式微服务下的一站式解决方案，是各个微服务架构落地技术的集合体，俗称微服务全家桶</p><h3 id="Spring-Cloud-版本"><a href="#Spring-Cloud-版本" class="headerlink" title="Spring Cloud 版本"></a>Spring Cloud 版本</h3><p>Spring Cloud是一个由众多独立子项目组成的大型综合项目，每个子项目有不同的发行节奏，都维护着自己的发布版本号。Spring Cloud通过一个资源清单BOM（Bill of Materials）来管理每个版本的子项目清单。为避免与子项目的发布号混淆，所以没有采用版本号的方式，而是通过命名的方式。</p><p>这些版本名称的命名方式采用了伦敦地铁站的名称，同时根据字母表的顺序来对应版本时间顺序，比如：最早的Release版本：Angel，第二个Release版本：Brixton，然后是Camden、Dalston、Edgware，当前稳定版为Hoxton SR7。</p><p>当一个版本的Spring Cloud项目的发布内容积累到临界点或者解决了一个严重bug后，就会发布一个“service releases”版本，简称SRX版本，其中X是一个递增数字。</p><h3 id="SpringBoot和SpringCloud关系"><a href="#SpringBoot和SpringCloud关系" class="headerlink" title="SpringBoot和SpringCloud关系"></a>SpringBoot和SpringCloud关系</h3><ul><li><strong>SpringBoot专注于快速、方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架。</strong></li><li>SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来，为各个服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、精选决策、分布式会话等集成服务。</li><li>SpringBoot可以离开SpringCloud独立开发项目，但是SpringCloud离不开SpringBoot，属于依赖关系。</li><li>Spring Boot 是 Spring 的一套快速配置脚手架，可以基于Spring Boot 快速开发单个微服务，Spring Cloud是一个基于Spring Boot实现的云应用开发工具。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200823101126.png" alt="20200823101126"></p><ul><li>API：API网关</li><li>Config server：云配置</li><li>Service registry：注册中心</li><li>Microservices：微服务</li><li>Distrubuted tracing：追踪</li></ul><h2 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h2><p>Apache Dubbo |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。</p><p>Dubbo核心组件：</p><ul><li>Provider：暴露服务的提供方，可以通过 jar 或者容器的方式启动服务。</li><li>Consumer：调用远程服务的服务消费方</li><li>Registry：服务注册中和发现中心</li><li>Monitor：统计服务和调用次数，调用时间监控中心。（Dubbo 的控制台页面中可以显示，目前只有一个简单版本。）</li><li>Container：服务运行的容器。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200823100704.png" alt="20200823100704"></p><h3 id="Dubbo和SpringCluod区别"><a href="#Dubbo和SpringCluod区别" class="headerlink" title="Dubbo和SpringCluod区别"></a>Dubbo和SpringCluod区别</h3><table><thead><tr><th align="center">Dubbo</th><th align="center">SpringCloud</th><th align="center"></th></tr></thead><tbody><tr><td align="center">服务注册中心</td><td align="center">Zookeeper</td><td align="center">Spring Cloud Netfix Eureka</td></tr><tr><td align="center">服务调用方式</td><td align="center">RPC</td><td align="center">REST API</td></tr><tr><td align="center">服务监控</td><td align="center">Dubbo-monitor</td><td align="center">Spring Boot Admin</td></tr><tr><td align="center">熔断器</td><td align="center">不完善</td><td align="center">Spring Cloud Netflix Hystrix</td></tr><tr><td align="center">服务网关</td><td align="center">无</td><td align="center">Spring Cloud Netflix Zuul</td></tr><tr><td align="center">分布式配置</td><td align="center">无</td><td align="center">Spring Cloud Config</td></tr><tr><td align="center">服务跟踪</td><td align="center">无</td><td align="center">Spring Cloud Sleuth</td></tr><tr><td align="center">数据流</td><td align="center">无</td><td align="center">Spring Cloud Stream</td></tr><tr><td align="center">批量任务</td><td align="center">无</td><td align="center">Spring Cloud Task</td></tr><tr><td align="center">信息总线</td><td align="center">无</td><td align="center">Spring Cloud Bus</td></tr></tbody></table><div class="note info flat"><p>注意：Dubbo对于上表中总结为“无”的组件不代表不能实现，而只是Dubbo框架自身不提供，需要另外整合以实现对应的功能。</p></div><p>整体比较：</p><ol><li>dubbo由于是二进制的传输，占用带宽会更少</li><li>springCloud是http协议传输，带宽会比较多，同时使用http协议一般会使用JSON报文，消耗会更大</li><li>dubbo的开发难度较大，原因是dubbo的jar包依赖问题很多大型工程无法解决</li><li>springcloud的接口协议约定比较自由且松散，需要有强有力的行政措施来限制接口无序升级</li><li>dubbo的注册中心可以选择zk,redis等多种，springcloud的注册中心只能用eureka或者自研</li></ol><div class="note info flat"><ul><li>Dubbo 只是实现了服务治理，而 Spring Cloud 子项目分别覆盖了微服务架构下的众多部件，服务治理只是其中的一个方面。</li><li>Dubbo的定位是一款RPC框架，Spring Cloud的目标是微服务架构下的一站式解决方案。</li></ul></div><h2 id="Zureka"><a href="#Zureka" class="headerlink" title="Zureka"></a>Zureka</h2><p>Eureka是Netflix开发的服务发现框架，本身是一个基于REST的服务，主要用于定位运行在AWS域中的中间层服务，以达到负载均衡和中间层服务故障转移的目的。<br>SpringCloud将它集成在其子项目spring-cloud-netflix中，以实现SpringCloud的服务发现功能。</p><p>Eureka包含两个组件：Eureka Server和Eureka Client。</p><ul><li>Eureka Server提供服务注册服务，各个节点启动后，会在Eureka Server中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观的看到。</li><li>Eureka Client是一个java客户端，用于简化与Eureka Server的交互，客户端同时也就是一个内置的、使用轮询(round-robin)负载算法的负载均衡器。<br>在应用启动后，将会向Eureka Server发送心跳,默认周期为30秒，如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，Eureka Server将会从服务注册表中把这个服务节点移除(默认90秒)。</li></ul><p>Eureka Server之间通过复制的方式完成数据的同步，Eureka还提供了客户端缓存机制，即使所有的Eureka Server都挂掉，客户端依然可以利用缓存中的信息消费其他服务的API。综上，Eureka通过心跳检查、客户端缓存等机制，确保了系统的高可用性、灵活性和可伸缩性。</p><h3 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h3><p>在微服务架构中，每个微服务通常有多个实例，每个实例有不同位置，而且实例位置会动态变化。而服务注册与发现技术就是用来解决微服务开发中的这个问题</p><p>服务要被使用，就需要对外提供服务的位置信息，这个位置信息通常是一个IP地址+端口。在服务只有单个实例并且地址不会动态变化的情况下，服务的位置在使用端可以通过配置文件甚至代码等方式固定死。但在位置信息会动态发生变化的情况下，服务实例就需要将这个地址注册到一个注册中心。</p><p>服务的所有实例在自己可以对外提供服务后，将位置注册到注册中心。这个注册中心具有固定的位置或域名，负责保存所有服务实例的位置信息。</p><p>举个例子：</p><p>电商中的订单服务需要调用库存服务，但是这两个服务部署在不同的客户端，如果库存的ip地址不变，那么只需要告诉订单：我是库存，我的地址是：192.137.1.33。订单就可以调用库存服务了。<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200821093432.png" alt="20200821093432"></p><p>当库存地址发生变化时，那么又需要重新通知订单，订单需要修改库存的地址才能调用。如果库存地址经常动态变化，显而易见，将会增加很多麻烦。而服务注册中心就是用来解决这个问题。</p><p>在系统架构引入独立部署在一台机器上的注册中心后，订单，库存在启动时都发送请求到服务注册中心进行注册。也就是说，得告诉服务注册中心，自己是哪个服务，然后自己部署在哪台机器上。然后服务注册中心会把大家注册上来的信息放在注册表里，如下图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200821093823.png" alt="20200821093823"></p><p>接着订单服务假如想要调用库存服务，那么就找服务注册中心问问：能不能告诉我库存服务部署在哪台机器上？服务注册中心是知道这个信息的，所以就会告诉订单服务：库存服务部署在192.1371.133这台机器上，你就给这台机器发送请求吧。然后，订单服务就可以往库存服务的那台机器发送请求了，完成了服务间的调用。整个过程，如下图所示：<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200821093859.png" alt="20200821093859"></p><p>Zureka服务注册参考<a href="https://www.iteye.com/blog/yangyangmyself-2334788">微服务架构中服务注册与发现</a></p><h3 id="Zureka使用"><a href="#Zureka使用" class="headerlink" title="Zureka使用"></a>Zureka使用</h3><div class="note info flat"><p>Zureka具体使用参考<a href="https://www.bilibili.com/video/BV1jJ411S7xr?p=7">Bilibili-【狂神说Java】SpringCloud最新教程IDEA版</a></p></div><blockquote><p>注意：在SpringCloud Hoxton.SR7版本中server依赖为spring-cloud-starter-netflix-eureka-server</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Zureka和Zookeeper的区别"><a href="#Zureka和Zookeeper的区别" class="headerlink" title="Zureka和Zookeeper的区别"></a>Zureka和Zookeeper的区别</h3><p>先了解两个概念</p><blockquote><p>Zookeeprer : ZooKeeper是用于维护配置信息，命名，提供分布式同步以及提供组服务的集中式服务。所有这些类型的服务都以某种形式被分布式应用程序使用。每次实施它们时，都会进行很多工作来修复不可避免的错误和竞争条件。由于难以实现这类服务，因此应用程序最初通常会跳过它们，这会使它们在发生更改时变脆并且难以管理。即使部署正确，这些服务的不同实现也会导致管理复杂。</p><p>分布式的CAP理论：</p><ul><li>一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（严格的一致性，所有节点访问同一份最新的数据副本）</li><li>可用性（A）在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性，不保证获取的数据为最新数据，但是保证最终一致性）</li><li>分区容错性（P）：分布式系统在遇到任何网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务，除非整个网络环境都发生了故障。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在 C 和 A 之间做出选择。</li></ul></blockquote><p>CAP原则又称CAP定理，指的是在一个分布式系统中：一致性（Consistency）可用性（Availability）分区容错性（Partition tolerance）。这三个要素最多只能同时实现两点，不可能三者兼顾。</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200821094819.png" alt="20200821094819"></p><p>在分布式存储系统中，最多只能实现以上两点。而由于当前网络延迟故障会导致丢包等问题，<strong>分区容错性P在分布式系统中是必须要保证的</strong>，因此我们只能在A和C之前权衡</p><ul><li>Zookeeper保证的是CP</li><li>Eureka保证的是AP</li></ul><h4 id="Zookeeper保证CP"><a href="#Zookeeper保证CP" class="headerlink" title="Zookeeper保证CP"></a>Zookeeper保证CP</h4><p>当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接down掉不可用。也就是说，<strong>服务注册功能对可用性的要求要高于一致性。</strong><br>但是zk会出现这样一种情况，当<strong>master节点因为网络故障与其他节点失去联系</strong>时，剩余节点会<strong>重新进行leader选举</strong>。问题在于，<strong>选举leader的时间太长</strong>，30 ~ 120s, 且<strong>选举期间整个zk集群都是不可用</strong>的，这就导致在选举期间注册服务瘫痪。<br>在云部署的环境下，因网络问题使得zk集群失去master节点是较大概率会发生的事，虽然服务能够最终恢复，但是漫长的选举时间导致的注册长期不可用是不能容忍的。</p><h4 id="Eureka保证AP"><a href="#Eureka保证AP" class="headerlink" title="Eureka保证AP"></a>Eureka保证AP</h4><p>Eureka看明白了这一点，因此在设计时就优先保证可用性。<strong>Eureka各个节点都是平等的</strong>，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。<br>而Eureka的客户端在向某个Eureka注册时如果发现连接失败，则会<strong>自动切换</strong>至其它节点，只要有一台Eureka还在，就能<strong>保证注册服务可用</strong>(保证可用性)，只不过查到的信息可能<strong>不是最新</strong>的(不保证强一致性)。<br>除此之外，Eureka还有一种<strong>自我保护机制</strong>，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况：</p><ol><li>Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务</li><li>Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节点依然可用)</li><li>当网络稳定时，当前实例新的注册信息会被同步到其它节点中</li></ol><p>因此， Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪。</p><h2 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h2><h3 id="什么是Ribbon"><a href="#什么是Ribbon" class="headerlink" title="什么是Ribbon"></a>什么是Ribbon</h3><p>Spring Cloud Ribbon是一个基于HTTP和TCP的<strong>客户端负载均衡工具</strong>，它基于Netflix Ribbon实现。</p><p>Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法，将Netflix的中间层服务连接在一起。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。简单的说，就是在配置文件中列出Load Balancer后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随即连接等）去连接这些机器。我们也很容易使用Ribbon实现自定义的负载均衡算法。</p><p>通过Spring Cloud的封装，可以让我们轻松地将面向服务的REST模版请求自动转换成客户端负载均衡的服务调用。Spring Cloud Ribbon虽然只是一个工具类框架，它不像服务注册中心、配置中心、API网关那样需要独立部署，但是它几乎存在于每一个Spring Cloud构建的微服务和基础设施中。</p><p>因为微服务间的调用，API网关的请求转发等内容，实际上都是通过Ribbon来实现的，包括后续介绍的Feign，它也是基于Ribbon实现的工具。所以，对Spring Cloud Ribbon的理解和使用，对于我们使用Spring Cloud来构建微服务非常重要。</p><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>负载均衡是高可用网络基础架构的关键组件，通常用于将工作负载分布到多个服务器来提高网站、应用、数据库或其他服务的性能和可靠性。</p><p>一个没有负载均衡的 web 架构类似下面这样：<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200821115219.png" alt="20200821115219"><br>在这里用户是直连到 web 服务器，如果这个服务器宕机了，那么用户自然也就没办法访问了。另外，如果同时有很多用户试图访问服务器，超过了其能处理的极限，就会出现加载速度缓慢或根本无法连接的情况。</p><p>而通过在后端引入一个负载均衡器和至少一个额外的 web 服务器，可以缓解这个故障。通常情况下，所有的后端服务器会保证提供相同的内容，以便用户无论哪个服务器响应，都能收到一致的内容。<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200821115251.png" alt="20200821115251"></p><p>如图，用户访问负载均衡器，再由负载均衡器将请求转发给后端服务器。在这种情况下，单点故障现在转移到负载均衡器上了。这里又可以通过引入第二个负载均衡器来缓解。</p><p>负载均衡方案</p><p>主流的负载均衡方案分为两类：</p><ul><li><strong>集中式负载均衡</strong><ul><li>即在服务的消费方和提供方之间使用独立的LB设施(可以是硬件，如F5, 也可以是软件，如nginx), 由该设施负责把访问请求通过某种策略转发至服务的提供方；</li></ul></li><li><strong>进程内负载均衡</strong><ul><li>将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。</li><li>Ribbon就属于后者，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。</li></ul></li></ul><h3 id="Ribbon负载均衡策略"><a href="#Ribbon负载均衡策略" class="headerlink" title="Ribbon负载均衡策略"></a>Ribbon负载均衡策略</h3><p>常用策略：</p><ol><li>RoundRobinRule：轮询</li><li>RandomRule：从状态为up（运行中）的服务中随机</li><li>AvailabilityFilteringRule：先过滤掉跳闸，访问故障的服务，再轮询</li><li>RetryRule：先轮询，如果服务访问失败，在指定的时间内，进行重试</li></ol><p>Ribbon策略（转）</p><table><thead><tr><th align="center">策略名</th><th align="center">策略声明</th><th align="center">策略描述</th><th align="center">实现说明</th></tr></thead><tbody><tr><td align="center">BestAvailableRule</td><td align="center">public class BestAvailableRule extends ClientConfigEnabledRoundRobinRule</td><td align="center">选择一个最小的并发请求的server</td><td align="center">逐个考察Server，如果Server被tripped了，则忽略，在选择其中ActiveRequestsCount最小的server</td></tr><tr><td align="center">AvailabilityFilteringRule</td><td align="center">public class AvailabilityFilteringRule extends PredicateBasedRule</td><td align="center">过滤掉那些因为一直连接失败的被标记为circuit tripped的后端server，并过滤掉那些高并发的的后端server（active connections 超过配置的阈值）</td><td align="center">使用一个AvailabilityPredicate来包含过滤server的逻辑，其实就就是检查status里记录的各个server的运行状态</td></tr><tr><td align="center">WeightedResponseTimeRule</td><td align="center">public class WeightedResponseTimeRule extends RoundRobinRule</td><td align="center">根据相应时间分配一个weight，相应时间越长，weight越小，被选中的可能性越低。</td><td align="center">一个后台线程定期的从status里面读取评价响应时间，为每个server计算一个weight。Weight的计算也比较简单responsetime 减去每个server自己平均的responsetime是server的权重。当刚开始运行，没有形成statas时，使用roubine策略选择server。</td></tr><tr><td align="center">RetryRule</td><td align="center">public class RetryRule extends AbstractLoadBalancerRule</td><td align="center">对选定的负载均衡策略机上重试机制。</td><td align="center">在一个配置时间段内当选择server不成功，则一直尝试使用subRule的方式选择一个可用的server</td></tr><tr><td align="center">RoundRobinRule</td><td align="center">public class RoundRobinRule extends AbstractLoadBalancerRule</td><td align="center">roundRobin方式轮询选择server</td><td align="center">轮询index，选择index对应位置的server</td></tr><tr><td align="center">RandomRule</td><td align="center">public class RandomRule extends AbstractLoadBalancerRule</td><td align="center">随机选择一个server</td><td align="center">在index上随机，选择index对应位置的server</td></tr><tr><td align="center">ZoneAvoidanceRule</td><td align="center">public class ZoneAvoidanceRule extends PredicateBasedRule</td><td align="center">复合判断server所在区域的性能和server的可用性选择server</td><td align="center">使用ZoneAvoidancePredicate和AvailabilityPredicate来判断是否选择某个server，前一个判断判定一个zone的运行性能是否可用，剔除不可用的zone（的所有server），AvailabilityPredicate用于过滤掉连接数过多的Server。</td></tr></tbody></table><p>同时，你也可以自定义算法策略，注意，自定义配置应放于xxxApplication.java父类同级的包下，避免被SpringBoot扫描到，从而覆盖掉之前的配置，结构如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200821133850.png" alt="20200821133850"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将自定义负载均衡策略添加到容器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRule <span class="title">myRule1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyRandomRule();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改后的随机策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRandomRule</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalancerRule</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRandomRule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个服务访问5次，然后换下一个服务（一共3个）</span></span><br><span class="line">    <span class="comment">// total = 0 ，默认为0，如果total = 5，指向下一个服务节点</span></span><br><span class="line">    <span class="comment">// index = 0 ，默认为0，如果total = 5，index + 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 被调用的次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 当前是谁在提供服务</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(ILoadBalancer lb, Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lb == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Server server = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                List&lt;Server&gt; upList = lb.getReachableServers();</span><br><span class="line">                <span class="comment">// 获得活着的全部服务</span></span><br><span class="line">                List&lt;Server&gt; allList = lb.getAllServers();</span><br><span class="line">                <span class="comment">// 获得全部服务</span></span><br><span class="line">                <span class="keyword">int</span> serverCount = allList.size();</span><br><span class="line">                <span class="keyword">if</span> (serverCount == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> index = <span class="keyword">this</span>.chooseRandomInt(serverCount);</span><br><span class="line">                <span class="comment">// 生成区间随机数</span></span><br><span class="line">                server = (Server) upList.get(index);</span><br><span class="line">                <span class="comment">// 从活着的服务中，随机获取一个</span></span><br><span class="line">                <span class="comment">/* ---------------- 自定义规则 -------------- */</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (total &lt; <span class="number">5</span>) &#123;</span><br><span class="line">                    server = upList.get(currentIndex);</span><br><span class="line">                    total++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    total = <span class="number">1</span>;</span><br><span class="line">                    currentIndex++;</span><br><span class="line">                    <span class="keyword">if</span> (currentIndex &gt;= upList.size()) &#123;</span><br><span class="line">                        currentIndex = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    server = upList.get(currentIndex);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(total);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* ----------------  -------------- */</span></span><br><span class="line">                <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Thread.yield();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (server.isAlive()) &#123;</span><br><span class="line">                        <span class="keyword">return</span> server;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    server = <span class="keyword">null</span>;</span><br><span class="line">                    Thread.yield();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> server;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">chooseRandomInt</span><span class="params">(<span class="keyword">int</span> serverCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ThreadLocalRandom.current().nextInt(serverCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.choose(<span class="keyword">this</span>.getLoadBalancer(), key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initWithNiwsConfig</span><span class="params">(IClientConfig clientConfig)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在启动类中启动自定义策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Eureka和Ribbon整合以后，不用关心ip地址和端口号</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@RibbonClient(name = &quot;SPRING-CLOUD-DEPT-PROVIDER&quot;, configuration = MyRule.class)</span></span><br><span class="line"><span class="comment">// 启动自定义策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h2><h3 id="Feign简介"><a href="#Feign简介" class="headerlink" title="Feign简介"></a>Feign简介</h3><p>Feign 是声明式的服务调用工具，我们<strong>只需创建一个接口</strong>并用<strong>注解</strong>的方式来配置它，就可以实现对某个服务接口的<strong>调用</strong>，简化了直接使用 RestTemplate 来调用服务接口的开发量。Feign 具备可插拔的注解支持，同时支持 Feign 注解、JAX-RS 注解及 SpringMvc 注解。当使用 Feign 时，Spring Cloud 集成了 Ribbon 和 Eureka 以提供负载均衡的服务调用及基于 Hystrix 的服务容错保护功能。</p><h3 id="Feign能干什么"><a href="#Feign能干什么" class="headerlink" title="Feign能干什么"></a>Feign能干什么</h3><p>Feign旨在使编写Java Http客户端变得更容易.</p><p>使用Ribbon+RestTemplate时,利用RestTemplate对http请求的封装处理,形成了一套模板化的调用方法.但是在实际开发中,由于对服务依赖的调用可能不止一处,往往一个接口会被多处调用,所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用。</p><p>所以,Feign在此基础上做了进一步封装,由他来帮助我们定义和实现依赖服务接口的定义.<strong>在Feign的实现下,我们只需要创建一个接口并使用注解的方式来配置它</strong>(以前是Dao接口上标注Mapper注解,现在是一个微服务接口上面标注一个Feign注解即可),<strong>即可完成对服务提供方的接口绑定</strong>,简化了使用Spring cloud Ribbon时,自动封装服务调用客户端的开发量</p><h3 id="Feign集成了Ribbon"><a href="#Feign集成了Ribbon" class="headerlink" title="Feign集成了Ribbon"></a>Feign集成了Ribbon</h3><p>利用Ribbon维护了MicroServiceCloud-Dept的服务列表信息,并且通过轮询实现了客户端的负载均衡。而与Ribbon不同的是,通过feign只需要定义服务绑定接口且以声明式的方法,优雅而简单的实现了服务调用。</p><h4 id="Feign使用"><a href="#Feign使用" class="headerlink" title="Feign使用"></a>Feign使用</h4><p>在原有consumer依赖基础上添加OpenFeign依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--启动器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--热部署--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建接口调用服务端方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;SPRING-CLOUD-DEPT-PROVIDER&quot;,fallbackFactory = MyFallBackFactory.class)</span></span><br><span class="line"><span class="comment">// value: application-服务器地址</span></span><br><span class="line"><span class="comment">// fallbackFactory: 服务降级，可以忽略</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserInfoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GetMappint要与将后端一致</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/userinfos&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteByPrimaryKey</span><span class="params">(String userId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/userinfos&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(UserInfo record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/userinfos&quot;)</span></span><br><span class="line">    <span class="function">List&lt;UserInfo&gt; <span class="title">selectAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/userinfos&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateByPrimaryKey</span><span class="params">(UserInfo record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/userinfos/&#123;phone&#125;&quot;)</span></span><br><span class="line">    <span class="function">UserInfo <span class="title">selectByPhone</span><span class="params">(<span class="meta">@PathVariable</span> String phone)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在客户端中添加Controller调用接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserInfoService userInfoService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/userinfos/&#123;phone&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserInfo <span class="title">userinfos</span><span class="params">(<span class="meta">@PathVariable</span> String phone)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userInfoService.selectByPhone(phone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/userinfos&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List <span class="title">userinfos</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userInfoService.selectAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加注解启动服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="comment">// 启用Erueaka</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="comment">// 启用Feign</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(FeignApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：浏览器调用客户端Controller，然后调用客户端接口，客户端接口再调用服务端Controller。</p><h2 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h2><p>Netflix Hystrix是SOA/微服务架构中提供服务隔离、熔断、降级机制的工具/框架。Netflix Hystrix是断路器的一种实现，用于高微服务架构的可用性，是防止服务出现雪崩的利器。</p><p>在分布式环境中，不可避免地会有许多服务依赖项中的某些失败。Hystrix是一个库，可通过添加等待时间容限和容错逻辑来帮助您控制这些分布式服务之间的交互。Hystrix通过隔离服务之间的访问点，停止服务之间的级联故障并提供后备选项来实现此目的，所有这些都可以提高系统的整体弹性。</p><p>Hystrix的作用：</p><ul><li>提供保护并控制延迟和失败，以及通过第三方客户端库（通常是通过网络）访问的依赖项的失败。</li><li>停止复杂的分布式系统中的级联故障。</li><li>快速失败并快速恢复。</li><li>回退并在可能的情况下正常降级。</li><li>启用近乎实时的监视，警报和操作控制</li></ul><h3 id="Hystrix解决了什么问题"><a href="#Hystrix解决了什么问题" class="headerlink" title="Hystrix解决了什么问题"></a>Hystrix解决了什么问题</h3><p>复杂分布式体系结构中的应用程序具有数十种依赖关系，每种依赖关系不可避免地会在某个时刻失败。如果主机应用程序未与这些外部故障隔离开来，则可能会被淘汰。</p><p>当一个应用依赖多个外部服务，一切正常时，请求流如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200821214756.png" alt="20200821214756"></p><p>多个微服务正常调用，无阻塞。</p><p>如果有一个服务发生延迟，当前请求就会阻塞：</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200821214931.png" alt="20200821214931"></p><p>随着高流量，单个服务延迟可能导致所有服务器上的资源在几分钟内饱和。</p><p>应用程序中可能会导致网络请求的，通过网络或客户端库延伸的每个点都是潜在故障的根源。比故障更糟糕的是，这些应用程序还会导致服务之间的延迟增加，从而备份队列，线程和其他系统资源，从而导致整个系统出现更多级联故障。</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200821215042.png" alt="20200821215042"></p><p>每个请求都占用了系统的CPU、内存、网络等资源，如果该应用的QPS较高，那么该应用所有的服务资源会被快速消耗完毕，直至应用死掉。如果这个出问题的依赖（Dependency I），不止这一个应用，亦或是受影响的应用上层也有更多的依赖，那就会带来服务雪崩效应。</p><blockquote><p>服务雪崩：一个服务失败，导致整个应用都崩溃。</p></blockquote><p>Hystrix提供的服务熔断和服务降级就是解决服务雪崩的手段之一</p><h3 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h3><p>服务熔断：当下游的服务因为某种原因突然变得不可用或响应过慢，上游服务为了保证自己整体服务的可用性，不再继续调用目标服务，直接返回，快速释放资源。如果目标服务情况好转则恢复调用。例如在高压电路中，如果某个地方的电压过高，熔断器就会熔断，对电路进行保护。<br>需要说明的是熔断其实是一个框架级的处理，那么这套熔断机制的设计，基本上业内用的是断路器模式，如Martin Fowler提供的状态转换图如下所示：<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200821215650.png" alt="20200821215650"></p><ul><li>最开始处于closed状态，一旦检测到错误到达一定阈值，便转为open状态；</li><li>这时候会有个 reset timeout，到了这个时间了，会转移到half open状态；</li><li>尝试放行一部分请求到后端，一旦检测成功便回归到closed状态，即恢复服务；</li></ul><p>在Spring Cloud框架里，熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败，就会启动熔断机制。</p><p>服务熔断解决如下问题：</p><ol><li>当所依赖的对象不稳定时，能够起到快速失败的目的；</li><li>快速失败后，能够根据一定的算法动态试探所依赖对象是否恢复。</li></ol><h3 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h3><p>服务降级是指当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，从而释放服务器资源以保证核心业务正常运作或高效运作。说白了，就是尽可能的把系统资源让给优先级高的服务。</p><p>资源有限，而请求是无限的。如果在并发高峰期，不做服务降级处理，一方面肯定会影响整体服务的性能，严重的话可能会导致宕机某些重要的服务不可用。所以，一般在高峰期，为了保证核心功能服务的可用性，都要对某些服务降级处理。例如当双11活动时，把交易无关的服务统统降级，如查看蚂蚁深林，查看历史订单等等。</p><p>上面是服务降级的一种情况，服务降级存在两种场景：</p><ul><li>当下游的服务因为某种原因响应过慢，下游服务主动停掉一些不太重要的业务，释放出服务器资源，增加响应速度！</li><li>当下游的服务因为某种原因不可用，上游主动调用本地的一些降级逻辑，避免卡顿，迅速返回给用户！</li></ul><div class="note info flat"><p>降级与熔断可以理解为：</p><ul><li>服务降级有很多种降级方式！如开关降级、限流降级、熔断降级!</li><li>服务熔断属于降级方式的一种！</li></ul></div><p>从实现上来说，熔断和降级必定是一起出现。因为当发生下游服务不可用的情况，这个时候为了对最终用户负责，就需要进入上游的降级逻辑了。因此，将熔断降级视为降级方式的一种，也是可以说的通的！</p><p>服务降级需要考虑以下几个问题：</p><ol><li>那些服务是核心服务，哪些服务是非核心服务</li><li>那些服务可以支持降级，那些服务不能支持降级，降级策略是什么</li><li>除服务降级之外是否存在更复杂的业务放通场景，策略是什么？</li></ol><p>自动降级分类</p><ul><li>超时降级：主要配置好超时时间和超时重试次数和机制，并使用异步机制探测回复情况</li><li>失败次数降级：主要是一些不稳定的api，当失败调用次数达到一定阀值自动降级，同样要使用异步机制探测回复情况</li><li>故障降级：比如要调用的远程服务挂掉了（网络故障、DNS故障、http服务返回错误的状态码、rpc服务抛出异常），则可以直接降级。降级后的处理方案有：默认值（比如库存服务挂了，返回默认现货）、兜底数据（比如广告挂了，返回提前准备好的一些静态页面）、缓存（之前暂存的一些缓存数据）</li><li>限流降级：秒杀或者抢购一些限购商品时，此时可能会因为访问量太大而导致系统崩溃，此时会使用限流来进行限制访问量，当达到限流阀值，后续请求会被降级；降级后的处理方案可以是：排队页面（将用户导流到排队页面等一会重试）、无货（直接告知用户没货了）、错误页（如活动太火爆了，稍后重试）。</li></ul><h3 id="Hystrix监控"><a href="#Hystrix监控" class="headerlink" title="Hystrix监控"></a>Hystrix监控</h3><h4 id="启用Actuator"><a href="#启用Actuator" class="headerlink" title="启用Actuator"></a>启用Actuator</h4><p>Actuator是Springboot提供的用来对应用系统进行自省和监控的功能模块，借助于Actuator开发者可以很方便地对应用系统某些监控指标进行查看、统计等。</p><p>若要使用Actuator对Hystrix 流进行监控，除了需在工程POM文件中引入spring-boot-starter-actuator依赖:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="启用Hystrix-Dashboard"><a href="#启用Hystrix-Dashboard" class="headerlink" title="启用Hystrix Dashboard"></a>启用Hystrix Dashboard</h4><p>使用Hystrix一个最大的好处就是它会为我们自动收集每一个HystrixCommand的信息，并利用Hystrix-Dashboard通过一种高效的方式对每一个断路器的健康状态进行展示。</p><p>值得注意的是，在使用HystrixCommand对RibbonClient进行包装的时候，你需要确保你配置的Hystrix超时时间要比Ribbon的超时时间长，包括由它们引起的重试时间，举个例子：如果你的Ribbon连接超时时间是1秒，并且Ribbon会连续重试请求3次，那么你的Hystrix连接超时时间需要配置成稍大于3秒。</p><p>使用Hystrix Dashboard需要新建一个项目作为监控页面</p><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="comment">&lt;!--版本号自己选一个就行--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--eureka客户端--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--客户端信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改监控项目端口</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">9001</span></span><br></pre></td></tr></table></figure><p>启用监控代理并启动项目</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DashBoardApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DashBoardApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问<code>http://localhost:9001/hystrix</code>可以看到监控面板已经启动了<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200821222243.png" alt="20200821222243"></p><p>被监控项目添加一个ServletRegistrationBean。<br>注意：被监控项目需要启用熔断，并且只能监控设置了fallbackMethod的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">hystrixMetricsStreamServlet</span><span class="params">()</span></span>&#123;</span><br><span class="line">       HystrixMetricsStreamServlet streamServlet = <span class="keyword">new</span> HystrixMetricsStreamServlet();</span><br><span class="line">       ServletRegistrationBean registrationBean = <span class="keyword">new</span> ServletRegistrationBean(streamServlet);</span><br><span class="line">       registrationBean.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">       registrationBean.addUrlMappings(<span class="string">&quot;/actuator/hystrix.stream&quot;</span>);</span><br><span class="line">       registrationBean.setName(<span class="string">&quot;HystrixMetricsStreamServlet&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> registrationBean;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在我使用的Hystrix 2.2.4.RELEASE版本中需要设置允许列表</p><p>修改监控项目配置文件，重启项目</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">hystrix.dashboard.proxy-stream-allow-list</span>= <span class="string">*</span></span><br></pre></td></tr></table></figure><p>启动eureka，消费者，生产者，监控面板。</p><p>在消费者页面连接生产者查询数据，然后访问<code>http://localhost:生产者端口/actuator/hystrix.stream</code>可以看到数据流。例：<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200821222549.png" alt="20200821222549"></p><p>打开监控面板<code>http://localhost:9001/hystrix</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200821222826.png" alt="20200821222826"></p><p>输入完成后点击<code>Monitor Stream</code>就可以看到数据面板了。</p><p>例：<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200821222919.png" alt="20200821222919"></p><h2 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h2><p>Zuul是Netflix开源的微服务网关，可以和Eureka、Ribbon、Hystrix等组件配合使用。<br>Spring Cloud对Zuul进行了整合与增强，Zuul默认使用的HTTP客户端是Apache HTTPClient，也可以使用RestClient或okhttp3.OkHttpClient。<br>Zuul的主要功能是路由转发和过滤器。路由功能是微服务的一部分，比如／demo/test转发到到demo服务。zuul默认和Ribbon结合实现了负载均衡的功能</p><blockquote><p>API网关是一个服务器，是系统的唯一入口。从面向对象设计的角度看，它与外观模式类似。API网关封装了系统内部架构，为每个客户端提供一个定制的API。它可能还具有其它职责，如身份验证、监控、负载均衡、缓存、请求分片与管理、静态响应处理。<br>API网关方式的核心要点是，所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。通常，网关也是提供REST/HTTP的访问API。服务端通过API-GW注册和管理服务。</p></blockquote><h3 id="Zuul的作用"><a href="#Zuul的作用" class="headerlink" title="Zuul的作用"></a>Zuul的作用</h3><p>网关有以下几个作用：</p><ul><li>统一入口：为全部服务提供一个唯一的入口，网关起到外部和内部隔离的作用，保障了后台服务的安全性。</li><li>权限校验：识别每个请求的权限，拒绝不符合要求的请求。</li><li>动态路由：动态的将请求路由到不同的后端集群中。</li><li>减少客户端与服务端的耦合：服务可以独立发展，通过网关层来做映射。</li></ul><h3 id="Zuul的使用"><a href="#Zuul的使用" class="headerlink" title="Zuul的使用"></a>Zuul的使用</h3><h4 id="新建Zuul模块，添加依赖"><a href="#新建Zuul模块，添加依赖" class="headerlink" title="新建Zuul模块，添加依赖"></a>新建Zuul模块，添加依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置application-yml文件"><a href="#配置application-yml文件" class="headerlink" title="配置application.yml文件"></a>配置application.yml文件</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">9527</span></span><br><span class="line"><span class="comment"># 端口号</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">springcloud-zuul</span></span><br><span class="line"><span class="comment"># 组件名称</span></span><br><span class="line"></span><br><span class="line"><span class="meta">eureka.client.service-url.defaultZone</span> = <span class="string">http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/</span></span><br><span class="line"><span class="comment"># eureka集群地址</span></span><br><span class="line"><span class="meta">eureka.instance.instance-id</span>=<span class="string">zuul9527.com</span></span><br><span class="line"><span class="comment"># 组件在eureka的名称</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># zuul路由配置</span></span><br><span class="line"><span class="meta">zuul.routes.SPRING-CLOUD-DEPT-PROVIDER.path</span>=<span class="string">/dept/**</span></span><br><span class="line"><span class="comment"># SPRING-CLOUD-DEPT-PROVIDER：Application，服务端名称</span></span><br><span class="line"><span class="comment"># /dept/**：路径</span></span><br></pre></td></tr></table></figure><p>默认路由规则：Zuul和Eureka结合使用，可以实现路由的自动配置，自动配置的路由以服务名称为匹配路径，相当于如下配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># zuul路由配置</span></span><br><span class="line"><span class="meta">zuul.routes.SPRING-CLOUD-DEPT-PROVIDER.path</span>=<span class="string">/dept/**</span></span><br><span class="line"><span class="comment"># SPRING-CLOUD-DEPT-PROVIDER：Application，服务端名称</span></span><br><span class="line"><span class="comment"># /dept/**：路径</span></span><br></pre></td></tr></table></figure><h4 id="添加-EnableZuulProxy注解"><a href="#添加-EnableZuulProxy注解" class="headerlink" title="添加@EnableZuulProxy注解"></a>添加@EnableZuulProxy注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@SpringCloudApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZoolApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ZoolApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完成后，可以在注册中心看到Zuul已经注册了，也可以通过<code>http:localhost:9527/dept/user/1</code>调用服务端</p><blockquote><p>注意：在Zuul 2.2.4.RELEASE版本的使用中，eureka的application要转为小写，别问我怎么知道的</p></blockquote><h4 id="URL路径匹配"><a href="#URL路径匹配" class="headerlink" title="URL路径匹配"></a>URL路径匹配</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URL pattern</span></span><br><span class="line"><span class="comment"># 使用路径方式匹配路由规则。</span></span><br><span class="line"><span class="comment"># 参数key结构： zuul.routes.customName.path=xxx</span></span><br><span class="line"><span class="comment"># 用于配置路径匹配规则。</span></span><br><span class="line"><span class="comment"># 其中customName自定义。通常使用要调用的服务名称，方便后期管理</span></span><br><span class="line"><span class="comment"># 可使用的通配符有： * ** ?</span></span><br><span class="line"><span class="comment"># ? 单个字符</span></span><br><span class="line"><span class="comment"># * 任意多个字符，不包含多级路径</span></span><br><span class="line"><span class="comment"># ** 任意多个字符，包含多级路径</span></span><br><span class="line"><span class="meta">zuul.routes.SPRING-CLOUD-DEPT-PROVIDER.path</span>=<span class="string">/api/**</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数key结构： zuul.routes.customName.url=xxx</span></span><br><span class="line"><span class="comment"># url用于配置符合path的请求路径路由到的服务地址。</span></span><br><span class="line"><span class="meta">zuul.routes.SPRING-CLOUD-DEPT-PROVIDER.url</span>=<span class="string">http://127.0.0.1:8080/</span></span><br></pre></td></tr></table></figure><h4 id="服务名称匹配"><a href="#服务名称匹配" class="headerlink" title="服务名称匹配"></a>服务名称匹配</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service id pattern 通过服务名称路由</span></span><br><span class="line"><span class="comment"># key结构 ： zuul.routes.customName.path=xxx</span></span><br><span class="line"><span class="comment"># 路径匹配规则</span></span><br><span class="line"><span class="meta">zuul.routes.eureka-application-service.path</span>=<span class="string">/api/**</span></span><br><span class="line"><span class="comment"># key结构 ： zuul.routes.customName.serviceId=xxx</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># serviceId用于配置符合path的请求路径路由到的服务名称。</span></span><br><span class="line"><span class="meta">zuul.routes.eureka-application-service.serviceId</span>=<span class="string">eureka-application-service</span></span><br></pre></td></tr></table></figure><p>也可以使用简化配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># simple service id pattern 简化配置方案</span></span><br><span class="line"><span class="comment"># 如果只配置path，不配置serviceId。则customName相当于服务名称。</span></span><br><span class="line"><span class="comment"># 符合path的请求路径直接路由到customName对应的服务上。</span></span><br><span class="line"><span class="meta">zuul.routes.eureka-application-service.path</span>=<span class="string">/api/**</span></span><br></pre></td></tr></table></figure><h4 id="路由排除设置"><a href="#路由排除设置" class="headerlink" title="路由排除设置"></a>路由排除设置</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ignored service id pattern</span></span><br><span class="line"><span class="comment"># 配置不被zuul管理的服务列表。多个服务名称使用逗号&#x27;,&#x27;分隔。</span></span><br><span class="line"><span class="comment"># 配置的服务将不被zuul代理。</span></span><br><span class="line"><span class="meta">zuul.ignored-services</span>=<span class="string">eureka-application-service</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此方式相当于给所有新发现的服务默认排除zuul网关访问方式，只有配置了路由网关的服务才可以通过zuul网关访问</span></span><br><span class="line"><span class="comment"># 通配方式配置排除列表。</span></span><br><span class="line"><span class="meta">zuul.ignored-services</span>=<span class="string">*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用服务名称匹配规则配置路由列表，相当于只对已配置的服务提供网关代理。</span></span><br><span class="line"><span class="meta">zuul.routes.eureka-application-service.path</span>=<span class="string">/api/**</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通配方式配置排除网关代理路径。所有符合ignored-patterns的请求路径都不被zuul网关代理。</span></span><br><span class="line"><span class="meta">zuul.ignored-patterns</span>=<span class="string">/**/test/**</span></span><br><span class="line"><span class="meta">zuul.routes.eureka-application-service.path</span>=<span class="string">/api/**</span></span><br></pre></td></tr></table></figure><h4 id="访问前缀"><a href="#访问前缀" class="headerlink" title="访问前缀"></a>访问前缀</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># prefix URL pattern 前缀路由匹配</span></span><br><span class="line"><span class="comment"># 配置请求路径前缀，所有基于此前缀的请求都由zuul网关提供代理。</span></span><br><span class="line"><span class="meta">zuul.prefix</span>=<span class="string">/api</span></span><br><span class="line"><span class="comment"># 使用服务名称匹配方式配置请求路径规则。</span></span><br><span class="line"><span class="comment"># 这里的配置将为：http://ip:port/api/appservice/**的请求提供zuul网关代理，可以将要访问服务进行前缀分类。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 并将请求路由到服务eureka-application-service中。</span></span><br><span class="line"><span class="meta">zuul.routes.eureka-application-service.path</span>=<span class="string">/appservice/**</span></span><br></pre></td></tr></table></figure><p>如上，配置访问前缀需要在路由前添加前缀才能访问，例：<code>http://localhost:9527/proxy/dept/userinfos/1</code>访问。</p><p>zuul网关其底层使用ribbon来实现请求的路由，并内置Hystrix，可选择性提供网关fallback逻辑。使用zuul的时候，并不推荐使用Feign作为application client端的开发实现。毕竟Feign技术是对ribbon的再封装，使用Feign本身会提高通讯消耗，降低通讯效率，</p><h2 id="SpringCloud-Config"><a href="#SpringCloud-Config" class="headerlink" title="SpringCloud  Config"></a>SpringCloud  Config</h2><p>分布式系统中，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件springCloud Config ，它支持从远程Git仓库中读取配置文件并存放到本地Git仓库。</p><p>备注：这是整个模块最简单的项目，简而言之就是将配置文件上传到git仓库，项目再从git获取并初始化项目。SpringCloud Config是C-S结构的。</p><h3 id="Config-Server"><a href="#Config-Server" class="headerlink" title="Config-Server"></a>Config-Server</h3><p>创建一个git仓库，这一步就不介绍了。直接开始项目搭建</p><h4 id="添加Config依赖"><a href="#添加Config依赖" class="headerlink" title="添加Config依赖"></a>添加Config依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- config启动器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置Server配置文件"><a href="#配置Server配置文件" class="headerlink" title="配置Server配置文件"></a>配置Server配置文件</h4><p>创建application.yml文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 端口号</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3344</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="comment"># 项目名</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">com.xqm.springcloud-config-server</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="comment"># git仓库地址，注意是https</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">https://gitee.com/xshiming/com.xqm.springcloud-config.git</span></span><br></pre></td></tr></table></figure><h4 id="启动Server"><a href="#启动Server" class="headerlink" title="启动Server"></a>启动Server</h4><p>添加注解<code>@EnableConfigServer</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigServer.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要三步就可以迅速搭建一个服务端，接下来看项目中如何获取配置文件。</p><h3 id="Config-Client"><a href="#Config-Client" class="headerlink" title="Config-Client"></a>Config-Client</h3><p>在仓库新建一个Config-Client文件，内容就是你接下用到的项目的配置，例：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"> <span class="attr">profiles:</span></span><br><span class="line">  <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"> <span class="attr">port:</span> <span class="number">8181</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"> <span class="attr">profiles:</span> <span class="string">dev</span></span><br><span class="line"> <span class="attr">application :</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">springcloud-provider-dept</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"> <span class="attr">port:</span> <span class="number">8182</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"> <span class="attr">profiles:</span> <span class="string">test</span></span><br><span class="line"> <span class="attr">application :</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">springcloud-provider-dept</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/</span></span><br></pre></td></tr></table></figure><p>将文件上传git仓库，就可以在<code>http://localhost:3344/config-client-dev.yml</code>访问到刚才配置的文件中的dev环境配置</p><p>访问规则：</p><ul><li>/{application}/{profile}[/{label}] 例：<code>http://localhost:3344/config-client/dev/master</code></li><li>/{application}-{profile}.yml 例：<code>http://localhost:3344/config-client-dev.yml</code></li><li>/{label}/{application}-{profile}.yml 例：<code>http://localhost:3344/master/config-client-dev.yml</code></li><li>/{application}-{profile}.properties</li><li>/{label}/{application}-{profile}.properties</li></ul><h4 id="添加客户端依赖"><a href="#添加客户端依赖" class="headerlink" title="添加客户端依赖"></a>添加客户端依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="修改客户端配置文件"><a href="#修改客户端配置文件" class="headerlink" title="修改客户端配置文件"></a>修改客户端配置文件</h4><p>在resources目录下新建<code>bootstrap.yml</code>文件，</p><blockquote><p>注：bootstrap.yml是系统配置，application.yml是个人配置，会被前者覆盖</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 系统级别配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">http://localhost:3344</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">config-client</span> <span class="comment"># 需要从git上读取的资源名称，不需要后缀</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">dev</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span></span><br><span class="line">     <span class="comment"># 即 http://localhost:3344/config-client/dev/master</span></span><br></pre></td></tr></table></figure><p>如上，两步就配置完成了。</p><p>测试一个属性取到没有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.application.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String applicationName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;eureka.client.service-url.defaultZone&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String eurekaServer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String port;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/config&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">config</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;applicationName : &quot;</span>+applicationName+<span class="string">&quot; eurekaServer : &quot;</span>+eurekaServer+<span class="string">&quot; port : &quot;</span>+port;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动项目访问<code>http://localhost:8182/config</code>能看到返回了刚才配置的值。大功告成</p><h2 id="SpringCloud总结"><a href="#SpringCloud总结" class="headerlink" title="SpringCloud总结"></a>SpringCloud总结</h2><ul><li>微服务</li><li>SpringCluod</li><li>Netflix<ul><li>Eureka</li><li>Ribbon</li><li>Feign</li><li>Zuul</li><li>Hystrix</li></ul></li><li>SpringCloud Config</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ul><li><a href="https://www.bilibili.com/video/av76020761?p=17">【狂神说Java】SpringCloud最新教程IDEA版</a></li><li><a href="https://blog.csdn.net/u013982921/article/details/93622716?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.edu_weight&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.edu_weight">Consul服务注册与服务发现机制</a></li><li><a href="https://www.cnblogs.com/snowjeblog/p/8821325.html">Eureka的工作原理以及它与ZooKeeper的区别</a></li><li><a href="https://www.cnblogs.com/jing99/p/11696192.html">SpringCloud之Zuul网关原理及其配置</a></li><li><a href="https://www.springcloud.cc/">Spring Cloud中文网</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring+Mybatis+Druid</title>
      <link href="blog/20547/"/>
      <url>blog/20547/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Spring-Mybatis-Druid"><a href="#Spring-Mybatis-Druid" class="headerlink" title="Spring+Mybatis+Druid"></a>Spring+Mybatis+Druid</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>选择Spring Initializr创建项目，选择jdk版本和默认的Service URL</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200807222127.png" alt="创建项目"><br>填写项目的Group，Artifact信息<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200807222145.png" alt="填写信息"><br>选择Web中的Spring Web和Sql中的Spring Data JDBC，Mybatis，MySQL四个依赖<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200807222201.png" alt="添加依赖"><br>然后填写项目信息点击Finish<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200807222217.png" alt="结束"></p><a id="more"></a><h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><p>添加Druid依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>修改datasource.properties文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#datasource</span></span><br><span class="line"><span class="meta">&lt;!--</span> <span class="string">mysql8.0以上版本 --&gt;</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/mysql?useUnicode=ture\</span></span><br><span class="line">  <span class="meta">&amp;characterEncoding</span>=<span class="string">UTF-8&amp;serverTimezone=UTC</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.datasource.type</span>=<span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#druid</span></span><br><span class="line"><span class="meta">spring.datasource.initialSize</span>: <span class="string">5</span></span><br><span class="line"><span class="meta">spring.datasource.minIdle</span>: <span class="string">5</span></span><br><span class="line"><span class="meta">spring.datasource.maxActive</span>: <span class="string">20</span></span><br><span class="line"><span class="meta">spring.datasource.maxWait</span>: <span class="string">60000</span></span><br><span class="line"><span class="meta">spring.datasource.timeBetweenEvictionRunsMillis</span>: <span class="string">60000</span></span><br><span class="line"><span class="meta">spring.datasource.minEvictableIdleTimeMillis</span>: <span class="string">300000</span></span><br><span class="line"><span class="meta">spring.datasource.validationQuery</span>: <span class="string">SELECT 1 FROM DUAL</span></span><br><span class="line"><span class="meta">spring.datasource.testWhileIdle</span>: <span class="string">true</span></span><br><span class="line"><span class="meta">spring.datasource.testOnBorrow</span>: <span class="string">false</span></span><br><span class="line"><span class="meta">spring.datasource.testOnReturn</span>: <span class="string">false</span></span><br><span class="line"><span class="meta">spring.datasource.poolPreparedStatements</span>: <span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置监控统计拦截的filters，stat:监控统计、logback：日志记录、wall：防御sql注入</span></span><br><span class="line"><span class="meta">spring.datasource.filters</span>: <span class="string">stat,wall,slf4j</span></span><br><span class="line"><span class="meta">spring.datasource.maxPoolPreparedStatementPerConnectionSize</span>: <span class="string">20</span></span><br><span class="line"><span class="meta">spring.datasource.useGlobalDataSourceStat</span>: <span class="string">true</span></span><br><span class="line"><span class="meta">spring.datasource.connectionProperties</span>: <span class="string">druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span></span><br><span class="line"><span class="comment">## mybatis config ###</span></span><br><span class="line"><span class="meta">mybatis.mapper-locations</span>=<span class="string">classpath:mybatis/*/*.xml</span></span><br><span class="line"><span class="meta">mybatis.type-aliases-package</span>=<span class="string">com/sx/sc/mapper/*</span></span><br><span class="line"><span class="meta">mybatis.configuration.map-underscore-to-camel-case</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">mybatis.configuration.lazy-loading-enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#mybatis.configuration.aggressive-lazy-loading=false</span></span><br><span class="line"><span class="comment">#是否显示sql语句</span></span><br><span class="line"><span class="meta">mybatis.configuration.log-impl</span>=<span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure><h3 id="创建conifg文件"><a href="#创建conifg文件" class="headerlink" title="创建conifg文件"></a>创建conifg文件</h3><p>创建config包，创建DruidConfig文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.support.http.StatViewServlet;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.support.http.WebStatFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.FilterRegistrationBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.ServletRegistrationBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">druidDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置监控服务器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回监控注册的servlet对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServletRegistrationBean&lt;?&gt; statViewServletDemo() &#123;</span><br><span class="line">        ServletRegistrationBean&lt;StatViewServlet&gt; srb =</span><br><span class="line">                <span class="keyword">new</span> ServletRegistrationBean&lt;&gt;(<span class="keyword">new</span> StatViewServlet(),</span><br><span class="line">                        <span class="string">&quot;/druid/*&quot;</span>);</span><br><span class="line">        <span class="comment">// 添加IP白名单</span></span><br><span class="line">        <span class="comment">//srb.addInitParameter(&quot;allow&quot;, &quot;0.0.0.0&quot;);</span></span><br><span class="line">        <span class="comment">//srb.addInitParameter(&quot;allow&quot;, &quot;192.168.1.*&quot;);</span></span><br><span class="line">        <span class="comment">// 添加IP黑名单，当白名单和黑名单重复时，黑名单优先级更高</span></span><br><span class="line">        <span class="comment">//srb.addInitParameter(&quot;deny&quot;, &quot;192.168.25.123&quot;);</span></span><br><span class="line">        <span class="comment">//添加控制台管理用户</span></span><br><span class="line">        srb.addInitParameter(<span class="string">&quot;loginUsername&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        srb.addInitParameter(<span class="string">&quot;loginPassword&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="comment">// 是否能够重置数据</span></span><br><span class="line">        srb.addInitParameter(<span class="string">&quot;resetEnable&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> srb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置服务过滤器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回过滤器配置对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">statFilterDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FilterRegistrationBean frb = <span class="keyword">new</span> FilterRegistrationBean(<span class="keyword">new</span> WebStatFilter());</span><br><span class="line">        <span class="comment">// 添加过滤规则</span></span><br><span class="line">        frb.addUrlPatterns(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">        <span class="comment">// 忽略过滤格式</span></span><br><span class="line">        frb.addInitParameter(<span class="string">&quot;exclusions&quot;</span>, <span class="string">&quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*,&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> frb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动Application进入<code>localhost:8080/druid</code>就可以进入druid管理页面，帐户密码就是DruidConfig内的数据</p><h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><p>然后按照ssm开发步骤创建controller,service,mapper.java,mapper.xml文件即可完成对数据库的访问</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol><li><p><code>controll</code>注解<code>@RestController</code>(返回json格式)</p></li><li><p><code>service</code>注解<code>@Service</code></p></li><li><p><code>mapper.java</code>注解<code>@Repository,@Mapper</code></p><ul><li><code>@Repository</code>使@Aotuwired不报错</li><li><code>@Mapper</code>使Spring能扫描到mapper</li></ul></li></ol><h2 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h2><ul><li><strong><code>@SpringBootApplication</code></strong><br><code>@SpringBootApplication</code>相当于<code>@Configuration,@EnableAutoConfiguration和@ComponentScan</code>并具有他们的默认属性值</li><li><strong><code>@ComponentScan(&quot;*.*&quot;)</code></strong><br>定义扫描的路径从中找出标识了需要装配的类自动装配到spring的bean容器中<br>一般情况下不需要这个注解，因为一般情况下Application启动时会加载Application父包下的所有子包及其文件。<br>但在模块打包为jar包，不能扫描第三方jar包时，需要加上 <code>@ComponentScan()</code>使Spring自动装配</li><li><strong><code>@Configuration</code></strong> 设为配置类</li><li><strong><code>@EnableAsync</code></strong> Spring通过任务执行器（TaskExecutor）来实现多线程和并发编程。使用ThreadPoolTaskExecutor可实现一个基于线程池的TaskExecutor.在开发中实现异步任务，我们可以在配置类中添加@EnableAsync开始对异步任务的支持，并在相应的方法中使用@Async注解来声明一个异步任务。</li><li><strong><code>@EnableTransactionManagement</code></strong> 事务管理</li><li><strong><code>@EnableAutoConfiguration</code></strong> 开启自动配置</li><li><strong><code>@EnableSwagger2</code></strong>   启动swagger注解</li><li><strong><code>@ServletComponentScan</code></strong> 在Application上使用@ServletComponentScan注解后，Servlet、Filter、Listener可以直接通过@WebServlet、@WebFilter、@WebListener注解自动注册，无需其他代码。</li><li><strong><code>@EnableAspectJAutoProxy(exposeProxy = true)</code></strong> 开启AOP</li></ul><a class="btn-beautify button--animated block blue right" href="https://www.shiming.online/blog/96a41905/"   title="SpringCloud"><i class="far fa-hand-point-right fa-fw"></i><span>SpringCloud</span></a>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 开发 </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志</title>
      <link href="blog/32353/"/>
      <url>blog/32353/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="JDK-Logging"><a href="#JDK-Logging" class="headerlink" title="JDK Logging"></a>JDK Logging</h2><p>从jdk1.4起，JDK开始自带一套日志系统。JDK Logging最大的优点就是不需要任何类库的支持，只要有Java的运行环境就可以使用。</p><p>日志能够很好的代替我们在调试过程的<code>System.out.pringln()</code>，日志能够避免反反复复添加输入语句的繁琐和更准确的输入想要的结果。<br>日志的优点有很多：</p><ol><li>可以设置输出样式，避免自己每次都写”ERROR: “ + var；</li><li>可以设置输出级别，禁止某些级别输出。例如，只输出错误日志；</li><li>可以被重定向到不同服务器，用于在控制台中显示，用于存储文件等；</li><li>可以按包名控制日志级别，只输出某些包打印的日志；</li><li>可以……</li></ol><p>但是因为JDK Logging和其他的日志相比比较简陋，所以在商业中很少使用JDK logging</p><p>一种由7个日志级别</p><table><thead><tr><th align="center">级别</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">SEVERE</td><td align="center">严重</td></tr><tr><td align="center">WARNING</td><td align="center">警告</td></tr><tr><td align="center">INFO</td><td align="center">信息</td></tr><tr><td align="center">CONFIG</td><td align="center">配置</td></tr><tr><td align="center">FINE</td><td align="center">良好</td></tr><tr><td align="center">FINER</td><td align="center">较好</td></tr><tr><td align="center">FINEST</td><td align="center">最好</td></tr></tbody></table><p>默认情况下，只记录前三个级别，也可以调整其他级别，例：<br>使用<code>logger.setLevel(Level.FINE)</code>调整显示FINE和更高级别的显示。还可以使用<code>Level.ALL</code>开启所有级别和<code>Level.OFF</code>关闭所有级别</p><blockquote><p>示例来自<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1264738568571776">廖雪峰的官方网站</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Logger logger = Logger.getGlobal();</span><br><span class="line">        logger.info(<span class="string">&quot;start process...&quot;</span>);</span><br><span class="line">        logger.warning(<span class="string">&quot;memory is running out...&quot;</span>);</span><br><span class="line">        logger.fine(<span class="string">&quot;ignored.&quot;</span>);</span><br><span class="line">        logger.severe(<span class="string">&quot;process will be terminated...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会得到类似如下输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Mar <span class="number">02</span>, <span class="number">2019</span> <span class="number">6</span>:<span class="number">32</span>:<span class="number">13</span> PM Hello main</span><br><span class="line">INFO: start process...</span><br><span class="line">Mar <span class="number">02</span>, <span class="number">2019</span> <span class="number">6</span>:<span class="number">32</span>:<span class="number">13</span> PM Hello main</span><br><span class="line">WARNING: memory is running out...</span><br><span class="line">Mar <span class="number">02</span>, <span class="number">2019</span> <span class="number">6</span>:<span class="number">32</span>:<span class="number">13</span> PM Hello main</span><br><span class="line">SEVERE: process will be terminated...</span><br></pre></td></tr></table></figure><p>使用Java标准库内置的Logging有以下局限：</p><ul><li>Logging系统在JVM启动时读取配置文件并完成初始化，一旦开始运行main()方法，就无法修改配置；</li><li>配置不太方便，需要在JVM启动时传递参数<code>-Djava.util.logging.config.file=&lt;config-file-name&gt;</code>。</li></ul><h2 id="Commons-Logging-和-Log4j2"><a href="#Commons-Logging-和-Log4j2" class="headerlink" title="Commons Logging 和 Log4j2"></a>Commons Logging 和 Log4j2</h2><h3 id="Commons-Logging"><a href="#Commons-Logging" class="headerlink" title="Commons Logging"></a>Commons Logging</h3><p>Jakarta  Commons-logging（JCL）是apache最早提供的日志的框架接口。提供简单的日志实现以及日志解耦功能。它本身并没有记录log的功能，只是统一了JDK Logging与Log4j的API，并把日志功能交给JDK Logging或者是log4j。</p><p>Commons Logging的特色是，它可以挂接不同的日志系统，并通过配置文件指定挂接的日志系统。默认情况下，Commons Logging自动搜索并使用Log4j，如果没有找到Log4j，再使用JDK Logging。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>使用Commons Logging只需要和两个类打交道，并且只有两步：</p><p>第一步，通过LogFactory获取Log类的实例； 第二步，使用Log实例的方法打印日志。</p><p>Maven依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>示例来自<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1264738568571776">廖雪峰的官方网站</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Log log = LogFactory.getLog(Main.class);</span><br><span class="line">        log.info(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        log.warn(<span class="string">&quot;end.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Commons Logging定义了6个日志级别:</p><ul><li>FATAL</li><li>ERROR</li><li>WARNING</li><li>INFO</li><li>DEBUG</li><li>TRACE</li></ul><p>默认级别是INFO，除此之外还有<strong>最高级的OFF和最低级的ALL</strong></p><p>使用Commons Logging时，如果在静态方法中引用Log，通常直接定义一个静态类型变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(Main.class);</span><br></pre></td></tr></table></figure><p>在实例方法中引用Log，通常定义一个实例变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Log log = LogFactory.getLog(getClass());</span><br></pre></td></tr></table></figure><p>实例变量log的获取方式是LogFactory.getLog(getClass())，虽然也可以用LogFactory.getLog(XXX.class)，但是前一种方式有个非常大的好处，就是子类可以直接使用该log实例。</p><h3 id="Log4j2"><a href="#Log4j2" class="headerlink" title="Log4j2"></a>Log4j2</h3><p>Commons Logging可以作为日志接口，而“日志实现”可以使用Log4j2</p><p>Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。</p><p>而Apache Log4j 2是Log4j的升级版，对Log4j的前身Log4j 1.x进行了重大改进，并提供了Logback中可用的许多改进，同时解决了Logback体系结构中的一些固有问题。</p><h4 id="使用Log4j2"><a href="#使用Log4j2" class="headerlink" title="使用Log4j2"></a>使用Log4j2</h4><p>Maven依赖：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;commons-logging&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.7&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;log4j-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.7&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>在resources目录下新增<code>commons-logging.properties</code>文件<br>内容为：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">org.apache.commons.logging.Log</span>=<span class="string">org.apache.commons.logging.impl.Log4JLogger</span></span><br></pre></td></tr></table></figure><p>在resources目录下新增<code>log4j2.xml</code>或<code>log4j2.properties</code>文件<br>内容为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，</span></span><br><span class="line"><span class="comment"> 你会看到log4j2内部各种详细输出。可以设置成OFF(关闭)或Error(只输出错误信息)</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span> <span class="attr">status</span>=<span class="string">&quot;WARN&quot;</span> <span class="attr">monitorInterval</span>=<span class="string">&quot;30&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">&quot;App&quot;</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">&quot;logDir&quot;</span>&gt;</span>logs<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">&quot;splitSize&quot;</span>&gt;</span>30 MB<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 输出控制台日志的配置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">&quot;console&quot;</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span> <span class="attr">onMatch</span>=<span class="string">&quot;ACCEPT&quot;</span> <span class="attr">onMismatch</span>=<span class="string">&quot;DENY&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 输出日志的格式 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 打印出所有的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RollingRandomAccessFile</span> <span class="attr">name</span>=<span class="string">&quot;infoLog&quot;</span> <span class="attr">fileName</span>=<span class="string">&quot;$&#123;logDir&#125;/$&#123;App&#125;-info.log&quot;</span> <span class="attr">immediateFlush</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">                                 <span class="attr">filePattern</span>=<span class="string">&quot;$&#123;logDir&#125;/$$&#123;date:yyyy-MM&#125;/$&#123;App&#125;-info-%d&#123;MM-dd-yyyy&#125;-%i.log.gz&quot;</span></span></span><br><span class="line"><span class="tag">                                 <span class="attr">append</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;%d&#123;yyyy-MM-dd &#x27;at&#x27; HH:mm:ss z&#125; [%t] %-5level %logger&#123;36&#125; %L %M - %msg%xEx%n&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span> <span class="attr">interval</span>=<span class="string">&quot;6&quot;</span> <span class="attr">modulate</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">&quot;$&#123;splitSize&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Filters</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 只记录info和warn级别信息 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">&quot;error&quot;</span> <span class="attr">onMatch</span>=<span class="string">&quot;DENY&quot;</span> <span class="attr">onMismatch</span>=<span class="string">&quot;NEUTRAL&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span> <span class="attr">onMatch</span>=<span class="string">&quot;ACCEPT&quot;</span> <span class="attr">onMismatch</span>=<span class="string">&quot;DENY&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Filters</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 指定每天的最大压缩包个数，默认7个，超过了会覆盖之前的 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">&quot;50&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">RollingRandomAccessFile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 存储所有error信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RollingRandomAccessFile</span> <span class="attr">name</span>=<span class="string">&quot;errorLog&quot;</span> <span class="attr">fileName</span>=<span class="string">&quot;$&#123;logDir&#125;/$&#123;App&#125;-error.log&quot;</span> <span class="attr">immediateFlush</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">                                 <span class="attr">filePattern</span>=<span class="string">&quot;$&#123;logDir&#125;/$$&#123;date:yyyy-MM&#125;/$&#123;App&#125;-error-%d&#123;MM-dd-yyyy&#125;-%i.log.gz&quot;</span></span></span><br><span class="line"><span class="tag">                                 <span class="attr">append</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;%d&#123;yyyy-MM-dd &#x27;at&#x27; HH:mm:ss z&#125; [%t] %-5level %logger&#123;36&#125; %L %M - %msg%xEx%n&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span> <span class="attr">interval</span>=<span class="string">&quot;6&quot;</span> <span class="attr">modulate</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">&quot;$&#123;splitSize&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Filters</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 只记录error级别信息 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">&quot;error&quot;</span> <span class="attr">onMatch</span>=<span class="string">&quot;ACCEPT&quot;</span> <span class="attr">onMismatch</span>=<span class="string">&quot;DENY&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Filters</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 指定每天的最大压缩包个数，默认7个，超过了会覆盖之前的 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">&quot;50&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">RollingRandomAccessFile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- root logger 配置,全局配置，默认所有的Logger都继承此配置 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- AsyncRoot - 异步记录日志 - 需要LMAX Disruptor的支持 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Root</span> <span class="attr">includeLocation</span>=<span class="string">&quot;true&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;infoLog&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;errorLog&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;console&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--第三方的软件日志级别 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.springframework&quot;</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>Appenders</strong>：定义日志输出目的地，内容和格式等。<br>上文中使用了三个appender： concole,infolog,errorlog<ul><li><strong>console</strong> 通过ThresholdFilter过滤规则只输出info级别的错误(onMatch=”ACCEPT” onMismatch=”DENY” 匹配到的接受，没有匹配的走人)</li><li><strong>infoLog</strong> 也通过ThresholdFilter的方式输出到日志，当然了append=”true” 会在服务每次启动的时候追加日志</li></ul></li><li><strong>Loggers</strong>：定义日志级别和使用的Appenders。</li></ul><h4 id="status和monitorInterval含义"><a href="#status和monitorInterval含义" class="headerlink" title="status和monitorInterval含义"></a>status和monitorInterval含义</h4><ul><li><strong>status</strong>: log4j2自身组件的日志级别,配置status可以看到log4j2相关的日志</li><li><strong>monitorInterval</strong>: 重新刷新配置文件的时间,配置monitorInterval可以通过修改配置文件来改变日志配置</li></ul><p>要打印日志，只需要按Commons Logging的写法写，不需要改动任何代码，就可以得到Log4j的日志输出，类似:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">03</span>-<span class="number">03</span> <span class="number">12</span>:<span class="number">09</span>:<span class="number">45.880</span> [main] INFO  com.itranswarp.learnjava.Main</span><br><span class="line">Start process...</span><br></pre></td></tr></table></figure><h2 id="SLF4J-和-Logback"><a href="#SLF4J-和-Logback" class="headerlink" title="SLF4J 和 Logback"></a>SLF4J 和 Logback</h2><p>SLF4J类似于Commons Logging，也是一个日志接口，而Logback类似于Log4j2，是一个日志的实现，而logback的日志级别和log4j2一致</p><blockquote><p>图片来自<a href="https://www.jianshu.com/p/da1c9e1e13ea">复杂Spring项目中SLF4J最佳使用姿势</a></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200809221458.png" alt="20200809221458"></p><h3 id="SLF4J"><a href="#SLF4J" class="headerlink" title="SLF4J"></a>SLF4J</h3><blockquote><p>示例来自<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1264739155914176">廖雪峰的官方网站</a></p></blockquote><p>在Commons Logging中，拼接字符串如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> score = <span class="number">99</span>;</span><br><span class="line">p.setScore(score);</span><br><span class="line">log.info(<span class="string">&quot;Set score &quot;</span> + score + <span class="string">&quot; for Person &quot;</span> + p.getName() + <span class="string">&quot; ok.&quot;</span>);</span><br></pre></td></tr></table></figure><p>在SLF4J中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> score = <span class="number">99</span>;</span><br><span class="line">p.setScore(score);</span><br><span class="line">logger.info(<span class="string">&quot;Set score &#123;&#125; for Person &#123;&#125; ok.&quot;</span>, score, p.getName());</span><br></pre></td></tr></table></figure><p>SLF4J的日志接口传入的是一个带占位符的字符串，用后面的变量自动替换占位符。</p><p>使用SLF4J接口如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br></pre></td></tr></table></figure><p><code>Log</code>变成了<code>Logger</code>，<code>LogFactory</code>变成了<code>LoggerFactory</code>。</p><h3 id="使用SLF4J"><a href="#使用SLF4J" class="headerlink" title="使用SLF4J"></a>使用SLF4J</h3><blockquote><p><a href="http://www.slf4j.org/manual.html">SLF4J用户手册</a></p></blockquote><p>SpringBoot日志默认就是slf4j+logback，所以不需要引入相关依赖，可以直接使用</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200819171852.png" alt="20200819171852"><br>每一个日志的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架自己本身的配置文件</p><h4 id="引入包"><a href="#引入包" class="headerlink" title="引入包"></a>引入包</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Logger logger = LoggerFactory.getLogger(getClass());</span><br></pre></td></tr></table></figure><p>使用Lombok引入包的方法：</p><p>使用Lombok可以避免每次都是定义logger</p><ol><li><p>在idea插件市场中下载Lombok</p></li><li><p>引入Lombok依赖：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>类上添加<code>@Slf4j</code>注解</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">LogController</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="配置log级别"><a href="#配置log级别" class="headerlink" title="配置log级别"></a>配置log级别</h4><p>在<code>application.properties</code>文件添加</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">logging.level.com.demo.course.mapper</span> = <span class="string">trace</span></span><br></pre></td></tr></table></figure><p>即定义com.demo.course.mapper中的日志级别为trace，用于调试，实际部署修改为error即可。</p><p>也可以自定义logback配置,在resources目录下创建<code>logback-spring.xml</code>文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">debug</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义日志文件的存储地址 勿在 LogBack 的配置中使用相对路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;LOG_HOME&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/HL/IdeaProjects/SpringBoot-Item/springboot-slf4j/log&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义日志格式  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;LOG_PATTERN&quot;</span> <span class="attr">value</span>=<span class="string">&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%-5level] [%thread] [%-30.30logger&#123;30&#125;] %msg%n&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 控制台输出 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 按照每天生成日志文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--日志文件输出的文件名--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">FileNamePattern</span>&gt;</span>$&#123;LOG_HOME&#125;/SpringBoot-Slf4j_%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">FileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--日志文件保留天数--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">MaxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">MaxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--日志文件最大的大小--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">triggeringPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">MaxFileSize</span>&gt;</span>10MB<span class="tag">&lt;/<span class="name">MaxFileSize</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">triggeringPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 日志输出级别 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.springframework&quot;</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.hl.magic&quot;</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="使用log打印日志"><a href="#使用log打印日志" class="headerlink" title="使用log打印日志"></a>使用log打印日志</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">FileController</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String SLF4J = <span class="string">&quot;SLF4J&quot;</span>;</span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125;&quot;</span>,SLF4J);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200809223549.png" alt="20200809223549"></p><h2 id="统一日志级别"><a href="#统一日志级别" class="headerlink" title="统一日志级别"></a>统一日志级别</h2><p>在实际开发中情况会更复杂一些，例子:<br>在开发a系统的时候用的是(slf4j+logback),系统中需要用到Spring(commons-logging),hibernate(（jboss-logging),mybatis等等,这些框架底层中又自带了日志记录,现在想统一使用slf4j日志<br>图示</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200819173009.png" alt="20200819173009"></p><p>从图中可以看出：官方的方案是针对不同的日志框架，开发了一套适配兼容的框架与之对应，使用这些兼容jar来替代原来的日志框架即可，例如log4j日志框架，与之对应的就是log4j-over-slf4j.jar，并且常见的日志框架，slf4j团队都实现了一套与之对应的基于slf4j的兼容框架，关系如下:</p><table><thead><tr><th align="center">日志框架</th><th align="center">slf4j兼容框架</th></tr></thead><tbody><tr><td align="center">log4j</td><td align="center">log4j-over-slf4j</td></tr><tr><td align="center">commons logging</td><td align="center">jcl-over-slf4j</td></tr><tr><td align="center">java.util.logging</td><td align="center">jui-to-slf4j</td></tr></tbody></table><h2 id="自定义配置文件"><a href="#自定义配置文件" class="headerlink" title="自定义配置文件"></a>自定义配置文件</h2><p><a href="https://docs.spring.io/spring-boot/docs/2.0.6.RELEASE/reference/htmlsingle/#boot-features-logging-format">官方文档</a></p><p>如果我们想要用springboot的日志高级功能,比如异步日志,自动归档等,我们需要自己写配置文件，而自定义配置文件的内容上面已经介绍了。这里讲一下配置文件名的设置。</p><p>之前在类路径(resources文件夹)下放上每个日志框架自己的配置文件，SpringBoot就不使用默认配置的文件，而适用我们定义的<code>logback-spring.xml</code>文件</p><p>名字有两种:</p><ul><li><code>logback.xml</code>：会直接就被日志框架识别,相当于绕过了springboot；</li><li><code>logback-spring.xml</code>：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能</li></ul><p>logback-spring.xml这种写法的好处是可以使用springProfile标签，即根据不同环境设置不同配置。<br>例如：设置开发环境的警告级别为trace，生产环境的警告级别为error。这样只需要修改环境而不需要修改配置文件。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;springProfile name=<span class="string">&quot;dev&quot;</span>&gt;</span><br><span class="line">&lt;!‐‐ configuration to be enabled when the <span class="string">&quot;staging&quot;</span> profile is active</span><br><span class="line">指定这段配置只在dev环境下生效--&gt;</span><br><span class="line">&lt;pattern&gt;%d&#123;yyyy‐MM‐dd HH:mm:ss.SSS&#125; ‐‐‐‐&gt; [%thread] ‐‐‐&gt; %‐<span class="number">5l</span>evel</span><br><span class="line">%logger&#123;50&#125; ‐ %msg%n&lt;/pattern&gt;</span><br><span class="line">&lt;/springProfile&gt;</span><br><span class="line"></span><br><span class="line">&lt;springProfile name=<span class="string">&quot;!dev&quot;</span>&gt;</span><br><span class="line">&lt;pattern&gt;%d&#123;yyyy‐MM‐dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %‐<span class="number">5l</span>evel</span><br><span class="line">%logger&#123;50&#125; ‐ %msg%n&lt;/pattern&gt;</span><br><span class="line">&lt;/springProfile&gt;</span><br></pre></td></tr></table></figure><p>其他日志名为：<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200819175448.png" alt="20200819175448"></p><h2 id="SpringBoot中使用Log4j2"><a href="#SpringBoot中使用Log4j2" class="headerlink" title="SpringBoot中使用Log4j2"></a>SpringBoot中使用Log4j2</h2><p>如上所说，SpringBoot默认使用logback，所以使用Log4j2需要先排除默认日志依赖，再添加log4j依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在配置文件<code>application.properties</code>中添加</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">logging.level.root</span>=<span class="string">error</span></span><br></pre></td></tr></table></figure><p>同样也自定义log4j2-spring.xml文件，内容同之前一样。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ul><li>Java核心技术</li><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1264738568571776">廖雪峰的官方网站</a></li><li><a href="https://www.jianshu.com/p/04962e1fb491">Java 进阶 &amp; commons-logging与log4j2结合使用实例</a></li><li><a href="https://blog.csdn.net/qq_27706119/article/details/104977666#4%E3%80%81logback.xml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%AE%9A%E4%B9%89">SpringBoot系列(6)：SpringBoot集成slf4j日志配置</a></li><li><a href="https://www.jianshu.com/p/46b530446d20">SpringBoot + Log4j2使用配置</a></li><li><a href="https://blog.csdn.net/qq_27706119/article/details/104977666#3%E3%80%81application.yml%E7%9A%84%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE">SpringBoot系列(6)：SpringBoot集成slf4j日志配置</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot自动配置</title>
      <link href="blog/2bea20dc/"/>
      <url>blog/2bea20dc/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>Spring Boot的出现，得益于“约定大于配置”的理念，没有繁琐的配置、难以集成的内容（大多数流行第三方技术都被集成），这是基于Spring 4.x提供的按条件配置Bean的能力。</p><p>自动配置作为SpringBoot的精髓，不仅仅是“面试”中会问到自动配置的原理，如果能理解自动配置的原理，将无往不利。</p><blockquote><p>本文使用SpringBoot版本为：2.3.3</p></blockquote><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><h3 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h3><p>首先，我们都知道SpringBoot项目运行标记  <code>@SpringBootApplication</code> 注解的类 的main方法来启动SpringBoot应用，那么从这里开始着手</p><blockquote><p>@SpringBootApplication: Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用。</p></blockquote><p>在xxxApplication.java文件中查看<code>@SpringBootApplication</code>注解（按住ctrl+点击注解）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SpringBootApplicaion.class</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">    excludeFilters = &#123;@Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;TypeExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">), @Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">)&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>@SpringBootConfiguration</code>：Spring Boot的配置类。<ul><li>标注在某个类上，表示这是一个Spring Boot的配置类。<ul><li>里面有<code>@Configuration</code>：配置类上标注这个注解。<br>配置类就相当于配置文件，配置类也是容器中的一个组件。<code>@Configuration</code>的底层也是<code>@Component</code></li></ul></li></ul></li><li><code>@ComponentScan</code>：自动扫描，这里搭配excludeFilters表示跳过扫描<ul><li>excludeFilters参考<a href="https://docs.spring.io/spring-boot/docs/current/api/">官方API</a></li></ul></li><li><code>@EnableAutoConfiguration</code>：开启自动配置功能，明显这就是自动配置的重点，查看这个注解。</li></ul><h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p>这个注解也是一个派生注解，@AutoConfigurationPackage和@Import提供了自动配置功能。</p><p>其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EnableAutoConfiguration.class</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h4><p><code>@AutoConfigurationPackage</code>： 自动配置包，查看其定义，可以看到导入了一个Registrar类。</p><p>@Import({Registrar.class}):Spring的底层注解@Import，给容器中导入一个组件；导入的组件由Registrar.class指定</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200819104946.png" alt="20200819104946"></p><p>查看Registrar类，有个registerBeanDefinitions方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Registrar.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    AutoConfigurationPackages.register(registry, (String[])(<span class="keyword">new</span> AutoConfigurationPackages.PackageImports(metadata)).getPackageNames().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>registerBeanDefinitions</strong>：获取bean的定义</p><ul><li>参数一：metadata：获取启动类信息，即获取该类所在包（<code>@SpringBootApplication</code>标记的类所在包）。</li><li>参数二：registry：bean注册。</li></ul><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>从上述内容中我们可以得出结论：<code>@AutoConfigurationPackage</code>的作用就是将<strong>主配置类</strong>（@SpringBootApplication标注的类）的<strong>所在包及下面所有子包</strong>里面的所有组件扫描到Spring容器。</p><h4 id="Import-AutoConfigurationImportSelector-class"><a href="#Import-AutoConfigurationImportSelector-class" class="headerlink" title="@Import({AutoConfigurationImportSelector.class})"></a>@Import({AutoConfigurationImportSelector.class})</h4><p>这是自动配置的重点，精髓就在这里，首先查看AutoConfigurationImportSelector类，这个类是配置选择器，将所有需要导入的组件以全类名的方式返回，这些组件就会被添加到容器中。会给容器中导入非常多的自动配置类（xxxAutoConfiguration）。</p><p>可以看到一个<code>selectImports()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AutoConfigurationImportSelector.class</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = <span class="keyword">this</span>.getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line">        <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200819110903.png" alt="20200819110903"></p><p>如上，这方法的返回值是调用<code>getAutoConfigurationEntry()</code>方法的结果-配置项信息，这个方法就在<code>selectImports()</code>方法下方，定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> AutoConfigurationImportSelector.<span class="function">AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        AnnotationAttributes attributes = <span class="keyword">this</span>.getAttributes(annotationMetadata);</span><br><span class="line">        List&lt;String&gt; configurations = <span class="keyword">this</span>.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">        configurations = <span class="keyword">this</span>.removeDuplicates(configurations);</span><br><span class="line">        Set&lt;String&gt; exclusions = <span class="keyword">this</span>.getExclusions(annotationMetadata, attributes);</span><br><span class="line">        <span class="keyword">this</span>.checkExcludedClasses(configurations, exclusions);</span><br><span class="line">        configurations.removeAll(exclusions);</span><br><span class="line">        configurations = <span class="keyword">this</span>.getConfigurationClassFilter().filter(configurations);</span><br><span class="line">        <span class="keyword">this</span>.fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200819111252.png" alt="20200819111252"></p><p>这行代码返回的是已申请即将导入容器的配置项信息集合，进入<code>getCandidateConfigurations()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(<span class="keyword">this</span>.getSpringFactoriesLoaderFactoryClass(), <span class="keyword">this</span>.getBeanClassLoader());</span><br><span class="line">    Assert.notEmpty(configurations, <span class="string">&quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一行断言：No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.</p><p>谷歌翻译：在META-INF / spring.factories中找不到自动配置类。如果使用的是自定义包装，请确保该文件正确。</p><p>可以知道是从META-INF / spring.factories找到配置类。</p><p>然后进入loadFactoryNames()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryType, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取一个传进来的Class的全路径</span></span><br><span class="line">    String factoryTypeName = factoryType.getName();</span><br><span class="line">    <span class="keyword">return</span> (List)loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体细节在<code>loadSpringFactories()</code>方法中，该方法就在下方。</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200819111817.png" alt="20200819111817"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line">    MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Enumeration&lt;URL&gt; urls = classLoader != <span class="keyword">null</span> ? classLoader.getResources(<span class="string">&quot;META-INF/spring.factories&quot;</span>) : ClassLoader.getSystemResources(<span class="string">&quot;META-INF/spring.factories&quot;</span>);</span><br><span class="line">            LinkedMultiValueMap result = <span class="keyword">new</span> LinkedMultiValueMap();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(urls.hasMoreElements()) &#123;</span><br><span class="line">                URL url = (URL)urls.nextElement();</span><br><span class="line">                UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">                Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">                Iterator var6 = properties.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(var6.hasNext()) &#123;</span><br><span class="line">                    Entry&lt;?, ?&gt; entry = (Entry)var6.next();</span><br><span class="line">                    String factoryTypeName = ((String)entry.getKey()).trim();</span><br><span class="line">                    String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue());</span><br><span class="line">                    <span class="keyword">int</span> var10 = var9.length;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> var11 = <span class="number">0</span>; var11 &lt; var10; ++var11) &#123;</span><br><span class="line">                        String factoryImplementationName = var9[var11];</span><br><span class="line">                        result.add(factoryTypeName, factoryImplementationName.trim());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cache.put(classLoader, result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var13) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unable to load factories from location [META-INF/spring.factories]&quot;</span>, var13);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200819112033.png" alt="20200819112033"></p><p>从 “META-INF/spring.factories” 中获取资源，这与之前那句断言相对应。</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200819112148.png" alt="20200819112148"></p><p>spring.factories位置如上，在<code>libraries的Maven: org.springframework.boot: spring-boot-autoconfigure.2.3.3.RELEASE下spring-boot-autoconfigure-2.3.3.RELEASE.jar!</code>文件夹的META-INF中</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200819112439.png" alt="20200819112439"></p><p>截取一段内容如上。</p><p>继续看loadSpringFactories()方法。</p><ul><li>在外层while中会将文件数据转换成URL，然后将URL装换成Properties，Properties是一个Hashtable，最终配置文件中的数据将以key-value的形式存在Properties中的entry中，如下所示：</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200819112653.png" alt="20200819112653"></p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200819112722.png" alt="20200819112722"></p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200819113147.png" alt="20200819113147"></p><ul><li><p>内层的while循环其实就是对Properties进行遍历，获取key，获取value，并且会将value的值按逗号分隔获取具体的每一个String，然后将这些数据存入result这个Map中。</p><table><thead><tr><th align="left">key</th><th align="left">value</th></tr></thead><tbody><tr><td align="left">org.springframework.context.ApplicationContextInitializer</td><td align="left">org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer</td></tr><tr><td align="left">org.springframework.context.ApplicationContextInitializer</td><td align="left">org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</td></tr><tr><td align="left">org.springframework.context.ApplicationListener</td><td align="left">org.springframework.boot.autoconfigure.BackgroundPreinitializer</td></tr></tbody></table></li><li><p>最后返回该保存了所有配置项信息的map，回到loadFactoryNames（）方法</p></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200819111817.png" alt="20200819111817"></p><p>getOrDefault(…)方法是map的方法，用来判断当前map中是否包指定的key，有则返回对应的数据,这个key就是loadFactoryNames()第一个参数的某个Class的全路径名，往回loadFactoryNames方法上一层看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200819114047.png" alt="20200819114047"></p><p>如图中所示，传进来的就是EnableAutoConfiguration，那自然这个key就是EnableAutoConfiguration的全路径，也就是会拿到配置文件(spring.factories)中EnableAutoConfiguration所对应的数据</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200819114237.png" alt="20200819114237"></p><p>这就是自动配置的配置的组件内容了。</p><h3 id="自动配置原理总结"><a href="#自动配置原理总结" class="headerlink" title="自动配置原理总结"></a>自动配置原理总结</h3><ol><li>SpringBoot启动的时候加载主配置类，开启了自动配置功能 <code>@EnableAutoConfiguration</code>注解</li><li>@EnableAutoConfiguration的作用：<ol><li>利用<code>@Import(&#123;AutoConfigurationImportSelector.class&#125;)</code>给容器中导入一些组件</li><li>查看<code>AutoConfigurationImportSelector</code>类中的<code>selectImports</code>方法</li><li>查看<code>selectImports</code>方法调用的<code>getAutoConfigurationEntry</code>方法</li><li>发现通过方法中的<code>List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes)</code>;获取候选的配置</li><li>查看<code>getCandidateConfigurations</code>方法，这个方法返回<code>loadFactoryNames</code>方法的返回值</li><li>查看<code>loadFactoryNames</code>方法，发现返回<code>loadSpringFactories</code>返回后通过<code>getOrDefault</code>筛选的值</li><li><code>loadSpringFactories</code>方法中扫描META-INF/spirng.factories文件内容，将文件中的数据转换成URL，然后将URL装换成Properties，最后对Properties进行遍历，处理数据并存入result这个map中</li><li>通过<code>getOrDefault</code>返回<code>EnableAutoConfiguration.class</code>类（类名）对应的值，然后把他们添加在容器中</li></ol></li></ol><p>总结起来就是:</p><ol><li>将类路径下 META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；</li><li>每一个这样的 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中，用他们来做自动配置。</li><li>每一个自动配置类进行自动配置功能</li></ol><h3 id="自动配置类进行自动配置示例"><a href="#自动配置类进行自动配置示例" class="headerlink" title="自动配置类进行自动配置示例"></a>自动配置类进行自动配置示例</h3><p>以<code>HttpEncodingAutoConfiguration</code>（Http编码自动配置）为例解释自动配置原理:</p><p>idea中双击shift搜索<code>HttpEncodingAutoConfiguration</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(</span></span><br><span class="line"><span class="meta">    proxyBeanMethods = false</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="comment">// 表示这是一个配置类，和以前编写的配置文件一样，也可以给容器中添加组件</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;ServerProperties.class&#125;)</span></span><br><span class="line"><span class="comment">// 启动指定类的ConfigurationProperties功能；将配置文件中对应的值和ServerProperties绑定起来；并把ServerProperties加入到ioc容器中</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(</span></span><br><span class="line"><span class="meta">    type = Type.SERVLET</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="comment">// Spring底层@Conditional注解，根据不同条件判断是否生效。</span></span><br><span class="line"><span class="comment">// 例如当前注解：判断当前应用是否是web应用，如果时，配置类生效。</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;)</span></span><br><span class="line"><span class="comment">// 判断当前项目有没有CharacterEncodingFilter这个类</span></span><br><span class="line"><span class="comment">// CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(</span></span><br><span class="line"><span class="meta">    prefix = &quot;server.servlet.encoding&quot;,</span></span><br><span class="line"><span class="meta">    value = &#123;&quot;enabled&quot;&#125;,</span></span><br><span class="line"><span class="meta">    matchIfMissing = true</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="comment">// 判断配置文件中是否存在某个配置 spring.http.encoding.enabled；matchIfMissing = true代表如果不存在，判断也是成立的</span></span><br><span class="line"><span class="comment">// 即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已经和SpringBoot的配置文件映射了(EnableConfigurationProperties)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HttpEncodingProperties properties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有一个有参构造器的情况下，参数的值就会从ioc容器中拿</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpEncodingAutoConfiguration</span><span class="params">(HttpEncodingProperties properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给容器中添加一个组件，这个组件的某些值需要从properties中获取</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">// 判断容器中有没有这个组件,没有才配</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CharacterEncodingFilter <span class="title">characterEncodingFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CharacterEncodingFilter filter = <span class="keyword">new</span> OrderedCharacterEncodingFilter();</span><br><span class="line">        filter.setEncoding(<span class="keyword">this</span>.properties.getCharset().name());</span><br><span class="line">        filter.setForceRequestEncoding(<span class="keyword">this</span>.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpEncodingProperties.Type.REQUEST));</span><br><span class="line">        filter.setForceResponseEncoding(<span class="keyword">this</span>.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpEncodingProperties.Type.RESPONSE));</span><br><span class="line">        <span class="keyword">return</span> filter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(</span></span><br><span class="line"><span class="meta">    prefix = &quot;server&quot;,</span></span><br><span class="line"><span class="meta">    ignoreUnknownFields = true</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="comment">// 从配置文件中获取指定的值和bean的属性进行绑定</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer port;</span><br><span class="line">    <span class="keyword">private</span> InetAddress address;</span><br><span class="line">    <span class="meta">@NestedConfigurationProperty</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ErrorProperties error = <span class="keyword">new</span> ErrorProperties();</span><br><span class="line">    <span class="keyword">private</span> ServerProperties.ForwardHeadersStrategy forwardHeadersStrategy;</span><br><span class="line">    <span class="keyword">private</span> String serverHeader;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些注解根据当前不同的条件判断，决定这个配置类是否生效</p><p>一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；</p><p>配置tomcat接口就是一个应用</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.post</span> = <span class="string">8081</span></span><br></pre></td></tr></table></figure><p>所有在配置文件中能配置的属性都是在xxxxProperties类中封装着，配置文件能配置什么就可以参照某个功能对应的这个属性类</p><p>xxxxAutoConfigurartion：自动配置类,作用是给容器中添加组件<br>xxxxProperties:作用是封装配置文件中的相关属性；</p><p>SpringBoot重点：</p><ol><li><strong>SpringBoot启动会加载大量配置类</strong></li><li><strong>编写时看需要的功能有没有默认写好的自动配置类</strong></li><li><strong>再看这个自动配置类写了哪些组件（有需要的组件，就不要配置了）</strong></li><li><strong>给容器中自动配置类添加组件的时候，会从properties类中获取某些属性，可以在配置文件中指定这些属性的值</strong></li></ol><h2 id="Conditional派生注解"><a href="#Conditional派生注解" class="headerlink" title="@Conditional派生注解"></a>@Conditional派生注解</h2><p>自动配置类必须在一定的条件下才能生效的条件靠@Conditional派生注解来判断</p><table><thead><tr><th align="left">@Conditional扩展注解</th><th align="left">作用（判断是否满足当前指定条件）</th></tr></thead><tbody><tr><td align="left">@ConditionalOnJava</td><td align="left">系统的java版本是否符合要求</td></tr><tr><td align="left">@ConditionalOnBean</td><td align="left">容器中存在指定Bean</td></tr><tr><td align="left">@ConditionalOnMissingBean</td><td align="left">容器中不存在指定Bean</td></tr><tr><td align="left">@ConditionalOnExpression</td><td align="left">满足SpEL表达式指定</td></tr><tr><td align="left">@ConditionalOnClass</td><td align="left">系统中有指定的类</td></tr><tr><td align="left">@ConditionalOnMissingClass</td><td align="left">系统中没有指定的类</td></tr><tr><td align="left">@ConditionalOnSingleCandidate</td><td align="left">容器中只有一个指定的Bean，或者这个Bean是首选Bean</td></tr><tr><td align="left">@ConditionalOnProperty</td><td align="left">系统中指定的属性是否有指定的值</td></tr><tr><td align="left">@ConditionalOnResource</td><td align="left">类路径下是否存在指定资源文件</td></tr><tr><td align="left">@ConditionalOnWebApplication</td><td align="left">当前是web环境</td></tr><tr><td align="left">@ConditionalOnNotWebApplication</td><td align="left">当前不是web环境</td></tr><tr><td align="left">@ConditionalOnJndi</td><td align="left">JNDI存在指定项</td></tr></tbody></table><h2 id="打印配置报告"><a href="#打印配置报告" class="headerlink" title="打印配置报告"></a>打印配置报告</h2><p>我们可以通过启用 debug=true属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效没生效了；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debug=<span class="keyword">true</span></span><br></pre></td></tr></table></figure><p>添加配置后运行项目就可以在配置台看到配置报告</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200819125947.png" alt="20200819125947"></p><p>报告中：</p><ul><li>CONDITIONS EVALUATION REPORT：自动配置报告</li><li>Positive matches：自动配置类启用的</li><li>Negative matches：没有启动，没有匹配成功的自动配置类</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ul><li><a href="https://www.bilibili.com/video/BV1gW411W76m?p=17">尚硅谷SpringBoot教程</a></li><li><a href="https://blog.csdn.net/qq_34975710/article/details/87898620">SpringBoot-2.1.3自动配置原理</a></li></ul></blockquote><a class="btn-beautify button--animated block blue right" href="https://www.shiming.online/blog/20547/"   title="SpringBoot+MyBatis+Druid"><i class="far fa-hand-point-right fa-fw"></i><span>SpringBoot+MyBatis+Druid</span></a>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 开发 </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot基础</title>
      <link href="blog/a8fdf5f8/"/>
      <url>blog/a8fdf5f8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="SpringBoot简介"><a href="#SpringBoot简介" class="headerlink" title="SpringBoot简介"></a>SpringBoot简介</h2><p>SpringBoot是一种全新的框架，目的是为了简化Spring应用的初始搭建以及开发过程。该框架使用特定的方式(集成starter，约定大于配置)来进行配置，从而使开发人员不需要再定义样板化的配置。SpringBoot提供了一种新的编程范式，可以更加快速便捷地开发Spring项目，在开发过程当中可以专注于应用程序本身的功能开发，而无需在Spring配置上花太大的工夫。</p><p>SpringBoot基于Sring4进行设计，继承了原有Spring框架的优秀基因。SpringBoot并不是一个框架，而是一些类库的集合。maven或者gradle项目导入相应依赖即可使用SpringBoot，而无需自行管理这些类库的版本。</p><blockquote><p>简化Spring应用开发的框架<br>整个Spring应用技术栈的大整合<br>J2EE开发的一站式解决方案</p></blockquote><h3 id="SpringBoot优缺点"><a href="#SpringBoot优缺点" class="headerlink" title="SpringBoot优缺点"></a>SpringBoot优缺点</h3><p>优点：</p><ul><li>快速构建独立运行的Spring项目以及与主流框架的继承。</li><li>使用嵌入式的Servlet容器，应用无需达成war包。</li><li>starters自动依赖和版本控制</li><li>大量的自动配置，简化开发，也可修改默认值</li><li>无需配置xml，无代码生成</li><li>准生产环境的运行时应用监控</li><li>与云计算的天然集成。</li></ul><p>缺点：</p><ul><li>版本迭代速度很快，一些模块改动很大。</li><li>由于不用自己做配置，报错时很难定位。</li><li>网上现成的解决方案比较少。</li></ul><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><blockquote><p>引用ThoughtWorks 公司的首席科学家 Martin Fowler <a href="https://martinfowler.com/articles/microservices.html">Microservices</a> 文中的介绍</p></blockquote><p>In short, the microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies.</p><p>谷歌翻译如下：</p><p>简而言之，微服务架构样式是一种将单个应用程序开发为一组小服务的方法，每个小服务都在自己的进程中运行并与轻量级机制（通常是HTTP资源API）进行通信。这些服务围绕业务功能构建，并且可以由全自动部署机制独立部署。这些服务的集中管理几乎没有，可以用不同的编程语言编写并使用不同的数据存储技术。</p><p>单体架构和微服务：</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200818212922.png" alt="20200818212922"></p><p>微服务架构风格中以构建一组小型服务的方式来构建应用系统。这些服务除了能被独立地部署和扩展之外，每一个服务还能提供一个稳固的模块边界，甚至能允许使用不同的编程语言来编写不同的服务。这些服务也能被不同的团队来管理。</p><p>每一个功能元素最终都是一个可独立替换和独立升级的软件单元</p><blockquote><p>具体参考 <a href="https://martinfowler.com/articles/microservices.html">Microservices</a></p></blockquote><h3 id="Hello-World-（快速开始）"><a href="#Hello-World-（快速开始）" class="headerlink" title="Hello World （快速开始）"></a>Hello World （快速开始）</h3><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200807222127.png" alt="创建项目"><br>填写项目的Group，Artifact信息<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200807222145.png" alt="填写信息"></p><p>选择Web中的Spring Web依赖</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200818213733.png" alt="20200818213733"></p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200818213759.png" alt="20200818213759"></p><p>创建controller文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动项目</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200818214157.png" alt="20200818214157"></p><p>能在控制台看见tomcat启动信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tomcat started on port(s): 8080 (http) with context path <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>浏览器中进入<code>localhost:8080/hello</code>，可以看到网页显示<code>hello world</code>。</p><h3 id="项目探究"><a href="#项目探究" class="headerlink" title="项目探究"></a>项目探究</h3><h4 id="POM文件"><a href="#POM文件" class="headerlink" title="POM文件"></a>POM文件</h4><h5 id="父项目"><a href="#父项目" class="headerlink" title="父项目"></a>父项目</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 它的父项目 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 它来真正管理Spring Boot应用里面的所有依赖版本 --&gt;</span></span><br></pre></td></tr></table></figure><p>SpringBoot的版本仲裁中心：</p><p>导入依赖默认不需要写版本（dependencies中未配置的依赖除外）</p><h5 id="导入的依赖"><a href="#导入的依赖" class="headerlink" title="导入的依赖"></a>导入的依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- web模块正常运行组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 单元测试 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>spring-boot-starter</strong>：</p><p>Spring Boot 将所有的功能场景都抽取出来，做成一个个的starter（启动器），只需要在项目中引入starter，相关场景的所有依赖都会导入进来。</p><h2 id="Spring-Boot配置"><a href="#Spring-Boot配置" class="headerlink" title="Spring Boot配置"></a>Spring Boot配置</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>SpringBoot使用一个全局的配置文件，配置文件名固定：</p><ul><li>application.properties</li><li>application.yml</li></ul><p>配置文件能修改SpringBoot自动配置的默认值</p><h3 id="YAML"><a href="#YAML" class="headerlink" title="YAML"></a>YAML</h3><p><a href="https://baike.baidu.com/item/YAML/1067697">YAML</a>是”YAML Ain’t a Markup Language”（YAML不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：”Yet Another Markup Language”（仍是一种标记语言），但为了强调这种语言以数据作为中心，而不是以标记语言为重点，而用反向缩略语重命名。</p><p>YAML是一个可读性高，用来表达数据序列化的格式。比xml,json更适合配置文件</p><p>代码示例：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.yml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改tomat端口为8081</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>基本语法：</p><ul><li>大小写敏感（属性和值）</li><li>使用缩进表示层级关系</li><li>缩进不允许使用tab，只允许空格</li><li>缩进的空格数不重要，只要相同层级的元素左对齐即可</li><li>‘#’表示注释</li></ul><p>数据类型：</p><ul><li><p>对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）<br>K:V(键值对形式):</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">friends:</span></span><br><span class="line">  <span class="attr">lastName:</span> <span class="string">zhangsan</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><p>行内形式：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">friends:</span> &#123;<span class="attr">lastName:</span> <span class="string">zhangsan</span>, <span class="attr">age:</span> <span class="number">19</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>数组：一组按次序排列的值，又称为序列（sequence） / 列表（list）<br>用 <code>-</code>表示数组中的一个元素</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pets:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">dog</span></span><br></pre></td></tr></table></figure><p>行内写法：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pets:</span> [<span class="string">cat</span>,<span class="string">dog</span>,<span class="string">pig</span>]</span><br></pre></td></tr></table></figure></li><li><p>纯量（scalars）：单个的、不可再分的值<br>字符串默认不用加上单引号或双引号，<br>“”：双引号，不会转移字符串内的特殊字符，特殊字符会作为本身的意思</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;zhangsan \n lisi&quot;</span> <span class="comment"># 输出: zhangsan 换行 lisi</span></span><br></pre></td></tr></table></figure><p>‘’：单引号，会转移字符，特殊符号最终只是一个普通的字符串数据</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;zhangsan \n lisi&quot;</span> <span class="comment"># 输出: zhangsan \n lisi</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="获取YAML文件值"><a href="#获取YAML文件值" class="headerlink" title="获取YAML文件值"></a>获取YAML文件值</h4><p>为什么从YAML中获取值：例：公司需要设置一个url作为某个某个方法的参数（例如下载地址，网页地址），将这个url值设置在配置文件中不仅方便调用，还方便修改。</p><h5 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h5><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>application.yml中添加如下值</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line">  <span class="comment"># String</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">zhangsan</span></span><br><span class="line">  <span class="comment"># Integer</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">20</span></span><br><span class="line">  <span class="comment"># Boolean</span></span><br><span class="line">  <span class="attr">flag:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Date</span></span><br><span class="line">  <span class="attr">birth:</span> <span class="number">2000</span><span class="string">/1/1</span></span><br><span class="line">  <span class="comment"># Map</span></span><br><span class="line">  <span class="attr">maps:</span> &#123;<span class="attr">k1:</span> <span class="string">v1</span>, <span class="attr">k2:</span> <span class="string">v2</span>&#125;</span><br><span class="line">  <span class="comment"># List</span></span><br><span class="line">  <span class="attr">lists:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">lisi</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">wangwu</span></span><br><span class="line">  <span class="comment"># 对象</span></span><br><span class="line">  <span class="attr">dog:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">小狗</span></span><br></pre></td></tr></table></figure><p>创建person.java文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将配置文件中的值映射到这个组件中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ConfigurationProperties</span>：告诉Spring将本类中的所有属性和配置文件中相关的配置进行绑定</span></span><br><span class="line"><span class="comment"> *      prefix = &quot;person&quot;：配置文件中哪个对应的模块</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Component</span>:注册为容器组件，只有这样才能使用容器提供的<span class="doctag">@ConfigurationProperties</span>功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> List&lt;?&gt; lists;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">(<span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getBirth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> birth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirth</span><span class="params">(Date birth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birth = birth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getMaps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaps</span><span class="params">(Map&lt;String, Object&gt; maps)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maps = maps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;?&gt; getLists() &#123;</span><br><span class="line">        <span class="keyword">return</span> lists;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLists</span><span class="params">(List&lt;?&gt; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lists = lists;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dog <span class="title">getDog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDog</span><span class="params">(Dog dog)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dog = dog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, flag=&quot;</span> + flag +</span><br><span class="line">                <span class="string">&quot;, birth=&quot;</span> + birth +</span><br><span class="line">                <span class="string">&quot;, maps=&quot;</span> + maps +</span><br><span class="line">                <span class="string">&quot;, lists=&quot;</span> + lists +</span><br><span class="line">                <span class="string">&quot;, dog=&quot;</span> + dog +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Dog&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Person person;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(person);</span><br><span class="line">        <span class="comment">// Person&#123;name=&#x27;zhangsan&#x27;, age=20, flag=true, birth=Sat Jan 01 00:00:00 CST 2000, maps=&#123;k1=v1, k2=v2&#125;, lists=[lisi, wangwu], dog=Dog&#123;name=&#x27;小狗&#x27;&#125;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相同的配置也可以配置在application.properties中</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">person.name</span>=<span class="string">张三</span></span><br><span class="line"><span class="meta">person.age</span>=<span class="string">20</span></span><br><span class="line"><span class="meta">person.birth</span>=<span class="string">2000/1/1</span></span><br><span class="line"><span class="meta">person.flag</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">person.maps.k1</span>=<span class="string">v1</span></span><br><span class="line"><span class="meta">person.maps.k2</span>=<span class="string">90</span></span><br><span class="line"><span class="meta">person.lists</span>=<span class="string">a,b,c</span></span><br><span class="line"><span class="meta">person.dog.name</span>=<span class="string">小白</span></span><br></pre></td></tr></table></figure><h5 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h5><p>示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;person.name&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="meta">@Value(&quot;#&#123;2*10&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br><span class="line"><span class="meta">@Value(&quot;true&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> flag;</span><br><span class="line"><span class="meta">@Value(&quot;$&#123;person.birth&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Date birth;</span><br></pre></td></tr></table></figure><p>区别：</p><table><thead><tr><th align="center"></th><th align="center">@ConfigurationProperties</th><th align="center">@Value</th></tr></thead><tbody><tr><td align="center">功能</td><td align="center">批量注入配置文件中的属性</td><td align="center">单独指定</td></tr><tr><td align="center">松散绑定（松散语法）</td><td align="center">支持</td><td align="center">不支持</td></tr><tr><td align="center">SpEL</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">JSR303数据校验</td><td align="center">支持</td><td align="center">不支持</td></tr><tr><td align="center">复杂类型封装</td><td align="center">支持</td><td align="center">不支持</td></tr></tbody></table><ul><li>松散绑定是指驼峰式、下划线(_)、短横线(-)效果一致，都能转化为驼峰式<br>例：firstName == first-name == first_name 推荐：FIRST_NAME</li><li>SpEL使用<code>#&#123;..&#125;</code>作为定界符，所有在大括号中的字符都被认为是SpEL,SpEL为bean的属性动态赋值提供了便利</li><li>数据校验是指<code>@Email</code>或者``@Length(min = 5,max=20)这类校验</li><li>复杂类型是指map这种</li></ul><div class="note info flat"><p>如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用<code>@Value</code>；<br>如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用<code>@ConfigurationProperties</code>；</p></div><h5 id="PropertySource-amp-ImportResource"><a href="#PropertySource-amp-ImportResource" class="headerlink" title="@PropertySource&amp;@ImportResource"></a>@PropertySource&amp;@ImportResource</h5><p>@<strong>PropertySource</strong>：加载指定配置文件</p><p>新建person.properties文件<br>注意：将application.yml和application.properties中的值注释掉</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">person.name</span>=<span class="string">zhaoliu</span></span><br><span class="line"><span class="meta">person.age</span>=<span class="string">20</span></span><br><span class="line"><span class="meta">person.birth</span>=<span class="string">2000/1/1</span></span><br><span class="line"><span class="meta">person.flag</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">person.maps.k1</span>=<span class="string">v1</span></span><br><span class="line"><span class="meta">person.maps.k2</span>=<span class="string">90</span></span><br><span class="line"><span class="meta">person.lists</span>=<span class="string">a,b,c</span></span><br><span class="line"><span class="meta">person.dog.name</span>=<span class="string">xiaobai</span></span><br></pre></td></tr></table></figure><p>注解为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySource(value = &#123;&quot;classpath:person.properties&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span></span><br></pre></td></tr></table></figure><p>@<strong>ImportResource</strong>：导入Spring的配置文件（xml），让配置文件里面的内容生效。</p><p>创建TestController.java文件</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200818231900.png" alt="20200818231900"></p><p>新建test.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.hello.controller.TestController&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在application.java文件中添加@ImportResource注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ImportResource(&quot;classpath:test.xml&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApplication</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">ApplicationContext ioc;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> f = ioc.containsBean(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    System.out.println(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到输出结果为true。</p><p>而SpringBoot中提供另一个注解@Bean来简化这种配置</p><p>@Bean：<strong>SpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式</strong></p><p>配置类@Configuration——&gt;Spring配置文件,用配置类来代替配置文件</p><p>创建配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Configuration</span>:告诉SpringBoot当前类是一个配置类,就是替代spring配置文件的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在配置文件中用&lt;bean&gt;&lt;/bean&gt;添加组件,在配置类中用<span class="doctag">@Bean</span></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Bean</span>的作用是将方法的返回值添加到容器中,容器中这个组件默认的id就是方法名</span></span><br><span class="line"><span class="comment">     * 方法名：id</span></span><br><span class="line"><span class="comment">     * return： 组件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestController <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;添加组件&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestController();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释掉<code>application.java</code>中<code>@ImportResource(&quot;classpath:test.xml&quot;)</code>注解，再运行importResource的测试类。</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200818232725.png" alt="20200818232725"></p><h3 id="配置文件占位符"><a href="#配置文件占位符" class="headerlink" title="配置文件占位符"></a>配置文件占位符</h3><p>随机数：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">$&#123;random.value&#125;、$&#123;random.int&#125;、$&#123;random.long&#125;</span></span><br><span class="line"><span class="attr">$&#123;random.int(10)&#125;、$&#123;random.int[1024,65536]&#125;</span></span><br></pre></td></tr></table></figure><p>可以使用占位符获取之前的值，并设置没有值时的默认值</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200818233115.png" alt="20200818233115"></p><h3 id="Profile多环境支持"><a href="#Profile多环境支持" class="headerlink" title="Profile多环境支持"></a>Profile多环境支持</h3><p>Profile是Spring对不同环境提供不同配置功能的支持，可以通过激活、指定参数等方式快速切换环境（例：生产环境，测试环境，开发环境）</p><p>将主配置文件名设为：<code>application-&#123;profile&#125;.properties/yml</code></p><p>例：</p><p>新建<code>application-dev.properties</code>，<code>application-prod.properties</code></p><p>设置不同端口</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application=dev.properties</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8081</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application=prod.properties</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8082</span></span><br></pre></td></tr></table></figure><p>运行项目，可以看到默认情况下端口号为8080</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200818233912.png" alt="20200818233912"></p><p>然后在application.properties中设置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.profiles.active</span>=<span class="string">dev</span></span><br></pre></td></tr></table></figure><p>运行，可以看到端口号变为了8081</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200818234035.png" alt="20200818234035"></p><p>将dev修改为prod，运行，端口号为8082</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.profiles.active</span>=<span class="string">prod</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200818234114.png" alt="20200818234114"></p><h4 id="yml支持多文档模式"><a href="#yml支持多文档模式" class="headerlink" title="yml支持多文档模式"></a>yml支持多文档模式</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8082</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">prod</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8083</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">dev</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">prod</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8084</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>yml文件可以在application.yml中书写不同配置,用—分割</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200818234315.png" alt="20200818234315"></p><h4 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h4><p>命令行方式激活：</p><p>application设置中修改Program arguments为<code>--spring.profiles.active=dev</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200818234534.png" alt="20200818234534"></p><p>命令行指定的方式级别比配置文件指定的级别高,比如你在配置文件中制定了是prod环境端口是8082;但是运行时用命令行指定了dev环境端口号是8081,那么运行出来后端口号会是8081的。</p><p>也可以在启动jar包时设置激活方式：</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200818234718.png" alt="20200818234718"></p><p>虚拟机参数：</p><p><code>-Dspring.profiles.active=dev</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200818234831.png" alt="20200818234831"></p><h3 id="配置文件加载位置"><a href="#配置文件加载位置" class="headerlink" title="配置文件加载位置"></a>配置文件加载位置</h3><p>Spring Boot 启动会扫描以下位置的<code>application.properties</code>或者<br><code>application.yml</code>文件作为Spring boot的默认配置文件</p><ol><li>file:./config/:文件路径下的config文件夹</li><li>file:./:文件路径下</li><li>classpath:/config/:类路径下的config文件夹</li><li>classpath:/:类路径下</li></ol><p>从上到下扫描,1的优先级最高,4的最低,所有位置的文件都会被加载，高优先级配置内容会覆盖低优先级配置内容。比如说1和4都配置了端口号,会采用1的配置</p><p>SpringBoot会从这四个位置全部加载主配置文件,高优先级有的就用高优先级的配置,没有就用低优先级的配置,这样就形成了互补配置</p><h4 id="通过配置spring-config-location来改变默认配置"><a href="#通过配置spring-config-location来改变默认配置" class="headerlink" title="通过配置spring.config.location来改变默认配置"></a>通过配置spring.config.location来改变默认配置</h4><p>项目打包好以后，在后来运行的时候我们可能需要修改一些配置,我们这时候只需要编写好要修改的配置,然后让项目重新启动,使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；这样旧的配置文件和新的配置文件共同起作用形成互补配置；</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200818235635.png" alt="20200818235635"></p><h3 id="外部配置加载顺序"><a href="#外部配置加载顺序" class="headerlink" title="外部配置加载顺序"></a>外部配置加载顺序</h3><p><strong>SpringBoot也可以从以下位置加载配置； 优先级从高到低(1~11)；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置。</strong></p><ol><li><p>命令行参数<br> 所有的配置都可以在命令行上进行指定<br> 例如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar --server.port=8087 --server.context-path=/abc</span><br></pre></td></tr></table></figure><p>多个配置用空格分开； –配置项=值</p></li><li><p>来自java:comp/env的JNDI属性</p></li><li><p>Java系统属性（System.getProperties()）</p></li><li><p>操作系统环境变量</p></li><li><p>RandomValuePropertySource配置的random.*属性值</p> <div class="note info flat"><p>由jar包外 向jar包内进行寻找；<br>优先加载带profile的</p></div></li><li><p>jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件</p></li><li><p>jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件</p> <div class="note info flat"><p>再加载不带profile</p></div></li><li><p>jar包外部的application.properties或application.yml(不带spring.profile)配置文件</p></li><li><p>jar包内部的application.properties或application.yml(不带spring.profile)配置文件</p></li><li><p>@Configuration注解类上的@PropertySource</p></li><li><p>通过SpringApplication.setDefaultProperties指定的默认属性</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ul><li><a href="https://www.bilibili.com/video/BV1gW411W76m?p=17">尚硅谷SpringBoot教程</a></li><li><a href="https://www.jianshu.com/p/350972a3a258">SpringBoot简介</a></li><li><a href="https://martinfowler.com/articles/microservices.html">Microservices</a></li></ul></blockquote><a class="btn-beautify button--animated block blue right" href="https://www.shiming.online/blog/2bea20dc/"   title="SpringBoot自动配置"><i class="far fa-hand-point-right fa-fw"></i><span>SpringBoot自动配置</span></a>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面试题</title>
      <link href="blog/1491d7b8/"/>
      <url>blog/1491d7b8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>题目来自<a href="https://mp.weixin.qq.com/s/MXKACpJKLMxep5bXO3EHhw">Java 面试收到offer必备 208 道面试题</a><br>答案整合自原文和个人学习总结</p></blockquote><h2 id="第一模块：Java基础"><a href="#第一模块：Java基础" class="headerlink" title="第一模块：Java基础"></a>第一模块：Java基础</h2><p><a href="https://shiming.online/blog/40121/">Java基础</a></p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>1. JDK 和 JRE 有什么区别？</span></div>    <div class="hide-content"><ul><li>JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。</li><li>JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。</li></ul><p>具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具。简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>2. == 和 equals 的区别是什么?</span></div>    <div class="hide-content"><p><a href="https://shiming.online/blog/40121/#%E5%92%8C-equals-%E5%8C%BA%E5%88%AB">参考博客</a></p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>3. 两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？</span></div>    <div class="hide-content"><p>不对，两个对象的 hashCode()相同，equals()不一定 true。<br>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;通话&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;重地&quot;</span>;</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;str1：%d | str2：%d&quot;</span>,</span><br><span class="line">                     str1.hashCode(),str2.hashCode()));</span><br><span class="line">System.out.println(str1.equals(str2));</span><br><span class="line">执行的结果：</span><br><span class="line">str1：<span class="number">1179395</span> | str2：<span class="number">1179395</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure><p>代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode()相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>4. final 在 java 中有什么作用？</span></div>    <div class="hide-content"><ul><li>final 修饰的类叫最终类，该类不能被继承。</li><li>final 修饰的方法不能被重写。</li><li>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>5. java 中的 Math.round(-1.5) 等于多少？</span></div>    <div class="hide-content"><p>等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>6. String 属于基础的数据类型吗？</span></div>    <div class="hide-content"><p>String 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于对象。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>7. java 中操作字符串都有哪些类？它们之间有什么区别？</span></div>    <div class="hide-content"><p>操作字符串的类有：String、StringBuffer、StringBuilder。</p><p>String用<code>final</code>修饰，不可继承。</p><p>String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。</p><p>StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>8. String str=i与 String str=new String(i)一样吗？</span></div>    <div class="hide-content"><p>不一样，因为内存的分配方式不一样。String str=”i”的方式，java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>9. 如何将字符串反转？</span></div>    <div class="hide-content"><p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StringBuffer reverse</span></span><br><span class="line">StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">stringBuffer.append(<span class="string">&quot;abcdefg&quot;</span>);</span><br><span class="line">System.out.println(stringBuffer.reverse()); <span class="comment">// gfedcba</span></span><br><span class="line"><span class="comment">// StringBuilder reverse</span></span><br><span class="line">StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">stringBuilder.append(<span class="string">&quot;abcdefg&quot;</span>);</span><br><span class="line">System.out.println(stringBuilder.reverse()); <span class="comment">// gfedcba</span></span><br></pre></td></tr></table></figure></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>10. String 类的常用方法都有那些？</span></div>    <div class="hide-content"><ul><li>indexOf()：返回指定字符的索引。</li><li>charAt()：返回指定索引处的字符。</li><li>replace()：字符串替换。</li><li>trim()：去除字符串两端空白。</li><li>split()：分割字符串，返回一个分割后的字符串数组。</li><li>getBytes()：返回字符串的 byte 类型数组。</li><li>length()：返回字符串长度。</li><li>toLowerCase()：将字符串转成小写字母。</li><li>toUpperCase()：将字符串转成大写字符。</li><li>substring()：截取字符串。</li><li>equals()：字符串比较。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>11. 抽象类必须要有抽象方法吗？</span></div>    <div class="hide-content"><p>不需要，抽象类不一定非要有抽象方法。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hi~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码，抽象类并没有抽象方法但完全可以正常运行。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>12. 普通类和抽象类有哪些区别？</span></div>    <div class="hide-content"><ul><li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li><li>抽象类不能直接实例化，普通类可以直接实例化。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>13. 抽象类能使用 final 修饰吗？</span></div>    <div class="hide-content"><p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，如下图所示，编辑器也会提示错误信息：<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200812215401.png" alt="20200812215401"></p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>14. 接口和抽象类有什么区别？</span></div>    <div class="hide-content"><p><a href="https://shiming.online/blog/40121/#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB">参考</a></p><p>相同点</p><ul><li>都不能被实例化</li><li>接口的实现类或抽象类的子类都只有实现了接口或抽象类中的抽象方法后才能实例化。</li></ul><p>不同点</p><ul><li>接口只有定义，不能有方法的实现，java 1.8 中可以定义 default 方法体，而抽象类可以有定义与实现，方法可在抽象类中实现。</li><li>实现接口的关键字为 implements，继承抽象类的关键字为 extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。</li><li>接口强调特定功能的实现，而抽象类强调所属关系。</li><li>接口成员变量默认为 public static final，必须赋初值，不能被修改；其所有的成员方法都是 public、abstract 的。抽象类中成员变量默认 default，可在子类中被重新定义，也可被重新赋值；抽象方法被 abstract 修饰，不能被 private、static、synchronized 和 native 等修饰，必须以分号结尾，不带花括号。</li><li>接口被用于常用的功能，便于日后维护和添加删除，而抽象类更倾向于充当公共类的角色，不适用于日后重新对立面的代码修改。功能需要累积时用抽象类，不需要累积时用接口。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>15. java 中 IO 流分为几种？</span></div>    <div class="hide-content"><p>按功能来分：输入流（input）、输出流（output）。</p><p>按类型来分：字节流和字符流。</p><p>字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。本质区别：字节流是原生的操作，字符流是经过处理后的操作。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>16. BIO、NIO、AIO 有什么区别？</span></div>    <div class="hide-content"><ul><li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li><li>NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li><li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>17. Files的常用方法都有哪些？</span></div>    <div class="hide-content"><ul><li>Files.exists()：检测文件路径是否存在。</li><li>Files.createFile()：创建文件。</li><li>Files.createDirectory()：创建文件夹。</li><li>Files.delete()：删除一个文件或目录。</li><li>Files.copy()：复制文件。</li><li>Files.move()：移动文件。</li><li>Files.size()：查看文件个数。</li><li>Files.read()：读取文件。</li><li>Files.write()：写入文件。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>toString 和 String.valueOf()的区别</span></div>    <div class="hide-content"><p>将对象转为字符串常用三种方法：(String) xxx, xxx.toString(), String.valueOf(xxx)</p><ol><li><strong>(String)</strong> ：强制转换，将object转成String类型的值。使用这种方法时，需要注意的是类型必须能转成String类型。否则容易抛出CalssCastException异常</li><li><strong>toString()</strong> ：在使用时要注意，必须保证转换的对象不是null值，否则将抛出NullPointerException异常。采用这种方法时，通常派生类会覆盖Object里的toString（）方法。</li><li><strong>String.valueOf()</strong> ：String的静态方法，避免了前两个的不足和缺点。在内部加了非空判断，不会抛出空指针异常，但是需要注意：<strong>对象为null时，会转换成字符串”null”，而不是 null ！</strong>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (obj == <span class="keyword">null</span>) ? <span class="string">&quot;null&quot;</span> : obj.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>重载和重写的区别</span></div>    <div class="hide-content"><p><strong>override（重写）：</strong></p><ul><li>方法名、参数、返回值相同。</li><li>子类方法不能缩小父类方法的访问权限。</li><li>子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。</li><li>存在于父类和子类之间。</li><li>方法被定义为final不能被重写。</li></ul><p><strong>overload（重载）：</strong></p><ul><li>参数类型、个数、顺序至少有一个不相同。</li><li>不能重载只有返回值不同的方法名。</li><li>存在于父类和子类、同类中。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>Comparator与Comparable有什么区别？</span></div>    <div class="hide-content"><ul><li>Comparable是排序接口；若一个类实现了Comparable接口，就意味着“该类支持排序”。</li><li>而Comparator是比较器；我们若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。</li><li>Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>int和Integer 有什么区别，还有Integer缓存的实现</span></div>    <div class="hide-content"><p><a href="https://www.cnblogs.com/guodongdidi/p/6953217.html">int和Integer的区别</a></p></div></div><h2 id="第二模块：容器"><a href="#第二模块：容器" class="headerlink" title="第二模块：容器"></a>第二模块：容器</h2><p><a href="https://shiming.online/blog/4509351/">Java集合</a></p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>18. java 容器都有哪些？</span></div>    <div class="hide-content"><p>Java集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键/值对映射。Collection接口又有3种子类型，List、Set和Queue，再下面是一些抽象类，最后是具体实现类，常用的有ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap等等。</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200811111639.png" alt="容器"></p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>19. Collection 和 Collections 有什么区别？</span></div>    <div class="hide-content"><ul><li>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</li><li>Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>20. List、Set、Map 之间的区别是什么？</span></div>    <div class="hide-content"><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200812215904.png" alt="20200812215904"></p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>21. HashMap 和 Hashtable 有什么区别？</span></div>    <div class="hide-content"><ul><li>hashMap去掉了HashTable 的contains方法，但是加上了containsValue（）和containsKey（）方法。</li><li>hashTable是同步的，而HashMap是非同步的，效率上比hashTable要高。</li><li>hashMap允许空键值，而hashTable不允许。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>22. 如何决定使用 HashMap 还是 TreeMap？</span></div>    <div class="hide-content"><p>对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，再将map换为TreeMap进行有序key的遍历。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>23. 说一下 HashMap 的实现原理？</span></div>    <div class="hide-content"><p>数组+链表<br><a href="https://shiming.online/blog/4509351/#HashMap">HashMap</a></p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>24. 说一下 HashSet 的实现原理？</span></div>    <div class="hide-content"><ul><li>HashSet底层由HashMap实现</li><li>HashSet的值存放于HashMap的key上</li><li>HashMap的value统一为PRESENT</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>25. ArrayList 和 LinkedList 的区别是什么？</span></div>    <div class="hide-content"><p>最明显的区别是 ArrrayList底层的数据结构是数组，支持随机访问，查询快，增删慢；线程不安全，效率高。<br>而 LinkedList 的底层数据结构是双向循环链表，不支持随机访问，查询慢，增删快;线程不安全，效率高。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>26. 如何实现数组和 List 之间的转换？</span></div>    <div class="hide-content"><ul><li>List转换成为数组：调用ArrayList的toArray方法。</li><li>数组转换成为List：调用Arrays的asList方法。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>27. ArrayList 和 Vector 的区别是什么？</span></div>    <div class="hide-content"><ul><li>Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。</li><li>ArrayList比Vector快，Vector因为有同步，不会过载。</li><li>ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>28. Array 和 ArrayList 有何区别？</span></div>    <div class="hide-content"><ul><li>Array可以容纳基本类型和对象，而ArrayList只能容纳对象。</li><li>Array是指定大小的，而ArrayList大小不是固定的。</li><li>Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>29. 在 Queue 中 poll()和 remove()有什么区别？</span></div>    <div class="hide-content"><p>poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，remove() 失败的时候会抛出异常。<br>相似的还有 element()和peek()用于在队列的头部查询元素。与 remove() 方法类似，在队列为空时， element() 抛出一个异常，而 peek() 返回 null。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>30. 哪些集合类是线程安全的？</span></div>    <div class="hide-content"><ul><li>vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。</li><li>statck：堆栈类，先进后出。</li><li>hashtable：就比hashmap多了个线程安全。</li><li>enumeration：枚举，相当于迭代器。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>31. 迭代器 Iterator 是什么？</span></div>    <div class="hide-content"><p>迭代器是Java 中常用的设计模式之一，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>32. Iterator 怎么使用？有什么特点？</span></div>    <div class="hide-content"><p><a href="https://shiming.online/blog/4509351/#%E8%BF%AD%E4%BB%A3%E5%99%A8">迭代器</a></p><p>Java中的Iterator功能比较简单，并且只能单向移动：</p><ol><li>使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。</li><li>使用next()获得序列中的下一个元素。</li><li>使用hasNext()检查序列中是否还有元素。</li><li>使用remove()将迭代器新返回的元素删除。</li></ol><p>Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>33. Iterator 和 ListIterator 有什么区别？</span></div>    <div class="hide-content"><p><a href="https://shiming.online/blog/4509351/#listIterator">ListIterator</a></p><ul><li>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。</li><li>Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。</li><li>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</li></ul></div></div><h2 id="第三模块：多线程"><a href="#第三模块：多线程" class="headerlink" title="第三模块：多线程"></a>第三模块：多线程</h2><p><a href="https://shiming.online/blog/24227/">多线程</a></p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>35. 并行和并发有什么区别？</span></div>    <div class="hide-content"><ul><li>并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。</li><li>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。</li><li>并发在一台处理器上“同时”处理多个任务，并行在多台处理器上同时处理多个任务。如hadoop分布式集群。</li></ul><p>所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。<br><a href="https://shiming.online/blog/24227/#%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91">并行与并发</a></p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>36. 线程和进程的区别？</span></div>    <div class="hide-content"><p>进程是<strong>程序运行和资源分配的基本单位</strong>，一个程序至少有一个进程，一个进程至少有一个线程。</p><p>多进程中每个进程拥有自己<strong>独立</strong>的代码和数据空间（进程上下文），而多线程<strong>共享</strong>代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)。共享变量使线程之间的通信比进程之间的通信更有效，更容易。此外,在某些操作系统中,线程更”轻量级”,创建,撤销一个线程比启动新线程开销更小。</p><p>线程是进程的一个实体，是<strong>CPU调度和分派的基本单位</strong>，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。</p><ul><li>多进程是指操作系统能同时运行多个任务（程序）。</li><li>多线程是指在同一程序中有多个顺序流在执行。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>37. 守护线程是什么？</span></div>    <div class="hide-content"><p>守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程。（例如：定时器）</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>38. 创建线程有哪几种方式？</span></div>    <div class="hide-content"><p>在 Java 中创建一个线程有三种方法</p><ol><li>实现Java.lang.Runnable接口，重写run方法，启动：new Thread(this).start();</li><li>继承Java.lang.Thread类，重写run方法</li><li>实现Callable接口，并与Future结合使用</li></ol><p><a href="https://shiming.online/blog/24227/#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B">参考</a></p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>39. 说一下 runnable 和 callable 有什么区别？</span></div>    <div class="hide-content"><p>有点深的问题了，也看出一个Java程序员学习知识的广度。</p><ul><li>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；</li><li>Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>40. 线程有哪些状态？</span></div>    <div class="hide-content"><p>多线程与多进程都分为五个阶段</p><ul><li>创建（new）：新创建了一个线程对象。</li><li>就绪（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。<br>该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。</li><li>运行（Running）：就绪状态的线程获取了CPU，执行程序代码</li><li>阻塞（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：<ol><li>等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持有的锁)</li><li>同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。</li><li>其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁）</li></ol></li><li>死亡（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200812143242.png" alt="生命周期"></p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>41. sleep() 和 wait() 有什么区别？</span></div>    <div class="hide-content"><p>sleep()：方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。</p><p>wait()：wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>42. notify()和 notifyAll()有什么区别？</span></div>    <div class="hide-content"><ul><li>如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。</li><li>当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。<br>也就是说，调用了notify后只有一个线程会从等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争。</li><li>优先级高的线程竞争到对象锁的概率大（唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势），假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。<br>而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>43. 线程的 run()和 start()有什么区别？</span></div>    <div class="hide-content"><p>每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，方法run()称为线程体。通过调用Thread类的start()方法来启动一个线程。</p><p>start()方法来启动一个线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码； 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。</p><p>run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>44. 创建线程池有哪几种方式？</span></div>    <div class="hide-content"><p>五种方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建单一线程的线程池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 创建固定数量的线程池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span>;</span><br><span class="line"><span class="comment">// 创建带缓存的线程池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 创建定时调度的线程池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span>;</span><br><span class="line"><span class="comment">// 创建流式（fork-join）线程池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/7ab4ae9443b9">Java线程池的使用</a></p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>45. 线程池都有哪些状态？</span></div>    <div class="hide-content"><p>线程池有5种状态：Running、ShutDown、Stop、Tidying、Terminated。</p><p>线程池各个状态切换框架图：<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200812221231.png" alt="20200812221231"></p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>46. 线程池中 submit()和 execute()方法有什么区别？</span></div>    <div class="hide-content"><ul><li>接收的参数不一样</li><li>submit有返回值，而execute没有</li><li>submit方便Exception处理</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>47. 在 java 程序中怎么保证多线程的运行安全？</span></div>    <div class="hide-content"><p>线程安全在三个方面体现：</p><ul><li>原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）；</li><li>可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）；</li><li>有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>48. 多线程锁的升级原理是什么？</span></div>    <div class="hide-content"><p>在Java中，锁共有4种状态，级别从低到高依次为：无状态锁，偏向锁，轻量级锁和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级。<br>锁升级的图示过程：<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200812221340.png" alt="20200812221340"></p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>49. 什么是死锁？</span></div>    <div class="hide-content"><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。<br>是操作系统层面的一个错误，是进程死锁的简称，最早在 1965 年由 Dijkstra 在研究银行家算法时提出的，它是计算机操作系统乃至整个并发程序设计领域最难处理的问题之一。</p><p><a href="https://shiming.online/blog/24227/#%E6%AD%BB%E9%94%81">参考</a></p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>50. 怎么防止死锁？</span></div>    <div class="hide-content"><p>在并发程序中，避免了逻辑中出现复数个线程互相持有对方线程所需要的独占锁的的情况，就可以避免死锁。<br><a href="https://shiming.online/blog/24227/#%E6%9D%A1%E4%BB%B6">参考</a></p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>51. ThreadLocal 是什么？有哪些使用场景？</span></div>    <div class="hide-content"><p>ThreadLocal是一个本地线程副本变量工具类。主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不同的变量值完成操作的场景。<br>但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。<br>任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</p><p>适用于数据库连接管理，线程会话管理等场景。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>52. 说一下 synchronized 底层实现原理？</span></div>    <div class="hide-content"><p>synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。</p><p>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：</p><ul><li>普通同步方法，锁是当前实例对象</li><li>静态同步方法，锁是当前类的class对象</li><li>同步方法块，锁是括号里面的对象</li></ul><p><a href="https://shiming.online/blog/24227/#synchronized">参考</a></p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>53. synchronized 和 volatile 的区别是什么？</span></div>    <div class="hide-content"><ul><li>volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</li><li>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。</li><li>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。</li><li>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。</li><li>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>54. synchronized 和 Lock 有什么区别？</span></div>    <div class="hide-content"><ul><li>首先synchronized是java内置关键字，在jvm层面，Lock是个java类；</li><li>synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；</li><li>synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；</li><li>用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；</li><li>synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）；</li><li>Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>55. synchronized 和 ReentrantLock 区别是什么？</span></div>    <div class="hide-content"><p>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。<br>既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：</p><ul><li>ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁</li><li>ReentrantLock可以获取各种锁的信息</li><li>ReentrantLock可以灵活地实现多路通知</li></ul><p>另外，二者的锁机制其实也是不一样的:ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>56. 说一下 atomic 的原理？</span></div>    <div class="hide-content"><p>Atomic 主要利用 CAS (Compare And Wwap) 和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p><p>Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。</p><p>Atomic系列的类中的核心方法都会调用unsafe类中的几个本地方法。我们需要先知道一个东西就是Unsafe类，全名为：sun.misc.Unsafe，这个类包含了大量的对C代码的操作，包括很多直接内存分配以及原子操作的调用，而它之所以标记为非安全的，是告诉你这个里面大量的方法调用都会存在安全隐患，需要小心使用，否则会导致严重的后果，例如在通过unsafe分配内存的时候，如果自己指定某些区域可能会导致一些类似C++一样的指针越界到其他进程的问题。</p></div></div><h2 id="第四模块：反射"><a href="#第四模块：反射" class="headerlink" title="第四模块：反射"></a>第四模块：反射</h2><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>57. 什么是反射？</span></div>    <div class="hide-content"><blockquote><p><a href="https://baike.baidu.com/item/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/6015990">JAVA反射（reflection）机制</a>是指在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。这种动态获取程序信息以及动态调用对象的功能称为Java语言的反射机制。反射被视为动态语言的关键。<br>反射主要是指程序可以访问，检测和修改它本身状态或行为的一种能力，并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。</p></blockquote><p>反射机制可以用来  </p><ol><li>在运行时判断任意一个对象所属的类；</li><li>在运行时构造任意一个类的对象；</li><li>在运行时判断任意一个类所具有的成员变量和方法；</li><li>在运行时调用任意一个对象的方法；</li><li>生成动态代理。</li></ol><p><a href="https://shiming.online/blog/7af799fd/">Java反射</a></p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>58. 什么是 java 序列化？什么情况下需要序列化？</span></div>    <div class="hide-content"><p>简单说就是为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。虽然你可以用你自己的各种各样的方法来保存object states，但是Java给你提供一种应该比你自己好的保存对象状态的机制，那就是序列化。<br>什么情况下需要序列化：</p><ol><li>当你想把的内存中的对象状态保存到一个文件中或者数据库中时候；</li><li>当你想用套接字在网络上传送对象的时候；</li><li>当你想通过RMI传输对象的时候；</li></ol></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>59. 动态代理是什么？有哪些应用？</span></div>    <div class="hide-content"><p>代理模式(Proxy)是一种设计模式，提供了对目标对象另外的访问方式：即通过代理对象访问目标对象。这样做的好处是：可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能，例：统计，log或对参数进行优化，更改。</p><p>动态代理是为了解决静态代理中代理对象和目标对象必须实现同一个接口的问题，是JDK的一种api</p><p>动态代理的应用：</p><ul><li>Spring的AOP</li><li>加事务</li><li>加权限</li><li>加日志</li></ul><p><a href="https://shiming.online/blog/7b510e10/">代理模式</a></p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>60. 怎么实现动态代理？</span></div>    <div class="hide-content"><p>步骤：</p><ol><li>声明调用处理器类(InvocationHandler)</li><li>声明目标对象类的抽象接口</li><li>声明目标对象类</li><li>通过动态代理对象，调用目标对象的方法</li></ol><p>原理：</p><ol><li>通过调用处理器类对象的.newProxyInstance()创建动态代理类及其实例对象<ul><li>通过为Proxy类指定类加载器对象&amp;一组接口，从而创建动态代理类的字节码。根据类字节码创建动态代理类</li><li>通过反射机制获取动态代理类的构造函数(参数类型=调用处理器接口类型)</li><li>通过动态代理类的构造函数创建代理类实例(传入调用处理器对象)</li></ul></li><li>通过调用动态代理对象方法从而调用目标对象方法<ul><li>动态代理类实现了与目标类一样的接口，并实现了需要目标类对象需要调用的方法</li><li>该方法的实现逻辑=调用父类Proxy类的h.invoke ()</li><li>在InvocationHandler.invoke ()中通过反射机制，从而调用目标类对象的方法</li></ul></li></ol><p><a href="https://shiming.online/blog/7b510e10/#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B">动态代理代码示例</a></p></div></div><h2 id="第五模块：对象拷贝"><a href="#第五模块：对象拷贝" class="headerlink" title="第五模块：对象拷贝"></a>第五模块：对象拷贝</h2><p><a href="https://shiming.online/blog/ed7a5ab9/">对象克隆</a></p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>61. 为什么要使用克隆？</span></div>    <div class="hide-content"><p>想对一个对象进行处理，又想保留原有的数据进行接下来的操作，就需要克隆了，Java语言中克隆针对的是类的实例。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>62. 如何实现对象克隆？</span></div>    <div class="hide-content"><p>有三种方式：</p><ul><li>实现Cloneable接口并重写Object类中的clone()方法（浅拷贝）</li><li>clone对象时也clone属性，实现深度克隆</li><li>实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>63. 深拷贝和浅拷贝区别是什么？</span></div>    <div class="hide-content"><ul><li>如果类中属性有自定义引用类型，浅拷贝只拷贝引用，不拷贝引用指向的对象。浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝</li><li>深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝（例：JSON.parse()和JSON.stringify()，但是此方法无法复制函数类型）</li></ul></div></div><h2 id="第六模块：Java-Web"><a href="#第六模块：Java-Web" class="headerlink" title="第六模块：Java Web"></a>第六模块：Java Web</h2><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>64. JSP 和 Servlet 有什么区别？</span></div>    <div class="hide-content"><p>JSP：</p><ul><li>JSP是 Servlet 的扩展，本质上还是 Servlet</li><li>每个 JSP 页面就是一个 Servlet 实例</li><li>JSP 页面会被 Web 容器编译成 Servlet，Servlet 再负责响应用户请求</li></ul><p>区别：</p><ol><li>Servlet在Java代码中可以通过HttpServletResponse对象动态输出HTML内容。</li><li>JSP是在静态HTML内容中嵌入Java代码，然后Java代码在被动态执行后生成HTML内容。</li></ol><div class="note info flat"><ul><li>JSP就是在html里面写java代码，servlet就是在java里面写html代码</li><li>JSP更注重前端显示，servlet更注重模型和业务逻辑。</li></ul></div></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>65. JSP 有哪些内置对象？作用分别是什么？</span></div>    <div class="hide-content"><p>JSP有9个内置对象：</p><ul><li>request：封装客户端的请求，其中包含来自GET或POST请求的参数；</li><li>response：封装服务器对客户端的响应；</li><li>pageContext：通过该对象可以获取其他对象；</li><li>session：封装用户会话的对象；</li><li>application：封装服务器运行环境的对象；</li><li>out：输出服务器响应的输出流对象；</li><li>config：Web应用的配置对象；</li><li>page：JSP页面本身（相当于Java程序中的this）；</li><li>exception：封装页面抛出异常的对象。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>66. 说一下 JSP 的 4 种作用域？</span></div>    <div class="hide-content"><p>JSP中的四种作用域包括page、request、session和application，具体来说：</p><ul><li>page代表与一个页面相关的对象和属性。</li><li>request代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。</li><li>session代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。</li><li>application代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>67. session 和 cookie 有什么区别？</span></div>    <div class="hide-content"><p><a href="https://shiming.online/blog/3a66a386/">Session和Cookie</a></p><ol><li>存储位置不同<ul><li>cookie的数据信息存放在客户端浏览器上。</li><li>session的数据信息存放在服务器上。</li></ul></li><li>存储容量不同<ul><li>单个cookie保存的数据&lt;=4KB，一个站点最多保存20个Cookie。</li><li>对于session来说并没有上限，但出于对服务器端的性能考虑，session内不要存放过多的东西，并且设置session删除机制。</li></ul></li><li>存储方式不同<ul><li>cookie中只能保管ASCII字符串，并需要通过编码方式存储为Unicode字符或者二进制数据。</li><li>session中能够存储任何类型的数据，包括且不限于string，integer，list，map等。</li></ul></li><li>隐私策略不同<ul><li>cookie对客户端是可见的，别有用心的人可以分析存放在本地的cookie并进行cookie欺骗，所以它是不安全的。</li><li>session存储在服务器上，对客户端是透明对，不存在敏感信息泄漏的风险。</li></ul></li><li>服务器压力不同<ul><li>cookie保管在客户端，不占用服务器资源。对于并发用户十分多的网站，cookie是很好的选择。</li><li>session是保管在服务器端的，每个用户都会产生一个session。假如并发访问的用户十分多，会产生十分多的session，耗费大量的内存。</li></ul></li><li>浏览器支持不同<ul><li>假如客户端浏览器不支持cookie：<ul><li>cookie是需要客户端浏览器支持的，假如客户端禁用了cookie，或者不支持cookie，则会话跟踪会失效。关于WAP上的应用，常规的cookie就派不上用场了。</li><li>运用session需要使用URL地址重写的方式。一切用到session程序的URL都要进行URL地址重写，否则session会话跟踪还会失效。</li></ul></li><li>假如客户端支持cookie：<ul><li>cookie既能够设为本浏览器窗口以及子窗口内有效，也能够设为一切窗口内有效。</li><li>session只能在本窗口以及子窗口内有效。</li></ul></li></ul></li></ol></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>68. 说一下 session 的工作原理？</span></div>    <div class="hide-content"><p>其实session是一个存在服务器上的类似于一个散列表格的文件。里面存有我们需要的信息，在我们需要用的时候可以从里面取出来。类似于一个大号的map，里面的键存储的是用户的sessionId，用户向服务器发送请求的时候会带上这个sessionId。这时就可以从中取出对应的值了。</p><ul><li>key：sessionId</li><li>value：用户信息</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>69. 如果客户端禁止 cookie 能实现 session 还能用吗？</span></div>    <div class="hide-content"><p>可以通过其他方法使用</p><p>一般默认情况下，在会话中，服务器存储 session 的 sessionId 是通过 cookie 存到浏览器里。<br>如果浏览器禁用了 cookie，浏览器请求服务器无法携带 sessionId，服务器无法识别请求中的用户身份，session失效。<br>但是可以通过其他方法在禁用 cookie 的情况下，可以继续使用session。</p><ol><li>通过url重写，把 sessionId 作为参数追加的原 url 中，后续的浏览器与服务器交互中携带 sessionId 参数。</li><li>服务器的返回数据中包含 sessionId，浏览器发送请求时，携带 sessionId 参数。</li><li>通过 Http 协议其他 header 字段，服务器每次返回时设置该 header 字段信息，浏览器中 js 读取该 header 字段，请求服务器时，js设置携带该 header 字段。</li></ol><p><a href="https://blog.csdn.net/meism5/article/details/90414108">原文</a></p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>70. spring mvc 和 struts 的区别是什么？</span></div>    <div class="hide-content"><ul><li><p>拦截机制的不同<br>Struts2是类级别的拦截，每次请求就会创建一个Action，和Spring整合时Struts2的ActionBean注入作用域是原型模式prototype，然后通过setter，getter吧request数据注入到属性。Struts2中，一个Action对应一个request，response上下文，在接收参数时，可以通过属性接收，这说明属性参数是让多个方法共享的。Struts2中Action的一个方法可以对应一个url，而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了，只能设计为多例。</p><p>SpringMVC是方法级别的拦截，一个方法对应一个Request上下文，所以方法直接基本上是独立的，独享request，response数据。而每个方法同时又何一个url对应，参数的传递是直接注入到方法中的，是方法所独有的。处理结果通过ModeMap返回给框架。在Spring整合时，SpringMVC的Controller Bean默认单例模式Singleton，所以默认对所有的请求，只会创建一个Controller，有应为没有共享的属性，所以是线程安全的，如果要改变默认的作用域，需要添加@Scope注解修改。</p><p>Struts2有自己的拦截Interceptor机制，SpringMVC这是用的是独立的Aop方式，这样导致Struts2的配置文件量还是比SpringMVC大。</p></li><li><p>底层框架的不同<br>Struts2采用Filter（StrutsPrepareAndExecuteFilter）实现，SpringMVC（DispatcherServlet）则采用Servlet实现。Filter在容器启动之后即初始化；服务停止以后坠毁，晚于Servlet。Servlet在是在调用时初始化，先于Filter调用，服务停止后销毁。</p></li><li><p>性能方面<br>Struts2是类级别的拦截，每次请求对应实例一个新的Action，需要加载所有的属性值注入，SpringMVC实现了零配置，由于SpringMVC基于方法的拦截，有加载一次单例模式bean注入。所以，SpringMVC开发效率和性能高于Struts2。</p></li><li><p>配置方面<br>Spring MVC和Spring是无缝的。从这个项目的管理和安全上也比Struts2高。</p></li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>71. 如何避免 sql 注入？</span></div>    <div class="hide-content"><p>Sql 注入攻击是通过将恶意的 Sql 查询或添加语句插入到应用的输入参数中，再在后台 Sql 服务器上解析执行进行的攻击，它目前黑客对数据库进行攻击的最常用手段之一。<br><a href="https://www.jianshu.com/p/078df7a35671">Sql注入原理</a></p><p>避免方式：</p><ul><li>严格限制 Web 应用的数据库的操作权限，给连接数据库的用户提供满足需要的最低权限，最大限度的减少注入攻击对数据库的危害</li><li>校验参数的数据格式是否合法（可以使用正则或特殊字符的判断）</li><li>对进入数据库的特殊字符进行转义处理，或编码转换</li><li>预编译 SQL（Java 中使用 PreparedStatement），参数化查询方式，避免 SQL 拼接</li><li>发布前，利用工具进行 SQL 注入检测</li><li>报错信息不要包含 SQL 信息输出到 Web 页面</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>72. 什么是 XSS 攻击，如何避免？</span></div>    <div class="hide-content"><p>XSS攻击又称CSS,全称Cross Site Script  （跨站脚本攻击），其原理是攻击者向有XSS漏洞的网站中输入恶意的 HTML 代码，当用户浏览该网站时，这段 HTML 代码会自动执行，从而达到攻击的目的。XSS 攻击类似于 SQL 注入攻击，SQL注入攻击中以SQL语句作为用户输入，从而达到查询/修改/删除数据的目的，而在XSS攻击中，通过插入恶意脚本，实现对用户游览器的控制，获取用户的一些信息。 XSS是 Web 程序中常见的漏洞，XSS 属于被动式且用于客户端的攻击方式。</p><p>XSS防范的总体思路是：对输入(和URL参数)进行过滤，对输出进行编码。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>73. 什么是 CSRF 攻击，如何避免？</span></div>    <div class="hide-content"><p>CSRF（Cross-site request forgery）也被称为 one-click attack或者 session riding，中文全称是叫跨站请求伪造。一般来说，攻击者通过伪造用户的浏览器的请求，向访问一个用户自己曾经认证访问过的网站发送出去，使目标网站接收并误以为是用户的真实操作而去执行命令。常用于盗取账号、转账、发送虚假消息等。攻击者利用网站对请求的验证漏洞而实现这样的攻击行为，网站能够确认请求来源于用户的浏览器，却不能验证请求是否源于用户的真实意愿下的操作行为。</p><p>如何避免：</p><ol><li>验证 HTTP Referer 字段<br>HTTP头中的Referer字段记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，而如果黑客要对其实施 CSRF攻击，他一般只能在他自己的网站构造请求。因此，可以通过验证Referer值来防御CSRF 攻击。</li><li>使用验证码<br>关键操作页面加上验证码，后台收到请求后通过判断验证码可以防御CSRF。但这种方法对用户不太友好。</li><li>在请求地址中添加token并验证<br>CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于cookie中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的cookie 来通过安全验证。<br>要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。<br>可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有token或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。<br>这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于session之中，然后在每次请求时把token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。<ul><li>对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 <code>http://url?csrftoken=tokenvalue</code>。</li><li>而对于 POST 请求来说，要在 form 的最后加上<code>&lt;input type=&quot;hidden&quot; name=&quot;csrftoken&quot; value=&quot;tokenvalue&quot;/&gt;</code>，这样就把token以参数的形式加入请求了。</li></ul></li><li>在HTTP 头中自定义属性并验证<br>这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</li></ol></div></div><h2 id="第七模块：异常"><a href="#第七模块：异常" class="headerlink" title="第七模块：异常"></a>第七模块：异常</h2><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>74. throw 和 throws 的区别？</span></div>    <div class="hide-content"><p>throws是用来声明一个方法可能抛出的所有异常信息，throws是将异常声明但是不处理，而是将异常往上传，谁调用我就交给谁处理。而throw则是指抛出的一个具体的异常类型。</p><ul><li><code>throws</code>：放置到方法头上  </li><li><code>throw</code> ：直接抛出一个异常</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>75. final、finally、finalize 有什么区别？</span></div>    <div class="hide-content"><ul><li>final是修饰符，可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。</li><li>finally是语句块，一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</li><li>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System的gc()方法的时候，由垃圾回收器调用finalize(),回收垃圾。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>76. try-catch-finally 中哪个部分可以省略？</span></div>    <div class="hide-content"><p>答：catch 可以省略<br>原因：</p><p>更为严格的说法其实是：try只适合处理运行时异常，try+catch适合处理运行时异常+普通异常。也就是说，如果你只用try去处理普通异常却不加以catch处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以catch可以省略，你加上catch编译器也觉得无可厚非。</p><p>理论上，编译器看任何代码都不顺眼，都觉得可能有潜在的问题，所以你即使对所有代码加上try，代码在运行期时也只不过是在正常运行的基础上加一层皮。但是你一旦对一段代码加上try，就等于显示地承诺编译器，对这段代码可能抛出的异常进行捕获而非向上抛出处理。如果是普通异常，编译器要求必须用catch捕获以便进一步处理；如果运行时异常，捕获然后丢弃并且+finally扫尾处理，或者加上catch捕获以便进一步处理。</p><p>至于加上finally，则是在不管有没捕获异常，都要进行的“扫尾”处理。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>77. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</span></div>    <div class="hide-content"><p><a href="https://shiming.online/blog/4876/#finally%E8%AF%AD%E5%8F%A5">finally语句</a><br>答：会执行，在 return 前执行。</p><p>示例一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * java面试题--如果catch里面有return语句，finally里面的代码还会执行吗？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(getInt());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(a / <span class="number">0</span>);</span><br><span class="line">            a = <span class="number">20</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            a = <span class="number">30</span>;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * return a 在程序执行到这一步的时候，这里不是return a 而是 return 30；这个返回路径就形成了</span></span><br><span class="line"><span class="comment">             * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40</span></span><br><span class="line"><span class="comment">             * 再次回到以前的路径,继续走return 30，形成返回路径之后，这里的a就不是a变量了，而是常量30</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            a = <span class="number">40</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//      return a;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：50</p><p>示例二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.java_02;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * java面试题--如果catch里面有return语句，finally里面的代码还会执行吗？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(getInt());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(a / <span class="number">0</span>);</span><br><span class="line">            a = <span class="number">20</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            a = <span class="number">30</span>;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * return a 在程序执行到这一步的时候，这里不是return a 而是 return 30；这个返回路径就形成了</span></span><br><span class="line"><span class="comment">             * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40</span></span><br><span class="line"><span class="comment">             * 再次回到以前的路径,继续走return 30，形成返回路径之后，这里的a就不是a变量了，而是常量30</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            a = <span class="number">40</span>;</span><br><span class="line">            <span class="keyword">return</span> a; <span class="comment">//如果这样，就又重新形成了一条返回路径，由于只能通过1个return返回，所以这里直接返回40</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//      return a;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：40</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>78. 常见的异常类有哪些？</span></div>    <div class="hide-content"><ul><li>NullPointerException：当应用程序试图访问空对象时，则抛出该异常。</li><li>SQLException：提供关于数据库访问错误或其他错误信息的异常。</li><li>IndexOutOfBoundsException：指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。</li><li>NumberFormatException：当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</li><li>FileNotFoundException：当试图打开指定路径名表示的文件失败时，抛出此异常。</li><li>IOException：当发生某种I/O异常时，抛出此异常。此类是失败或中断的I/O操作生成的异常的通用类。</li><li>ClassCastException：当试图将对象强制转换为不是实例的子类时，抛出该异常。</li><li>ArrayStoreException：试图将错误类型的对象存储到一个对象数组时抛出的异常。</li><li>IllegalArgumentException：抛出的异常表明向方法传递了一个不合法或不正确的参数。</li><li>ArithmeticException：当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例。</li><li>NegativeArraySizeException：如果应用程序试图创建大小为负的数组，则抛出该异常。</li><li>NoSuchMethodException：无法找到某一特定方法时，抛出该异常。</li><li>SecurityException：由安全管理器抛出的异常，指示存在安全侵犯。</li><li>UnsupportedOperationException：当不支持请求的操作时，抛出该异常。</li><li>RuntimeExceptionRuntimeException：是那些可能在Java虚拟机正常运行期间抛出的异常的超类。</li></ul></div></div><h2 id="第八模块：网络"><a href="#第八模块：网络" class="headerlink" title="第八模块：网络"></a>第八模块：网络</h2><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>79. http 响应码 301 和 302 代表的是什么？有什么区别？</span></div>    <div class="hide-content"><p>答：301，302 都是HTTP状态的编码，都代表着某个URL发生了转移。</p><p>区别：</p><ul><li>301 redirect: 301 代表永久性转移(Permanently Moved)。</li><li>302 redirect: 302 代表暂时性转移(Temporarily Moved )。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>80. forward 和 redirect 的区别？</span></div>    <div class="hide-content"><p><a href="https://shiming.online/blog/ab0d8940/">forward和redirect</a></p><ul><li>地址栏<br>forward浏览器地址不变化，redirect显示新网址</li><li>数据共享<br>forward共享数据，redirect数据清空</li><li>应用场景<br>forward用于登录等情况，redirect用于注销或跳转其他网站</li><li>效率<br>forword效率高，而redirect效率低</li><li>本质<br>forword转发是服务器的行为，而redirect重定向是客户端的行为</li><li>转发次数。<br>forword只有一次请求，而redirect有两次请求。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>81. 简述 tcp 和 udp的区别？</span></div>    <div class="hide-content"><ul><li>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接。</li><li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，但不保证可靠交付。</li><li>TCP通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。</li><li>UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</li><li>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信。</li><li>TCP对系统资源要求较多，UDP对系统资源要求较少。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>82. tcp 为什么要三次握手，两次不行吗？为什么？</span></div>    <div class="hide-content"><p>为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤。</p><p>如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>83. 说一下 tcp 粘包是怎么产生的？</span></div>    <div class="hide-content"><ol><li>发送方产生粘包<br>采用TCP协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据；但当发送的数据包过于小时，那么TCP协议默认的会启用Nagle算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200813141221.png" alt="20200813141221"></li><li>接收方产生粘包<br>接收方采用TCP协议接收数据时的过程是这样的：数据到达接收方，从网络模型的下方传递至传输层，传输层的TCP协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C语言用recv、read等函数）。这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入缓冲区末尾，等我们读取数据时就是一个粘包。（放数据的速度 &gt; 应用层拿数据速度）<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200813141236.png" alt="20200813141236"></li></ol></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>84. OSI 的七层模型都有哪些？</span></div>    <div class="hide-content"><ul><li>应用层：网络服务与最终用户的一个接口。</li><li>表示层：数据的表示、安全、压缩。</li><li>会话层：建立、管理、终止会话。</li><li>传输层：定义传输数据的协议端口号，以及流控和差错校验。</li><li>网络层：进行逻辑地址寻址，实现不同网络之间的路径选择。</li><li>数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能。</li><li>物理层：建立、维护、断开物理连接。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>85. get 和 post 请求有哪些区别？</span></div>    <div class="hide-content"><p><a href="https://shiming.online/blog/8564/#GET%E4%B8%8EPOST%E7%9A%84%E5%8C%BA%E5%88%AB">GET和POST区别</a></p><ol><li><p>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中.</p></li><li><p>GET提交的数据大小有限制（因为<strong>浏览器</strong>对URL的长度有限制），而POST方法提交的数据没有限制.</p></li><li><p>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。</p></li><li><p>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.</p></li></ol></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>86. 如何实现跨域？</span></div>    <div class="hide-content"><p>方式一：图片ping或script标签跨域</p><p>图片ping常用于跟踪用户点击页面或动态广告曝光次数。<br>script标签可以得到从其他来源数据，这也是JSONP依赖的根据。</p><p>方式二：JSONP跨域</p><p>JSONP（JSON with Padding）是数据格式JSON的一种“使用模式”，可以让网页从别的网域要数据。根据 XmlHttpRequest 对象受到同源策略的影响，而利用 <code>&lt;script&gt;</code>元素的这个开放策略，网页可以得到从其他来源动态产生的JSON数据，而这种使用模式就是所谓的 JSONP。用JSONP抓到的数据并不是JSON，而是任意的JavaScript，用 JavaScript解释器运行而不是用JSON解析器解析。所有，通过Chrome查看所有JSONP发送的Get请求都是js类型，而非XHR。<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200813141435.png" alt="20200813141435"><br>缺点：</p><ul><li>只能使用Get请求</li><li>不能注册success、error等事件监听函数，不能很容易的确定JSONP请求是否失败</li><li>JSONP是从其他域中加载代码执行，容易受到跨站请求伪造的攻击，其安全性无法确保</li></ul><p>方式三：CORS</p><p>Cross-Origin Resource Sharing（CORS）跨域资源共享是一份浏览器技术的规范，提供了 Web 服务从不同域传来沙盒脚本的方法，以避开浏览器的同源策略，确保安全的跨域数据传输。现代浏览器使用CORS在API容器如XMLHttpRequest来减少HTTP请求的风险来源。与 JSONP 不同，CORS 除了 GET 要求方法以外也支持其他的 HTTP 要求。服务器一般需要增加如下响应头的一种或几种：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Origin</span>: *</span><br><span class="line"><span class="attribute">Access-Control-Allow-Methods</span>: POST, GET, OPTIONS</span><br><span class="line"><span class="attribute">Access-Control-Allow-Headers</span>: X-PINGOTHER, Content-Type</span><br><span class="line"><span class="attribute">Access-Control-Max-Age</span>: 86400</span><br></pre></td></tr></table></figure><p>跨域请求默认不会携带Cookie信息，如果需要携带，请配置下述参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;Access-Control-Allow-Credentials&quot;: true</span><br><span class="line">&#x2F;&#x2F; Ajax设置</span><br><span class="line">&quot;withCredentials&quot;: true</span><br></pre></td></tr></table></figure><p>方式四：window.name+iframe<br>window.name通过在iframe（一般动态创建i）中加载跨域HTML文件来起作用。然后，HTML文件将传递给请求者的字符串内容赋值给window.name。然后，请求者可以检索window.name值作为响应。</p><ul><li>iframe标签的跨域能力；</li><li>window.name属性值在文档刷新后依旧存在的能力（且最大允许2M左右）。</li></ul><p>每个iframe都有包裹它的window，而这个window是top window的子窗口。contentWindow属性返回<code>&lt;iframe&gt;</code>元素的Window对象。你可以使用这个Window对象来访问iframe的文档及其内部DOM。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment"> 下述用端口 </span></span><br><span class="line"><span class="comment"> 10000表示：domainA</span></span><br><span class="line"><span class="comment"> 10001表示：domainB</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- localhost:10000 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">&#x27;iframe&#x27;</span>);</span></span><br><span class="line"><span class="javascript">  iframe.style.display = <span class="string">&#x27;none&#x27;</span>; <span class="comment">// 隐藏</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> state = <span class="number">0</span>; <span class="comment">// 防止页面无限刷新</span></span></span><br><span class="line"><span class="javascript">  iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">if</span>(<span class="params">state === <span class="number">1</span></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(iframe.contentWindow.name));</span></span><br><span class="line"><span class="javascript">          <span class="comment">// 清除创建的iframe</span></span></span><br><span class="line"><span class="javascript">          iframe.contentWindow.document.write(<span class="string">&#x27;&#x27;</span>);</span></span><br><span class="line">          iframe.contentWindow.close();</span><br><span class="line"><span class="javascript">          <span class="built_in">document</span>.body.removeChild(iframe);</span></span><br><span class="line"><span class="javascript">      &#125; <span class="keyword">else</span> <span class="function"><span class="title">if</span>(<span class="params">state === <span class="number">0</span></span>)</span> &#123;</span></span><br><span class="line">          state = 1;</span><br><span class="line"><span class="javascript">          <span class="comment">// 加载完成，指向当前域，防止错误(proxy.html为空白页面)</span></span></span><br><span class="line"><span class="javascript">          <span class="comment">// Blocked a frame with origin &quot;http://localhost:10000&quot; from accessing a cross-origin frame.</span></span></span><br><span class="line"><span class="javascript">          iframe.contentWindow.location = <span class="string">&#x27;http://localhost:10000/proxy.html&#x27;</span>;</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  iframe.src = <span class="string">&#x27;http://localhost:10001&#x27;</span>;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.body.appendChild(iframe);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- localhost:10001 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.name = <span class="built_in">JSON</span>.stringify(&#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>方式五：window.postMessage()</p><p>HTML5新特性，可以用来向其他所有的 window 对象发送消息。需要注意的是我们必须要保证所有的脚本执行完才发送 MessageEvent，如果在函数执行的过程中调用了它，就会让后面的函数超时无法执行。</p><p>下述代码实现了跨域存储localStorage</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment"> 下述用端口 </span></span><br><span class="line"><span class="comment"> 10000表示：domainA</span></span><br><span class="line"><span class="comment"> 10001表示：domainB</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- localhost:10000 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;http://localhost:10001/msg.html&quot;</span> <span class="attr">name</span>=<span class="string">&quot;myPostMessage&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display:none;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      LSsetItem(<span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;Test: &#x27;</span> + <span class="keyword">new</span> <span class="built_in">Date</span>());</span></span><br><span class="line"><span class="javascript">      LSgetItem(<span class="string">&#x27;test&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">&#x27;value: &#x27;</span> + value);</span></span><br><span class="line">      &#125;);</span><br><span class="line"><span class="javascript">      LSremoveItem(<span class="string">&#x27;test&#x27;</span>);</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> callbacks = &#123;&#125;;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (event.source === frames[<span class="string">&#x27;myPostMessage&#x27;</span>]) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(event)</span></span><br><span class="line"><span class="javascript">          <span class="keyword">var</span> data = <span class="regexp">/^#localStorage#(\d+)(null)?#([\S\s]*)/</span>.exec(event.data);</span></span><br><span class="line">          if (data) &#123;</span><br><span class="line">              if (callbacks[data[1]]) &#123;</span><br><span class="line"><span class="javascript">                  callbacks[data[<span class="number">1</span>]](data[<span class="number">2</span>] === <span class="string">&#x27;null&#x27;</span> ? <span class="literal">null</span> : data[<span class="number">3</span>]);</span></span><br><span class="line">              &#125;</span><br><span class="line"><span class="javascript">              <span class="keyword">delete</span> callbacks[data[<span class="number">1</span>]];</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="javascript">  &#125;, <span class="literal">false</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> domain = <span class="string">&#x27;*&#x27;</span>;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 增加</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">LSsetItem</span>(<span class="params">key, value</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> obj = &#123;</span></span><br><span class="line">          setItem: key,</span><br><span class="line">          value: value</span><br><span class="line">      &#125;;</span><br><span class="line"><span class="javascript">      frames[<span class="string">&#x27;myPostMessage&#x27;</span>].postMessage(<span class="built_in">JSON</span>.stringify(obj), domain);</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="javascript">  <span class="comment">// 获取</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">LSgetItem</span>(<span class="params">key, callback</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> identifier = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> obj = &#123;</span></span><br><span class="line">          identifier: identifier,</span><br><span class="line">          getItem: key</span><br><span class="line">      &#125;;</span><br><span class="line">      callbacks[identifier] = callback;</span><br><span class="line"><span class="javascript">      frames[<span class="string">&#x27;myPostMessage&#x27;</span>].postMessage(<span class="built_in">JSON</span>.stringify(obj), domain);</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="javascript">  <span class="comment">// 删除</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">LSremoveItem</span>(<span class="params">key</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> obj = &#123;</span></span><br><span class="line">          removeItem: key</span><br><span class="line">      &#125;;</span><br><span class="line"><span class="javascript">      frames[<span class="string">&#x27;myPostMessage&#x27;</span>].postMessage(<span class="built_in">JSON</span>.stringify(obj), domain);</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- localhost:10001 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&#x27;Receiver debugging&#x27;</span>, event);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (event.origin == <span class="string">&#x27;http://localhost:10000&#x27;</span>) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(event.data);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (<span class="string">&#x27;setItem&#x27;</span> <span class="keyword">in</span> data) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">localStorage</span>.setItem(data.setItem, data.value);</span></span><br><span class="line"><span class="javascript">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&#x27;getItem&#x27;</span> <span class="keyword">in</span> data) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> gotItem = <span class="built_in">localStorage</span>.getItem(data.getItem);</span></span><br><span class="line">        event.source.postMessage(</span><br><span class="line"><span class="javascript">          <span class="string">&#x27;#localStorage#&#x27;</span> + data.identifier +</span></span><br><span class="line"><span class="javascript">          (gotItem === <span class="literal">null</span> ? <span class="string">&#x27;null#&#x27;</span> : <span class="string">&#x27;#&#x27;</span> + gotItem),</span></span><br><span class="line">          event.origin</span><br><span class="line">        );</span><br><span class="line"><span class="javascript">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&#x27;removeItem&#x27;</span> <span class="keyword">in</span> data) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">localStorage</span>.removeItem(data.removeItem);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">  &#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>方式六：修改document.domain跨子域</p><p>前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域，所以只能跨子域</p><p>在根域范围内，允许把domain属性的值设置为它的上一级域。例如，在”aaa.xxx.com”域内，可以把domain设置为 “xxx.com” 但不能设置为 “xxx.org” 或者”com”。</p><blockquote><p>现在存在两个域名aaa.xxx.com和bbb.xxx.com。在aaa下嵌入bbb的页面，由于其document.name不一致，无法在aaa下操作bbb的js。可以在aaa和bbb下通过js将document.name = ‘xxx.com’;设置一致，来达到互相访问的作用。</p></blockquote><p>方式七：WebSocket</p><p>WebSocket protocol 是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很棒的实现。相关文章，请查看：WebSocket、WebSocket-SockJS</p><p>需要注意：WebSocket对象不支持DOM 2级事件侦听器，必须使用DOM 0级语法分别定义各个事件。</p><p>方式八：代理</p><p>同源策略是针对浏览器端进行的限制，可以通过服务器端来解决该问题</p><p>DomainA客户端（浏览器） ==&gt; DomainA服务器 ==&gt; DomainB服务器 ==&gt; DomainA客户端（浏览器）</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>87. 说一下 JSONP 实现原理？</span></div>    <div class="hide-content"><p>jsonp 即 json+padding，动态创建script标签，利用script标签的src属性可以获取任何域下的js脚本，通过这个特性(也可以说漏洞)，服务器端不在返回json格式，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。</p></div></div><h2 id="第九模块：设计模式"><a href="#第九模块：设计模式" class="headerlink" title="第九模块：设计模式"></a>第九模块：设计模式</h2><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>88. 说一下你熟悉的设计模式？</span></div>    <div class="hide-content"><p><a href="https://shiming.online/blog/41682/">设计模式</a></p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>89. 简单工厂和抽象工厂有什么区别？</span></div>    <div class="hide-content"><ul><li>简单工厂<br>是由一个工厂对象创建产品实例，简单工厂模式的工厂类一般是使用静态方法，通过不同的参数的创建不同的对象实例<br>可以生产结构中的任意产品，不能增加新的产品</li><li>抽象工厂<br>提供一个创建一系列相关或相互依赖对象的接口，而无需制定他们具体的类，生产多个系列产品<br>生产不同产品族的全部产品，不能新增产品，可以新增产品族</li></ul></div></div><h2 id="第十模块：Spring-Spring-MVC"><a href="#第十模块：Spring-Spring-MVC" class="headerlink" title="第十模块：Spring / Spring MVC"></a>第十模块：Spring / Spring MVC</h2><p><a href="https://shiming.online/blog/8981">SpringCore</a></p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>90. 为什么要使用 spring？</span></div>    <div class="hide-content"><p>spring 是一个开源的轻量级 JavaBean 容器框架。使用 JavaBean 代替 EJB ，并提供了丰富的企业应用功能，降低应用开发的复杂性。</p><ul><li>轻量：非入侵性的、所依赖的东西少、资源占用少、部署简单，不同功能选择不同的 jar 组合</li><li>容器：工厂模式实现对 JavaBean 进行管理，通过控制反转（IOC）将应用程序的配置和依赖性与应用代码分开</li><li>松耦合：通过 xml 配置或注解即可完成 bean 的依赖注入</li><li>AOP：通过 xml 配置 或注解即可加入面向切面编程的能力，完成切面功能，如：日志，事务…的统一处理</li><li>方便集成：通过配置和简单的对象注入即可集成其他框架，如 Mybatis、Hibernate、Shiro…</li><li>丰富的功能：JDBC 层抽象、事务管理、MVC、Java Mail、任务调度、JMX、JMS、JNDI、EJB、动态语言、远程访问、Web Service…</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>91. 解释一下什么是 aop？</span></div>    <div class="hide-content"><p>AOP 即 Aspect Oriented Program 面向切面编程<br>面向切面编程的思想里面，把功能分为核心业务功能，和周边功能。周边功能在 Spring 的面向切面编程 AOP 思想里，即被定义为切面。<br>在面向切面编程 AOP 的思想里面，核心业务功能和切面功能分别独立进行开发，然后把切面功能和核心业务功能 “编织” 在一起，这就叫 AOP。<br><a href="https://shiming.online/blog/8981/#%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B">切面编程</a></p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>92. 解释一下什么是 ioc？</span></div>    <div class="hide-content"><p>IOC (Inversion of Control），即 “控制反转”，不是什么技术，而是一种设计思想。在 Java 开发中，IOC 意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。<br>控制的什么被反转了？获得依赖对象的方式反转了。<br><a href="https://shiming.online/blog/8981/#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%92%8C%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC">IOC和DI</a></p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>93. spring 有哪些主要模块？</span></div>    <div class="hide-content"><p>Spring框架至今已集成了20多个模块。这些模块主要被分如下图所示的核心容器，数据访问/集成，Web，AOP（面向切面编程），工具，消息和测试模块。</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200813142322.png" alt="20200813142322"><br><a href="https://shiming.online/blog/8981/#Spring%E7%BB%84%E4%BB%B6">Spring组件</a></p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>94. spring 常用的注入方式有哪些？</span></div>    <div class="hide-content"><p>Spring通过DI（依赖注入）实现IOC（控制反转），常用的注入方式主要有三种：</p><ul><li>构造方法注入</li><li>setter注入</li><li>基于注解的注入</li></ul><p><a href="https://shiming.online/blog/8981/#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">实现方式</a></p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>95. spring 中的 bean 是线程安全的吗？</span></div>    <div class="hide-content"><p>容器本身并没有提供Bean的线程安全策略，因此可以说spring容器中的Bean本身不具备线程安全的特性，但是具体还是要结合具体scope的Bean去研究。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>96. spring 支持几种 bean 的作用域？</span></div>    <div class="hide-content"><p>目前Spring Bean的作用域或者说范围主要有五种。</p><ul><li>singleton: 在spring IoC容器仅存在一个Bean实例，Bean以单例方式存在，bean作用域范围的默认值。</li><li>prototype: 每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时，相当于执行newXxxBean()。</li><li>request: 每次HTTP请求都会创建一个新的Bean，该作用域仅适用于web的Spring WebApplicationContext环境。</li><li>session: 同一个HTTP Session共享一个Bean，不同Session使用不同的Bean。该作用域仅适用于web的Spring WebApplicationContext环境。</li><li>application: 限定一个Bean的作用域为ServletContext的生命周期。该作用域仅适用于web的Spring WebApplicationContext环境。</li></ul><p><a href="https://blog.csdn.net/kongmin_123/article/details/82048392">SpringBean的作用域</a></p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>97. spring 自动装配 bean 有哪些方式？</span></div>    <div class="hide-content"><p>Spring容器负责创建应用程序中的bean同时通过ID来协调这些对象之间的关系。作为开发人员，我们需要告诉Spring要创建哪些bean并且如何将其装配到一起。</p><p>spring中bean装配有三种方式：</p><ul><li>隐式的bean发现机制和自动装配</li><li>在java代码中进行显示配置</li><li>在XML中进行装配</li></ul><p>当然这些方式也可以配合使用。<br><a href="https://shiming.online/blog/8981/#Xml%E8%A3%85%E9%85%8Dbean">xml装配bean</a></p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>98. spring 事务实现方式有哪些？</span></div>    <div class="hide-content"><ol><li>编程式事务管理对基于 POJO 的应用来说是唯一选择。我们需要在代码中调用beginTransaction()、commit()、rollback()等事务管理相关的方法，这就是编程式事务管理。</li><li>基于 TransactionProxyFactoryBean 的声明式事务管理</li><li>基于 @Transactional 的声明式事务管理</li><li>基于 Aspectj AOP 配置事务</li></ol></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>99. 说一下 spring 的事务隔离？</span></div>    <div class="hide-content"><p>事务隔离级别指的是一个事务对数据的修改与另一个并行的事务的隔离程度，当多个事务同时访问相同数据时，如果没有采取必要的隔离机制，就可能发生以下问题：</p><ul><li>脏读：一个事务读到另一个事务未提交的更新数据。</li><li>幻读：例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样。</li><li>不可重复读：比方说在同一个事务中先后执行两条一模一样的select语句，期间在此次事务中没有执行过任何DDL语句，但先后得到的结果不一致，这就是不可重复读。</li></ul><p>Spring支持的隔离级别：</p><ul><li>DEFAULT：使用数据库本身使用的隔离级别，<ul><li>ORACLE（读已提交）</li><li>MySQL（可重复读）</li></ul></li><li>READ_UNCOMITTED：读未提交（脏读）最低的隔离级别，一切皆有可能。</li><li>READ_COMMITED：读已提交，ORACLE默认隔离级别，有幻读以及不可重复读风险。</li><li>REPEATABLE_READ：可重复读，解决不可重复读的隔离级别，但还是有幻读风险。</li><li>SERLALIZABLE：串行化，最高的事务隔离级别，不管多少事务，挨个运行完一个事务的所有子事务之后才可以执行另外一个事务里面的所有子事务，这样就解决了脏读、不可重复读和幻读的问题了</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200814214542.png" alt="20200814214542"><br><a href="https://blog.csdn.net/qq_38526573/article/details/87898730">Spring事务的隔离级别</a></p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>100. 说一下 spring mvc 运行流程？</span></div>    <div class="hide-content"><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200819205025.png" alt="20200819205025"></p><ol><li>用户发送请求至前端控制器DispatcherServlet。</li><li>DispatcherServlet收到请求调用HandlerMapping处理器映射器。</li><li>处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</li><li>DispatcherServlet调用HandlerAdapter处理器适配器。</li><li>HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。</li><li>Controller执行完成返回ModelAndView。</li><li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。</li><li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器。</li><li>ViewReslover解析后返回具体View。</li><li>ispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。</li><li>DispatcherServlet响应用户。</li></ol></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>101. spring mvc 有哪些组件？</span></div>    <div class="hide-content"><p>Spring MVC的核心组件：</p><ul><li>DispatcherServlet：中央控制器，把请求给转发到具体的控制类</li><li>Controller：具体处理请求的控制器</li><li>HandlerMapping：映射处理器，负责映射中央处理器转发给controller时的映射策略</li><li>ModelAndView：服务层返回的数据和视图层的封装类</li><li>ViewResolver：视图解析器，解析具体的视图</li><li>Interceptors ：拦截器，负责拦截我们定义的请求然后做处理工作</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>102. @RequestMapping 的作用是什么？</span></div>    <div class="hide-content"><p>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。<br>RequestMapping注解有六个属性，下面我们把她分成三类进行说明。</p><p>value， method</p><ul><li>value：指定请求的实际地址，指定的地址可以是URL Template 模式；</li><li>method：指定请求的method类型， GET、POST、PUT、DELETE等；</li></ul><p>consumes，produces</p><ul><li>consumes：指定处理请求的提交内容类型（Content-Type），例如application/json, text/html；</li><li>produces：指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；</li></ul><p>params，headers</p><ul><li>params： 指定request中必须包含某些参数值时，才让该方法处理。</li><li>headers：指定request中必须包含某些指定的header值，才能让该方法处理请求。</li></ul><p><a href="https://shiming.online/blog/4780/#%E8%B7%AF%E5%BE%84%E6%98%A0%E5%B0%84">@RequestMapping解释</a></p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>103. @Autowired 的作用是什么？</span></div>    <div class="hide-content"><p>属于 Spring 的 org.springframework.beans.factory.annotation 包下，可用于为类的属性、构造器、方法进行注值<br><a href="https://shiming.online/blog/8981/#Autowired">@Autowired解释</a></p></div></div><h2 id="第十一模块：Spring-Boot-Spring-Cloud"><a href="#第十一模块：Spring-Boot-Spring-Cloud" class="headerlink" title="第十一模块：Spring Boot / Spring Cloud"></a>第十一模块：Spring Boot / Spring Cloud</h2><p><a href="https://shiming.online/blog/20547/">SpringBoot搭建</a></p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>104. 什么是 spring boot？</span></div>    <div class="hide-content"><p>在Spring框架这个大家族中，产生了很多衍生框架，比如 Spring、SpringMVC框架等，Spring的核心内容在于控制反转(IOC)和依赖注入(DI),所谓控制反转并非是一种技术，而是一种思想，在操作方面是指在spring配置文件中创建<code>&lt;bean&gt;</code>，依赖注入即为由spring容器为应用程序的某个对象提供资源，比如 引用对象、常量数据等。</p><p>SpringBoot是一个框架，一种全新的编程规范，他的产生简化了框架的使用，所谓简化是指简化了Spring众多框架中所需的大量且繁琐的配置文件，所以 SpringBoot是一个服务于框架的框架，服务范围是简化配置文件。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>105. 为什么要用 spring boot？</span></div>    <div class="hide-content"><ul><li>Spring Boot使编码变简单</li><li>Spring Boot使配置变简单</li><li>Spring Boot使部署变简单</li><li>Spring Boot使监控变简单</li><li>Spring的不足</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>106. spring boot 核心配置文件是什么？</span></div>    <div class="hide-content"><p>Spring Boot提供了两种常用的配置文件：</p><ul><li>properties文件</li><li>yml文件</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>107. spring boot 配置文件有哪几种类型？它们有什么区别？</span></div>    <div class="hide-content"><p>Spring Boot提供了两种常用的配置文件，分别是properties文件和yml文件。相对于properties文件而言，yml文件更年轻，也有很多的坑。可谓成也萧何败萧何，yml通过空格来确定层级关系，使配置文件结构跟清晰，但也会因为微不足道的空格而破坏了层级关系</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>108. spring boot 有哪些方式可以实现热部署？</span></div>    <div class="hide-content"><p>SpringBoot热部署实现有两种方式：</p><ol><li><p>使用spring loaded<br> 在项目中添加如下插件：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- springBoot编译插件--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- spring热部署 --&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 该依赖在此处下载不下来，可以放置在build标签外部下载完成后再粘贴进plugin中 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springloaded<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 添加完毕后需要使用mvn指令运行：<br> 首先找到IDEA中的Edit configurations ,然后进行如下操作：（点击左上角的”+”,然后选择maven将出现右侧面板，在红色划线部位输入如图所示指令，你可以为该指令命名(此处命名为MvnSpringBootRun)）<br> <img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200814095230.png" alt="20200814095230"><br> 点击保存将会在IDEA项目运行部位出现，点击绿色箭头运行即可</p></li><li><p>使用spring-boot-devtools<br>在项目的pom文件中添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--热部署jar--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 然后：使用 <code>shift+ctrl+alt+&quot;/&quot;</code> （IDEA中的快捷键） 选择”Registry” 然后勾选 compiler.automake.allow.when.app.running</p></li></ol></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>109. jpa 和 hibernate 有什么区别？</span></div>    <div class="hide-content"><ul><li>JPA Java Persistence API，是Java EE 5的标准ORM接口，也是ejb3规范的一部分。</li><li>Hibernate，当今很流行的ORM框架，是JPA的一个实现，但是其功能是JPA的超集。</li><li>JPA和Hibernate之间的关系，可以简单的理解为JPA是标准接口，Hibernate是实现。那么Hibernate是如何实现与JPA的这种关系的呢。Hibernate主要是通过三个组件来实现的，及hibernate-annotation、hibernate-entitymanager和hibernate-core。</li><li>hibernate-annotation是Hibernate支持annotation方式配置的基础，它包括了标准的JPA annotation以及Hibernate自身特殊功能的annotation。</li><li>hibernate-core是Hibernate的核心实现，提供了Hibernate所有的核心功能。</li><li>hibernate-entitymanager实现了标准的JPA，可以把它看成hibernate-core和JPA之间的适配器，它并不直接提供ORM的功能，而是对hibernate-core进行封装，使得Hibernate符合JPA的规范。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>110. 什么是 spring cloud？</span></div>    <div class="hide-content"><p>从字面理解，Spring Cloud 就是致力于分布式系统、云服务的框架。</p><p>Spring Cloud 是整个 Spring 家族中新的成员，是最近云服务火爆的必然产物。</p><p>Spring Cloud 为开发人员提供了快速构建分布式系统中一些常见模式的工具，例如：</p><ul><li>配置管理</li><li>服务注册与发现</li><li>断路器</li><li>智能路由</li><li>服务间调用</li><li>负载均衡</li><li>微代理</li><li>控制总线</li><li>一次性令牌</li><li>全局锁</li><li>领导选举</li><li>分布式会话</li><li>集群状态</li><li>分布式消息</li><li>……</li></ul><p>使用 Spring Cloud 开发人员可以开箱即用的实现这些模式的服务和应用程序。这些服务可以任何环境下运行，包括分布式环境，也包括开发人员自己的笔记本电脑以及各种托管平台。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>111. spring cloud 断路器的作用是什么？</span></div>    <div class="hide-content"><p>在Spring Cloud中使用了Hystrix 来实现断路器的功能，断路器可以防止一个应用程序多次试图执行一个操作，即很可能失败，允许它继续而不等待故障恢复或者浪费 CPU 周期，而它确定该故障是持久的。断路器模式也使应用程序能够检测故障是否已经解决，如果问题似乎已经得到纠正，应用程序可以尝试调用操作。</p><p>断路器增加了稳定性和灵活性，以一个系统，提供稳定性，而系统从故障中恢复，并尽量减少此故障的对性能的影响。它可以帮助快速地拒绝对一个操作，即很可能失败，而不是等待操作超时（或者不返回）的请求，以保持系统的响应时间。如果断路器提高每次改变状态的时间的事件，该信息可以被用来监测由断路器保护系统的部件的健康状况，或以提醒管理员当断路器跳闸，以在打开状态。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>112. spring cloud 的核心组件有哪些？</span></div>    <div class="hide-content"><ol><li>服务发现——Netflix Eureka<br> 一个RESTful服务，用来定位运行在AWS地区（Region）中的中间层服务。由两个组件组成：Eureka服务器和Eureka客户端。Eureka服务器用作服务注册服务器。Eureka客户端是一个java客户端，用来简化与服务器的交互、作为轮询负载均衡器，并提供服务的故障切换支持。Netflix在其生产环境中使用的是另外的客户端，它提供基于流量、资源利用率以及出错状态的加权负载均衡。</li><li>客服端负载均衡——Netflix Ribbon<br> Ribbon，主要提供客户侧的软件负载均衡算法。Ribbon客户端组件提供一系列完善的配置选项，比如连接超时、重试、重试算法等。Ribbon内置可插拔、可定制的负载均衡组件。</li><li>断路器——Netflix Hystrix<br> 断路器可以防止一个应用程序多次试图执行一个操作，即很可能失败，允许它继续而不等待故障恢复或者浪费 CPU 周期，而它确定该故障是持久的。断路器模式也使应用程序能够检测故障是否已经解决。如果问题似乎已经得到纠正，应用程序可以尝试调用操作。</li><li>服务网关——Netflix Zuul<br> 类似nginx，反向代理的功能，不过netflix自己增加了一些配合其他组件的特性。</li><li>分布式配置——Spring Cloud Config<br> 这个还是静态的，得配合Spring Cloud Bus实现动态的配置更新。</li></ol></div></div><h2 id="第十二模块：Hibernate"><a href="#第十二模块：Hibernate" class="headerlink" title="第十二模块：Hibernate"></a>第十二模块：Hibernate</h2><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>113. 为什么要使用 hibernate？</span></div>    <div class="hide-content"><ul><li>对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。</li><li>Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现。他很大程度的简化DAO层的编码工作</li><li>hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。</li><li>hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>114. 什么是 ORM 框架？</span></div>    <div class="hide-content"><p>对象-关系映射（Object-Relational Mapping，简称ORM），面向对象的开发方法是当今企业级应用开发环境中的主流开发方法，关系数据库是企业级应用环境中永久存放数据的主流数据存储系统。对象和关系数据是业务实体的两种表现形式，业务实体在内存中表现为对象，在数据库中表现为关系数据。内存中的对象之间存在关联和继承关系，而在数据库中，关系数据无法直接表达多对多关联和继承关系。因此，对象-关系映射(ORM)系统一般以中间件的形式存在，主要实现程序对象到关系数据库数据的映射。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>115. hibernate 中如何在控制台查看打印的 sql 语句？</span></div>    <div class="hide-content"><p><a href="https://blog.csdn.net/Randy_Wang_/article/details/79460306">参考</a></p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>116. hibernate 有几种查询方式？</span></div>    <div class="hide-content"><ol><li>hql查询</li><li>sql查询</li><li>条件查询</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// hql查询，sql查询，条件查询</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HQL:  Hibernate Query Language. 面向对象的写法:</span></span><br><span class="line">Query query = session.createQuery(<span class="string">&quot;from Customer where name = ?&quot;</span>);</span><br><span class="line">query.setParameter(<span class="number">0</span>, <span class="string">&quot;苍老师&quot;</span>);</span><br><span class="line">Query.list();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// QBC:  Query By Criteria.(条件查询)</span></span><br><span class="line">Criteria criteria = session.createCriteria(Customer.class);</span><br><span class="line">criteria.add(Restrictions.eq(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;花姐&quot;</span>));</span><br><span class="line">List&lt;Customer&gt; list = criteria.list();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// SQL:</span></span><br><span class="line">SQLQuery query = session.createSQLQuery(<span class="string">&quot;select * from customer&quot;</span>);</span><br><span class="line">List&lt;Object[]&gt; list = query.list();</span><br><span class="line"></span><br><span class="line">SQLQuery query = session.createSQLQuery(<span class="string">&quot;select * from customer&quot;</span>);</span><br><span class="line">query.addEntity(Customer.class);</span><br><span class="line">List&lt;Customer&gt; list = query.list();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Hql： 具体分类</span></span><br><span class="line"><span class="comment">// 1、 属性查询 2、 参数查询、命名参数查询 3、 关联查询 4、 分页查询 5、 统计函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// HQL和SQL的区别</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HQL是面向对象查询操作的，SQL是结构化查询语言 是面向数据库表结构的</span></span><br></pre></td></tr></table></figure></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>117. hibernate 实体类可以被定义为 final 吗？</span></div>    <div class="hide-content"><p>可以将Hibernate的实体类定义为final类，但这种做法并不好。因为Hibernate会使用代理模式在延迟关联的情况下提高性能，如果你把实体类定义成final类之后，因为 Java不允许对final类进行扩展，所以Hibernate就无法再使用代理了，如此一来就限制了使用可以提升性能的手段。不过，如果你的持久化类实现了一个接口而且在该接口中声明了所有定义于实体类中的所有public的方法轮到话，你就能够避免出现前面所说的不利后果。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>118. 在 hibernate 中使用 Integer 和 int 做映射有什么区别？</span></div>    <div class="hide-content"><p>在Hibernate中，如果将OID定义为Integer类型，那么Hibernate就可以根据其值是否为null而判断一个对象是否是临时的，如果将OID定义为了int类型，还需要在hbm映射文件中设置其unsaved-value属性为0。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>119. hibernate 是如何工作的？</span></div>    <div class="hide-content"><p>hibernate工作原理：</p><ol><li>通过Configuration config = new Configuration().configure();//读取并解析hibernate.cfg.xml配置文件</li><li>由hibernate.cfg.xml中的<code>&lt;mapping resource=&quot;com/xx/User.hbm.xml&quot;/&gt;</code>读取并解析映射信息</li><li>通过SessionFactory sf = config.buildSessionFactory();//创建SessionFactory</li><li>Session session = sf.openSession();//打开Sesssion</li><li>Transaction tx = session.beginTransaction();//创建并启动事务Transation</li><li>persistent operate操作数据，持久化操作</li><li>tx.commit();//提交事务</li><li>关闭Session</li><li>关闭SesstionFactory</li></ol></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>120. get()和 load()的区别？</span></div>    <div class="hide-content"><ul><li>load() 没有使用对象的其他属性的时候，没有SQL  延迟加载</li><li>get() 没有使用对象的其他属性的时候，也生成了SQL  立即加载</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>121. 说一下 hibernate 的缓存机制？</span></div>    <div class="hide-content"><p>Hibernate中的缓存分为一级缓存和二级缓存。</p><p>一级缓存就是  Session 级别的缓存，在事务范围内有效是,内置的不能被卸载。二级缓存是 SesionFactory级别的缓存，从应用启动到应用结束有效。是可选的，默认没有二级缓存，需要手动开启。保存数据库后，缓存在内存中保存一份，如果更新了数据库就要同步更新。</p><p>什么样的数据适合存放到第二级缓存中？</p><ul><li>很少被修改的数据   帖子的最后回复时间</li><li>经常被查询的数据   电商的地点</li><li>不是很重要的数据，允许出现偶尔并发的数据</li><li>不会被并发访问的数据</li><li>常量数据</li></ul><p>扩展：hibernate的二级缓存默认是不支持分布式缓存的。使用  memcahe,redis等中央缓存来代替二级缓存。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>122. hibernate 对象有哪些状态？</span></div>    <div class="hide-content"><p>hibernate里对象有三种状态：</p><ol><li>Transient（瞬时）：对象刚new出来，还没设id，设了其他值。</li><li>Persistent（持久）：调用了save()、saveOrUpdate()，就变成Persistent，有id。</li><li>Detached（脱管）：当session  close()完之后，变成Detached。</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200814100403.png" alt="20200814100403"></p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>123. 在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？</span></div>    <div class="hide-content"><p>openSession 从字面上可以看得出来，是打开一个新的session对象，而且每次使用都是打开一个新的session，假如连续使用多次，则获得的session不是同一个对象，并且使用完需要调用close方法关闭session。</p><p>getCurrentSession ，从字面上可以看得出来，是获取当前上下文一个session对象，当第一次使用此方法时，会自动产生一个session对象，并且连续使用多次时，得到的session都是同一个对象，这就是与openSession的区别之一，简单而言，getCurrentSession 就是：如果有已经使用的，用旧的，如果没有，建新的。</p><p>注意：在实际开发中，往往使用getCurrentSession多，因为一般是处理同一个事务（即是使用一个数据库的情况），所以在一般情况下比较少使用openSession或者说openSession是比较老旧的一套接口了。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>124. hibernate 实体类必须要有无参构造函数吗？为什么？</span></div>    <div class="hide-content"><p>必须，因为hibernate框架会调用这个默认构造方法来构造实例对象，即Class类的newInstance方法，这个方法就是通过调用默认构造方法来创建实例对象的。</p><p>另外再提醒一点，如果你没有提供任何构造方法，虚拟机会自动提供默认构造方法（无参构造器），但是如果你提供了其他有参数的构造方法的话，虚拟机就不再为你提供默认构造方法，这时必须手动把无参构造器写在代码里，否则new Xxxx()是会报错的，所以默认的构造方法不是必须的，只在有多个构造方法时才是必须的，这里“必须”指的是“必须手动写出来”。</p></div></div><h2 id="第十三模块：Mybatis"><a href="#第十三模块：Mybatis" class="headerlink" title="第十三模块：Mybatis"></a>第十三模块：Mybatis</h2><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>125. mybatis 中 #{}和 ${}的区别是什么？</span></div>    <div class="hide-content"><ul><li><code>#{}</code>是预编译处理，<code>${}</code>是字符串替换；</li><li>Mybatis在处理<code>#{}</code>时，会将sql中的<code>#{}</code>替换为?号，调用PreparedStatement的set方法来赋值；</li><li>Mybatis在处理<code>${}</code>时，就是把<code>${}</code>替换成变量的值；</li><li>使用<code>#{}</code>可以有效的防止SQL注入，提高系统安全性。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>126. mybatis 有几种分页方式？</span></div>    <div class="hide-content"><ol><li>数组分页<br>一次性查询所有结果，再从结果中截取</li><li>sql分页<br>使用 sql 语句中的<code>limit</code></li><li>拦截器分页<br>插件：pagehelper</li><li>RowBounds分页<br>一次性获取所有数据，然后在内存中操作</li></ol></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>127.</span></div>    <div class="hide-content"></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>128. mybatis 逻辑分页和物理分页的区别是什么？</span></div>    <div class="hide-content"><p>逻辑分页：RowBounds<br>物理分页：其他三种方式</p><ul><li>逻辑分页：内存开销比较大,在数据量比较小的情况下效率比物理分页高;在数据量很大的情况下,内存开销过大,容易内存溢出,不建议使用</li><li>物理分页：内存开销比较小,在数据量比较小的情况下效率比逻辑分页<br>低,在数据量很大的情况下,建议使用物理分页</li></ul><p>总结：</p><ul><li>物理分页速度上并不一定快于逻辑分页，逻辑分页速度上也并不一定快于物理分页。</li><li>物理分页总是优于逻辑分页：没有必要将属于数据库端的压力加诸到应用端来，就算速度上存在劣势,然而其它性能上的优点足以弥补这个缺点。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>129. mybatis 是否支持延迟加载？延迟加载的原理是什么？</span></div>    <div class="hide-content"><p>Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载<code>mybatis.configuration.lazy-loading-enabled=true|false</code><br>。</p><p>延迟加载主要是通过动态代理的形式实现，通过代理拦截到指定方法，执行数据加载。</p><p>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p><p>当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>130. 说一下 mybatis 的一级缓存和二级缓存？</span></div>    <div class="hide-content"><p>Mybatis的一级缓存是指Session缓存。一级缓存的作用域默认是一个SqlSession。Mybatis默认开启一级缓存。<br>也就是在同一个SqlSession中，执行相同的查询SQL，第一次会去数据库进行查询，并写到缓存中；<br>第二次以后是直接去缓存中取。</p><p>当执行SQL查询中间发生了增删改的操作，MyBatis会把SqlSession的缓存清空。</p><p>一级缓存的范围有SESSION和STATEMENT两种，默认是SESSION，如果不想使用一级缓存，可以把一级缓存的范围指定为STATEMENT，这样每次执行完一个Mapper中的语句后都会将一级缓存清除。</p><p>二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于二级缓存的作用域是同一个namespace下的mapper映射文件内容，多个SqlSession共享，并且可自定义存储源，如 Ehcache。<br>默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置<code>&lt;cache/&gt; ；</code></p><p>对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>131. mybatis 和 hibernate 的区别有哪些？</span></div>    <div class="hide-content"><ol><li>Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句。</li><li>Mybatis直接编写原生态sql，可以严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，因为这类软件需求变化频繁，一但需求变化要求迅速输出成果。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件，则需要自定义多套sql映射文件，工作量大。</li><li>Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件，如果用hibernate开发可以节省很多代码，提高效率。</li></ol></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>132. mybatis 有哪些执行器（Executor）？</span></div>    <div class="hide-content"><p>Mybatis有三种基本的执行器（Executor）：</p><ol><li><strong>SimpleExecutor</strong>：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</li><li><strong>ReuseExecutor</strong>：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map内，供下一次使用。简言之，就是重复使用Statement对象。</li><li><strong>BatchExecutor</strong>：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</li></ol></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>133. mybatis 分页插件的实现原理是什么？</span></div>    <div class="hide-content"><p>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>134. mybatis 如何编写一个自定义插件？</span></div>    <div class="hide-content"><p><a href="https://blog.csdn.net/qq_30051265/article/details/80266434">参考</a></p></div></div><h2 id="第十四模块：RabbitMQ"><a href="#第十四模块：RabbitMQ" class="headerlink" title="第十四模块：RabbitMQ"></a>第十四模块：RabbitMQ</h2><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>135. rabbitmq 的使用场景有哪些？</span></div>    <div class="hide-content"><ul><li>应用耦合：多应用间通过消息队列对同一消息进行处理，避免调用接口失败导致整个过程失败；</li><li>异步处理：多应用对消息队列中同一消息进行处理，应用间并发处理消息，相比串行处理，减少处理时间；</li><li>限流削峰：广泛应用于秒杀或抢购活动中，避免流量过大导致应用系统挂掉的情况；</li><li>消息驱动的系统：系统分为消息队列、消息生产者、消息消费者，生产者负责产生消息，消费者(可能有多个)负责对消息进行处理；</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>136. rabbitmq 有哪些重要的角色？</span></div>    <div class="hide-content"><p>RabbitMQ 中重要的角色有：生产者、消费者和代理：</p><ul><li>生产者：消息的创建者，负责创建和推送数据到消息服务器；</li><li>消费者：消息的接收方，用于处理数据和确认消息；</li><li>代理：就是 RabbitMQ 本身，用于扮演“邮局”的角色，本身不生产消息，只是扮演“邮局”的角色。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>137. rabbitmq 有哪些重要的组件？</span></div>    <div class="hide-content"><ul><li>ConnectionFactory（连接管理器）：应用程序与Rabbit之间建立连接的管理器，程序代码中使用。</li><li>Channel（信道）：消息推送使用的通道。</li><li>Exchange（交换器）：用于接受、分配消息。</li><li>Queue（队列）：用于存储生产者的消息。</li><li>RoutingKey（路由键）：用于把生成者的数据分配到交换器上。</li><li>BindingKey（绑定键）：用于把交换器的消息绑定到队列上。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>138. rabbitmq 中 vhost 的作用是什么？</span></div>    <div class="hide-content"><p>vhost 可以理解为虚拟 broker ，即 mini-RabbitMQ  server。其内部均含有独立的 queue、exchange 和 binding 等，但最最重要的是，其拥有独立的权限系统，可以做到 vhost 范围的用户控制。当然，从 RabbitMQ 的全局角度，vhost 可以作为不同权限隔离的手段（一个典型的例子就是不同的应用可以跑在不同的 vhost 中）。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>139. rabbitmq 的消息是怎么发送的？</span></div>    <div class="hide-content"><p>首先客户端必须连接到 RabbitMQ 服务器才能发布和消费消息，客户端和 rabbit server 之间会创建一个 tcp 连接，一旦 tcp 打开并通过了认证（认证就是你发送给 rabbit 服务器的用户名和密码），你的客户端和 RabbitMQ 就创建了一条 amqp 信道（channel），信道是创建在“真实” tcp 上的虚拟连接，amqp 命令都是通过信道发送出去的，每个信道都会有一个唯一的 id，不论是发布消息，订阅队列都是通过这个信道完成的。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>140. rabbitmq 怎么保证消息的稳定性？</span></div>    <div class="hide-content"><ul><li>提供了事务的功能。</li><li>通过将 channel 设置为 confirm（确认）模式。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>141. rabbitmq 怎么避免消息丢失？</span></div>    <div class="hide-content"><ol><li>消息持久化</li><li>ACK确认机制</li><li>设置集群镜像模式</li><li>消息补偿机制</li></ol></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>142. 要保证消息持久化成功的条件有哪些？</span></div>    <div class="hide-content"><ul><li>声明队列必须设置持久化 durable 设置为 true.</li><li>消息推送投递模式必须设置持久化，deliveryMode 设置为 2（持久）。</li><li>消息已经到达持久化交换器。</li><li>消息已经到达持久化队列。</li></ul><p>以上四个条件都满足才能保证消息持久化成功。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>143. rabbitmq 持久化有什么缺点？</span></div>    <div class="hide-content"><p>持久化的缺点就是降低了服务器的吞吐量，因为使用的是磁盘而非内存存储，从而降低了吞吐量。可尽量使用 ssd 硬盘来缓解吞吐量的问题。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>144. rabbitmq 有几种广播类型？</span></div>    <div class="hide-content"><p>三种广播模式：</p><ul><li>fanout: 所有bind到此exchange的queue都可以接收消息（纯广播，绑定到RabbitMQ的接受者都能收到消息）；</li><li>direct: 通过routingKey和exchange决定的那个唯一的queue可以接收消息；</li><li>topic:所有符合routingKey(此时可以是一个表达式)的routingKey所bind的queue可以接收消息；</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>145. rabbitmq 怎么实现延迟消息队列？</span></div>    <div class="hide-content"><ol><li>通过消息过期后进入死信交换器，再由交换器转发到延迟消费队列，实现延迟功能；</li><li>使用 RabbitMQ-delayed-message-exchange 插件实现延迟功能。</li></ol></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>146. rabbitmq 集群有什么用？</span></div>    <div class="hide-content"><p>集群主要有以下两个用途：</p><ol><li>高可用：某个服务器出现问题，整个 RabbitMQ 还可以继续使用；</li><li>高容量：集群可以承载更多的消息量。</li></ol></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>147. rabbitmq 节点的类型有哪些？</span></div>    <div class="hide-content"><ul><li>磁盘节点：消息会存储到磁盘。</li><li>内存节点：消息都存储在内存中，重启服务器消息丢失，性能高于磁盘类型。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>148. rabbitmq 集群搭建需要注意哪些问题？</span></div>    <div class="hide-content"><ul><li>各节点之间使用“–link”连接，此属性不能忽略。</li><li>各节点使用的 erlang cookie 值必须相同，此值相当于“秘钥”的功能，用于各节点的认证。</li><li>整个集群中必须包含一个磁盘节点。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>149. rabbitmq 每个节点是其他节点的完整拷贝吗？为什么？</span></div>    <div class="hide-content"><p>不是，原因有以下两个：</p><ol><li>存储空间的考虑：如果每个节点都拥有所有队列的完全拷贝，这样新增节点不但没有新增存储空间，反而增加了更多的冗余数据；</li><li>性能的考虑：如果每条消息都需要完整拷贝到每一个集群节点，那新增节点并没有提升处理消息的能力，最多是保持和单节点相同的性能甚至是更糟。</li></ol></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>150. rabbitmq 集群中唯一一个磁盘节点崩溃了会发生什么情况？</span></div>    <div class="hide-content"><p>如果唯一磁盘的磁盘节点崩溃了，不能进行以下操作：</p><ul><li>不能创建队列</li><li>不能创建交换器</li><li>不能创建绑定</li><li>不能添加用户</li><li>不能更改权限</li><li>不能添加和删除集群节点</li></ul><p>唯一磁盘节点崩溃了，集群是可以保持运行的，但你不能更改任何东西。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>151. rabbitmq 对集群节点停止顺序有要求吗？</span></div>    <div class="hide-content"><p>RabbitMQ 对集群的停止的顺序是有要求的，应该先关闭内存节点，最后再关闭磁盘节点。如果顺序恰好相反的话，可能会造成消息的丢失。</p></div></div><h2 id="第十五模块：Kafka"><a href="#第十五模块：Kafka" class="headerlink" title="第十五模块：Kafka"></a>第十五模块：Kafka</h2><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>152. kafka 可以脱离 zookeeper 单独使用吗？为什么？</span></div>    <div class="hide-content"><p>kafka 不能脱离 zookeeper 单独使用，因为 kafka 使用 zookeeper 管理和协调 kafka 的节点服务器。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>153. kafka 有几种数据保留的策略？</span></div>    <div class="hide-content"><p>kafka 有两种数据保存策略：按照过期时间保留和按照存储的消息大小保留。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>154. kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？</span></div>    <div class="hide-content"><p>这个时候 kafka 会执行数据清除工作，时间和大小不论那个满足条件，都会清空数据。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>155. 什么情况会导致 kafka 运行变慢？</span></div>    <div class="hide-content"><ul><li>cpu 性能瓶颈</li><li>磁盘读写瓶颈</li><li>网络瓶颈</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>156. 使用 kafka 集群需要注意什么？</span></div>    <div class="hide-content"><ul><li>集群的数量不是越多越好，最好不要超过 7 个，因为节点越多，消息复制需要的时间就越长，整个群组的吞吐量就越低。</li><li>集群数量最好是单数，因为超过一半故障集群就不能用了，设置为单数容错率更高。</li></ul></div></div><h2 id="第十六模块：Zookeeper"><a href="#第十六模块：Zookeeper" class="headerlink" title="第十六模块：Zookeeper"></a>第十六模块：Zookeeper</h2><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>157. zookeeper 是什么？</span></div>    <div class="hide-content"><p>zookeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 google chubby 的开源实现，是 hadoop 和 hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>158. zookeeper 都有哪些功能？</span></div>    <div class="hide-content"><ul><li>集群管理：监控节点存活状态、运行请求等。</li><li>主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 zookeeper 可以协助完成这个过程。</li><li>分布式锁：zookeeper 提供两种锁：独占锁、共享锁。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。zookeeper可以对分布式锁进行控制。</li><li>命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>159. zookeeper 有几种部署模式？</span></div>    <div class="hide-content"><p>zookeeper 有三种部署模式：</p><ul><li>单机部署：一台集群上运行；</li><li>集群部署：多台集群运行；</li><li>伪集群部署：一台集群启动多个 zookeeper 实例运行。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>160. zookeeper 怎么保证主从节点的状态同步？</span></div>    <div class="hide-content"><p>zookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 zab 协议。 zab 协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>161. 集群中为什么要有主节点？</span></div>    <div class="hide-content"><p>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>162. 集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？</span></div>    <div class="hide-content"><p>可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>163. 说一下 zookeeper 的通知机制？</span></div>    <div class="hide-content"><p>客户端端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些客户端会收到 zookeeper 的通知，然后客户端可以根据 znode 变化来做出业务上的改变。</p></div></div><h2 id="第十七模块：MySQL"><a href="#第十七模块：MySQL" class="headerlink" title="第十七模块：MySQL"></a>第十七模块：MySQL</h2><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>164. 数据库的三范式是什么？</span></div>    <div class="hide-content"><ul><li>第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。</li><li>第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。</li><li>第三范式：任何非主属性不依赖于其它非主属性。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>165. 一张自增表里面总共有 17 条数据，删除了最后 2 条数据，重启 mysql 数据库，又插入了一条数据，此时 id 是几？</span></div>    <div class="hide-content"><ul><li>表类型如果是 MyISAM ，那 id 就是 18。</li><li>表类型如果是 InnoDB，那 id 就是 15。</li></ul><p>InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>166. 如何获取当前数据库版本？</span></div>    <div class="hide-content"><p>使用 select version() 获取当前 MySQL 数据库版本。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>167. 说一下 ACID 是什么？</span></div>    <div class="hide-content"><ul><li>Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li><li>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。</li><li>Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li><li>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>168. char 和 varchar 的区别是什么？</span></div>    <div class="hide-content"><p>char(n) ：固定长度类型，比如订阅 char(10)，当你输入”abc”三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。</p><p>chat 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。</p><p>varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。</p><p>所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>169. float 和 double 的区别是什么？</span></div>    <div class="hide-content"><ul><li>float 最多可以存储 8 位的十进制数，并在内存中占 4 字节。</li><li>double 最可可以存储 16 位的十进制数，并在内存中占 8 字节。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>170. mysql 的内连接、左连接、右连接有什么区别？</span></div>    <div class="hide-content"><p>内连接关键字：inner join；左连接：left join；右连接：right join。</p><p>内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>171. mysql 索引是怎么实现的？</span></div>    <div class="hide-content"><p>索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。</p><p>具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>172. 怎么验证 mysql 的索引是否满足需求？</span></div>    <div class="hide-content"><p>使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。</p><p>explain 语法：<code>explain select * from table where type=1</code>。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>173. 说一下数据库的事务隔离？</span></div>    <div class="hide-content"><ol><li><strong>读未提交：read uncommitted</strong><br>SELECT语句以非锁定方式被执行，所以有可能读到脏数据，隔离级别最低。（读不锁）</li><li><strong>读已提交：read committed</strong><br>只能读取到已经提交的数据。即解决了脏读，但未解决不可重复读。（读锁，等写完）</li><li><strong>可重复读：repeatable read</strong><br>在同一个事务内的查询都是事务开始时刻一致的，InnoDB的默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻读。(写锁，等读完)</li><li><strong>串行化：serializable</strong><br>完全的串行化读，所有SELECT语句都被隐式的转换成SELECT … LOCK IN SHARE MODE，即读取使用表级共享锁，读写相互都会阻塞。隔离级别最高。(以上3个均为行锁/记录锁，当前为表锁)</li></ol></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>174. 说一下 mysql 常用的引擎？</span></div>    <div class="hide-content"><p>InnoDB 引擎：InnoDB 引擎提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。</p><p>MyIASM 引擎：MySQL 的默认引擎，但不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>175. 说一下 mysql 的行锁和表锁？</span></div>    <div class="hide-content"><p>MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。</p><ul><li>表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。</li><li>行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>176. 说一下乐观锁和悲观锁？</span></div>    <div class="hide-content"><ul><li>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。</li><li>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。</li></ul><p>数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>177. mysql 问题排查都有哪些手段？</span></div>    <div class="hide-content"><ul><li>使用 show processlist 命令查看当前所有连接信息。</li><li>使用 explain 命令查询 SQL 语句执行计划。</li><li>开启慢查询日志，查看慢查询的 SQL。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>178. 如何做 mysql 的性能优化？</span></div>    <div class="hide-content"><ul><li>为搜索字段创建索引。</li><li>避免使用 select *，列出需要查询的字段。</li><li>垂直分割分表。</li><li>选择正确的存储引擎。</li></ul></div></div><h2 id="第十八模块：Redis"><a href="#第十八模块：Redis" class="headerlink" title="第十八模块：Redis"></a>第十八模块：Redis</h2><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>179. redis 是什么？都有哪些使用场景？</span></div>    <div class="hide-content"><p><a href="https://shiming.online/blog/27273/#Redis">Redis</a><br>Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。<br>Redis 使用场景：</p><ul><li>数据高并发的读写</li><li>海量数据的读写</li><li>对扩展性要求高的数据</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>180. redis 有哪些功能？</span></div>    <div class="hide-content"><ul><li>数据缓存功能</li><li>分布式锁的功能</li><li>支持数据持久化</li><li>支持事务</li><li>支持消息队列</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>181. redis 和 memecache 有什么区别？</span></div>    <div class="hide-content"><ul><li>memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型</li><li>redis的速度比memcached快很多</li><li>redis可以持久化其数据</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>182. redis 为什么是单线程的？</span></div>    <div class="hide-content"><p>Redis 是基于内存操作，CPU 不是 Redis 性能瓶颈，Redis 的瓶颈是机器的内存和网络带宽。既然可以使用单线程，就是用单线程了。</p><p>关于 Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。</p><p>而且单线程并不代表就慢， nginx 和 nodejs 也都是高性能单线程的代表。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>183. 什么是缓存穿透？怎么解决？</span></div>    <div class="hide-content"><p><a href="https://shiming.online/blog/48573/">缓存穿透，缓存击穿和雪崩</a><br>缓存穿透：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。</p><p>解决方案：最简单粗暴的方法如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>184. redis 支持的数据类型有哪些？</span></div>    <div class="hide-content"><p><a href="https://shiming.online/blog/6834/">Redis数据类型</a><br>五种基础数据类型：string、list、hash、set、zset。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>186. jedis 和 redisson 有哪些区别？</span></div>    <div class="hide-content"><p>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持。</p><p>Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>187. 怎么保证缓存和数据库数据的一致性？</span></div>    <div class="hide-content"><ul><li>合理设置缓存的过期时间。</li><li>新增、更改、删除数据库操作时同步更新 Redis，可以使用事务机制来保证数据的一致性。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>188. redis 持久化有几种方式？</span></div>    <div class="hide-content"><p><a href="https://shiming.online/blog/62112/">Redis持久化</a><br>Redis 的持久化有两种方式，或者说有两种策略：</p><ul><li>RDB（Redis Database）：指定的时间间隔能对你的数据进行快照存储。</li><li>AOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>189. redis 怎么实现分布式锁？</span></div>    <div class="hide-content"><p>Redis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。</p><p>占坑一般使用 setnx(set if not exists)指令，只允许被一个程序占有，使用完调用 del 释放锁。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>190. redis 分布式锁有什么缺陷？</span></div>    <div class="hide-content"><p>Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>191. redis 如何做内存优化？</span></div>    <div class="hide-content"><p>尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。</p><p>比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>192. redis 淘汰策略有哪些？</span></div>    <div class="hide-content"><ul><li>volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。</li><li>volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。</li><li>volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。</li><li>allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。</li><li>allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。</li><li>no-enviction（驱逐）：禁止驱逐数据。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>193. redis 常见的性能问题有哪些？该如何解决？</span></div>    <div class="hide-content"><ul><li>主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。</li><li>Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。</li></ul></div></div><h2 id="第十九模块：JVM"><a href="#第十九模块：JVM" class="headerlink" title="第十九模块：JVM"></a>第十九模块：JVM</h2><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>194. 说一下 jvm 的主要组成部分？及其作用？</span></div>    <div class="hide-content"><ul><li>类加载器（ClassLoader）</li><li>运行时数据区（Runtime Data Area）</li><li>执行引擎（Execution Engine）</li><li>本地库接口（Native Interface）</li></ul><p>组件的作用： 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>195. 说一下 jvm 运行时数据区？</span></div>    <div class="hide-content"><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li><li>堆</li><li>方法区</li></ul><p>有的区域随着虚拟机进程的启动而存在，有的区域则依赖用户进程的启动和结束而创建和销毁。</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200814114057.png" alt="20200814114057"></p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>196. 说一下堆栈的区别？</span></div>    <div class="hide-content"><ol><li>栈内存存储的是局部变量而堆内存存储的是实体；</li><li>栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短；</li><li>栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。</li></ol></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>197. 队列和栈是什么？有什么区别？</span></div>    <div class="hide-content"><ul><li>队列和栈都是被用来预存储数据的。</li><li>队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。</li><li>栈和队列很相似，但它运行对元素进行后进先出进行检索。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>198. 什么是双亲委派模型？</span></div>    <div class="hide-content"><p>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。</p><p>类加载器分类：</p><p>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；</p><p>其他类加载器：</p><ul><li>扩展类加载器（Extension ClassLoader）：负责加载<java_home style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; text-size-adjust: none; -webkit-font-smoothing: antialiased; outline: 0px !important;">\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；</java_home></li><li>应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</li></ul><p>双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>199. 说一下类加载的执行过程？</span></div>    <div class="hide-content"><p>类加载分为以下 5 个步骤：</p><ol><li>加载：根据查找路径找到相应的 class 文件然后导入；</li><li>检查：检查加载的 class 文件的正确性；</li><li>准备：给类中的静态变量分配内存空间；</li><li>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</li><li>初始化：对静态变量和静态代码块执行初始化工作。</li></ol></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>200. 怎么判断对象是否可以被回收？</span></div>    <div class="hide-content"><p>一般有两种方法来判断：</p><ul><li>引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；</li><li>可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>201. java 中都有哪些引用类型？</span></div>    <div class="hide-content"><ul><li>强引用</li><li>软引用</li><li>弱引用</li><li>虚引用（幽灵引用/幻影引用）</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>202. 说一下 jvm 有哪些垃圾回收算法？</span></div>    <div class="hide-content"><ul><li>标记-清除算法</li><li>标记-整理算法</li><li>复制算法</li><li>分代算法</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>203. 说一下 jvm 有哪些垃圾回收器？</span></div>    <div class="hide-content"><ul><li>Serial：最早的单线程串行垃圾回收器。</li><li>Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。</li><li>ParNew：是 Serial 的多线程版本。</li><li>Parallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。</li><li>Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。</li><li>CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。</li><li>G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>204. 详细介绍一下 CMS 垃圾回收器？</span></div>    <div class="hide-content"><p>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。</p><p>CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>205.新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</span></div>    <div class="hide-content"><ul><li>新生代回收器：Serial、ParNew、Parallel Scavenge</li><li>老年代回收器：Serial Old、Parallel Old、CMS</li><li>整堆回收器：G1</li></ul><p>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>206. 简述分代垃圾回收器是怎么工作的？</span></div>    <div class="hide-content"><p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。</p><p>新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</p><ul><li>把 Eden + From Survivor 存活的对象放入 To Survivor 区；</li><li>清空 Eden 和 From Survivor 分区；</li><li>From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。</li></ul><p>每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。</p><p>老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>207. 说一下 jvm 调优的工具？</span></div>    <div class="hide-content"><p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p><ul><li>jconsole：用于对 JVM 中的内存、线程和类等进行监控；</li><li>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>208. 常用的 jvm 调优的参数都有哪些？</span></div>    <div class="hide-content"><ul><li>-Xms2g：初始化推大小为 2g；</li><li>-Xmx2g：堆最大内存为 2g；</li><li>-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；</li><li>-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；</li><li>–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；</li><li>-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；</li><li>-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；</li><li>-XX:+PrintGC：开启打印 gc 信息；</li><li>-XX:+PrintGCDetails：打印 gc 详细信息。</li></ul></div></div><hr><!-- <div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span></span></div>    <div class="hide-content"></div></div> --><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ul><li><a href="https://mp.weixin.qq.com/s/MXKACpJKLMxep5bXO3EHhw">Java 面试收到offer必备 208 道面试题</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引</title>
      <link href="blog/43a71ae4/"/>
      <url>blog/43a71ae4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>索引是一种特殊的数据库结构，由数据表中的一列或多列组合而成，可以用来快速查询数据表中有某一特定值的记录。</p><p>打个比方，如果合理的设计且使用索引的MySQL是一辆兰博基尼的话，那么没有设计和使用索引的MySQL就是一个人力三轮车。</p><p>通过索引，查询数据时不用读完记录的所有信息，而只是查询索引列。否则，数据库系统将读取每条记录的所有信息进行匹配。<br>拿汉语字典的目录页（索引）打比方，我们可以按拼音、笔画、偏旁部首等排序的目录（索引）快速查找到需要的字。</p><p>因此，使用索引可以很大程度上提高数据库的查询速度，还有效的提高了数据库系统的性能。</p><h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><ol><li>普通索引：index：加速查找</li><li>唯一索引<ul><li>主键索引：primary key：加速查找+约束（不为空且唯一）</li><li>唯一索引：unique：加速查找+约束 （唯一）</li></ul></li><li>联合索引<ul><li>primary key(id,name):联合主键索引</li><li>unique(id,name):联合唯一索引</li><li>index(id,name):联合普通索引</li></ul></li><li>全文索引fulltext :用于搜索很长一篇文章的时候，效果最好。</li><li>空间索引spatial :了解就好，几乎不用</li></ol><h2 id="哪些类适合建立索引"><a href="#哪些类适合建立索引" class="headerlink" title="哪些类适合建立索引"></a>哪些类适合建立索引</h2><ul><li>在经常需要搜索的列上，建立索引，增加搜索速度。</li><li>在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构。</li><li>在经常用在连接的列上，这些列主要是外键，可以加快连接速度。</li><li>在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，所以其指定的范围是连续的。</li><li>在经常需要排列的列上创建索引，因为索引已经排序，这样可以利用索引的排序，加快查询的速度。</li><li>在经常需要使用WHERE子句的列上创建索引，加快条件的判断速度。</li></ul><a class="btn-beautify button--animated block blue right" href="https://www.shiming.online/blog/c9dc7fee/"   title="MySQL引擎"><i class="far fa-hand-point-right fa-fw"></i><span>MySQL引擎</span></a>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL引擎</title>
      <link href="blog/c9dc7fee/"/>
      <url>blog/c9dc7fee/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>转自<a href="https://blog.csdn.net/qq_35642036/article/details/82820178">MyISAM与InnoDB 的区别（9个不同点）</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>MySQL中，常用的引擎主要就是2个：</p><ul><li>InnoDB</li><li>MyIASM</li></ul><p>MyISAM是默认存储引擎（Mysql5.1前）。由早期的ISAM（Indexed Sequential Access Method：有索引的顺序访问方法）所改良 。 每个MyISAM在磁盘上存储成三个文件，每一个文件的名字均以表的名字开始，扩展名指出文件类型。</p><p>InnoDB，是MySQL的数据库引擎之一，为MySQL AB发布binary的标准之一。InnoDB由Innobase Oy公司所开发，2006年五月时由甲骨文公司并购。与传统的ISAM与MyISAM相比，InnoDB的最大特色就是支持了ACID兼容的事务（Transaction）功能，类似于PostgreSQL。目前InnoDB采用双轨制授权，一是GPL授权，另一是专有软件授权。</p><h2 id="InnoDB和MyIASM区别"><a href="#InnoDB和MyIASM区别" class="headerlink" title="InnoDB和MyIASM区别"></a>InnoDB和MyIASM区别</h2><table><thead><tr><th align="center"></th><th align="center">MyIASM</th><th align="center">InnoDB</th></tr></thead><tbody><tr><td align="center">事务支持</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">外键约束</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">索引结构</td><td align="center">非聚集索引</td><td align="center">聚集索引</td></tr><tr><td align="center">保存行数</td><td align="center">保存</td><td align="center">不保存</td></tr><tr><td align="center">全文索引</td><td align="center">支持</td><td align="center">不支持</td></tr><tr><td align="center">粒度</td><td align="center">表锁</td><td align="center">行锁</td></tr><tr><td align="center">主键</td><td align="center">不必需</td><td align="center">必需</td></tr><tr><td align="center">存储文件</td><td align="center">frm</td><td align="center">frm,MYD,MYI</td></tr><tr><td align="center">存储空间</td><td align="center">可压缩</td><td align="center">不可压缩</td></tr></tbody></table><ol><li>InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务。</li><li>InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败。</li><li>InnoDB是聚集索引，MyIASM是非聚集索引<ul><li>InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。</li><li>MyISAM是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</li><li>也就是说：InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。</li></ul></li><li>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件）。</li><li>Innodb不支持全文索引，而MyISAM支持全文索引，在涉及全文索引领域的查询效率上MyISAM速度更快高。<em>PS：5.7以后的InnoDB支持全文索引了</em></li><li>InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁<ul><li>InnoDB的行锁是实现在索引上的，而不是锁在物理行记录上。潜台词是，如果访问没有命中索引，也无法使用行锁，将要退化为表锁。</li></ul></li><li>InnoDB表必须有主键（用户没有指定的话会自己找或生产一个主键），而Myisam可以没有</li><li>Innodb存储文件有frm、ibd，而Myisam是frm、MYD、MYI<ul><li>Innodb：frm是表定义文件，ibd是数据文件</li><li>Myisam：frm是表定义文件，myd是数据文件，myi是索引文件</li></ul></li><li>MyIASM可以压缩后查询</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>InnoDB 引擎：InnoDB 引擎提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。启动较慢，它是不会保存表的行数的，所以当进行 select count (*) from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的，所以在并发度较高的场景下使用会提升效率的。</p><p>MyIASM 引擎：MySQL 的默认引擎，但不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count (*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</p><p><strong>不知道选什么的情况下，选InnoDB就对了。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程同步</title>
      <link href="blog/895e9db/"/>
      <url>blog/895e9db/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="为什么需要同步"><a href="#为什么需要同步" class="headerlink" title="为什么需要同步"></a>为什么需要同步</h2><p>在大多数实际的多线程应用中，两个或两个以上线程需要共享对统一数据的存取。如果两个线程同时修改一个对象，可能就是导致数据不准确，使对象状态混乱，引起程序错误。因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用，从而保证了该变量的唯一性和准确性。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟三个人买票，一人买10张</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuyTicket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UnsafeBuyTicket unsafeBuyTicket = <span class="keyword">new</span> UnsafeBuyTicket();</span><br><span class="line">        <span class="keyword">new</span> Thread(unsafeBuyTicket, <span class="string">&quot;我&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(unsafeBuyTicket, <span class="string">&quot;你&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(unsafeBuyTicket, <span class="string">&quot;黄牛&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsafeBuyTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 100张票</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticketNums = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 买十张票</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            buy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 买票</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 模拟延时</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 买票</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;拿到：&quot;</span> + ticketNums--);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，运行结果中有时会出现重复购买同一张票的情况，这就是线程不安全的表现。</p><h2 id="七种解决办法"><a href="#七种解决办法" class="headerlink" title="七种解决办法"></a>七种解决办法</h2><ol><li>同步方法<br>有synchronized关键字修饰的方法。 由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。</li><li>同步代码块<br>有synchronized关键字修饰的语句块。 被该关键字修饰的语句块会自动被加上内置锁，从而实现同步。<code>synchronized(this)&#123;/*区块*/&#125;</code>，它的作用域是当前对象；</li><li>使用特殊域变量(volatile)实现线程同步</li><li>使用重入锁(Lock)实现线程同步</li><li>使用局部变量(ThreadLocal)实现线程同步</li><li>使用阻塞队列(LinkedBlockingQueue)实现线程同步</li><li>使用原子变量(Atomic)实现线程同步</li></ol><h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p>同步方法即有synchronized关键字修饰的方法。<br>由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。</p><p>示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><p>同步代码块即有synchronized关键字修饰的语句块。<br>被该关键字修饰的语句块会自动被加上内置锁，从而实现同步</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 买票</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;拿到：&quot;</span> + ticketNums--);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><p>注：同步是一种高开销的操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。</p></div><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><p>关键字synchronized的作用是实现线程间的同步。它的工作是对同步的代码加锁,使得每一次,只能有一个线程进入同步块,从而保证线程间的安全性。</p><ol><li>synchronized修饰方法时，只要一个线程访问了此对象其中的一个synchronized方法，其它线程不能同时访问这个对象中任何一个synchronized方法。但是，不同的对象实例的synchronized方法是不相干扰的。也就是说，其它线程照样可以同时访问相同类的另一个对象实例中的synchronized方法。锁的是当前实例对象。</li><li>synchronized修饰类的静态方法时，对此类的所有实例对象起作用。锁的是当前类的所有实例对象</li><li>无论synchronized关键字加在方法上还是对象上，它取得的锁都是对象，而不是把一段代码或函数当作锁――否则同步方法很可能还会被其他线程的对象访问。</li><li>synchronized关键字是不能继承的，也就是说，基类的方法synchronized f(){} 在继承类中并不自动是synchronized f(){}，而是变成了f(){}。继承类需要你显式的指定它的某个方法为synchronized方法</li></ol><h3 id="使用特殊域变量-volatile-实现线程同步"><a href="#使用特殊域变量-volatile-实现线程同步" class="headerlink" title="使用特殊域变量(volatile)实现线程同步"></a>使用特殊域变量(volatile)实现线程同步</h3><ol><li>volatile关键字为域变量的访问提供了一种免锁机制，</li><li>使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新，</li><li>因此每次使用该域就要重新计算，而不是使用寄存器中的值</li><li>volatile不会提供任何原子操作，它也不能用来修饰final类型的变量</li></ol><p>例如：<br>在上面的例子当中，在ticketNums前面加上volatile修饰</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> ticketNums = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>你会发现运行结果还是不能避免重复购票的情况。这是因为<code>ticketNums--</code>看起来是一个原子操作，但其实是由读取-修改-写入操作序列组成的组合操作，必须以原子方式执行，而 volatile 不能提供必须的原子特性。如果在读取后ticketNums的值又发生变化，volatile是无法解决的。</p><h4 id="volatile条件"><a href="#volatile条件" class="headerlink" title="volatile条件"></a>volatile条件</h4><p>所以要<strong>使 volatile 变量提供理想的线程安全</strong>，必须同时满足下面<strong>两个条件</strong>需要满足以下两个条件：</p><ol><li>对变量的写操作不依赖于当前值。</li><li>该变量没有包含在具有其他变量的不变式中。</li></ol><p>实际上，这些条件表明，可以被写入 volatile 变量的这些有效值<strong>独立于任何程序的状态</strong>，包括变量的当前状态。</p><h4 id="volatile适用场景"><a href="#volatile适用场景" class="headerlink" title="volatile适用场景"></a>volatile适用场景</h4><ol><li>状态标志</li><li>一次性安全发布（one-time safe publication）</li><li>独立观察（independent observation）</li><li>“volatile bean” 模式</li><li>开销较低的“读－写锁”策略</li></ol><p>具体使用参考<a href="https://blog.csdn.net/vking_wang/article/details/9982709#">【Java线程】volatile的适用场景</a></p><h3 id="使用重入锁实现线程同步"><a href="#使用重入锁实现线程同步" class="headerlink" title="使用重入锁实现线程同步"></a>使用重入锁实现线程同步</h3><p>在JavaSE5.0中新增了一个<code>java.util.concurrent</code>包来支持同步。</p><h4 id="synchronized-和-Lock-区别"><a href="#synchronized-和-Lock-区别" class="headerlink" title="synchronized 和 Lock 区别"></a>synchronized 和 Lock 区别</h4><ul><li>Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；</li><li>synchronized 无法判断是否获取锁的状态，Lock 可以判断是否获取到锁；</li><li>synchronized 会自动释放锁 (a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock 需在 finally 中手工释放锁（unlock () 方法释放锁），否则容易造成线程死锁；</li><li>Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</li><li>Lock 锁适合大量同步的代码的同步问题，synchronized 锁适合代码少量的同步问题。</li><li>Lock可以提高多个线程读的效率</li><li>synchronized 的锁可重入、不可中断、非公平，而 Lock 锁可重入（两者皆可）、可中断、可公平；</li></ul><p>ReentrantLock类是可重入、互斥、实现了Lock接口的锁，<br>它与synchronized具有相同的基本行为和语义，并且扩展了其能力</p><p>ReenreantLock类的常用方法有：</p><ul><li>ReentrantLock() : 创建一个ReentrantLock实例</li><li>lock() : 获得锁</li><li>unlock() : 释放锁</li></ul><p>注：ReentrantLock()还有一个可以创建公平锁的构造方法，但是会大幅度降低程序运行效率，不推荐使用</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsafeBuyTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 10张票</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticketNums = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 创建ReentrantLock实例</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用局部变量实现线程同步"><a href="#使用局部变量实现线程同步" class="headerlink" title="使用局部变量实现线程同步"></a>使用局部变量实现线程同步</h3><p>ThreadLocal是一个本地线程副本变量工具类。主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不同的变量值完成操作的场景。<br>ThreadLocal的作用主要是做数据隔离，填充的数据只属于当前线程，变量的数据对别的线程而言是相对隔离的，在多线程环境下，防止自己的变量被其它线程篡改。</p><h4 id="核心机制"><a href="#核心机制" class="headerlink" title="核心机制"></a>核心机制</h4><ul><li>每个Thread线程内部都有一个Map。</li><li>Map里面存储线程本地对象（key）和线程的变量副本（value）</li><li>但是，Thread内部的Map是由ThreadLocal维护的，由ThreadLocal负责向map获取和设置线程的变量值。</li></ul><p>所以对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离，互不干扰。</p><p>ThreadLocal在Spring中发挥着巨大的作用，在管理Request作用域中的Bean、事务管理、任务调度、AOP等模块都出现了它的身影。</p><p>Spring中绝大部分Bean都可以声明成Singleton作用域，采用ThreadLocal进行封装，因此有状态的Bean就能够以singleton的方式在多线程中正常工作了。</p><h4 id="ThreadLocal-类的常用方法"><a href="#ThreadLocal-类的常用方法" class="headerlink" title="ThreadLocal 类的常用方法"></a>ThreadLocal 类的常用方法</h4><ul><li>ThreadLocal() : 创建一个线程本地变量</li><li>get() : 获取当前线程的副本变量值。</li><li>initialValue() : 返回此线程局部变量的当前线程的”初始值”</li><li>set(T value) : 设置当前线程的副本变量值为value。</li><li>remove()：移除当前线程的副本变量值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsafeBuyTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 100张票</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; ticketNums = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            buy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 买票</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 延时</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 买票</span></span><br><span class="line">        ticketNums.set(ticketNums.get() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> num = ticketNums.get();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;拿到：&quot;</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，修改代码后可以看到三个线程的变量值互不影响。</p><h4 id="ThreadLocal适用场景"><a href="#ThreadLocal适用场景" class="headerlink" title="ThreadLocal适用场景"></a>ThreadLocal适用场景</h4><p>例：Hibernate的session获取场景。<br>每个线程访问数据库都应当是一个独立的Session会话，如果多个线程共享同一个Session会话，有可能其他线程关闭连接了，当前线程再执行提交时就会出现会话已关闭的异常，导致系统异常。此方式能避免线程争抢Session，提高并发下的安全性。</p><p>使用ThreadLocal的典型场景正如上面的数据库连接管理，线程会话管理等场景，只适用于独立变量副本的情况，如果变量为全局共享的，则不适用在高并发下使用。<br>又或者：<strong>时间格式：SimpleDataFormat</strong></p><p>解析参考<a href="https://www.jianshu.com/p/98b68c97df9b">ThreadLocal-面试必问深度解析</a></p><h3 id="使用阻塞队列实现线程同步"><a href="#使用阻塞队列实现线程同步" class="headerlink" title="使用阻塞队列实现线程同步"></a>使用阻塞队列实现线程同步</h3><p>前面5种同步方式都是在底层实现的线程同步，但是我们在实际开发当中，应当尽量远离底层结构。<br>使用javaSE5.0版本中新增的<code>java.util.concurrent</code>包将有助于简化开发。<br>本小节主要是使用<code>LinkedBlockingQueue&lt;E&gt;</code>来实现线程的同步<br><code>LinkedBlockingQueue&lt;E&gt;</code>是一个基于已连接节点的，范围任意的blocking queue。</p><p>LinkedBlockingQueue 类常用方法</p><ul><li>LinkedBlockingQueue() : 创建一个容量为Integer.MAX_VALUE的- LinkedBlockingQueue</li><li>put(E e) : 在队尾添加一个元素，如果队列满则阻塞</li><li>size() : 返回队列中的元素个数</li><li>take() : 移除并返回队头元素，如果队列空则阻塞</li></ul><p>使用阻塞队列实现生产和消费，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用阻塞队列实现线程同步 LinkedBlockingQueue的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingSynchronizedThread</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个阻塞队列用来存储生产出来的商品</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LinkedBlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Integer&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义生产商品个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义启动线程的标志，为0时，启动生产商品的线程；为1时，启动消费商品的线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkBlockThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> newFlag = flag++;</span><br><span class="line">            System.out.println(<span class="string">&quot;启动线程 &quot;</span> + newFlag);</span><br><span class="line">            <span class="keyword">if</span> (newFlag == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; i++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> b = <span class="keyword">new</span> Random().nextInt(<span class="number">255</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;生产商品：&quot;</span> + b + <span class="string">&quot;号&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        queue.put(b);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;生产者：仓库中还有商品：&quot;</span> + queue.size() + <span class="string">&quot;个&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE / <span class="number">2</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> n = queue.take();</span><br><span class="line">                        System.out.println(<span class="string">&quot;消费者买去了&quot;</span> + n + <span class="string">&quot;号商品&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;消费者：仓库中还有商品：&quot;</span> + queue.size() + <span class="string">&quot;个&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BlockingSynchronizedThread bst = <span class="keyword">new</span> BlockingSynchronizedThread();</span><br><span class="line">        LinkBlockThread lbt = bst.<span class="function">new <span class="title">LinkBlockThread</span><span class="params">()</span></span>;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(lbt);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(lbt);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><p>注：<code>BlockingQueue&lt;E&gt;</code>定义了阻塞队列的常用方法，尤其是三种添加元素的方法需要多加注意，当队列满时：</p><ul><li>add()方法会抛出异常</li><li>offer()方法返回false</li><li>put()方法会阻塞</li></ul></div><h3 id="使用原子变量实现线程同步"><a href="#使用原子变量实现线程同步" class="headerlink" title="使用原子变量实现线程同步"></a>使用原子变量实现线程同步</h3><p>需要使用线程同步的根本原因在于对普通变量的操作不是原子的。</p><p>在java的util.concurrent.atomic包中提供了创建了原子类型变量的工具类，使用该类可以简化线程同步。</p><p>其中<code>AtomicInteger</code> 包可以用原子方式更新int的值，可用在应用程序中(如以原子方式增加的计数器)，<br>但不能用于替换Integer；可扩展Number，允许那些处理机遇数字类的工具和实用工具进行统一访问。</p><p>AtomicInteger类常用方法：</p><ul><li>AtomicInteger(int initialValue) : 创建具有给定初始值的新的AtomicInteger</li><li>addAddGet(int dalta) : 以原子方式将给定值与当前值相加</li><li>get() : 获取当前值</li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsafeBuyTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 100张票</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger ticketNums = <span class="keyword">new</span> AtomicInteger(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            buy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 买票</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 延时</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 买票</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;拿到：&quot;</span> + ticketNums.getAndAdd(-<span class="number">1</span>));</span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ul><li><a href="https://blog.csdn.net/vking_wang/article/details/9982709#">【Java线程】volatile的适用场景</a></li><li><a href="https://www.cnblogs.com/XHJT/p/3897440.html">java笔记–关于线程同步（7种同步方式）</a></li><li><a href="https://www.cnblogs.com/dolphin0520/p/3923167.html">Java并发编程：Lock</a></li></ul></blockquote><a class="btn-beautify button--animated block blue right" href="https://www.shiming.online/blog/7af799fd/"   title="Java反射"><i class="far fa-hand-point-right fa-fw"></i><span>Java反射</span></a>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
          <category> 线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis分页</title>
      <link href="blog/60c9167b/"/>
      <url>blog/60c9167b/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>本文为基于mybatis和MySql进行分页功能的实现，一共四种方式：</p><ol><li>数组分页</li><li>sql语句分页</li><li>拦截器分页</li><li>RowBounds分页</li></ol><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="数组分页"><a href="#数组分页" class="headerlink" title="数组分页"></a>数组分页</h3><p>原理：进行数据库查询操作时，获取到数据库中所有满足条件的记录，保存在应用的临时数组中，再通过List的subList方法，获取到满足条件的所有记录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span></span>;</span><br></pre></td></tr></table></figure><p>即从list中截取从fromInde [(page-1)*size] 到toIndex [fromIndex+size] 的数据，这里不介绍具体实现。</p><p>缺点：数据库查询并返回所有的数据，而我们需要的只是极少数符合要求的数据。当数据量少时，还可以接受。当数据库数据量过大时，每次查询对数据库和程序的性能都会产生极大的影响。</p><h3 id="sql分页"><a href="#sql分页" class="headerlink" title="sql分页"></a>sql分页</h3><p>使用limit语句直接在数据库语言中只检索符合条件的记录，不需要在通过程序对其作处理。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> studeng <span class="keyword">LIMIT</span> [&lt;<span class="keyword">offset</span>&gt;,] &lt;<span class="keyword">row</span> <span class="keyword">count</span>&gt;</span><br></pre></td></tr></table></figure><ul><li>offset：偏移量，(page-1)+size，可以不添加，默认从0开始</li><li>row count：查询数量，size</li></ul><p>缺点：虽然这里实现了按需查找，每次检索得到的是指定的数据。但是每次在分页的时候都需要去编写limit语句，很冗余。而且不方便统一管理，维护性较差。所以我们希望能够有一种更方便的分页实现。</p><h3 id="拦截器分页（重点）"><a href="#拦截器分页（重点）" class="headerlink" title="拦截器分页（重点）"></a>拦截器分页（重点）</h3><p>自定义拦截器实现了拦截所有以ByPage结尾的查询语句，并且利用获取到的分页相关参数统一在sql语句后面加上limit分页的相关语句，一劳永逸。不再需要在每个语句中单独去配置分页相关的参数了。</p><p>这里介绍Spring插件<a href="https://github.com/pagehelper/Mybatis-PageHelper">PageHelper</a>的用法，自定义拦截器参考<a href="https://blog.csdn.net/duan196_118/article/details/105298291">mybatis的四种分页方式</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 导入依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SpringBoot中导入依赖后使用PageHelper默认配置即可，可以直接使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">调用mapper方法时，使用PageHelper分页</span><br><span class="line">PageHelper.startPage(page, size);</span><br><span class="line">List&lt;SnackInfo&gt; list = snackInfoMapper.selectAll();</span><br><span class="line">PageInfo&lt;SnackInfo&gt; pageInfo = <span class="keyword">new</span> PageInfo&lt;&gt;(list);</span><br><span class="line">System.out.println(pageInfo);</span><br></pre></td></tr></table></figure><p>如上所示，添加依赖后只需要三行代码就可以按照要求分页查询。</p><h3 id="RowBounds分页"><a href="#RowBounds分页" class="headerlink" title="RowBounds分页"></a>RowBounds分页</h3><p>原理：通过RowBounds实现分页和通过数组方式分页原理差不多，都是一次获取所有符合条件的数据，然后在内存中对大数据进行操作，实现分页效果。只是数组分页需要我们自己去实现分页逻辑，这里更加简化而已。</p><p>存在问题：一次性从数据库获取的数据可能会很多，对内存的消耗很大，可能导致性能变差，甚至引发内存溢出。</p><p>适用场景：在数据量很大的情况下，建议还是适用拦截器实现分页效果。RowBounds建议在数据量相对较小的情况下使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mapper</span></span><br><span class="line"><span class="function">List&lt;SnackInfo&gt; <span class="title">selectAll</span><span class="params">(RowBounds rowBounds)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> start = (page - <span class="number">1</span>) * size;</span><br><span class="line">List&lt;SnackInfo&gt; list = snackInfoMapper.selectAll(<span class="keyword">new</span> RowBounds(start, size));</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从上面四种sql分页的实现方式可以看出，通过RowBounds实现是最简便的，但是通过拦截器的实现方式是最优的方案。</p><p>自定义拦截器只需一次编写，所有的分页方法共同使用，还可以避免多次配置时的出错机率，需要修改时也只需要修改这一个文件，一劳永逸。而且是我们自己实现的，便于我们去控制和增加一些逻辑处理，使我们在外层更简单的使用。</p><p>同时也不会出现数组分页和RowBounds分页导致的性能问题。当然，具体情况可以采取不同的解决方案。数据量小时，RowBounds不失为一种好办法。但是数据量大时，实现拦截器就很有必要了。</p><div class="note warning flat"><p>无论数据量如何，一般建议使用物理查询（除RowBounds之外的方式），因为不需要将数据库的压力加在服务端上。逻辑查询就算速度上存在劣势,然而其它性能上的优点足以弥补这个缺点。</p></div>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
            <tag> 分页 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象克隆</title>
      <link href="blog/ed7a5ab9/"/>
      <url>blog/ed7a5ab9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="为什么要使用对象克隆"><a href="#为什么要使用对象克隆" class="headerlink" title="为什么要使用对象克隆"></a>为什么要使用对象克隆</h2><p>想对一个对象进行处理，又想保留原有的数据进行接下来的操作，就需要克隆了，Java语言中克隆针对的是类的实例。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>三种方式</p><h3 id="实现Cloneable接口并重写Object类中的clone-方法（浅拷贝）"><a href="#实现Cloneable接口并重写Object类中的clone-方法（浅拷贝）" class="headerlink" title="实现Cloneable接口并重写Object类中的clone()方法（浅拷贝）"></a>实现Cloneable接口并重写Object类中的clone()方法（浅拷贝）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Person类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;        <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">private</span> Car car;        <span class="comment">// 座驾</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, Car car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.car = car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCar</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.car = car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;, car=&quot;</span> + car + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 小汽车类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String brand;       <span class="comment">// 品牌</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSpeed;       <span class="comment">// 最高时速</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(String brand, <span class="keyword">int</span> maxSpeed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brand = brand;</span><br><span class="line">        <span class="keyword">this</span>.maxSpeed = maxSpeed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBrand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBrand</span><span class="params">(String brand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brand = brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxSpeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maxSpeed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaxSpeed</span><span class="params">(<span class="keyword">int</span> maxSpeed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSpeed = maxSpeed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Car [brand=&quot;</span> + brand + <span class="string">&quot;, maxSpeed = &quot;</span> + maxSpeed + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Car c1 = <span class="keyword">new</span> Car(<span class="string">&quot;bc&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>, c1);</span><br><span class="line">        Person p2 = (Person) p1.clone();</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">        <span class="comment">// Person [name=a, age=1, car=Car [brand=bc, maxSpeed = 100]]</span></span><br><span class="line">        p2.setName(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        p2.getCar().setBrand(<span class="string">&quot;bm&quot;</span>);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">        <span class="comment">// Person [name=b, age=1, car=Car [brand=bm, maxSpeed = 100]]</span></span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        <span class="comment">// Person [name=a, age=1, car=Car [brand=bm, maxSpeed = 100]]</span></span><br><span class="line">        <span class="comment">// 浅拷贝，只拷贝引用地址</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="clone对象时也clone属性，实现深度克隆"><a href="#clone对象时也clone属性，实现深度克隆" class="headerlink" title="clone对象时也clone属性，实现深度克隆"></a>clone对象时也clone属性，实现深度克隆</h3><p>当自定义引用过多时，增加代码复杂度</p><p>clone方法示例如下，其余跟浅克隆一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    Person person = (Person) <span class="keyword">super</span>.clone();</span><br><span class="line">    person.setCar((Car) person.getCar().clone());</span><br><span class="line">    <span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆"><a href="#实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆" class="headerlink" title="实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆"></a>实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化工具</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Serializable&gt; <span class="function">T <span class="title">clone</span><span class="params">(T obj)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteArrayOutputStream bout = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bout);</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream bin =</span><br><span class="line">                <span class="keyword">new</span> ByteArrayInputStream(bout.toByteArray());</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bin);</span><br><span class="line">        <span class="keyword">return</span> (T) ois.readObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 说明：调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义</span></span><br><span class="line">        <span class="comment">// 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源，这一点不同于对外部资源（如文件流）的释放</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Person类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;        <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">private</span> Car car;        <span class="comment">// 座驾</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, Car car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.car = car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCar</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.car = car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;, car=&quot;</span> + car + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 小汽车类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String brand;       <span class="comment">// 品牌</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSpeed;       <span class="comment">// 最高时速</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(String brand, <span class="keyword">int</span> maxSpeed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brand = brand;</span><br><span class="line">        <span class="keyword">this</span>.maxSpeed = maxSpeed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBrand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBrand</span><span class="params">(String brand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brand = brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxSpeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maxSpeed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaxSpeed</span><span class="params">(<span class="keyword">int</span> maxSpeed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSpeed = maxSpeed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Car [brand=&quot;</span> + brand + <span class="string">&quot;, maxSpeed = &quot;</span> + maxSpeed + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Car c1 = <span class="keyword">new</span> Car(<span class="string">&quot;bc&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>, c1);</span><br><span class="line">        Person p2 = MyUtil.clone(p1);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">        <span class="comment">// Person [name=a, age=1, car=Car [brand=bc, maxSpeed = 100]]</span></span><br><span class="line">        p2.setName(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        p2.getCar().setBrand(<span class="string">&quot;bm&quot;</span>);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">        <span class="comment">// Person [name=b, age=1, car=Car [brand=bm, maxSpeed = 100]]</span></span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        <span class="comment">// Person [name=a, age=1, car=Car [brand=bc, maxSpeed = 100]]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning flat"><p>注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。让问题在编译的时候暴露出来总是好过把问题留到运行时。</p></div><h2 id="浅拷贝和深拷贝的区别"><a href="#浅拷贝和深拷贝的区别" class="headerlink" title="浅拷贝和深拷贝的区别"></a>浅拷贝和深拷贝的区别</h2><ul><li>浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝（例：assign ()）</li><li>深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝（例：JSON.parse () 和 JSON.stringify ()，但是此方法无法复制函数类型）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 对象克隆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代理模式</title>
      <link href="blog/7b510e10/"/>
      <url>blog/7b510e10/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>代理模式(Proxy)是一种设计模式，提供了对目标对象另外的访问方式：即通过代理对象访问目标对象.这样做的好处是：可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能，例：统计，log或对参数进行优化，更改.</p><p>这里使用到编程中的一个思想：不要随意去修改别人已经写好的代码或者方法，如果需改修改，可以通过代理的方式来扩展该方法.</p><p>举个例子来说明代理的作用：假设我们想邀请一位明星，那么并不是直接连接明星，而是联系明星的经纪人，来达到同样的目的.明星就是一个目标对象，他只要负责活动中的节目，而其他琐碎的事情就交给他的代理人(经纪人)来解决.这就是代理思想在现实中的一个例子.</p><p>图片示例：<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200815215421.png" alt="20200815215421"></p><p>代理模式的关键点是:<strong>代理对象与目标对象</strong>.代理对象是对目标对象的扩展，并会调用目标对象.</p><h2 id="代理模式的使用场景"><a href="#代理模式的使用场景" class="headerlink" title="代理模式的使用场景"></a>代理模式的使用场景</h2><p>当无法或不想直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，委托对象与代理对象需要实现同一个接口.</p><h2 id="三种代理模式"><a href="#三种代理模式" class="headerlink" title="三种代理模式"></a>三种代理模式</h2><p>Java代理分为静态代理和动态代理和Cglib代理.</p><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>静态代理在使用时，需要定义接口或者父类，被代理对象与代理对象一起<strong>实现相同的接口或者是继承相同父类</strong>.</p><p>例：模拟文件操作：<br>定义一个文件操作的接口：IUserDao.java，然后目标对象实现这个接口的方法：UserDao.java，此时如果使用静态代理方式，就需要在代理对象(UserDaoProxy.java)中也实现IUserDao接口.调用的时候通过调用代理对象的方法来调用目标对象.<br>需要注意的是，代理对象与目标对象要实现相同的接口，然后通过调用相同的方法来调用目标对象的方法.</p><ul><li>1个静态代理只服务1种类型的目标对象.</li><li>若要服务多类型的目标对象，则需要为每种目标对象都实现一个静态代理对象.</li></ul><h4 id="静态代理代码示例"><a href="#静态代理代码示例" class="headerlink" title="静态代理代码示例"></a>静态代理代码示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IUserDao接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目标对象：UserDao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> <span class="keyword">implements</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----保存数据!----&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态代理对象：UserDaoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoProxy</span> <span class="keyword">implements</span> <span class="title">IUserDao</span></span>&#123;</span><br><span class="line">    <span class="comment">//接收保存目标对象</span></span><br><span class="line">    <span class="keyword">private</span> IUserDao target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserDaoProxy</span><span class="params">(IUserDao target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target=target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始事务.&quot;</span>);</span><br><span class="line">        target.operate();<span class="comment">//执行目标对象的方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;提交事务.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//目标对象</span></span><br><span class="line">        UserDao target = <span class="keyword">new</span> UserDao();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//代理对象，把目标对象传给代理对象，建立代理关系</span></span><br><span class="line">        UserDaoProxy proxy = <span class="keyword">new</span> UserDaoProxy(target);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行的是代理的方法</span></span><br><span class="line">        proxy.operate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态代理总结"><a href="#静态代理总结" class="headerlink" title="静态代理总结"></a>静态代理总结</h4><p>优点：</p><ul><li>协调调用者和被调用者，降低了系统的耦合度</li><li>可以做到在不修改目标对象的功能前提下，对目标功能扩展</li></ul><p>缺点：</p><ul><li>由于在客户端和真实主题之间增加了代理对象，因此会造成请求的处理速度变慢；</li><li>在目标对象较多的情况下（或代理实现复杂），若采用静态代理，则会出现静态代理对象量多、代码量大，从而导致代码复杂的问题.</li></ul><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>为解决静态代理对象必须实现接口的问题，Java给出了动态代理</p><p>特点：</p><ul><li>设计动态代理类（<code>DynamicProxy</code>）时，不需要显式实现与目标对象类（<code>RealSubject</code>）相同的接口，而是将这种实现推迟到程序运行时在内存中由 JVM来实现</li><li>通过Java反射机制的<code>method.invoke（）</code>，通过调用动态代理类对象方法，从而自动调用目标对象的方法</li></ul><h4 id="动态代理应用场景"><a href="#动态代理应用场景" class="headerlink" title="动态代理应用场景"></a>动态代理应用场景</h4><ul><li>基于静态代理应用场景下，需要代理对象数量较多的情况下使用动态代理</li><li>AOP 领域（<a href="https://shiming.online/blog/8981/#%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B">切面编程</a>）</li></ul><h4 id="动态代理与静态代理区别"><a href="#动态代理与静态代理区别" class="headerlink" title="动态代理与静态代理区别"></a>动态代理与静态代理区别</h4><table><thead><tr><th align="center">类型</th><th align="center">代码创建&amp;绑定时机</th><th align="center">原理</th><th align="center">效率</th><th align="center">具体使用</th></tr></thead><tbody><tr><td align="center">静态代理</td><td align="center">代码运行前<br />在代理类实现时就指定与目标对象类相同的接口</td><td align="center">/</td><td align="center">/</td><td align="center">代理单一目标对象</td></tr><tr><td align="center">动态代理</td><td align="center">运行时<br />  不需要显式实现与对象类相同的接口</td><td align="center">反射</td><td align="center">低</td><td align="center">代理多个对象</td></tr></tbody></table><h4 id="动态代理代码示例"><a href="#动态代理代码示例" class="headerlink" title="动态代理代码示例"></a>动态代理代码示例</h4><p>模拟文件操作：<br>文件操作接口<code>IUserDao.java</code>，实现类<code>UserDao1</code>保存文件，另一个实现类<code>UserDao2</code>下载文件.</p><p>步骤：</p><ol><li>声明调用处理器类</li><li>声明目标对象类的抽象接口</li><li>声明目标对象类</li><li>通过动态代理对象，调用目标对象的方法</li></ol><h5 id="1-声明调用处理器类DynamicProxy-java"><a href="#1-声明调用处理器类DynamicProxy-java" class="headerlink" title="1. 声明调用处理器类DynamicProxy.java"></a>1. 声明调用处理器类DynamicProxy.java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作用:</span></span><br><span class="line"><span class="comment">// 1. 生成动态代理对象</span></span><br><span class="line"><span class="comment">// 2. 指定 代理对象运行目标对象方法时需要完成的 具体任务</span></span><br><span class="line"><span class="comment">// 注：需实现InvocationHandler接口 = 调用处理器 接口</span></span><br><span class="line"><span class="comment">// 所以称为 调用处理器类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明代理对象</span></span><br><span class="line">  <span class="comment">// 作用：绑定关系，即关联到哪个接口（与具体的实现类绑定）的哪些方法将被调用时，执行invoke（）</span></span><br><span class="line">  <span class="keyword">private</span> Object ProxyObject;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">newProxyInstance</span><span class="params">(Object ProxyObject)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.ProxyObject =ProxyObject;</span><br><span class="line">      <span class="keyword">return</span> Proxy.newProxyInstance(ProxyObject.getClass().getClassLoader()，</span><br><span class="line">              ProxyObject.getClass().getInterfaces()，<span class="keyword">this</span>);</span><br><span class="line">      <span class="comment">// Proxy类 = 动态代理类的主类</span></span><br><span class="line">      <span class="comment">// Proxy.newProxyInstance（）作用：根据指定的类装载器、一组接口 &amp; 调用处理器 生成动态代理类实例，并最终返回</span></span><br><span class="line">      <span class="comment">// 参数说明：</span></span><br><span class="line">      <span class="comment">// 参数1：指定产生代理对象的类加载器，需要将其指定为和目标对象同一个类加载器</span></span><br><span class="line">      <span class="comment">// 参数2：指定目标对象的实现接口</span></span><br><span class="line">      <span class="comment">// 即要给目标对象提供一组什么接口.若提供了一组接口给它，那么该代理对象就默认实现了该接口，这样就能调用这组接口中的方法</span></span><br><span class="line">      <span class="comment">// 参数3：指定InvocationHandler对象.即动态代理对象在调用方法时，会关联到哪个InvocationHandler对象</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  复写InvocationHandler接口的invoke（）</span></span><br><span class="line">  <span class="comment">//  动态代理对象调用目标对象的任何方法前，都会调用调用处理器类的invoke（）</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy， Method method， Object[] args)</span></span></span><br><span class="line"><span class="function">      <span class="comment">// 参数说明：</span></span></span><br><span class="line"><span class="function">      <span class="comment">// 参数1：动态代理对象（即哪个动态代理对象调用了method（）</span></span></span><br><span class="line"><span class="function">      <span class="comment">// 参数2：目标对象被调用的方法</span></span></span><br><span class="line"><span class="function">      <span class="comment">// 参数3：指定被调用方法的参数</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;开始操作数据&quot;</span>);</span><br><span class="line">          Object result = <span class="keyword">null</span>;</span><br><span class="line">          before();</span><br><span class="line">          <span class="comment">// 通过Java反射机制调用目标对象方法</span></span><br><span class="line">          result = method.invoke(ProxyObject， args);</span><br><span class="line">          after();</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;开始事务.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;结束事务.&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-声明目标对象抽象接口"><a href="#2-声明目标对象抽象接口" class="headerlink" title="2. 声明目标对象抽象接口"></a>2. 声明目标对象抽象接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-声明目标对象类"><a href="#3-声明目标对象类" class="headerlink" title="3. 声明目标对象类"></a>3. 声明目标对象类</h5><p>UserDao1.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao1</span> <span class="keyword">implements</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----保存数据!----&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserDao2.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao2</span> <span class="keyword">implements</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----下载数据!----&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-通过动态代理对象，调用目标对象的方法"><a href="#4-通过动态代理对象，调用目标对象的方法" class="headerlink" title="4. 通过动态代理对象，调用目标对象的方法"></a>4. 通过动态代理对象，调用目标对象的方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span>  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建调用处理器类对象</span></span><br><span class="line">        DynamicProxy DynamicProxy = <span class="keyword">new</span> DynamicProxy();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建目标对象的对象</span></span><br><span class="line">        IUserDao target1 = <span class="keyword">new</span> UserDao1();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 创建动态代理类 &amp; 对象：通过调用处理器类对象newProxyInstance（）</span></span><br><span class="line">        <span class="comment">// 传入上述目标对象的对象</span></span><br><span class="line">        IUserDao target1DynamicProxy = (IUserDao) DynamicProxy.newProxyInstance(target1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 通过调用动态代理对象方法从而调用目标对象方法</span></span><br><span class="line">        <span class="comment">// 实际上是调用了invoke（），再通过invoke（）里的反射机制调用目标对象的方法</span></span><br><span class="line">        target1DynamicProxy.operate();</span><br><span class="line">        <span class="comment">// 以上为UserDao1保存数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以下为UserDao2下载数据</span></span><br><span class="line">        IUserDao target2 = <span class="keyword">new</span> UserDao2();</span><br><span class="line">        IUserDao target2DynamicProxy = (IUserDao) DynamicProxy.newProxyInstance(target2);</span><br><span class="line">        target2DynamicProxy.operate();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体原理参考<a href="https://www.jianshu.com/p/cd945f5ab6ec">代理模式（静态代理 and 动态代理）</a></p><h4 id="动态代理优缺点"><a href="#动态代理优缺点" class="headerlink" title="动态代理优缺点"></a>动态代理优缺点</h4><p>优点：</p><ul><li>只需要1个动态代理类就可以解决创建多个静态代理的问题，避免重复、多余代码更强的灵活性.</li></ul><p>缺点：</p><ul><li>效率低<br>相比静态代理中 直接调用目标对象方法，动态代理则需要先通过java反射机制 从而 间接调用目标对象方法</li><li>应用场景局限<br>因为Java的单继承特性（每个代理类都继承了 Proxy 类），即只能针对接口创建代理类，不能针对类创建代理类<div class="note info flat"><p>即只能动态代理实现了接口的类</p></div></li></ul><h3 id="Cglib代理"><a href="#Cglib代理" class="headerlink" title="Cglib代理"></a>Cglib代理</h3><p>上面的静态代理和动态代理模式都是要求目标对象是实现一个接口的目标对象，但是有时候目标对象只是一个单独的对象，并没有实现任何的接口，这个时候就可以使用以目标对象子类的方式类实现代理，这种方法就叫做：Cglib代理.</p><p>Cglib代理，也叫作子类代理，它是在内存中构建一个子类对象从而实现对目标对象功能的扩展.</p><ul><li>JDK的动态代理有一个限制，就是使用动态代理的对象必须实现一个或多个接口，如果想代理没有实现接口的类，就可以使用Cglib实现.</li><li>Cglib是一个强大的高性能的代码生成包，它可以在运行期扩展java类与实现java接口.它广泛的被许多AOP的框架使用，例如Spring AOP和synaop，为他们提供方法的interception(拦截)</li><li>Cglib包的底层是通过使用一个小而快的字节码处理框架ASM来转换字节码并生成新的类.不鼓励直接使用ASM，因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉.</li></ul><p>Cglib子类代理实现方法:</p><ol><li><p>需要引入cglib的jar文件，但是Spring的核心包中已经包括了Cglib功能，所以直接引入pring-core依赖即可.</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>引入功能包后，就可以在内存中动态构建子类</p></li><li><p>代理的类不能为final，否则报错</p></li><li><p>目标对象的方法如果为final/static，那么就不会被拦截，即不会执行目标对象额外的业务方法.</p></li></ol><h4 id="Cglib代理代码示例"><a href="#Cglib代理代码示例" class="headerlink" title="Cglib代理代码示例"></a>Cglib代理代码示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目标对象类UserDao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----保存数据!----&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cglib代理工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span>&#123;</span><br><span class="line">    <span class="comment">//维护目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给目标对象创建一个代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.工具类</span></span><br><span class="line">        Enhancer en = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//2.设置父类</span></span><br><span class="line">        en.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//3.设置回调函数</span></span><br><span class="line">        en.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//4.创建子类(代理对象)</span></span><br><span class="line">        <span class="keyword">return</span> en.create();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始事务...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行目标对象的方法</span></span><br><span class="line">        Object returnValue = method.invoke(target, args);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;提交事务...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span>  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 目标对象</span></span><br><span class="line">        UserDao target = <span class="keyword">new</span> UserDao();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 代理对象</span></span><br><span class="line">        UserDao proxy = (UserDao)<span class="keyword">new</span> ProxyFactory(target).getProxyInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行代理对象的方法</span></span><br><span class="line">        proxy.operate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Spring的AOP编程中:</p><ul><li>如果加入容器的目标对象有实现接口,用JDK代理</li><li>如果目标对象没有实现接口,用Cglib代理</li></ul><p>Spring也可以通过<code>&lt;aop:config proxy-target-class=&quot;true&quot;&gt;</code>强制使用Cglib代理，使用Java字节码编辑类库ASM操作字节码来实现，直接以二进制形式动态地生成 stub 类或其他代理类，性能比JDK更强.</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ul><li><a href="https://www.jianshu.com/p/cd945f5ab6ec">代理模式（静态代理 and 动态代理）</a></li><li><a href="https://www.cnblogs.com/cenyu/p/6289209.html#autoid-1-0-0">Java的三种代理模式</a></li></ul></blockquote><a class="btn-beautify button--animated block blue right" href="https://www.shiming.online/blog/ed7a5ab9/"   title="对象克隆"><i class="far fa-hand-point-right fa-fw"></i><span>对象克隆</span></a>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java反射</title>
      <link href="blog/7af799fd/"/>
      <url>blog/7af799fd/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>本文转自<a href="https://www.jianshu.com/p/10c29883eac1">Java反射</a>并加以修改</p></blockquote><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p><a href="https://baike.baidu.com/item/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/6015990">JAVA反射（reflection）机制</a>是指在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。这种动态获取程序信息以及动态调用对象的功能称为Java语言的反射机制。反射被视为动态语言的关键。<br>反射主要是指程序可以访问，检测和修改它本身状态或行为的一种能力，并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。</p></blockquote><p>程序中一般的对象的类型都是在编译期就确定下来的，而Java反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。即我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。</p><p>反射的核心是JVM在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。</p><p>反射机制主要提供以下功能：</p><ol><li>在运行时判断任意一个对象所属的类；</li><li>在运行时构造任意一个类的对象；</li><li>在运行时判断任意一个类所具有的成员变量和方法；</li><li>在运行时调用任意一个对象的方法；</li><li>生成动态代理。</li></ol><div class="note warning flat"><p>重点：是运行时而不是编译时</p></div><p>实际使用：</p><ol><li>当我们在使用IDE(如Eclipse，IDEA)时，当我们输入一个对象或类并想调用它的属性或方法时，一按点号，编译器就会自动列出它的属性或方法，这里就会用到反射。</li><li>反射最重要的用途就是开发各种通用框架。<br>很多框架（比如Spring）都是配置化的（比如通过XML文件配置JavaBean,Action之类的），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。</li></ol><p>对于框架开发人员来说，反射虽小但作用非常大，它是各种容器实现的核心。而对于一般的开发者来说，不深入框架开发则用反射用的就会少一点，不过了解一下框架的底层机制有助于丰富自己的编程思想，也是很有益的。</p><h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><p>Class可以说是反射能够实现的基础</p><ol><li>class关键字是在声明java类时使用的；而 Class 是java JDK提供的一个类，一个描述类的类（也就是描述类本身），封装了描述方法的Method，描述字段的Filed，描述构造器的Constructor等属性,完整路径为 java.lang.Class</li><li>对于每一个类，Java虚拟机都会初始化出一个Class类型的实例，每当我们编写并且编译一个新创建的类就会产生一个对应Class对象，并且这个Class对象会被保存在同名.class文件里。</li><li>当我们new一个新对象或者引用静态成员变量时，Java虚拟机(JVM)中的类加载器系统会将对应Class对象加载到JVM中，然后JVM再根据这个类型信息相关的Class对象创建我们需要实例对象或者提供静态变量的引用值。</li></ol><p><strong>Class对象构造器是私有的，只有JVM才可以调用这个构造函数创建Class的对象</strong><br>4. 每个class（注意class是小写，代表普通类）类，无论创建多少个实例对象，在JVM中都对应同一个Class对象。<br>5. Class是反射能够实现的基础的另一个原因是：Java反射包java.lang.reflect中的所有类都没有public构造方法，要想获得这些类实例，只能通过Class类获取。所以说如果想使用反射，必须得获得Class对象。</p><h2 id="基本运用"><a href="#基本运用" class="headerlink" title="基本运用"></a>基本运用</h2><h3 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h3><ol><li><p>通过类的类型获取Class对象,基本类型同样可以使用这种方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Class&lt;?&gt;是一个泛型表示，用于获取一个类的类型。</span></span><br><span class="line">Class&lt;?&gt; c = <span class="keyword">boolean</span>.class;  </span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; classInt = Integer.TYPE;</span><br></pre></td></tr></table></figure></li><li><p>通过对象实例获取对应Class对象<code>Object.getClass()</code>–对于基本类型无法使用这种方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder str = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">Class&lt;?&gt; klass = str.getClass();</span><br></pre></td></tr></table></figure></li><li><p>使用Class类的forName静态方法(通过类的全限定名)</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)</span><br></pre></td></tr></table></figure><p> 在JDBC开发中常用此方法加载数据库驱动:<br> 要使用全类名来加载这个类，一般数据库驱动的配置信息会写在配置文件中。加载这个驱动前要先导入jar包</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(driver);</span><br></pre></td></tr></table></figure></li><li><p>另外还有一些反射方法可以获取Class对象，但前提是你已经获取了一个Class对象</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.getSuperclass()<span class="comment">//获得给定类的父类Class</span></span><br></pre></td></tr></table></figure><ul><li>Class.getClasses()</li><li>Class.getDeclaredClasses()</li><li>Class.getDeclaringClass()</li><li>Class.getEnclosingClass()</li><li>java.lang.reflect.Field.getDeclaringClass()</li><li>java.lang.reflect.Method.getDeclaringClass()</li><li>java.lang.reflect.Constructor.getDeclaringClass()</li></ul></li></ol><p>示例：通过Class获取类修饰，类型等</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200815140112.png" alt="20200815140112"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReflection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;Reflection&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReflection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; c = HashMap.class;</span><br><span class="line">        <span class="comment">//获取类名</span></span><br><span class="line">        System.out.println(TAG + <span class="string">&quot;Class : &quot;</span> + c.getCanonicalName());</span><br><span class="line">        <span class="comment">//获取类限定符</span></span><br><span class="line">        System.out.println(TAG + <span class="string">&quot;Modifiers : &quot;</span> + Modifier.toString(c.getModifiers()));</span><br><span class="line">        <span class="comment">//获取类泛型信息</span></span><br><span class="line">        TypeVariable&lt;?&gt;[] tv = c.getTypeParameters();</span><br><span class="line">        <span class="keyword">if</span> (tv.length != <span class="number">0</span>) &#123;</span><br><span class="line">            StringBuilder parameter = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;Parameters : &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (TypeVariable&lt;?&gt; t : tv) &#123;</span><br><span class="line">                parameter.append(t.getName());</span><br><span class="line">                parameter.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(TAG + parameter.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(TAG + <span class="string">&quot;  -- No Type Parameters --&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取类实现的所有接口</span></span><br><span class="line">        Type[] intfs = c.getGenericInterfaces();</span><br><span class="line">        <span class="keyword">if</span> (intfs.length != <span class="number">0</span>) &#123;</span><br><span class="line">            StringBuilder interfaces = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;Implemented Interfaces : &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Type intf : intfs) &#123;</span><br><span class="line">                interfaces.append(intf.toString());</span><br><span class="line">                interfaces.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(TAG + interfaces.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(TAG + <span class="string">&quot;  -- No Implemented Interfaces --&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取类继承数上的所有父类</span></span><br><span class="line">        List&lt;Class&gt; l = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        printAncestor(c, l);</span><br><span class="line">        <span class="keyword">if</span> (l.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            StringBuilder inheritance = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;Inheritance Path : &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; cl : l) &#123;</span><br><span class="line">                inheritance.append(cl.getCanonicalName());</span><br><span class="line">                inheritance.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(TAG + inheritance.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(TAG + <span class="string">&quot;  -- No Super Classes --&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取类的注解(只能获取到 RUNTIME 类型的注解)</span></span><br><span class="line">        Annotation[] ann = c.getAnnotations();</span><br><span class="line">        <span class="keyword">if</span> (ann.length != <span class="number">0</span>) &#123;</span><br><span class="line">            StringBuilder annotation = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;Annotations : &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Annotation a : ann) &#123;</span><br><span class="line">                annotation.append(a.toString());</span><br><span class="line">                annotation.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(TAG + annotation.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(TAG + <span class="string">&quot;  -- No Annotations --&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAncestor</span><span class="params">(Class&lt;?&gt; c, List&lt;Class&gt; l)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; ancestor = c.getSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (ancestor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            l.add(ancestor);</span><br><span class="line">            printAncestor(ancestor, l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> TestReflection().testReflection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// ReflectionClass : java.util.HashMap</span></span><br><span class="line"><span class="comment">// ReflectionModifiers : public</span></span><br><span class="line"><span class="comment">// ReflectionParameters : K V</span></span><br><span class="line"><span class="comment">// ReflectionImplemented Interfaces : java.util.Map&lt;K, V&gt; interface java.lang.Cloneable interface java.io.Serializable</span></span><br><span class="line"><span class="comment">// ReflectionInheritance Path : java.util.AbstractMap java.lang.Object</span></span><br><span class="line"><span class="comment">// Reflection  -- No Annotations --</span></span><br></pre></td></tr></table></figure><h3 id="判断是否为某个类的实例"><a href="#判断是否为某个类的实例" class="headerlink" title="判断是否为某个类的实例"></a>判断是否为某个类的实例</h3><p>一般地，我们用instanceof关键字来判断是否为某个类的实例。同时我们也可以借助反射中Class对象的<code>isInstance()</code>方法来判断是否为某个类的实例，它是一个Native方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInstance</span><span class="params">(Object obj)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h3><p>通过反射来生成对象主要有两种方式。</p><ol><li><p>使用Class对象的newInstance()方法来创建Class对象对应类的实例。</p><div class="note info flat"><p>利用newInstance创建对象：调用的类必须有无参的构造器</p></div> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Class&lt;?&gt;代表任何类的一个Class对象。</span></span><br><span class="line"><span class="comment">//使用这个Class对象可以为其他类进行实例化</span></span><br><span class="line"><span class="comment">//因为jvm加载类以后自动在堆区生成一个对应的*.Class对象</span></span><br><span class="line"><span class="comment">//该对象用于让JVM对进行所有*对象实例化。</span></span><br><span class="line">Class&lt;?&gt; c = String.class;</span><br><span class="line"><span class="comment">//Class&lt;?&gt; 中的 ? 是通配符，其实就是表示任意符合泛类定义条件的类，和直接使用 Class效果基本一致。</span></span><br><span class="line"><span class="comment">//但是这样写更加规范，在某些类型转换时可以避免不必要的 unchecked 错误。</span></span><br><span class="line">Object str = c.newInstance();</span><br></pre></td></tr></table></figure></li><li><p>先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建实例。这种方法可以用指定的构造器构造类的实例。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取String所对应的Class对象</span></span><br><span class="line">Class&lt;?&gt; c = String.class;</span><br><span class="line"><span class="comment">//获取String类带一个String参数的构造器</span></span><br><span class="line">Constructor constructor = c.getConstructor(String.class);</span><br><span class="line"><span class="comment">//根据构造器创建实例</span></span><br><span class="line">Object obj = constructor.newInstance(<span class="string">&quot;23333&quot;</span>);</span><br></pre></td></tr></table></figure></li></ol><h2 id="Member"><a href="#Member" class="headerlink" title="Member"></a>Member</h2><p>类成员主要包括<strong>构造函数</strong>，<strong>变量</strong>和<strong>方法</strong>，Java中的操作基本都和这三者相关，而Member的这三个实现类就分别对应他们。</p><ul><li>java.lang.reflect.Field ：对应类变量</li><li>java.lang.reflect.Method ：对应类方法</li><li>java.lang.reflect.Constructor ：对应类构造函数</li></ul><p>反射就是通过这三个类才能在运行时改变对象状态</p><h3 id="突破java的权限检测"><a href="#突破java的权限检测" class="headerlink" title="突破java的权限检测"></a>突破java的权限检测</h3><p>Java运行时会进行访问权限检查，private类型的变量无法进行直接访问<br><code>java.lang.reflect.AccessibleObject</code><br>AccessibleObject为我们提供了一个方法 setAccessible(boolean flag)，该方法的作用就是可以取消 Java 语言访问权限检查。<br>所以任何继承AccessibleObject的类的对象都可以使用该方法取消 Java 语言访问权限检查。（final类型变量也可以通过这种办法访问）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Field</span> <span class="keyword">extends</span> <span class="title">AccessibleObject</span> <span class="keyword">implements</span> <span class="title">Member</span></span></span><br></pre></td></tr></table></figure><p>Field、Method和Constructor都是继承AccessibleObject</p><h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注解类，可用于表示方法，可以通过反射获取注解的内容。</span></span><br><span class="line"><span class="comment">//Java注解的实现是很多注框架实现注解配置的基础</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> Invoke &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserBean的父类PersonBean</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserBean实现的接口User</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserBean</span> <span class="keyword">extends</span> <span class="title">PersonBean</span> <span class="keyword">implements</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;login&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eat food &quot;</span> + food);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String... foods)</span> </span>&#123;</span><br><span class="line">        StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (String food : foods) &#123;</span><br><span class="line">            s.append(food);</span><br><span class="line">            s.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;eat food &quot;</span> + s.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String userName;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> j;</span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> userId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserBean</span><span class="params">(String userName, <span class="keyword">long</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">        <span class="keyword">this</span>.userId = userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Invoke</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">(String devName, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;Hi %s, I&#x27;m a static method&quot;</span>, devName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Invoke</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publicMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m a public method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Invoke</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">privateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m a private method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;UserBean&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;userName=&#x27;&quot;</span> + userName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, userId=&quot;</span> + userId +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h3><p>通过Field你可以访问给定对象的类变量，包括获取变量的类型、修饰符、注解、变量名、变量的值或者重新设置变量值，即使变量是private的。</p><h4 id="获取Field"><a href="#获取Field" class="headerlink" title="获取Field"></a>获取Field</h4><p>Class提供了4种方法获得给定类的Field。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getDeclaredField(String name)</span><br><span class="line"><span class="comment">// 获取指定的变量（只要是声明的变量都能获得，包括private）</span></span><br><span class="line">getField(String name)</span><br><span class="line"><span class="comment">// 获取指定的变量（只能获得public的）</span></span><br><span class="line">getDeclaredFields()</span><br><span class="line"><span class="comment">// 获取所有声明的变量（包括private）</span></span><br><span class="line">getFields()</span><br><span class="line"><span class="comment">// 获取所有的public变量</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Class c = UserBean.class;</span><br><span class="line">    Field[] fields = c.getDeclaredFields();</span><br><span class="line">    <span class="keyword">for</span> (Field f : fields) &#123;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//获取名称</span></span><br><span class="line">        builder.append(<span class="string">&quot;filed name = &quot;</span>);</span><br><span class="line">        builder.append(f.getName());</span><br><span class="line">        <span class="comment">//获取类型</span></span><br><span class="line">        builder.append(<span class="string">&quot; type = &quot;</span>);</span><br><span class="line">        builder.append(f.getType());</span><br><span class="line">        <span class="comment">//获取修饰符</span></span><br><span class="line">        builder.append(<span class="string">&quot; modifiers = &quot;</span>);</span><br><span class="line">        builder.append(Modifier.toString(f.getModifiers()));</span><br><span class="line">        <span class="comment">//获取注解</span></span><br><span class="line">        Annotation[] ann = f.getAnnotations();</span><br><span class="line">        <span class="keyword">if</span> (ann.length != <span class="number">0</span>) &#123;</span><br><span class="line">            builder.append(<span class="string">&quot; annotations = &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Annotation a : ann) &#123;</span><br><span class="line">                builder.append(a.toString());</span><br><span class="line">                builder.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            builder.append(<span class="string">&quot;  -- No Annotations --&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(builder.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// filed name = userName type = class java.lang.String modifiers = public  -- No Annotations --</span></span><br><span class="line"><span class="comment">// filed name = i type = int modifiers = protected  -- No Annotations --</span></span><br><span class="line"><span class="comment">// filed name = j type = int modifiers = static  -- No Annotations --</span></span><br><span class="line"><span class="comment">// filed name = k type = int modifiers = private annotations = @java.lang.Deprecated()</span></span><br><span class="line"><span class="comment">// filed name = userId type = long modifiers = private  -- No Annotations --</span></span><br></pre></td></tr></table></figure><p>获取、设置变量值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserBean userBean = <span class="keyword">new</span> UserBean(<span class="string">&quot;Tom&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        Class c = userBean.getClass();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field fieldName = c.getField(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line">            <span class="comment">//注意获取private变量时，需要用getDeclaredField</span></span><br><span class="line">            Field fieldId = c.getDeclaredField(<span class="string">&quot;userId&quot;</span>);</span><br><span class="line">            fieldName.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//反射获取名字, 年龄</span></span><br><span class="line">            String name = (String) fieldName.get(userBean);</span><br><span class="line">            <span class="keyword">long</span> age = fieldId.getLong(userBean);</span><br><span class="line">            System.out.println(<span class="string">&quot;before set, UserBean userName = &quot;</span> + name + <span class="string">&quot; userId = &quot;</span> + age);</span><br><span class="line">            <span class="comment">//反射重新set名字和年龄</span></span><br><span class="line">            fieldName.set(userBean, <span class="string">&quot;Timmy&quot;</span>);</span><br><span class="line">            fieldId.setInt(userBean, <span class="number">3</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;after set, UserBean &quot;</span> + userBean.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// before set, UserBean userName = Tom userId = 2</span></span><br><span class="line"><span class="comment">// after set, UserBean UserBean&#123;userName=&#x27;Timmy&#x27;, userId=3&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><h4 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h4><p>Class依然提供了4种方法获取Method:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">getDeclaredMethods()</span><br><span class="line"><span class="comment">// 获取所有声明的方法</span></span><br><span class="line"><span class="comment">// 包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。</span></span><br><span class="line">getMethods()</span><br><span class="line"><span class="comment">// 获取所有的public方法</span></span><br><span class="line"><span class="comment">// 包括其继承类的公用方法。</span></span><br><span class="line">getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</span><br><span class="line"><span class="comment">// 根据方法名获得指定的方法，参数name为方法名，参数parameterTypes为方法的参数类型</span></span><br><span class="line"><span class="comment">// 如 getDeclaredMethod(“eat”, String.class)</span></span><br><span class="line">getMethod(String name, Class&lt;?&gt;... parameterTypes)</span><br><span class="line"><span class="comment">// 根据方法名获取指定的public方法，其它同上</span></span><br></pre></td></tr></table></figure><div class="note info flat"><p>注意：获取带参数方法时，如果参数类型错误会报NoSuchMethodException，对于参数是泛型的情况，泛型须当成Object处理（Object.class）</p></div><p>getMethods()和getDeclaredMethods()区别:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Class clazz = UserBean.class;</span><br><span class="line">    <span class="comment">// getDeclaredMethod*()获取的是类自身声明的所有方法，包含public、protected和private方法。</span></span><br><span class="line">    System.out.println(<span class="string">&quot;------共有方法------&quot;</span>);</span><br><span class="line">    <span class="comment">// getDeclaredMethod*()获取的是类自身声明的所有方法，包含public、protected和private方法。</span></span><br><span class="line">    <span class="comment">// getMethod*()获取的是类的所有共有方法，这就包括自身的所有public方法，和从基类继承的、从接口实现的所有public方法。</span></span><br><span class="line">    <span class="keyword">for</span> (Method method : clazz.getMethods()) &#123;</span><br><span class="line">        String name = method.getName();</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        <span class="comment">//打印出了UserBean.java的所有方法以及父类的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;------独占方法------&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Method method : clazz.getDeclaredMethods()) &#123;</span><br><span class="line">        String name = method.getName();</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取所有方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAllMethods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Class c = UserBean.class;</span><br><span class="line">    <span class="keyword">for</span> (Method method : c.getDeclaredMethods()) &#123;</span><br><span class="line">        <span class="comment">//依次获得方法的修饰符，返回类型和名称，外加方法中的参数</span></span><br><span class="line">        <span class="comment">// private static</span></span><br><span class="line">        StringBuilder methodString = <span class="keyword">new</span> StringBuilder(Modifier.toString(method.getModifiers()) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="comment">// void</span></span><br><span class="line">        methodString.append(method.getReturnType().getSimpleName()).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="comment">// staticMethod</span></span><br><span class="line">        methodString.append(method.getName()).append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">        Class[] parameters = method.getParameterTypes();</span><br><span class="line">        Parameter[] p = method.getParameters();</span><br><span class="line">        <span class="keyword">for</span> (Class parameter : parameters) &#123;</span><br><span class="line">            <span class="comment">// String</span></span><br><span class="line">            methodString.append(parameter.getSimpleName()).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        methodString.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        System.out.println(methodString.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取方法返回类型"><a href="#获取方法返回类型" class="headerlink" title="获取方法返回类型"></a>获取方法返回类型</h4><ul><li>getReturnType()：获取目标方法返回类型对应的Class对象</li><li>getGenericReturnType()：获取目标方法返回类型对应的Type对象</li></ul><p>这两个方法有啥区别呢？</p><ol><li><p>getReturnType()返回类型为Class，getGenericReturnType()返回类型为Type， Class实现Type。</p></li><li><p>返回值为普通简单类型如Object, int, String等，getGenericReturnType()返回值和getReturnType()一样</p><p> 例如<code>public String function1()</code>，那么各自返回值为：</p><ul><li>getReturnType()：<code>class java.lang.String</code></li><li>getGenericReturnType()：<code>class java.lang.String</code></li></ul></li><li><p>返回值为泛型<br> 例如<code>public T function2()</code>，那么各自返回值为：</p><ul><li>getReturnType()：<code>class java.lang.Object</code></li><li>getGenericReturnType()：<code>T</code></li></ul></li><li><p>返回值为参数化类型<br> 例如<code>public Class&lt;String&gt; function3()</code>，那么各自返回值为：</p><ul><li>getReturnType()：<code>class java.lang.Class</code></li><li>getGenericReturnType()：<code>java.lang.Class&lt;java.lang.String&gt;</code></li></ul><p>其实反射中所有形如getGenericXXX()的方法规则都与上面所述类似。</p></li></ol><h4 id="获取方法参数类型"><a href="#获取方法参数类型" class="headerlink" title="获取方法参数类型"></a>获取方法参数类型</h4><ul><li>getParameterTypes()：获取目标方法各参数类型对应的Class对象</li><li>getGenericParameterTypes()：获取目标方法各参数类型对应的Type对象</li></ul><p>返回值为数组，区别同上 “方法返回类型的区别” 。</p><h4 id="获取方法声明抛出的异常的类型"><a href="#获取方法声明抛出的异常的类型" class="headerlink" title="获取方法声明抛出的异常的类型"></a>获取方法声明抛出的异常的类型</h4><ul><li>getExceptionTypes()：获取目标方法抛出的异常类型对应的Class对象</li><li>getGenericExceptionTypes()：获取目标方法抛出的异常类型对应的Type对象</li></ul><p>返回值为数组，区别同上</p><h4 id="获取方法参数名称"><a href="#获取方法参数名称" class="headerlink" title="获取方法参数名称"></a>获取方法参数名称</h4><p>.class文件中默认不存储方法参数名称，如果想要获取方法参数名称，需要在编译的时候加上-parameters参数。(构造方法的参数获取方法同样)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的m可以是普通方法Method，也可以是构造方法Constructor</span></span><br><span class="line"><span class="comment">// 获取方法所有参数</span></span><br><span class="line">Parameter[] params = m.getParameters();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; params.length; i++) &#123;</span><br><span class="line">    Parameter p = params[i];</span><br><span class="line">    <span class="comment">// 获取参数类型</span></span><br><span class="line">    p.getType();</span><br><span class="line">    <span class="comment">// 获取参数名称，如果编译时未加上`-parameters`，返回的名称形如`argX`</span></span><br><span class="line">    <span class="comment">// X为参数在方法声明中的位置，从0开始  </span></span><br><span class="line">    p.getName();</span><br><span class="line">    <span class="comment">// 获取参数修饰符</span></span><br><span class="line">    p.getModifiers();</span><br><span class="line">    <span class="comment">// .class文件中是否保存参数名称, 编译时加上`-parameters`返回true,反之flase</span></span><br><span class="line">    p.isNamePresent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取方法修饰符"><a href="#获取方法修饰符" class="headerlink" title="获取方法修饰符"></a>获取方法修饰符</h4><p>方法与Filed等类似</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method.getModifiers();</span><br></pre></td></tr></table></figure><h4 id="几个Method方法"><a href="#几个Method方法" class="headerlink" title="几个Method方法"></a>几个Method方法</h4><ol><li><p>method.isVarArgs()：判断方法参数是否是可变参数</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Constructor&lt;T&gt; <span class="title">getConstructor</span><span class="params">(Class&lt;?&gt;... parameterTypes)</span>  <span class="comment">//返回true</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Constructor&lt;T&gt; <span class="title">getConstructor</span><span class="params">(Class&lt;?&gt; [] parameterTypes)</span>  <span class="comment">//返回flase</span></span></span><br></pre></td></tr></table></figure></li><li><p>method.isSynthetic()：判断是否是复合方法，个人理解复合方法是编译期间编译器生成的方法，并不是源代码中有的方法</p></li><li><p>method.isBridge()：判断是否是桥接方法，桥接方法是 JDK 1.5 引入泛型后，为了使Java的泛型方法生成的字节码和 1.5 版本前的字节码相兼容，由编译器自动生成的方法</p></li></ol><h4 id="通过反射调用方法"><a href="#通过反射调用方法" class="headerlink" title="通过反射调用方法"></a>通过反射调用方法</h4><p>反射通过Method的invoke()方法来调用目标方法。第一个参数为需要调用的目标类对象，如果方法为static的，则该参数为null。后面的参数都为目标方法的参数值，顺序与目标方法声明中的参数顺序一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException, InvocationTargetException</span></span><br></pre></td></tr></table></figure><div class="note info flat"><p>注意：如果方法是private的，可以使用method.setAccessible(true)方法绕过权限检查</p></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Class&lt;?&gt; c = UserBean.class;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//构造UserBean实例</span></span><br><span class="line">        Constructor constructor = c.getConstructor(String.class, <span class="keyword">long</span>.class);</span><br><span class="line">        Object userBean = constructor.newInstance( <span class="string">&quot;Jack&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">//调用无参方法</span></span><br><span class="line">        Method sleep = c.getDeclaredMethod(<span class="string">&quot;login&quot;</span>);</span><br><span class="line">        sleep.invoke(userBean);</span><br><span class="line">        <span class="comment">//调用定项参数方法</span></span><br><span class="line">        Method eat = c.getDeclaredMethod(<span class="string">&quot;eat&quot;</span>, String.class);</span><br><span class="line">        eat.invoke(userBean, <span class="string">&quot;meat&quot;</span>);</span><br><span class="line">        <span class="comment">//调用不定项参数方法</span></span><br><span class="line">        <span class="comment">//不定项参数可以当成数组来处理</span></span><br><span class="line">        Class[] argTypes = <span class="keyword">new</span> Class[] &#123; String[].class &#125;;</span><br><span class="line">        Method varargsEat = c.getDeclaredMethod(<span class="string">&quot;eat&quot;</span>, argTypes);</span><br><span class="line">        String[] foods = <span class="keyword">new</span> String[]&#123;</span><br><span class="line">                <span class="string">&quot;meat&quot;</span>, <span class="string">&quot;vegetable&quot;</span></span><br><span class="line">        &#125;;</span><br><span class="line">        varargsEat.invoke(userBean, (Object)foods);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// login</span></span><br><span class="line"><span class="comment">// eat food meat</span></span><br><span class="line"><span class="comment">// eat food meat vegetable</span></span><br></pre></td></tr></table></figure><p>被调用的方法本身所抛出的异常在反射中都会以InvocationTargetException抛出。换句话说，反射调用过程中如果异常InvocationTargetException抛出，说明反射调用本身是成功的，因为这个异常是目标方法本身所抛出的异常。</p><h2 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h2><p>和Method一样，Class也为Constructor提供了4种方法获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</span><br><span class="line"><span class="comment">// 获取指定构造函数，参数parameterTypes为构造方法的参数类型</span></span><br><span class="line">getConstructor(Class&lt;?&gt;... parameterTypes)</span><br><span class="line"><span class="comment">// 获取指定public构造函数，参数parameterTypes为构造方法的参数类型</span></span><br><span class="line">getDeclaredConstructors()</span><br><span class="line"><span class="comment">// 获取所有声明的构造方法</span></span><br><span class="line">getConstructors()</span><br><span class="line"><span class="comment">// 获取所有的public构造方法</span></span><br></pre></td></tr></table></figure><p>构造方法的名称、限定符、参数、声明的异常等获取方法都与Method类似，请参照Method。</p><p>之前见过，有两种方式创建实例</p><ol><li>java.lang.reflect.Constructor.newInstance()<br>2， Class.newInstance()</li></ol><p>区别：</p><ol><li>Class.newInstance()仅可用来调用无参的构造方法；Constructor.newInstance()可以调用任意参数的构造方法</li><li>Class.newInstance()会将构造方法中抛出的异常不作处理原样抛出;Constructor.newInstance()会将构造方法中抛出的异常都包装成InvocationTargetException抛出。</li><li>Class.newInstance()需要拥有构造方法的访问权限;Constructor.newInstance()可以通过setAccessible(true)方法绕过访问权限访问private构造方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; c = UserBean.class;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Constructor constructor = c.getConstructor(String.class, <span class="keyword">long</span>.class);</span><br><span class="line">    UserBean userBean = (UserBean) constructor.newInstance( <span class="string">&quot;Jack&quot;</span>, <span class="number">3</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><p>注意：反射不支持自动封箱，传入参数时要小心（自动封箱是在编译期间的，而反射在运行期间）</p></div><h2 id="数组和枚举"><a href="#数组和枚举" class="headerlink" title="数组和枚举"></a>数组和枚举</h2><p>数组和枚举也是对象，但是在反射中，对数组和枚举的创建、访问和普通对象有那么一丢丢的不同，所以Java反射为数组和枚举提供了一些特定的API接口。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h4><p>数组类型：数组本质是一个对象，所以它也有自己的类型。<br>例如对于<code>int[] intArray</code>，数组类型为<code>class [I</code>。数组类型中的<code>[</code>个数代表数组的维度，例如<code>[</code>代表一维数组，<code>[[</code>代表二维数组；<code>[</code>后面的字母代表数组元素类型，<code>I</code>代表int，一般为类型的首字母大写(long类型例外，为J)。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// byte类型一维数组</span></span><br><span class="line">class [B</span><br><span class="line"><span class="comment">// short类型一维数组</span></span><br><span class="line">class [S</span><br><span class="line"><span class="comment">// int类型一维数组</span></span><br><span class="line">class [I</span><br><span class="line"><span class="comment">// char类型一维数组</span></span><br><span class="line">class [C</span><br><span class="line"><span class="comment">// long类型一维数组，J代表long类型，因为L被引用对象类型占用了</span></span><br><span class="line">class [J</span><br><span class="line"><span class="comment">// float类型一维数组</span></span><br><span class="line">class [F</span><br><span class="line"><span class="comment">// double类型一维数组</span></span><br><span class="line">class [D</span><br><span class="line"><span class="comment">// 引用类型一维数组</span></span><br><span class="line">class [Lcom.dada.Season</span><br><span class="line"><span class="comment">// 引用类型二维数组</span></span><br><span class="line">class [[Ljava.lang.String  </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取一个变量的类型</span></span><br><span class="line">Class&lt;?&gt; c = field.getType();</span><br><span class="line"><span class="comment">//判断该变量是否为数组</span></span><br><span class="line"><span class="keyword">if</span> (c.isArray()) &#123;</span><br><span class="line">   <span class="comment">//获取数组的元素类型</span></span><br><span class="line">   c.getComponentType()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建和初始化数组"><a href="#创建和初始化数组" class="headerlink" title="创建和初始化数组"></a>创建和初始化数组</h4><p>Java反射为我们提供了java.lang.reflect.Array类用来创建和初始化数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建数组，参数componentType为数组元素的类型，后面不定项参数的个数代表数组的维度，参数值为数组长度</span></span><br><span class="line">Array.newInstance(Class&lt;?&gt; componentType, <span class="keyword">int</span>... dimensions)</span><br><span class="line"><span class="comment">//设置数组值，array为数组对象，index为数组的下标，value为需要设置的值</span></span><br><span class="line">Array.set(Object array, <span class="keyword">int</span> index, <span class="keyword">int</span> value)</span><br><span class="line"><span class="comment">//获取数组的值，array为数组对象，index为数组的下标</span></span><br><span class="line">Array.get(Object array, <span class="keyword">int</span> index)</span><br></pre></td></tr></table></figure><p>例：用反射创建<code>int[] array = new int[]&#123;1, 2&#125;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object array = Array.newInstance(<span class="keyword">int</span>.class, <span class="number">2</span>);</span><br><span class="line">Array.setInt(array , <span class="number">0</span> , <span class="number">1</span>);</span><br><span class="line">Array.setInt(array , <span class="number">1</span> , <span class="number">2</span>);</span><br></pre></td></tr></table></figure><div class="note info flat"><p>注意：反射支持数据自动转换，但不允许数据强制转换。意思是对于上述set方法，你可以在int类型数组中 set short类型数据，但不可以set long类型数据，否则会报IllegalArgumentException</p></div><h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><p>Java反射没有提供能够直接访问多维数组元素的API，但你可以把多维数组当成数组的数组处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Object matrix = Array.newInstance(<span class="keyword">int</span>.class, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">Object row0 = Array.get(matrix, <span class="number">0</span>);</span><br><span class="line">Object row1 = Array.get(matrix, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Array.setInt(row0, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">Array.setInt(row0, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">Array.setInt(row1, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">Array.setInt(row1, <span class="number">1</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Object matrix = Array.newInstance(<span class="keyword">int</span>.class, <span class="number">2</span>);</span><br><span class="line">Object row0 = Array.newInstance(<span class="keyword">int</span>.class, <span class="number">2</span>);</span><br><span class="line">Object row1 = Array.newInstance(<span class="keyword">int</span>.class, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Array.setInt(row0, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">Array.setInt(row0, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">Array.setInt(row1, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">Array.setInt(row1, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">Array.set(matrix, <span class="number">0</span>, row0);</span><br><span class="line">Array.set(matrix, <span class="number">1</span>, row1);</span><br></pre></td></tr></table></figure><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举隐式继承自java.lang.Enum，Enum继承自Object，所以枚举本质也是一个类，也可以有成员变量，构造方法，方法等；对于普通类所能使用的反射方法，枚举都能使用；另外java反射额外提供了几个方法为枚举服务。<br>枚举隐式继承自java.lang.Enum，Enum继承自Object，所以枚举本质也是一个类，也可以有成员变量，构造方法，方法等；对于普通类所能使用的反射方法，枚举都能使用；另外java反射额外提供了几个方法为枚举服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class.isEnum()</span><br><span class="line"><span class="comment">// Indicates whether this class represents an enum type</span></span><br><span class="line">Class.getEnumConstants()</span><br><span class="line"><span class="comment">// Retrieves the list of enum constants defined by the enum in the order they&#x27;re declared</span></span><br><span class="line">java.lang.reflect.Field.isEnumConstant()</span><br><span class="line"><span class="comment">// Indicates whether this field represents an element of an enumerated type</span></span><br></pre></td></tr></table></figure><h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><p>注解中常用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取class对象的所有注解</span></span><br><span class="line">Annotation[] annotations = (Annotation[]) class1.getAnnotations();</span><br><span class="line"><span class="comment">// 获取class对象指定注解</span></span><br><span class="line">Annotation annotation = (Annotation) class1.getAnnotation(Deprecated.class);</span><br><span class="line"><span class="comment">// 获取class对象的直接超类</span></span><br><span class="line">Type genericSuperclass = class1.getGenericSuperclass();</span><br><span class="line"><span class="comment">// 获取class对象的所有接口的type集合</span></span><br><span class="line">getGenericInterfaces();</span><br></pre></td></tr></table></figure><p>获取Class对象其他信息方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否是基础类型</span></span><br><span class="line"><span class="keyword">boolean</span> isPrimitive = class1.isPrimitive();</span><br><span class="line"><span class="comment">// 判断是否是集合类</span></span><br><span class="line"><span class="keyword">boolean</span> isArray = class1.isArray();</span><br><span class="line"><span class="comment">// 判断是否是注解类</span></span><br><span class="line"><span class="keyword">boolean</span> isAnnotation = class1.isAnnotation();</span><br><span class="line"><span class="comment">// 判断是否是接口类</span></span><br><span class="line"><span class="keyword">boolean</span> isInterface = class1.isInterface();</span><br><span class="line"><span class="comment">// 判断是否是枚举类</span></span><br><span class="line"><span class="keyword">boolean</span> isEnum = class1.isEnum();</span><br><span class="line"><span class="comment">// 判断是否是匿名内部类</span></span><br><span class="line"><span class="keyword">boolean</span> isAnonymousClass = class1.isAnonymousClass();</span><br><span class="line"><span class="comment">// 判断是否被某个注解类修饰</span></span><br><span class="line"><span class="keyword">boolean</span> isAnnotationPresent = class1.isAnnotationPresent(Deprecated.class);</span><br><span class="line"><span class="comment">// 获取class名字 包含包名路径</span></span><br><span class="line">String className = class1.getName();</span><br><span class="line"><span class="comment">// 获取class的包信息</span></span><br><span class="line">Package aPackage = class1.getPackage();</span><br><span class="line"><span class="comment">// 获取class类名</span></span><br><span class="line">String simpleName = class1.getSimpleName();</span><br><span class="line"><span class="comment">// 获取class访问权限</span></span><br><span class="line"><span class="keyword">int</span> modifiers = class1.getModifiers();</span><br><span class="line"><span class="comment">// 内部类</span></span><br><span class="line">Class&lt;?&gt;[] declaredClasses = class1.getDeclaredClasses();</span><br><span class="line"><span class="comment">// 外部类</span></span><br><span class="line">Class&lt;?&gt; declaringClass = class1.getDeclaringClass();</span><br><span class="line"><span class="comment">// 返回类加载器</span></span><br><span class="line">ClassLoader ClassLoader = class1.getClassLoader()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取某类所有的父类</span></span><br><span class="line">getSuperclass()：  </span><br><span class="line"><span class="comment">// 获取某类所有实现的接口</span></span><br><span class="line">getInterfaces()：</span><br></pre></td></tr></table></figure><h2 id="静态元素"><a href="#静态元素" class="headerlink" title="静态元素"></a>静态元素</h2><p>静态的类，方法，字段和实例类，方法，字段完全不一样，因为它无需初始化类就可以直接使用。</p><h2 id="反射缺点"><a href="#反射缺点" class="headerlink" title="反射缺点"></a>反射缺点</h2><ul><li>性能问题。因为反射是在运行时而不是在编译时，所有不会利用到编译优化，同时因为是动态生成，因此，反射操作的效率要比那些非反射操作低得多。</li><li>安全问题。使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如Applet，那么这就是个问题了。</li><li>代码问题。由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用－－代码有功能上的错误，降低可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/10c29883eac1">Java反射</a><br><a href="https://www.yisu.com/zixun/275335.html">Java基础13：反射详解</a></p><a class="btn-beautify button--animated block blue right" href="https://www.shiming.online/blog/7b510e10/"   title="代理模式"><i class="far fa-hand-point-right fa-fw"></i><span>代理模式</span></a>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
          <category> 反射 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Session和Cookie</title>
      <link href="blog/3a66a386/"/>
      <url>blog/3a66a386/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>本文转发自<a href="https://www.cnblogs.com/endlessdream/p/4699273.html">Session和Cookie的区别与联系</a>并加以修改</p></blockquote><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>你可能有留意到当你浏览网页时，会有一些推送消息，大多数是你最近留意过的同类东西，比如你想买桌子，上淘宝搜了一下，结果连着几天会有各种各样的桌子的链接。<br>这是因为你浏览某个网页的时候，WEB 服务器会先送一些资料放在你的计算机上，类似于你打的文字，选的一些东西什么的，Cookie 会帮你都纪录下来。当下次你再光临同一个网站，WEB服务器会先看看有没有它上次留下的 Cookie 资料，有的话，就会依据 Cookie里的内容来判断使用者，送出特定的网页内容给你。</p><p>Cookie 的使用很普遍，许多有提供个人化服务的网站，都是利用 Cookie来辨认使用者，以方便送出使用者量身定做的内容。</p><p>然而，cookie是什么呢？session又是什么？</p><p>先来了解几个概念:</p><ol><li><p>无状态的HTTP协议：<br> 协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则，超文本传输协议(HTTP)是一种通信协议，它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器。</p><p> HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。</p></li><li><p>会话（Session）跟踪：<br>会话，指用户登录网站后的一系列动作，比如浏览商品添加到购物车并购买。会话（Session）跟踪是Web程序中常用的技术，用来跟踪用户的整个会话。<br>常用的会话跟踪技术是Cookie与Session。Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。</p></li></ol><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>由于HTTP是一种无状态的协议，服务器单从网络连接上无从知道客户身份。用户A购买了一件商品放入购物车内，当再次购买商品时服务器已经无法判断该购买行为是属于用户A的会话还是用户B的会话了。</p><p>怎么办呢？就给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理。</p><p>Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端会把Cookie保存起来。<br>当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。</p><h3 id="Cookie内容"><a href="#Cookie内容" class="headerlink" title="Cookie内容"></a>Cookie内容</h3><p>cookie的内容主要包括：名字，值，过期时间，路径和域。路径与域一起构成cookie的作用范围</p><ul><li><p>Name 和 Value 属性由程序设定,默认值都是空引用。</p></li><li><p>Domain属性的默认值为当前URL的域名部分，不管发出这个cookie的页面在哪个目录下的。</p></li><li><p>Path属性的默认值是根目录，即 ”/” ，不管发出这个cookie的页面在哪个目录下的。可以由程序设置为一定的路径来进一步限制此cookie的作用范围。</p></li><li><p>Expires 属性，这个属性设置此Cookie 的过期日期和时间。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HttpCookie cookie = new HttpCookie(&quot;MyCook&quot;);//初使化并设置Cookie的名称</span><br><span class="line">DateTime dt = DateTime.Now;</span><br><span class="line">TimeSpan ts = new TimeSpan(0, 0, 1, 0, 0);//过期时间为1分钟</span><br><span class="line">cookie.Expires = dt.Add(ts);//设置过期时间</span><br><span class="line">cookie.Values.Add(&quot;userid&quot;, &quot;value&quot;);</span><br><span class="line">cookie.Values.Add(&quot;userid2&quot;, &quot;value2&quot;);</span><br><span class="line">Response.AppendCookie(cookie);</span><br></pre></td></tr></table></figure></li></ul><h3 id="Path和Domain属性"><a href="#Path和Domain属性" class="headerlink" title="Path和Domain属性"></a>Path和Domain属性</h3><ul><li><p>path:　　</p><p>如果<code>http://www.china.com/test/index.html</code> 建立了一个cookie，那么在<code>http://www.china.com/test/</code>目录里的所有页面，以及该目录下面任何子目录里的页面都可以访问这个cookie。</p><p>这就是说，在<code>http://www.china.com/test/test2/test3</code> 里的任何页面都可以访问<code>http://www.china.com/test/index.html</code>建立的cookie。<br>但是，如果<code>http://www.china.com/test/</code> 需要访问<code>http://www.china.com/test/index.html</code>设置的cookie，该怎么办？</p><p>这时，我们要把cookies的path属性设置成“/”。在指定路径的时候，凡是来自同一服务器，URL里有相同路径的所有WEB页面都可以共享cookies。</p></li><li><p>Domain:</p><p>比如： <code>http://www.baidu.com/xxx/login.aspx</code> 页面中发出一个cookie，Domain属性缺省就是<code>www.baidu.com</code>，可以由程序设置此属性为需要的值。这个值是域名，比如<code>www.china.com</code>。<br>这是对path路径属性的一个延伸。如果我们想让 <code>www.china.com</code>能够访问bbs.china.com设置的cookies，该怎么办? 我们可以把domain属性设置成<code>“china.com”</code>， 并把path属性设置成<code>“/”</code>。</p></li></ul><h3 id="会话Cookie和持久Cookie"><a href="#会话Cookie和持久Cookie" class="headerlink" title="会话Cookie和持久Cookie"></a>会话Cookie和持久Cookie</h3><p>若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话cookie。<br>会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规范规定的。</p><p>若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在浏览器的不同进程间共享。<br>这种称为持久Cookie。</p><h3 id="Cookie具有不可跨域名性"><a href="#Cookie具有不可跨域名性" class="headerlink" title="Cookie具有不可跨域名性"></a>Cookie具有不可跨域名性</h3><p>就是说，浏览器访问百度不会带上谷歌的cookie。</p><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。</p><p>客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。</p><p>每个用户访问服务器都会建立一个session，那服务器是怎么标识用户的唯一身份呢？事实上，用户与服务器建立连接的同时，服务器会自动为其分配一个SessionId。</p><h3 id="两个问题"><a href="#两个问题" class="headerlink" title="两个问题"></a>两个问题</h3><ol><li><p>什么东西可以让你每次请求都把SessionId自动带到服务器呢？显然就是cookie了，如果你想为用户建立一次会话，可以在用户授权成功时给他一个唯一的cookie。<br>当一个用户提交了表单时，浏览器会将用户的SessionId自动附加在HTTP头信息中，（这是浏览器的自动功能，用户不会察觉到），当服务器处理完这个表单后，将结果返回给SessionId所对应的用户。<br>试想，如果没有 SessionId，当有两个用户同时进行注册时，服务器怎样才能知道到底是哪个用户提交了哪个表单呢。</p></li><li><p>如何储存需要的信息？服务器通过SessionId作为key，读写到对应的value，这就达到了保持会话信息的目的。</p></li></ol><h3 id="session的创建"><a href="#session的创建" class="headerlink" title="session的创建"></a>session的创建</h3><p>当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了sessionId，如果已包含则说明以前已经为此客户端创建过session，服务器就按照sessionId把这个session检索出来使用（检索不到，会新建一个）。如果客户端请求不包含sessionId，则为此客户端创建一个session并且生成一个与此session相关联的sessionId。<br>sessionId的值是一个既不会重复，又不容易被找到规律以仿造的字符串，这个sessionId将被在本次响应中返回给客户端保存。</p><h3 id="禁用cookie"><a href="#禁用cookie" class="headerlink" title="禁用cookie"></a>禁用cookie</h3><p>如果客户端禁用了cookie，通常有两种方法实现session而不依赖cookie。</p><ol><li><p>URL重写，就是把sessionId直接附加在URL路径的后面。</p></li><li><p>表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。比如：</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">&quot;testform&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/xxx&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;jsessionid&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Session共享"><a href="#Session共享" class="headerlink" title="Session共享"></a>Session共享</h3><p>对于多网站(同一父域不同子域)单服务器，我们需要解决的就是来自不同网站之间SessionId的共享。<br>由于域名不同(<code>aaa.test.com</code>和<code>bbb.test.com</code>)，而SessionId又分别储存在各自的cookie中，因此服务器会认为对于两个子站的访问,是来自不同的会话。<br>解决的方法是通过修改cookies的域名为父域名达到cookie共享的目的,从而实现SessionId的共享。带来的弊端就是，子站间的cookie信息也同时被共享了。  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>cookie数据存放在客户的浏览器上，session数据放在服务器上。</li><li>cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。</li><li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie（Cookies不会占用服务器资源，是存在客服端内存或者一个cookie的文本文件中）。</li><li>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</li><li>可以考虑将登陆信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中。</li></ol><h2 id="Cookie和Session的区别"><a href="#Cookie和Session的区别" class="headerlink" title="Cookie和Session的区别"></a>Cookie和Session的区别</h2><ol><li>存储位置不同<ul><li>cookie的数据信息存放在客户端浏览器上。</li><li>session的数据信息存放在服务器上。</li></ul></li><li>存储容量不同<ul><li>单个cookie保存的数据&lt;=4KB，一个站点最多保存20个Cookie。</li><li>对于session来说并没有上限，但出于对服务器端的性能考虑，session内不要存放过多的东西，并且设置session删除机制。</li></ul></li><li>存储方式不同<ul><li>cookie中只能保管ASCII字符串，并需要通过编码方式存储为Unicode字符或者二进制数据。</li><li>session中能够存储任何类型的数据，包括且不限于string，integer，list，map等。</li></ul></li><li>隐私策略不同<ul><li>cookie对客户端是可见的，别有用心的人可以分析存放在本地的cookie并进行cookie欺骗，所以它是不安全的。</li><li>session存储在服务器上，对客户端是透明对，不存在敏感信息泄漏的风险。</li></ul></li><li>服务器压力不同<ul><li>cookie保管在客户端，不占用服务器资源。对于并发用户十分多的网站，cookie是很好的选择。</li><li>session是保管在服务器端的，每个用户都会产生一个session。假如并发访问的用户十分多，会产生十分多的session，耗费大量的内存。</li></ul></li><li>浏览器支持不同<ul><li>假如客户端浏览器不支持cookie：<ul><li>cookie是需要客户端浏览器支持的，假如客户端禁用了cookie，或者不支持cookie，则会话跟踪会失效。关于WAP上的应用，常规的cookie就派不上用场了。</li><li>运用session需要使用URL地址重写的方式。一切用到session程序的URL都要进行URL地址重写，否则session会话跟踪还会失效。</li></ul></li><li>假如客户端支持cookie：<ul><li>cookie既能够设为本浏览器窗口以及子窗口内有效，也能够设为一切窗口内有效。</li><li>session只能在本窗口以及子窗口内有效。</li></ul></li></ul></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ul><li><a href="https://www.cnblogs.com/endlessdream/p/4699273.html">Session和Cookie的区别与联系</a></li><li><a href="https://www.jianshu.com/p/2f7031a69f43">Cookie和Session的区别</a></li></ul></blockquote><a class="btn-beautify button--animated block blue right" href="https://www.shiming.online/blog/a8fdf5f8/"   title="SpringBoot基础"><i class="far fa-hand-point-right fa-fw"></i><span>SpringBoot基础</span></a>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> Java Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Session和Cookie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>forward和redirect</title>
      <link href="blog/ab0d8940/"/>
      <url>blog/ab0d8940/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>本文转自<a href="https://blog.csdn.net/weixin_37766296/article/details/80375106">forward和redirect的区别是什么？</a></p></blockquote><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>forward和redirect是servlet中的两种主要的跳转方式。forward又叫转发（直接转发），redirect叫做重定向（间接转发）。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li>地址栏</li><li>数据共享</li><li>应用场景</li><li>效率</li><li>本质</li><li>转发次数。</li></ul><ol><li><p>从地址栏显示来说：</p><ul><li><p>forword是服务器内部的重定向，服务器直接访问目标地址的 url 网址，把里面的东西读取出来，但是客户端并不知道，因此用forward的话，客户端浏览器的网址是<strong>不会发生变化</strong>的。</p></li><li><p>redirect是服务器根据逻辑，发送一个状态码，告诉浏览器重新去请求那个地址，所以地址栏显示的是<strong>新的地址</strong>。</p></li></ul></li><li><p>从数据共享来说：</p><ul><li><p>由于在整个定向的过程中用的是同一个request，因此forward会将request的信息带到被重定向的jsp或者servlet中使用。即可以<strong>共享数据</strong></p></li><li><p>redirect<strong>不能共享</strong></p></li></ul></li><li><p>从运用的地方来说:</p><ul><li><p>forword 一般用于用户登录的时候，根据角色转发到相应的模块</p></li><li><p>redirect一般用于用户注销登录时返回主页面或者跳转到其他网站</p></li></ul></li><li><p>从效率来说：</p><p> forword效率高，而redirect效率低</p></li><li><p>从本质来说：<br> <strong>forword转发是服务器的行为，而redirect重定向是客户端的行为</strong></p><ul><li>转发过程:客户浏览器发送http请求–web服务器接受此请求–调用内部的一个方法在容器内部完成请求处理和转发动作–将目标资源发送给客户。<br>在这里,转发的路径必须是同一个web容器下的url,其不能转向到其他的web路径上去,中间传递的是自己的容器内的request。在客户浏览器路径栏显<br>示的仍然是其第一次访问的路径,也就是说客户是感觉不到服务器做了转发的。转发行为是浏览器只做了一次访问请求。</li><li>重定向过程:客户浏览器发送http请求–web服务器接受后发送302状态码响应及对应新的location给客户浏览器–客户浏览器发现是302响应，则自动再发送一个新的http请求,请求url是新的location地址–服务器根据此请求寻找资源并发送给客户。<br>在这里location可以重定向到任意URL,既然是浏览器重新发出了请求,则就没有什么request传递的概念了。在客户浏览器路径栏显示的是其重定向的路径,客户可以观察到地址的变化的。<br>重定向行为是浏览器做了至少两次的访问请求的。</li></ul></li><li><p>从请求的次数来说：<br> 如上一节所说：forword只有一次请求，而redirect有两次请求。</p><p> 重定向，其实是两次request:第一次，客户端 request A；服务器响应，并response回来，告诉浏览<br>器，你应该去B。第二次，客户端 request B；服务器响应，返回数据。这个时候IE可以看到地址变了，而且历史的回退按钮也亮了。重定向可以访问自己web应用以外的资源。在重定向的过程中,传输的信息会被丢失。</p></li></ol><p>举例：<br>请求转发是服务器内部把对一个request/response的处理权，移交给另外一个，对于客户端而言，它只知道自己最早请求的那个A,而不知道中间的B,甚<br>至C、D。传输的信息不会丢失。</p><p>再举一个简单的例子：<br>假设你去办理某个执照：</p><ul><li>重定向:你先去了A局，A局的人说:“这个事情不归我们管，去B局”然后你就从A退了出来，自己乘车去了B局。</li><li>转发:你先去了A局，A局看了以后，知道这个事情其实应该B局来管，但是他没有把你退回来，而是让你坐一会儿，<br>自己到后面办公室联系了B的人，让他们办好后，送了过来。</li></ul><p>转发的时候你并不知道A局有没有去联系B局，信息有没有被泄露，有没有丢失。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 转发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合</title>
      <link href="blog/4509351/"/>
      <url>blog/4509351/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Java是面向对象的语言，而面向对象语言对事物的描述是通过对象体现的，为了方便对多个对象进行操作，我们必须把多个对象进行存储。<br>已有的容器类型有：数组和StringBuffer。但是，StringBuffer的结果是一个字符串，不一定满足我们的要求，所以我们只能选择数组，这就是对象数组。<br>而对象数组又不能适应变化的需求，因为数组的长度是固定的，此时，为了适应变化的需求，Java就提供了集合类。</p><blockquote><p>来自百度百科：集合框架（Java Collections Framework，JCF）是为表示和操作集合而规定的一种统一的标准的体系结构。任何集合框架都包含三大块内容：对外的接口、接口的实现和对集合运算的算法。<br>合理地利用Java集合框架不但可以提高程序的运行速度和质量，而且还可以减少设计新的API（Application Programming Interface，应用程序接口），设计者和实现者不需要在每次创建一种依赖于集合内容的API时重新设计，只需使用标准集合框架的接口即可。</p></blockquote><p>与现代数据结构常见的类库一样，Java集合类库将接口(interface)与实现(implementation)分离。</p><p>Java集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键/值对映射。Collection接口又有3种子类型，List、Set和Queue，再下面是一些抽象类，最后是具体实现类，常用的有ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap等等。</p><blockquote><p>常用容器(图片来自<a href="https://mp.weixin.qq.com/s/Yl9pTaQYKwf0rZ6InG9OZg">Java 208 道面试题：第二模块答案</a>)</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200811111639.png" alt="20200811111639"></p><h3 id="数组和集合的区别"><a href="#数组和集合的区别" class="headerlink" title="数组和集合的区别"></a>数组和集合的区别</h3><ol><li>长度区别<br>数组的长度固定；集合长度可变</li><li>内容区别<br>数组存储的是同一种类型的元素；集合可以存储不同类型的元素</li><li>元素的数据类型<br>数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用类型。</li></ol><h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h2><p>在Java类库中，集合类的基本接口是Collection接口。这个接口有两个基本方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E element)</span></span>;</span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>add(): 用于向集合中添加元素，如果添加元素改变了集合就返回true，集合没有变化就返回false。</li><li>iterator(): 用于返回一个实现了Iterator接口的对象。可以使用这个迭代器对象依次访问集合中的元素。</li></ul><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。</p><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;remove&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span></span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">while</span> (hasNext())</span><br><span class="line">            action.accept(next());</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>default:<br>Java 8 新增了接口的默认方法。<br>简单说，默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法。<br>我们只需在方法名前面加个 default 关键字即可实现默认方法。</p></blockquote><ul><li>next(): 返回迭代器的下一个元素，并且更新迭代器的状态。</li><li>hasNext(): 检测集合中是否还有元素。</li><li>remove(): 将迭代器返回的元素删除。</li><li>forEachRemaining(): jdk1.8新增默认方法。简单来说，就是对集合中<strong>剩余的元素</strong>进行操作，直到元素完毕或者抛出异常。</li></ul><p>通过反复调用next()方法，可以逐个访问集合中的每个元素，但是，如果到达了集合的末尾，next()方法将抛出<code>NoSuchElementException</code>。<br>因此，需要在调用next之前调用hasNext()方法，如果迭代器还有多个可访问对象，这个方法就返回true。</p><blockquote><p>next()方法说明(来自《Java核心技术》)<br>Java 集合类库中的迭代器与其他类库中的迭代器在概念上有着重要的区别。在传统的集合类库中，例如，C++的标准模版库，迭代器是根据数组索引建模的。<br>如果给定这样一个迭代器，就可以查看指定位置上的元素，就像知道数组索引i就可以查看数组元素a[i]一样。<br>不需要查找元素， 就可以将迭代器向前移动一个位置。这与不需要执行查找操作就可以通过i++将数组索引向前移动相同。<br>但是，Java 迭代器并不是这样操作的。查找操作与位置变更是紧密相连的。查找一个元素的唯一方法是调用 next. 而在执行查找操作的同时，迭代器的位置随之向前移动。<br>因此，应该<strong>将 Java 迭代器认为是位于两个元素之间。当调用 next 时， 迭代器就越过下一个元素 ，并返回刚刚越过的那个元素的引用。</strong></p></blockquote><p>用<code>for each</code>循环可以很简单的完成查看集合中每个元素的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Collection c =  ... ;</span><br><span class="line"><span class="keyword">for</span>(String element : c)&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用<code>forEach()</code> 方法遍历。<code>forEach</code>为Iterable接口的方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">            <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">                action.accept(t);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Spilterator 可以让我们在多线程下遍历集合，基本思想就是把一个集合分割成多个小集合由多个线程遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Spliterator&lt;T&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliteratorUnknownSize(iterator(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例：<code>list.forEach(System.out::println)</code>可以输出list中的每个值。</p><p>Collection接口扩展了Iterable接口。因此，对于标准类库中的任何集合都可以使用<code>forEach</code>循环。</p><p>Java SE 8中，可以调用forEachRemaining()方法并提供一个lambda表达式，他将对剩余所有元素调用这个表达式，直到没有元素位置。</p><blockquote><p>示例代码参考<a href="https://www.cnblogs.com/it-deepinmind/p/13376544.html">forEachRemaining()方法的用法</a></p></blockquote><p>remove()方法会删除上次调用next()方法返回的元素。对next()方法和remove()方法的调用具有依赖性，如果调用remove()之前没有调用next()是不合法的，会抛出<code>IllegalStateException</code>异常。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建元素类型为Integer的集合</span></span><br><span class="line">        Collection&lt;Integer&gt; collection = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 添加数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            collection.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取该集合的迭代器</span></span><br><span class="line">        Iterator&lt;Integer&gt; it = collection.iterator();</span><br><span class="line">        <span class="comment">// 删除集合中的第一个元素(先越过第一个元素  ,再删除)</span></span><br><span class="line">        it.next();</span><br><span class="line">        it.remove();</span><br><span class="line">        <span class="comment">// 连续删除两个元素(类似于删除第一个元素,删除第二个元素也需要先越过)</span></span><br><span class="line">        it.next();</span><br><span class="line">        it.remove();</span><br><span class="line">        <span class="comment">// for each输出集合剩余元素</span></span><br><span class="line">        <span class="keyword">for</span> (Integer i : collection) &#123;</span><br><span class="line">            System.out.print(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出结果：2 3 4</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="集合常用方法"><a href="#集合常用方法" class="headerlink" title="集合常用方法"></a>集合常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于将元素e放入当前集合中。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 用于将参数指定集合中的所有元素放入当前集合中。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 用于从当前集合中删除参数指定的元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 用于从当前集合中删除参数指定集合中的所有元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 用于将当前集合中的所有元素移除。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 用于判断当前集合中是否包含参数指定的单个元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 用于判断当前集合中是否包含参数指定集合中的所有元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 用于判断当前集合是否为空。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 用于返回当前集合中元素的个数。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 用于获取当前集合和参数集合的交集并保留到当前集合中。</span></span></span><br><span class="line"><span class="function"><span class="comment">// 若当前集合中的内容发生了更改则返回true，否则返回false。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span></span></span><br></pre></td></tr></table></figure><h2 id="具体集合"><a href="#具体集合" class="headerlink" title="具体集合"></a>具体集合</h2><blockquote><p>Collection接口继承树,来自<a href="https://www.cnblogs.com/nayitian/p/3266090.html">Java：集合，Collection接口框架图</a></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200811111341.png" alt="20200811111341"></p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>列表<strong>特有且常用</strong>方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 在指定位置添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;</span><br><span class="line">    <span class="comment">// 用于将集合c中所有元素插入到当前集合中index指向的位置。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 获取指定位置的元素</span></span></span><br><span class="line"><span class="function">    E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="comment">// 用于将index位置的元素从当前集合移除。</span></span><br><span class="line">    <span class="comment">// 返回被删除的元素值，下标不合理时会产生下标越界异常。</span></span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 使用element元素替换当前集合中index位置的元素，返回被替换的元素。</span></span></span><br><span class="line"><span class="function">    E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 用于返回当前集合中从fromIndex(包含)到toIndex(不包含)之间的部分视图。</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 返回的集合和当前集合共用同一块内存区域。</span></span></span><br><span class="line"><span class="function">    List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// List集合特有迭代器</span></span></span><br><span class="line"><span class="function">    ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="listIterator"><a href="#listIterator" class="headerlink" title="listIterator"></a>listIterator</h4><blockquote><p>此部分内容来自<a href="https://blog.csdn.net/manduner/article/details/79982287">Java实用方法整理（五）——集合类常用方法</a></p></blockquote><p>ListIterator listIterator()：List集合特有的迭代器。该迭代器继承了Iterator迭代器，所以，就可以直接使用hasNext()和next()方法。</p><p>特有功能：</p><ul><li>Object previous()：获取上一个元素；</li><li>boolean hasPrevious()：判断是否有元素。</li></ul><p>注意：ListIterator可以实现逆向遍历，但是必须先正向遍历，才能逆向遍历，所以一般无意义，不使用该方法进行集合的迭代。</p><h5 id="Iterator-和-ListIterator-区别"><a href="#Iterator-和-ListIterator-区别" class="headerlink" title="Iterator 和 ListIterator 区别"></a>Iterator 和 ListIterator 区别</h5><ul><li>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。</li><li>Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。</li><li>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</li></ul><p>应用示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 需求：有如下集合，请判断该集合里面是否包含“java”这个元素，如果有，就添加一个“love”元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1，展示一个会出错的代码</span></span><br><span class="line"><span class="comment"> * 出错提示：ConcurrentModificationException：当方法检测到对象的并发修改，但不允许这种修改时，抛出此异常。</span></span><br><span class="line"><span class="comment"> * 也就是说：迭代器遍历元素的时候，通过集合是不能修改元素的（不能调用集合方法）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Iterator it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    String s = (String)it.next();</span><br><span class="line">    <span class="keyword">if</span>(s.equals(<span class="string">&quot;java&quot;</span>))&#123;</span><br><span class="line">      list.add(<span class="string">&quot;love&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2，当遇到以上错误时，给出两种解决办法</span></span><br><span class="line"><span class="comment"> * 首先展示第一种解决办法：使用ListIterator的add()方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">ListIterator lit = list.listItertor();</span><br><span class="line"><span class="keyword">while</span>(lit.hasNext())&#123;</span><br><span class="line">    String s = (String)lit.next();</span><br><span class="line">    <span class="keyword">if</span>(s.equals(<span class="string">&quot;java&quot;</span>))&#123;</span><br><span class="line">      lit.add(<span class="string">&quot;love&quot;</span>);<span class="comment">//注意：此处是利用迭代器进行添加元素，刚添加的元素处于刚才迭代的元素的后面。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 3，给出另一种解决办法：</span></span><br><span class="line"><span class="comment"> * 使用普通循环方法，即使用get()和size()的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">    String s = (String)list.get(i);</span><br><span class="line">    <span class="keyword">if</span>(s.equals(<span class="string">&quot;java&quot;</span>))&#123;</span><br><span class="line">        list.add(<span class="string">&quot;love&quot;</span>);<span class="comment">//注意：此处是将新的元素添加到了集合的最后</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="List子类特点"><a href="#List子类特点" class="headerlink" title="List子类特点"></a>List子类特点</h4><ul><li>ArrayList：底层数据结构是数组，查询快，增删慢；线程不安全，效率高。</li><li>Vector：底层数据结构是数组，查询快，增删慢；线程安全，效率低。现在已不常用</li><li>LinkedList：底层数据结构是链表，查询慢，增删快。线程不安全，效率高。</li></ul><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>如继承树中所示,LinkedList既可以实现Queue接口,也可以实现List接口.只不过, Queue接口窄化了对LinkedList的方法的访问权限（即在方法中的参数类型如果是Queue时，就完全只能访问Queue接口所定义的方法了，而不能直接访问 LinkedList的非Queue的方法），以使得只有恰当的方法才可以使用。</p><h5 id="LinkedList常用方法"><a href="#LinkedList常用方法" class="headerlink" title="LinkedList常用方法"></a>LinkedList常用方法</h5><ul><li>添加<ul><li>public void addFirst(Object e)</li><li>public void addLast(Object e) //和add()功能一样，所以不常用此方法</li></ul></li><li>获取<ul><li>puclic Object getFirst()</li><li>public Object getLast()</li></ul></li><li>删除<ul><li>public Object removeFirst()</li><li>public Object removeLast()</li></ul></li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set接口的特点是不能包含重复的元素。对Set中任意的两个元素element1和element2都有elementl.equals（element2）= false。另外，Set最多有一个null元素。此接口模仿了数学上的集合概念。</p><ul><li>AbstractSet是一个实现Set接口的抽象类，Set接口有三个具体实现类，分别是散列集HashSet、链式散列集LinkedHashSet和树形集TreeSet。</li><li>SortedSet是个接口，它里面的（只有TreeSet这一个实现可用）中的元素一定是有序的。</li></ul><blockquote><p>Set常用方法参考Collection接口即可。</p></blockquote><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>散列集HashSet是一个用于实现Set接口的具体类，可以使用它的无参构造方法来创建空的散列集，也可以由一个现有的集合创建散列集。</p><p>查看散列集HashSet的源码实现可以看到它内部是使用一个HashMap来存放元素的，因为HashSet的元素就是其内部HashMap的键集合，所以HashSet可以做到元素不重复。</p><p>示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">set.add(<span class="string">&quot;11111&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;22222&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;33333&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;44444&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;22222&quot;</span>);</span><br><span class="line">System.out.println(set.size()); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String e : set) &#123;</span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 44444</span></span><br><span class="line"><span class="comment">// 33333</span></span><br><span class="line"><span class="comment">// 11111</span></span><br><span class="line"><span class="comment">// 22222</span></span><br></pre></td></tr></table></figure><p>可以看到只输出4个结果,并且无序</p><h5 id="HashSet总结"><a href="#HashSet总结" class="headerlink" title="HashSet总结"></a>HashSet总结</h5><ol><li><strong>实现原理</strong>（面试）<ol><li>底层数据结构是哈希表。(无序,唯一)</li><li>HashSet的值存放于HashMap的key上。</li><li>HashMap的value统一为PRESENT。</li></ol></li><li>依赖hashCode()和equals()(<em>hashcode相等不代表equals也相等</em>)保证数据唯一性(所以加入的元素要注意hashCode()方法的实现)</li><li>不能保证元素的排列顺序</li><li>HashSet不是同步的，多线程访问同一步HashSet对象时，需要手工同步。</li><li>集合元素值可以是null</li></ol><h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><p>LinkedHashSet是继承自HashSet的，支持对规则集内的元素排序。HashSet中的元素是没有被排序的，而LinkedHashSet中的元素可以按照它们插入规则集的顺序提取。</p><h5 id="LinkedHashSet总结"><a href="#LinkedHashSet总结" class="headerlink" title="LinkedHashSet总结"></a>LinkedHashSet总结</h5><ol><li>底层数据结构是链表和哈希表。(FIFO插入有序,唯一)<ol><li>由链表保证元素有序</li><li>由哈希表保证元素唯一</li></ol></li><li>对集合迭代时，按增加顺序返回元素。</li><li>性能略低于HashSet，因为需要维护元素的插入顺序。但迭代访问元素时会有好性能，因为它采用链表维护内部顺序。</li></ol><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>TreeSet类是SortedSet接口的实现类。因为需要排序，所以性能肯定差于HashSet。底层数据结构是红黑树。(唯一，有序),这样就能从Set里面提取一个有序序列了</p><h5 id="TreeSet总结"><a href="#TreeSet总结" class="headerlink" title="TreeSet总结"></a>TreeSet总结</h5><ol><li>新增方法:<ul><li>first()：返回第一个元素</li><li>last()：返回最后一个元素</li><li>lower(Object o)：返回指定元素之前的元素</li><li>higher(Obect o)：返回指定元素之后的元素</li><li>subSet(fromElement, toElement)：返回子集合</li></ul></li><li>如何保证元素排序的呢?<ul><li>自然排序</li><li>比较器排序</li></ul></li><li>如何保证元素唯一性的呢?<br>根据比较的返回值是否是0来决定</li></ol><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>Queue接口是Collection接口的子接口，与List接口是平级关系。<br>该接口主要描述具有先进先出特性的数据结构，简称为FIFO(first in first out)，叫队列。<br>该接口的主要实现类是LinkedList类，因此该类在增删方面有一定的优势。</p><p>Queue 接口并未定义阻塞队列的方法，而这在并发编程中是很常见的。BlockingQueue 接口定义了那些等待元素出现或等待队列中有可用空间的方法，这些方法扩展了此接口。</p><p>Queue 实现通常不允许插入 null 元素，尽管某些实现（如 LinkedList）并不禁止插入 null。即使在允许 null 的实现中，也不应该将 null 插入到 Queue 中，因为 null 也用作 poll 方法的一个特殊返回值，表明队列不包含元素。</p><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将元素加入到队尾</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"><span class="comment">// 将指定的元素插入此队列（如果立即可行且不会违反容量限制），当使用有容量限制的队列时，此方法通常要优于 add(E)，后者可能无法插入元素，而只是抛出一个异常。推荐使用此方法取代add</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line"><span class="comment">// 移除队列头部的元素，队列为空时抛出异常</span></span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 移除队列头部的元素，队列为空时返回null。推荐使用此方法取代remove</span></span><br><span class="line"><span class="function">E <span class="title">poll</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取但是不移除此队列的头，</span></span><br><span class="line"><span class="function">E <span class="title">element</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取队列头部元素却不删除元素，队列为空返回null。</span></span><br><span class="line"><span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><p>PriorityQueue保存队列元素的顺序并不是按照加入队列的顺序，而是按队列元素的大小重新排序。当调用peek()或者是poll()方法时，返回的是队列中最小的元素。当然你可以与TreeSet一样，可以自定义排序。自定义排序的一个示范：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPriorityQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(<span class="number">20</span>, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer i, Integer j)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 对数字进行奇偶分类，然后比较返回；偶数有较低的返回值（对2取余数然后相减），奇数直接相减。</span></span><br><span class="line">            <span class="keyword">int</span> result = i % <span class="number">2</span> - j % <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line">                result = i - j;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 倒序插入测试数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        pq.offer(<span class="number">20</span> - i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印结果，偶数因为有较低的值，所以排在前面</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        System.out.println(pq.poll());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Deque子接口与ArrayDeque类"><a href="#Deque子接口与ArrayDeque类" class="headerlink" title="Deque子接口与ArrayDeque类"></a>Deque子接口与ArrayDeque类</h4><p>Deque代表一个双端队列，可以当作一个双端队列使用，也可以当作“栈”来使用，因为它包含出栈pop()与入栈push()方法。</p><p><strong>ArrayDeque类为Deque的实现类，数组方式实现。</strong></p><p>常用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 元素增加至队列开头</span></span><br><span class="line">addFirst(E e);</span><br><span class="line"><span class="comment">// 元素增加至队列末尾</span></span><br><span class="line">addLast(E e)；</span><br><span class="line"><span class="comment">// 获取并删除队列第一个元素，队列为空返回null</span></span><br><span class="line">poolFirst()；</span><br><span class="line"><span class="comment">// 获取并删除队列最后一个元素，队列为空返回null</span></span><br><span class="line">poolLast()；</span><br><span class="line"><span class="comment">// “栈”方法，出栈，相当于removeFirst()</span></span><br><span class="line">pop()；</span><br><span class="line"><span class="comment">// “栈”方法，入栈，相当于addFirst()</span></span><br><span class="line">push(E e)；</span><br><span class="line"><span class="comment">// 获取并删除队列第一个元素</span></span><br><span class="line">removeFirst()；</span><br><span class="line"><span class="comment">// 获取并删除队列最后一个元素</span></span><br><span class="line">removeLast()；</span><br></pre></td></tr></table></figure><h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><blockquote><p>来自<a href="https://blog.csdn.net/zhangqunshuai/article/details/80660974">Java集合中List,Set以及Map等集合体系详解(史上最全)</a></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200811210018.png" alt="20200811210018"></p><p>java.util.Map&lt;K,V&gt;接口主要用于存放一对一对元素，分别叫做key(键)和value(值)。<br>  类型参数：<br>      K - 此映射所维护的键的类型<br>      V - 映射值的类型<br>该集合中key是不允许重复的，而且每个key对应唯一的value。</p><p>Map接口有三个比较重要的实现类，分别是HashMap、TreeMap和HashTable。<br>HashMap对键进行散列，TreeMap用将的整体顺序对元素进行排序，并将其组织成搜索值。<br>散列或比较函数只能作用于键。与键关联的值不能进行散列或比较。</p><ul><li>TreeMap是有序的，HashMap和HashTable是无序的。</li><li>Hashtable的方法是同步的，HashMap的方法不是同步的。这是两者最主要的区别。<br>其他区别：<ul><li>Hashtable是线程安全的，HashMap不是线程安全的。</li><li>HashMap效率较高，Hashtable效率较低。<br>如果对同步性或与遗留代码的兼容性没有任何要求，建议使用HashMap。 查看Hashtable的源代码就可以发现，除构造函数外，Hashtable的所有 public 方法声明中都有 synchronized关键字，而HashMap的源码中则没有。</li><li>Hashtable不允许null值，HashMap允许null值（key和value都允许）</li><li>父类不同：Hashtable的父类是Dictionary，HashMap的父类是AbstractMap</li></ul></li></ul><h3 id="Map常用方法"><a href="#Map常用方法" class="headerlink" title="Map常用方法"></a>Map常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于将参数指定的key和value组成一对放入当前集合中。</span></span><br><span class="line"><span class="comment">// 增加key和value时则返回null，修改key和value时则返回key之前对应的value。</span></span><br><span class="line"><span class="function">V <span class="title">put</span><span class="params">(K key, V value)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 用于从当前集合删除key关联的键值对。</span></span></span><br><span class="line"><span class="function"><span class="comment">// 若key不存在则返回null，否则返回key对应的value。</span></span></span><br><span class="line"><span class="function">V <span class="title">remove</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 用于判断当前集合中是否存在参数指定的key。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 用于判断当前集合中是否包含参数指定的value。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 用于根据参数指定的key来返回对应的value。</span></span></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 用于返回当前集合中包含映射关系的Set视图，通俗来说，就是把Map转换为Set。</span></span></span><br><span class="line"><span class="function">Set&lt;Map.Entry&lt;K,V&gt;&gt; <span class="title">entrySet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 用于返回当前集合中包含key的Set视图。</span></span></span><br><span class="line"><span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 接口代表键值对，提供的方法有：</span></span></span><br><span class="line"><span class="function">java.util.Map.Entry&lt;K,V&gt;</span></span><br><span class="line"><span class="function">      <span class="comment">// 用于获取当前键值对中key的数值并返回。</span></span></span><br><span class="line"><span class="function">      K <span class="title">getKey</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      <span class="comment">// 用于获取当前键值对中value的数值并返回。</span></span></span><br><span class="line"><span class="function">      V <span class="title">getValue</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p><p>HashMap的数据结构： 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p><p>当我们往Hashmap中put元素时,首先根据key的hashcode重新计算hash值,根据hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上。</p><p>需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)</p><blockquote><p>图片来自<a href="https://www.jianshu.com/p/63e76826e852">Java - 集合框架完全解析</a></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200811213057.png" alt="20200811213057"></p><h4 id="HashMap容量的初始化"><a href="#HashMap容量的初始化" class="headerlink" title="HashMap容量的初始化"></a>HashMap容量的初始化</h4><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200825093558.png" alt="20200825093558"></p><p><strong>1. 为什么要指定HashMap的容量？</strong></p><p>HashMap的默认容量为16，如果不指定HashMap的容量，要插入768个元素，第一次容量为16，需要持续扩容多次到1024，才能保存1024*0.75=768个元素。<br>所以，如果我们没有设置初始容量大小，随着元素的不断增加，HashMap会发生多次扩容，而HashMap中的扩容机制决定了每次扩容都需要重建hash表，是非常影响性能的。</p><p><strong>2. HashMap指定容量初始化后，底层Hash数组已经被分配内存了吗？</strong></p><p>默认情况下，当我们设置HashMap的初始化容量时，实际上HashMap会采用第一个大于该数值的2的幂作为初始化容量。比如指定容量为1000，则初始化容量为1024。<br>但是指定HashMap的初始化容量后，底层的数组并没有被初始化，依然为null。当第一次put元素时，才会初始化底层Hash数组</p><p>第一次调用put方法插入key-value，会调用resize方法，由于指定了HashMap的容量，那么这里会将底层的Hash数组Node&lt;K,V&gt;[] table初始化容量为上面所说的2的整数次幂;</p><p><strong>3. HashMap中初始容量的合理值是多少？</strong></p><p>在阿里巴巴Java开发手册中：<strong>initialCapacity = （需要存储的元素个数 / 负载因子）+ 1</strong>，负载因子（loadFacotr）默认为0.75。</p><p>当我们使用HashMap(int initialCapacity)来初始化容量的时候，jdk会默认帮我们计算一个相对合理的值当做初始容量。但是这个值并没有参考loadFactor的值。<br>也就是说，如果我们设置的默认值是7，经过Jdk处理之后，会被设置成8，但是，这个HashMap在元素个数达到 8*0.75 = 6的时候就会进行一次扩容，这明显是我们不希望见到的。</p><p>如果我们通过 <code>expectedSize / 0.75F + 1.0F</code> 计算，7 / 0.75 + 1 = 10 ,10经过Jdk处理之后，会被设置成16，这就大大的减少了扩容的几率。</p><p>当HashMap内部维护的哈希表的容量达到75%时（默认情况下），会触发rehash，而rehash的过程是比较耗费时间的。所以初始化容量要设置成expectedSize/0.75 + 1的话，可以有效的减少冲突也可以减小误差。</p><p>所以，我可以认为，当我们明确知道HashMap中元素的个数的时候，把默认容量设置成expectedSize / 0.75F + 1.0F 是一个在性能上相对好的选择，但是，同时也会牺牲些内存。</p><h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><p>LinkedHashMap继承自HashMap，它主要是用链表实现来扩展HashMap类，HashMap中条目是没有顺序的，但是在LinkedHashMap中元素既可以按照它们插入图的顺序排序，也可以按它们最后一次被访问的顺序排序。</p><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>TreeMap基于红黑树数据结构的实现，键值可以使用Comparable或Comparator接口来排序。TreeMap继承自AbstractMap，同时实现了接口NavigableMap，而接口NavigableMap则继承自SortedMap。SortedMap是Map的子接口，使用它可以确保图中的条目是排好序的。</p><p>在实际使用中，如果更新图时不需要保持图中元素的顺序，就使用HashMap，如果需要保持图中元素的插入顺序或者访问顺序，就使用LinkedHashMap，如果需要使图按照键值排序，就使用TreeMap。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ul><li>Java核心技术</li><li><a href="https://blog.csdn.net/zhangqunshuai/article/details/80660974">Java集合中List,Set以及Map等集合体系详解(史上最全)</a></li><li><a href="https://www.cnblogs.com/it-deepinmind/p/13376544.html">forEachRemaining()方法的用法</a></li><li><a href="https://www.cnblogs.com/nayitian/p/3266090.html">Java：集合，Collection接口框架图</a></li><li><a href="https://blog.csdn.net/xyphf/article/details/84000952#3.2%20Queue%E6%8E%A5%E5%8F%A3%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95">Java集合常用方法介绍</a></li><li><a href="https://www.jianshu.com/p/63e76826e852">Java - 集合框架完全解析</a></li><li><a href="https://www.cnblogs.com/hollischuang/p/11974886.html">关于HashMap容量的初始化，还有这么多学问。</a></li><li><a href="https://www.cnblogs.com/theRhyme/p/11763685.html">为什么要指定HASHMAP的容量？HASHMAP指定容量初始化后，底层HASH数组已经被分配内存了吗？</a></li></ul></blockquote><a class="btn-beautify button--animated block blue right" href="https://www.shiming.online/blog/425444d1/"   title="HashMap和Hashtable区别"><i class="far fa-hand-point-right fa-fw"></i><span>HashMap和Hashtable区别</span></a>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
          <category> 集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java IO</title>
      <link href="blog/11330/"/>
      <url>blog/11330/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p>百度百科：流是一种抽象概念，它代表了数据的无结构化传递。按照流的方式进行输入输出，数据被当成无结构的字节序或字符序列。从流中取得数据的操作称为提取操作，而向流中添加数据的操作称为插入操作。用来进行输入输出操作的流就称为IO流。换句话说，IO流就是以流的方式进行输入输出。</p></blockquote><p>在Java API中，可以从其中读取一个字节序列的对象称作<em>输入流</em>，而可以向其中写入一个字节序列的对象称作<em>输出流</em>。<br>抽象类InputStream和OutputStream构成了输入/输出(I/O)类层次结构的基础<br>Java.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。</p><p>一个流被定义为一个数据序列。输入流用于从源读取数据，输出流用于向目标写数据。<br>下图是一个描述输入流和输出流的类层次图。</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200810165127.png" alt="20200810165127"></p><h3 id="IO分类"><a href="#IO分类" class="headerlink" title="IO分类"></a>IO分类</h3><p>按功能来分：输入流（input）、输出流（output）。<br>按类型来分：字节流和字符流。<br>字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。本质区别：字节流是原生的操作，字符流是经过处理后的操作。</p><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h3><p>该流用于从文件读取数据，它的对象可以用关键字 new 来创建。<br>可以使用字符串类型的文件名来创建一个输入流对象来读取文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStream f = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:/java/hello&quot;</span>);</span><br></pre></td></tr></table></figure><p>也可以使用文件对象创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File f = <span class="keyword">new</span> File(<span class="string">&quot;C:/java/hello&quot;</span>);</span><br><span class="line">InputStream out = <span class="keyword">new</span> FileInputStream(f);</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">序号</th><th align="center">方法及描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">public void close() throws IOException{} 关闭此文件输入流并释放与此流有关的所有系统资源。抛出IOException异常。</td></tr><tr><td align="center">2</td><td align="center">protected void finalize()throws IOException {}                                 这个方法清除与该文件的连接。确保在不再引用文件输入流时调用其 close 方法。抛出IOException异常。</td></tr><tr><td align="center">3</td><td align="center">public int read(int r)throws IOException{}这个方法从 InputStream 对象读取指定字节的数据。返回为整数值。返回下一字节数据，如果已经到结尾则返回-1。</td></tr><tr><td align="center">4</td><td align="center">public int read(byte[] r) throws IOException{}这个方法从输入流读取r.length长度的字节。返回读取的字节数。如果是文件结尾则返回-1。</td></tr><tr><td align="center">5</td><td align="center">public int available() throws IOException{}返回下一次对此输入流调用的方法可以不受阻塞地从此输入流读取的字节数。返回一个整数值。</td></tr></tbody></table><p>InputStream常用子类还有：</p><ul><li>ByteArrayInputStream: 字节数组输入流,</li><li>ObjectInputStream：序列化时使用 一般和ObjectOutputStream一起使用</li><li>FilterInputStream: 过滤输入流,为基础的输入流提供一些额外的操作。</li></ul><h3 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h3><p>该类用来创建一个文件并向文件中写数据。<br>如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件。<br>有两个构造方法可以用来创建 FileOutputStream 对象。<br>使用字符串类型的文件名来创建一个输出流对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OutputStream f = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;C:/java/hello&quot;</span>)</span><br></pre></td></tr></table></figure><p>同样，也可以使用文件对象创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File f = <span class="keyword">new</span> File(<span class="string">&quot;C:/java/hello&quot;</span>);</span><br><span class="line">OutputStream f = <span class="keyword">new</span> FileOutputStream(f);</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">序号</th><th align="center">方法及描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">public void close() throws IOException{}关闭此文件输入流并释放与此流有关的所有系统资源。抛出IOException异常。</td></tr><tr><td align="center">2</td><td align="center">protected void finalize()throws IOException {}这个方法清除与该文件的连接。确保在不再引用文件输入流时调用其 close 方法。抛出IOException异常。</td></tr><tr><td align="center">3</td><td align="center">public void write(int w)throws IOException{}这个方法把指定的字节写到输出流中。</td></tr><tr><td align="center">4</td><td align="center">public void write(byte[] w)把指定数组中w.length长度的字节写到OutputStream中。</td></tr></tbody></table><p>OutputSteam常用子类还有：</p><ul><li>ByteArrayOutputStream: 字节数组输出流</li><li>ObjectOutputStream: 序列化时使用 一般和OjbectInputStream一起使用</li><li>FilterOutputStream:过滤输出流,为基础的输出流提供一些额外的操作。</li></ul><h3 id="常用方法示例"><a href="#常用方法示例" class="headerlink" title="常用方法示例"></a>常用方法示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//根据文件夹的名字来创建对象</span></span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\hello.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//往文件里面一个字节一个字节的写入数据</span></span><br><span class="line">        fileOutputStream.write((<span class="keyword">int</span>)<span class="string">&#x27;h&#x27;</span>);</span><br><span class="line">        fileOutputStream.write((<span class="keyword">int</span>)<span class="string">&#x27;e&#x27;</span>);</span><br><span class="line">        fileOutputStream.write((<span class="keyword">int</span>)<span class="string">&#x27;l&#x27;</span>);</span><br><span class="line">        fileOutputStream.write((<span class="keyword">int</span>)<span class="string">&#x27;l&#x27;</span>);</span><br><span class="line">        fileOutputStream.write((<span class="keyword">int</span>)<span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">        String s = <span class="string">&quot; world&quot;</span>;</span><br><span class="line">        <span class="comment">//向文件里面一个字节数组的写入文件</span></span><br><span class="line">        fileOutputStream.write(s.getBytes());</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">        <span class="comment">//根据文件夹的名字来创建对象</span></span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\hello.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> by = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//一个字节一个字节的读出数据</span></span><br><span class="line">        <span class="keyword">while</span>((by = fileInputStream.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)by);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">        fileInputStream.close();</span><br><span class="line">        <span class="comment">//通过File对象来创建对象</span></span><br><span class="line">        fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;new File(&quot;</span>D:\\hello.txt<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span> []bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">//一个字节数组的读出数据</span></span><br><span class="line">        <span class="keyword">while</span> ((by = fileInputStream.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; by ; i++)&#123;</span><br><span class="line">                System.out.print((<span class="keyword">char</span>) bytes[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">        fileInputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="File常用方法"><a href="#File常用方法" class="headerlink" title="File常用方法"></a>File常用方法</h2><ul><li>Files.exists()：检测文件路径是否存在</li><li>Files.createFile()：创建文件。</li><li>Files.createDirectory()：创建文件夹。</li><li>Files.delete()：删除一个文件或目录。</li><li>Files.copy()：复制文件。</li><li>Files.move()：移动文件。</li><li>Files.size()：查看文件个数。</li><li>Files.read()：读取文件。</li><li>Files.write()：写入文件</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ul><li><a href="https://zhuanlan.zhihu.com/p/99609337">一文带你看懂JAVA IO流，史上最全面的IO教学啦</a></li><li><a href="https://www.runoob.com/java/java-files-io.html">Java 流(Stream)、文件(File)和IO</a></li></ul></blockquote><a class="btn-beautify button--animated block blue right" href="https://www.shiming.online/blog/7af799fd/"   title="Java反射"><i class="far fa-hand-point-right fa-fw"></i><span>Java反射</span></a>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis</title>
      <link href="blog/61918/"/>
      <url>blog/61918/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。<br>Mybatis它是个高轻量级的半自动的持久层框架，它更加关注原生sql的编写。所以在实际项目中mybatis可以实现代码和sql的完全解耦。Mybatis还提供了强大的基于OGNL的动态sql语句编写。它支持定制化 SQL、存储过程以及高级映射。所以深受广大程序员的喜爱。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>工作流程如下</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200808152241.png" alt="mybatis工作原理"></p><h4 id="OR映射"><a href="#OR映射" class="headerlink" title="OR映射"></a>OR映射</h4><p>实体对象采用的是面向对象技术，它表达实体的关系是用关联、继承。而RDBMS 是遵循关系的范式理论构建的二维表,主要采用主键和外键的关联方式。因此，对象模型与数据库模型是不一致的，需要在两者之间进行变换即映射。 映射的完成可以按照规则进行人工映射，可以从O映射到R，反之亦然。可以借助开发工具的正、反向工程完成映射。</p><p>Mybatis通过映射将对象的属性信息通过一种规范与数据库里的信息实现一一对应。例如：查询结果中的字段名要和类属性名一致，才能将字段映射到类中。</p><p>mybatis由两种方式实现映射器：XML/注解</p><h5 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口中定义方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Role <span class="title">getRole</span><span class="params">(Long id)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- xml文件中写sql语句 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getRole&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;long&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;role&quot;</span>&gt;</span></span><br><span class="line">  SELECT id,role_name as roleName,note FROM role WHERE id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="注解实现"><a href="#注解实现" class="headerlink" title="注解实现"></a>注解实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select id,role_name as roleName,note from t_role where id=#&#123;id&#125;&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Role <span class="title">getRole</span><span class="params">(Long id)</span></span>;</span><br></pre></td></tr></table></figure><p>这完全等同于 XML 方式创建映射器。如果它和 XML 方式同时定义时，XML 方式将覆盖掉注解方式。但是当sql语句过于复杂时，会增加注解内容，降低代码可读性，还会影响动态sql的使用</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>见本博客<a href="http://shiming.online/categories/Spring/">Spring</a>分类下<a href="http://shiming.online/blog/56612/">ssm搭建</a>或<a href="http://shiming.online/blog/20547/">SpringBoot搭建</a>中内容</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="基本CRUD"><a href="#基本CRUD" class="headerlink" title="基本CRUD"></a>基本CRUD</h3><p>xml文件配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- namespace一般定义为 包名+文件名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.demo.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.demo.pojo.User&quot;</span>&gt;</span></span><br><span class="line">      select * from user;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.demo.pojo.User&quot;</span>&gt;</span></span><br><span class="line">      insert into user values (#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;);</span><br><span class="line">   <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.demo.pojo.User&quot;</span>&gt;</span></span><br><span class="line">      update user set username=#&#123;username&#125;,password=#&#123;password&#125; where id=#&#123;id&#125;;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.String&quot;</span>&gt;</span></span><br><span class="line">      delete from user where id=#&#123;id&#125;;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接口配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法名、参数类型、返回类型要和mapper.xml文件中的id相同</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">selectUser</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">(String id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><h4 id="简单参数"><a href="#简单参数" class="headerlink" title="简单参数"></a>简单参数</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">  select id, username, password</span><br><span class="line">  from users</span><br><span class="line">  where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的这个示例说明了一个非常简单的命名参数映射。鉴于参数类型（parameterType）会被自动设置为 int，这个参数可以随意命名。原始类型或简单数据类型（比如 Integer 和 String）因为没有其它属性，会用它们的值来作为参数。</p><h4 id="传递对象或map类型"><a href="#传递对象或map类型" class="headerlink" title="传递对象或map类型"></a>传递对象或map类型</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">  insert into users (id, username, password)</span><br><span class="line">  values (#&#123;id&#125;, #&#123;username&#125;, #&#123;password&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果 User 类型的参数对象传递到了语句中，会查找 id、username 和 password 属性，然后将它们的值传入预处理语句的参数中。Map类型也可以这么使用</p><h4 id="传递多个字符串"><a href="#传递多个字符串" class="headerlink" title="传递多个字符串"></a>传递多个字符串</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传递多个字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Emp&gt; <span class="title">queryParamListEmp</span> <span class="params">(String ename,String job)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 解决方案有两种 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryParamListEmp&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.demo.pojo.Emp&quot;</span>&gt;</span></span><br><span class="line">    select * from emp where ename = #&#123;arg0&#125; or job = #&#123;arg1&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryParamListEmp&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.demo.pojo.Emp&quot;</span>&gt;</span></span><br><span class="line">    select * from emp where ename = #&#123;param1&#125; or job = #&#123;param2&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="传递不同类型多个参数"><a href="#传递不同类型多个参数" class="headerlink" title="传递不同类型多个参数"></a>传递不同类型多个参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传递不同类型参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Emp&gt; <span class="title">queryParamListEmp</span> <span class="params">(String job,<span class="keyword">double</span> sal)</span></span>;</span><br></pre></td></tr></table></figure><p>解决方案</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Emp&gt; <span class="title">queryParamListEmp</span> <span class="params">(<span class="meta">@Param(&quot;job &quot;)</span> String job, <span class="meta">@Param(&quot;sal &quot;)</span> <span class="keyword">double</span> sal)</span></span>;</span><br><span class="line"><span class="comment">// 注意：@Param(&quot;字段名称 &quot;) 字段的名称必须和sql语句中变量保持一致</span></span><br></pre></td></tr></table></figure><h3 id="结果映射"><a href="#结果映射" class="headerlink" title="结果映射"></a>结果映射</h3><p>一对一，一对多参考<a href="https://blog.csdn.net/wuskzuo/article/details/79186144">[MyBatis]-resultMap结果映射集详解</a><br>多对多参考<a href="http://c.biancheng.net/view/4374.html">MyBatis多对多关联查询（级联查询）</a></p><h3 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h3><p>开发人员通常根据需求手动拼接 SQL 语句，这是一个极其麻烦的工作，而 MyBatis 提供了对 SQL 语句动态组装的功能，恰能解决这一问题。</p><p>MyBatis 的动态 SQL 元素与 JSTL 或 XML 文本处理器相似，常用 <code>&lt;if&gt;、&lt;choose&gt;、&lt;when&gt;、&lt;otherwise&gt;、&lt;trim&gt;、&lt;where&gt;、&lt;set&gt;、&lt;foreach&gt; 和 &lt;bind&gt;</code> 等元素。</p><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG WHERE state = ‘ACTIVE’</span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">    AND title like #&#123;title&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class="line">    AND author_name like #&#123;author.name&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这条语句提供了可选的查找文本功能。如果不传入 “title”，那么所有处于 “ACTIVE” 状态的 BLOG 都会返回；如果传入了 “title” 参数，那么就会对 “title” 一列进行模糊查找并返回对应的 BLOG 结果。如上所示：也可以传入多个参数进行查询</p><h4 id="where"><a href="#where" class="headerlink" title="where"></a>where</h4><p>如果我们有多个条件需要添加，但是有可能一个条件都不满足，那么这时候使用上面的方式就会出现问题，所以我们还需要在if外部添加一个where标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG</span><br><span class="line">  <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;state != null&quot;</span>&gt;</span></span><br><span class="line">         state = #&#123;state&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">        AND title like #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class="line">        AND author_name like #&#123;author.name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>where 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，where 元素也会将它们去除。</p><h4 id="choose、when、otherwise"><a href="#choose、when、otherwise" class="headerlink" title="choose、when、otherwise"></a>choose、when、otherwise</h4><p>从多个条件选择一个查询的情况下可以使用<code>choose,when,otherwise</code>进行条件查询<br>示例策略：传入了 “title” 就按 “title” 查找，传入了 “author” 就按 “author” 查找的情形。若两者都没有传入，就返回标记为 featured 的 BLOG（这可能是管理员认为，与其返回大量的无意义随机 Blog，还不如返回一些由管理员挑选的 Blog）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG WHERE state = ‘ACTIVE’</span><br><span class="line">  <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">      AND title like #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class="line">      AND author_name like #&#123;author.name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">      AND featured = 1</span><br><span class="line">    <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Choose when 类似于java中的switch case，任中只会走一个，一般是在有一个条件固定的情况下，需要额外不确定的条件时，使用choose的方式</p><h4 id="trim-set"><a href="#trim-set" class="headerlink" title="trim,set"></a>trim,set</h4><p>如果 where 元素与你期望的不太一样，你也可以通过自定义 trim 元素来定制 where 元素的功能。比如，和 where 元素等价的自定义 trim 元素为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;WHERE&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;AND |OR &quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure><p>用于动态更新语句的类似解决方案叫做 set。set 元素可以用于动态包含需要更新的列，忽略其它不更新的列。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateAuthorIfNecessary&quot;</span>&gt;</span></span><br><span class="line">  update Author</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span>username=#&#123;username&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;password != null&quot;</span>&gt;</span>password=#&#123;password&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null&quot;</span>&gt;</span>email=#&#123;email&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;bio != null&quot;</span>&gt;</span>bio=#&#123;bio&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">  where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>set 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）</p><h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><p>动态 SQL 的另一个常见使用场景是对集合进行遍历（尤其是在构建 IN 条件语句的时候）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectPostIn&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;domain.blog.Post&quot;</span>&gt;</span></span><br><span class="line">  SELECT *</span><br><span class="line">  FROM POST P</span><br><span class="line">  WHERE ID in</span><br><span class="line">  <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        #&#123;item&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>foreach 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及集合项迭代之间的分隔符。这个元素也不会错误地添加多余的分隔符。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ul><li><a href="https://www.cnblogs.com/Coeus-P/p/9057918.html">什么是OR映射？</a></li><li><a href="https://blog.csdn.net/wuskzuo/article/details/79186144">[MyBatis]-resultMap结果映射集详解</a></li></ul></blockquote><a class="btn-beautify button--animated block blue right" href="https://www.shiming.online/blog/397/"   title="MyBatis "#" 和 "$" 区别"><i class="far fa-hand-point-right fa-fw"></i><span>MyBatis "#" 和 "$" 区别</span></a>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="blog/9977/"/>
      <url>blog/9977/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="关系型数据库概念"><a href="#关系型数据库概念" class="headerlink" title="关系型数据库概念"></a>关系型数据库概念</h2><p>关系型数据库，是指采用了关系模型来组织数据的数据库，其以行和列的形式存储数据，以便于用户理解。<br>关系型数据库这一系列的行和列被称为表，一组表组成了数据库。<br>用户通过查询来检索数据库中的数据，而查询是一个用于限定数据库中某些区域的执行代码。<br>关系模型可以简单理解为二维表格模型，而一个关系型数据库就是由二维表及其之间的关系组成的一个数据组织</p><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><p>创建MySQL数据表需要以下信息：</p><ul><li>表名</li><li>表字段名</li><li>定义每个表字段</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  如果表不存在则创建表</span></span><br><span class="line">CREATE TABLE IF NOT EXISTS `runoob_tbl`(</span><br><span class="line">  <span class="comment">// 字段名(runoob_id) 数据类型(INT) 无符号(UNSIGNED)  自增(AUTO_INCREMENT)</span></span><br><span class="line">   `runoob_id` INT UNSIGNED AUTO_INCREMENT,</span><br><span class="line">  <span class="comment">//  非空(NOT NULL)</span></span><br><span class="line">   `runoob_title` VARCHAR(<span class="number">100</span>) NOT NULL,</span><br><span class="line">   `runoob_author` VARCHAR(<span class="number">40</span>) NOT NULL,</span><br><span class="line">   `submission_date` DATE,</span><br><span class="line">  <span class="comment">//  主键(PRIMARY KEY)</span></span><br><span class="line">   <span class="function">PRIMARY <span class="title">KEY</span> <span class="params">( `runoob_id` )</span></span></span><br><span class="line"><span class="function">  <span class="comment">//  引擎  字符格式</span></span></span><br><span class="line"><span class="function">)ENGINE</span>=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><h2 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h2><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">&#123;* | &lt;字段列名&gt;&#125;</span><br><span class="line">[</span><br><span class="line"><span class="keyword">FROM</span> &lt;表 <span class="number">1</span>&gt;, &lt;表 <span class="number">2</span>&gt;…</span><br><span class="line">[<span class="keyword">WHERE</span> &lt;表达式&gt;</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;<span class="keyword">group</span> <span class="keyword">by</span> definition&gt;</span><br><span class="line">[<span class="keyword">HAVING</span> &lt;expression&gt; [&#123;&lt;<span class="keyword">operator</span>&gt; &lt;expression&gt;&#125;…]]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;<span class="keyword">order</span> <span class="keyword">by</span> definition&gt;]</span><br><span class="line">[<span class="keyword">LIMIT</span>[&lt;<span class="keyword">offset</span>&gt;,] &lt;<span class="keyword">row</span> <span class="keyword">count</span>&gt;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>其中，各条子句的含义如下：</p><ul><li><code>&#123;*|&lt;字段列名&gt;&#125;</code>包含星号通配符的字段列表，表示所要查询字段的名称。</li><li><code>&lt;表 1&gt;，&lt;表 2&gt;…</code>，表 1 和表 2 表示查询数据的来源，可以是单个或多个。</li><li><code>WHERE &lt;表达式&gt;</code>是可选项，如果选择该项，将限定查询数据必须满足该查询条件。</li><li><code>GROUP BY&lt; 字段 &gt;</code>，该子句告诉 MySQL 如何显示查询出来的数据，并按照指定的字段分组。</li><li><code>[ORDER BY&lt; 字段 &gt;]</code>，该子句告诉 MySQL 按什么样的顺序显示查询出来的数据，可以进行的排序有升序（ASC）和降序（DESC），默认情况下是升序。可以设置多个字段，按照顺序进行排序</li><li><code>[LIMIT[&lt;offset&gt;,]&lt;row count&gt;]</code>，该子句告诉 MySQL 每次显示查询出来的数据条数。<br>offset:初始位置，row count：记录数。不指定初始位置时，默认从第一条数据开始查询</li></ul><h4 id="查询结果去重"><a href="#查询结果去重" class="headerlink" title="查询结果去重"></a>查询结果去重</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> &lt;字段名&gt; <span class="keyword">FROM</span> &lt;表名&gt;;</span><br></pre></td></tr></table></figure><h4 id="设置别名"><a href="#设置别名" class="headerlink" title="设置别名"></a>设置别名</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">``&lt;表名&gt; [AS] &lt;别名&gt;``</span><br></pre></td></tr></table></figure><h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> &lt;表名&gt;  <span class="keyword">where</span> &lt;字段名&gt; [<span class="keyword">NOT</span>] <span class="keyword">LIKE</span>  <span class="string">&#x27;字符串&#x27;</span>;</span><br></pre></td></tr></table></figure><p>LIKE 关键字支持百分号”%”和下划线”_”通配符。</p><h5 id="“-”"><a href="#“-”" class="headerlink" title="“%”"></a>“%”</h5><p>“%”是 MySQL 中最常用的通配符，它能代表任何长度的字符串，字符串的长度可以为 0。例如，a%b表示以字母 a 开头，以字母 b 结尾的任意长度的字符串。该字符串可以代表 ab、acb、accb、accrb 等字符串。**中文字符需要使用”%%”**。</p><h5 id="“-”-1"><a href="#“-”-1" class="headerlink" title="“_”"></a>“_”</h5><p>“_”只能代表单个字符，字符的长度不能为 0。例如，a_b可以代表 acb、adb、aub 等字符串。</p><h4 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> &lt;表名&gt;  <span class="keyword">where</span> &lt;字段名&gt; [<span class="keyword">NOT</span>] <span class="keyword">BETWEEN</span> 取值<span class="number">1</span> <span class="keyword">AND</span> 取值<span class="number">2</span>;</span><br></pre></td></tr></table></figure><h4 id="空值查询"><a href="#空值查询" class="headerlink" title="空值查询"></a>空值查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> &lt;表名&gt;  <span class="keyword">where</span> &lt;字段名&gt; <span class="keyword">IS</span> [<span class="keyword">NOT</span>] <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p>多表查询分为交叉查询，内连接，外连接三种</p><h4 id="交叉查询"><a href="#交叉查询" class="headerlink" title="交叉查询"></a>交叉查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &lt;字段名&gt; <span class="keyword">FROM</span> &lt;表<span class="number">1</span>&gt; <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> &lt;表<span class="number">2</span>&gt; [<span class="keyword">WHERE</span>子句];</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">SELECT</span> &lt;字段名&gt; <span class="keyword">FROM</span> &lt;表<span class="number">1</span>&gt;, &lt;表<span class="number">2</span>&gt; [<span class="keyword">WHERE</span>子句] ;</span><br></pre></td></tr></table></figure><p>如果在交叉连接时使用 WHERE 子句，MySQL 会先生成两个表的笛卡尔积，然后再选择满足 WHERE 条件的记录。因此，表的数量较多时，交叉连接会非常非常慢。一般情况下不建议使用交叉连接。</p><h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &lt;字段名&gt; <span class="keyword">FROM</span> &lt;表<span class="number">1</span>&gt; <span class="keyword">INNER</span> <span class="keyword">JOIN</span> &lt;表<span class="number">2</span>&gt; [<span class="keyword">ON</span>子句];</span><br></pre></td></tr></table></figure><p>内连接（INNER JOIN）主要通过设置连接条件的方式，来移除查询结果中某些数据行的交叉连接。简单来说，就是利用条件表达式来消除交叉连接的某些数据行。(只返回满足条件的数据)</p><h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><p>内连接的查询结果都是符合连接条件的记录，而外连接会先将连接的表分为基表和参考表，再以基表为依据返回满足和不满足条件的记录。<br>外连接可以分为左外连接和右外连接。</p><h5 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &lt;字段名&gt; <span class="keyword">FROM</span> &lt;表<span class="number">1</span>&gt; <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> &lt;表<span class="number">2</span>&gt; &lt;<span class="keyword">ON</span>子句&gt;;</span><br><span class="line"><span class="comment">-- outer可以省略，即:LEFT JOIN</span></span><br></pre></td></tr></table></figure><p>“表1”为基表，“表2”为参考表。左连接查询时，可以查询出“表1”中的所有记录和“表2”中匹配连接条件的记录。如果“表1”的某行在“表2”中没有匹配行，那么在返回结果中，“表2”的字段值均为空值（NULL）。</p><h5 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &lt;字段名&gt; <span class="keyword">FROM</span> &lt;表<span class="number">1</span>&gt; <span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> &lt;表<span class="number">2</span>&gt; &lt;<span class="keyword">ON</span>子句&gt;;</span><br><span class="line"><span class="comment">-- 同左连接一样可以直接使用：RIGHT JOIN</span></span><br></pre></td></tr></table></figure><p>与左连接相反，右连接以“表2”为基表，“表1”为参考表。右连接查询时，可以查询出“表2”中的所有记录和“表1”中匹配连接条件的记录。如果“表2”的某行在“表1”中没有匹配行，那么在返回结果中，“表1”的字段值均为空值（NULL）。</p><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE &lt;表达式&gt; &lt;操作符&gt; (子查询)</span><br></pre></td></tr></table></figure><p>操作符可以是比较运算符和 IN、NOT IN、EXISTS、NOT EXISTS 等关键字</p><ol><li><code>IN | NOT IN</code><br>当表达式与子查询返回的结果集中的某个值相等时，返回 TRUE，否则返回 FALSE；若使用关键字 NOT，则返回值正好相反。</li><li><code>EXISTS | NOT EXISTS</code><br>用于判断子查询的结果集是否为空，若子查询的结果集不为空，返回 TRUE，否则返回 FALSE；若使用关键字 NOT，则返回的值正好相反。</li></ol><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> &lt;表名&gt; [ &lt;列名<span class="number">1</span>&gt; [ , … &lt;列名n&gt;] ]</span><br><span class="line"><span class="keyword">VALUES</span> (值<span class="number">1</span>) [… , (值n) ];</span><br></pre></td></tr></table></figure><p>语法说明如下：</p><ul><li>&lt;表名&gt;：指定被操作的表名。</li><li>&lt;列名&gt;：指定需要插入数据的列名。若向表中的所有列插入数据，则全部的列名均可以省略，直接采用 INSERT&lt;表名&gt;VALUES(…) 即可。<br>VALUES 或 VALUE 子句：该子句包含要插入的数据清单。数据清单中数据的顺序要和列的顺序相对应。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> &lt;表名&gt;</span><br><span class="line"><span class="keyword">SET</span> &lt;列名<span class="number">1</span>&gt; = &lt;值<span class="number">1</span>&gt;,</span><br><span class="line">        &lt;列名<span class="number">2</span>&gt; = &lt;值<span class="number">2</span>&gt;,</span><br><span class="line">        …</span><br></pre></td></tr></table></figure><p>此语句用于直接给表中的某些列指定对应的列值，即要插入的数据的列名在 SET 子句中指定，col_name 为指定的列名，等号后面为指定的数据，而对于未指定的列，列值会指定为该列的默认值。</p><p>由 INSERT 语句的两种形式可以看出：</p><ul><li>使用 INSERT…VALUES 语句可以向表中插入一行数据，也可以插入多行数据；</li><li>使用 INSERT…SET 语句可以指定插入行中每列的值，也可以指定部分列的值；</li><li>INSERT…SELECT 语句向表中插入其他表的数据。</li><li>采用 INSERT…SET 语句可以向表中插入部分列的值，这种方式更为灵活；</li><li>INSERT…VALUES 语句可以一次插入多条数据。</li></ul><p>在 MySQL 中，用单条 INSERT 语句处理多个插入要比使用多条 INSERT 语句更快。</p><p>当使用单条 INSERT 语句插入多行数据的时候，只需要将每行数据用圆括号括起来即可。</p><h4 id="复制表值"><a href="#复制表值" class="headerlink" title="复制表值"></a>复制表值</h4><p>INSERT INTO…SELECT…FROM 语句用于快速地从一个或多个表中取出数据，并将这些数据作为行数据插入另一个表中<br>SELECT 子句返回的是一个查询到的结果集，INSERT 语句将这个结果集插入指定表中，结果集中的每行数据的字段数、字段的数据类型都必须与被操作的表完全一致。</p><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> &lt;表名&gt; <span class="keyword">SET</span> 字段 <span class="number">1</span>=值 <span class="number">1</span> [,字段 <span class="number">2</span>=值 <span class="number">2</span>… ] [<span class="keyword">WHERE</span> 子句 ]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> 子句] [<span class="keyword">LIMIT</span> 子句]</span><br></pre></td></tr></table></figure><p>语法说明如下：</p><ul><li>&lt;表名&gt;：用于指定要更新的表名称。</li><li>SET 子句：用于指定表中要修改的列名及其列值。其中，每个指定的列值可以是表达式，也可以是该列对应的默认值。如果指定的是默认值，可用关键字 DEFAULT 表示列值。</li><li>WHERE 子句：可选项。用于限定表中要修改的行。若不指定，则修改表中所有的行。</li><li>ORDER BY 子句：可选项。用于限定表中的行被修改的次序。</li><li>LIMIT 子句：可选项。用于限定被修改的行数。</li></ul><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> &lt;表名&gt; [<span class="keyword">WHERE</span> 子句] [<span class="keyword">ORDER</span> <span class="keyword">BY</span> 子句] [<span class="keyword">LIMIT</span> 子句]</span><br></pre></td></tr></table></figure><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>MySQL 事务主要用于处理操作量大，复杂度高的数据。用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。</p><h3 id="ACID原则"><a href="#ACID原则" class="headerlink" title="ACID原则"></a>ACID原则</h3><p>ACID原则是数据库事务正常执行的四个原则</p><ol><li><p><strong>A (Atomicity) 原子性</strong><br>原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。<br>比如银行转账，从A账户转100元至B账户，分为两个步骤：1）从A账户取100元；2）存入100元至B账户。这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100元。</p></li><li><p><strong>C (Consistency) 一致性</strong><br>一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。<br>例如现有完整性约束a+b=10，如果一个事务改变了a，那么必须得改变b，使得事务结束后依然满足a+b=10，否则事务失败。</p></li><li><p><strong>I (Isolation) 隔离性</strong><br>所谓的隔离性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。<br>比如现有有个交易是从A账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元的。</p></li><li><p><strong>D (Durability) 持久性</strong><br>持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。</p></li></ol><h4 id="事务隔离导致的问题"><a href="#事务隔离导致的问题" class="headerlink" title="事务隔离导致的问题"></a>事务隔离导致的问题</h4><p>首先了解几个概念：</p><ul><li>脏读 ：表示一个事务能够读取另一个事务中还<strong>未提交</strong>的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</li><li>不可重复读 ：是指在一个事务内，多次读<strong>同一数据</strong>。</li><li>幻读 ：指同一个事务内多次查询返回的<strong>结果集</strong>不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了</li></ul><p><strong>隔离级别：</strong></p><ol><li><strong>读未提交：read uncommitted</strong><br>SELECT语句以非锁定方式被执行，所以有可能读到脏数据，隔离级别最低。（读不锁）</li><li><strong>读已提交：read committed</strong><br>只能读取到已经提交的数据。即解决了脏读，但未解决不可重复读。（读锁，等写完）</li><li><strong>可重复读：repeatable read</strong><br>在同一个事务内的查询都是事务开始时刻一致的，InnoDB的默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻读。(写锁，等读完)</li><li><strong>串行化：serializable</strong><br>完全的串行化读，所有SELECT语句都被隐式的转换成SELECT … LOCK IN SHARE MODE，即读取使用表级共享锁，读写相互都会阻塞。隔离级别最高。(以上3个均为行锁/记录锁，当前为表锁)</li></ol><table><thead><tr><th align="center"></th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">Read uncommitted</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">Read committed</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">Repeatable read</td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">Serializable</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><h3 id="使用事务"><a href="#使用事务" class="headerlink" title="使用事务"></a>使用事务</h3><div class="note info flat"><p>在MySQL中，默认情况下，事务是自动提交的，也就是说，只要执行一条DML语句就开启了事物，并且提交了事务</p></div><p>提交事务（事务成功）：</p><ul><li>start transaction</li><li>DML语句</li><li>commit</li></ul><p>回滚操作（事务失败）：</p><ul><li>start transaction</li><li>DML语句</li><li>rollback</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ul><li><a href="http://c.biancheng.net/mysql/">MySQL教程：MySQL数据库学习宝典（从入门到精通）</a></li><li><a href="https://www.jianshu.com/p/081a3e208e32">MySQL事务</a></li></ul></blockquote><a class="btn-beautify button--animated block blue right" href="https://www.shiming.online/blog/43a71ae4/"   title="MySQL索引"><i class="far fa-hand-point-right fa-fw"></i><span>MySQL索引</span></a>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python</title>
      <link href="blog/43687/"/>
      <url>blog/43687/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><ul><li>本文由学习所作思维导图转换而来</li><li><a href="https://share.weiyun.com/ljwIcZPk">思维导图下载链接</a> 密码：vhm66n</li></ul></blockquote><h2 id="基本语法元素"><a href="#基本语法元素" class="headerlink" title="基本语法元素"></a>基本语法元素</h2><h3 id="格式框架"><a href="#格式框架" class="headerlink" title="格式框架"></a>格式框架</h3><ul><li><p>缩进表达程序的格式框架</p><ul><li>严格明确，缩进是语言的一部分，缩进不正确程序运行错误</li><li>所属关系，表达代码间包含和层次关系的唯一手段</li><li>长度一致，程序内一致即可，一般用4个空格或1个tab</li></ul></li><li><p>注释</p><ul><li><code>#</code>开头，单行注释</li><li><code>&#39;&#39;&#39;</code>多行注释</li></ul></li></ul><h3 id="命名与保留字"><a href="#命名与保留字" class="headerlink" title="命名与保留字"></a>命名与保留字</h3><ul><li><p>变量</p><ul><li>用于保存和表示数据的占位符号</li></ul></li><li><p>命名</p><ul><li><p>关联标识符的过程</p><ul><li>命名规则，大小写字母，数字，下划线和汉字等字符及组合</li><li>注意事项：大小写敏感，首字符不能是数字，不与保留字相同</li></ul></li></ul></li><li><p>保留字</p><ul><li>被编程语言内部定义并保留使用的标识符（33个）</li></ul></li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li>供计算机程序理解的数据形式</li></ul><h3 id="语句与函数"><a href="#语句与函数" class="headerlink" title="语句与函数"></a>语句与函数</h3><ul><li><p>赋值语句</p><ul><li>由赋值符号构成的一行代码</li></ul></li><li><p>分支语句</p><ul><li>由判断方向运行程序运行方向的语句</li></ul></li><li><p>函数</p><ul><li>根据输入参数产生不同输出的功能过程</li></ul></li></ul><h3 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h3><ul><li><p>输入函数input()</p><ul><li><code>&lt;变量&gt;=input(&lt;提示信息字符串&gt;)</code></li></ul></li><li><p>输出函数print()</p><ul><li><code>print</code>(&lt;拟输出字符串和字符串变量&gt;)</li><li><code>&#123;&#125;</code>-&gt;槽，<code>&#123;:.2f&#125;</code>表示填充时取小数后两位</li></ul></li><li><p>评估函数eval()</p><ul><li>去掉参数最外侧引号并执行余下语句的函数</li></ul></li></ul><h2 id="基本图形绘制"><a href="#基本图形绘制" class="headerlink" title="基本图形绘制"></a>基本图形绘制</h2><h3 id="turtle的使用"><a href="#turtle的使用" class="headerlink" title="turtle的使用"></a>turtle的使用</h3><ul><li><p>turtle的绘图窗体</p><ul><li><code>turtle.setup(width,height,startx,starty)</code></li></ul></li><li><p>turtle空间坐标体系</p><ul><li><p>绝对坐标</p><ul><li><code>turtle.goto(x,y)</code></li></ul></li><li><p>海龟坐标</p><ul><li><code>turtle.circle(r,angle)</code></li><li><code>turtle.fd(d)</code></li><li><code>turtle.bk(d)</code></li></ul></li></ul></li><li><p>turtle角度坐标体系</p><ul><li><p>绝对角度</p><ul><li><p><code>turtle.seth(angle)</code></p><ul><li>seth()改变海龟行进方向</li><li>seth()只改变方向但不行进</li><li>angle为角度</li></ul></li></ul></li><li><p>海龟角度</p><ul><li><code>turtle.left(angle)</code></li><li><code>turtle.right(angle)</code></li></ul></li></ul></li><li><p>turtle的RGB色彩模式</p><ul><li><p>默认采用小数值，可切换为整数值</p><ul><li><p><code>turtle.colormode(mode)</code></p><ul><li>1.0小数值模式</li><li>255整数值模式</li></ul></li></ul></li></ul></li><li><p>导入</p><ul><li><p>import&lt;函数名&gt;</p><ul><li><p>&lt;库名&gt;.&lt;函数名&gt;(&lt;函数参数&gt;)</p><ul><li>不会出现函数重名问题</li></ul></li></ul></li></ul></li><li><p>from&lt;库名&gt;import&lt;函数名&gt;/from&lt;库名&gt;import *</p><ul><li>&lt;函数名&gt;(&lt;函数参数&gt;)</li></ul></li><li><p>import&lt;库名&gt; as &lt;库别名&gt;</p><ul><li>&lt;库别名&gt;.&lt;函数名&gt;(&lt;函数参数&gt;)</li></ul></li><li><p>turtle画笔控制函数</p><ul><li><code>turtle.penup()</code>别名<code>turtle.pu()</code>画笔抬起，不形成图案</li><li><code>turtle.pendown()</code>别名<code>turtle.pd()</code>画笔落下，形成图案</li><li><code>turtle.pensize(width)</code>别名<code>turtle.width(width)</code>画笔宽度</li><li><code>turtle.pencolor(color)</code>画笔颜色</li></ul></li><li><p>turtle运动控制函数</p><ul><li><code>turtle.forward(d)</code> 别名 turtle.fd(d)直线</li><li><code>turtle.circle(r,extent=None)</code>曲线</li></ul></li><li><p>turtle方向控制函数</p><ul><li><code>turtle.setheading(angle)</code>别名<code>turtle.seth(angle)</code>绝对角度</li><li><code>turtle.left(angle)</code>左转</li><li><code>turtle.right(angle)</code>右转</li></ul></li></ul><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><ul><li>十进制</li><li>二进制：以0b或0B开头</li><li>八进制：以0o或0O开头</li><li>十六进制：以0x或0X开头</li></ul><h3 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a>浮点数类型</h3><ul><li>-10^308-10^308</li><li>不确定尾数，round()函数辅助比较大小</li><li><code>&lt;a&gt;e&lt;b&gt;</code>，表示a*10^b</li></ul><h3 id="复数类型"><a href="#复数类型" class="headerlink" title="复数类型"></a>复数类型</h3><ul><li>a+bj</li></ul><h3 id="数值运算操作符"><a href="#数值运算操作符" class="headerlink" title="数值运算操作符"></a>数值运算操作符</h3><ul><li><p>+,-,*,/(产生浮点数结果),//(整数除)</p></li><li><p>+x(x本身），-y（y负值），x%y（余数），x**y（幂运算）</p></li><li><p>x op = y</p></li><li><p>数据类型逐渐变宽</p></li><li><p>数值运算函数</p><ul><li>abs(x)绝对值</li><li>divmod(x,y)商余操作，输出商和余数</li><li>pow(x,y[,z])幂余</li><li>round(x[,d])四舍五入，d是保留小数位数</li><li>max(x1,x2…,xn)最大值</li><li>min(x1,x2,…xn)最小值</li><li>int(x)变整</li><li>float(x)变为小数</li></ul></li></ul><h3 id="字符串类型及操作"><a href="#字符串类型及操作" class="headerlink" title="字符串类型及操作"></a>字符串类型及操作</h3><ul><li><p>2类共四种表达方式</p><ul><li><code>&#39;,&#39;&#39;,&#39;&#39;&#39;</code></li><li>多行</li><li>单行</li></ul></li><li><p>序号</p><ul><li>正向递增序号，0开始</li><li>方向递减序号，-1开始</li></ul></li><li><p>切片高级用法</p><ul><li><p>&lt;字符串&gt;[M:N]，m缺失表示至开头，n缺失表示至表尾</p></li><li><p>&lt;字符串&gt;[M:N:K],根据步长对字符串切片</p><ul><li>[::-1]字符串取反</li></ul></li><li><p>转义符\</p><ul><li>表达特定字符的本意</li></ul></li></ul></li><li><p>字符串操作符</p><ul><li><p>x+y</p><ul><li>连接字符串x和y</li></ul></li><li><p>n<em>x或x</em>n</p><ul><li>复制n次字符串x</li></ul></li><li><p>x in s</p><ul><li>如果x是s的字串，返回True，否则返回False</li></ul></li></ul></li><li><p>字符串处理函数</p><ul><li><p>len(x)</p><ul><li>返回字符串的长度</li></ul></li><li><p>str(x)</p><ul><li>任意类型x所对应的字符串形式</li></ul></li><li><p>hex(x)或oct(x)</p><ul><li>十六进制或八进制形式字符串</li></ul></li><li><p>chr(u)</p><ul><li>u为Unicode编码，返回其对应的字符</li></ul></li><li><p>ord(x)</p><ul><li>x为字符，返回其对应的Unicode编码</li></ul></li></ul></li><li><p>字符串处理方法</p><ul><li><p>str.lower()或str.upper()</p><ul><li>返回字符串的副本，全小写/大写</li></ul></li><li><p>str.split(sep=None)</p><ul><li>返回一个列表，有sep分割</li></ul></li><li><p>str.count(sub)</p><ul><li>返回子串sub在str中出现的次数</li></ul></li><li><p>str.replace(old,new)</p><ul><li>返回副本，所有old被替换为new</li></ul></li><li><p>str.center(width,[.fillchar])</p><ul><li>根据宽度居中，fillchar可选</li></ul></li><li><p>str.strip(chars)</p><ul><li>从str中去掉在其左侧和右侧chars中列出的字符</li></ul></li><li><p>str.join(iter)</p><ul><li>在iter变量除最后元素外每个元素后增加一个str</li></ul></li></ul></li><li><p>字符串类型的格式化</p><ul><li><p>{}槽</p><ul><li><p>{&lt;参数序号&gt;:&lt;格式控制标记&gt;}</p><ul><li>填充，对齐（&lt;左对齐，&gt;右对齐，^居中对齐），宽度</li><li>&lt;,&gt;（数字的千位分隔符）,&lt;.精度&gt;,&lt;类型&gt;</li></ul></li></ul></li></ul></li></ul><h3 id="time库的使用"><a href="#time库的使用" class="headerlink" title="time库的使用"></a>time库的使用</h3><ul><li><p>获取时间</p><ul><li><p>time()</p><ul><li>获取当前时间的时间戳，浮点数形式</li></ul></li><li><p>ctime()</p><ul><li>获取当前时间的易读方式</li></ul></li><li><p>gmtime()</p><ul><li>获取当前时间，表示为计算机可处理的时间格式</li></ul></li></ul></li><li><p>时间格式化</p><ul><li><p>strftime(tpl,ts)</p><ul><li>tpl是格式化模板字符串，用来定义输出效果，ts是计算机内部时间类型变量</li></ul></li><li><p>strptime(str,tpl)</p><ul><li>字符串转为为可以处理的时间</li></ul></li></ul></li><li><p>程序计时</p><ul><li><p>测量时间</p><ul><li>perf_counter()</li></ul></li><li><p>产生时间</p><ul><li><p>sleep(s)</p><ul><li>休眠时间，s可以是浮点数</li></ul></li></ul></li></ul></li></ul><h2 id="程序的控制结构"><a href="#程序的控制结构" class="headerlink" title="程序的控制结构"></a>程序的控制结构</h2><h3 id="程序的分支结构"><a href="#程序的分支结构" class="headerlink" title="程序的分支结构"></a>程序的分支结构</h3><ul><li><p>单分支结构</p><ul><li>if:</li></ul></li><li><p>二分支结构</p><ul><li>if：else:</li><li>紧凑形式：适用于简单表达式的二分之结构</li><li>&lt;表达式1&gt;if&lt;条件&gt;else&lt;表达式2&gt;</li></ul></li><li><p>多分支结构</p><ul><li>if:elif:else:</li></ul></li><li><p>条件判断及组合</p><ul><li>and(逻辑与),or(逻辑或),not(逻辑非)</li></ul></li><li><p>异常处理</p><ul><li>try:  except:</li><li>try: except: else: finally:</li></ul></li></ul><h3 id="程序的循环结构"><a href="#程序的循环结构" class="headerlink" title="程序的循环结构"></a>程序的循环结构</h3><ul><li><p>遍历循环</p><ul><li><p>for &lt;循环变量&gt; in &lt;遍历结构&gt;:  &lt;语句块&gt;</p><ul><li>计数循环</li><li>字符串遍历循环</li><li>列表遍历循环</li><li>文件遍历循环</li></ul></li></ul></li><li><p>无限循环</p><ul><li>while &lt;条件&gt;:  &lt;语句块&gt;</li></ul></li><li><p>循环控制保留字</p><ul><li>break,continue</li></ul></li><li><p>循环的扩展</p><ul><li><p>循环语句后加else：</p><ul><li>没有退出即执行else语句块</li></ul></li></ul></li></ul><h3 id="random库的使用"><a href="#random库的使用" class="headerlink" title="random库的使用"></a>random库的使用</h3><ul><li>seed(a=None)初始化给定的随机数种子，默认为系统时间</li><li>random()生成一个（0.0，1.0）之间的随机小数</li><li>randint(a,b)生成a,b之间的整数</li><li>randrange(m,n[,k])生成一个[m,n]之间以k为步长的随机整数</li><li>getrandbits(k)生成一个k比特长的随机整数</li><li>uniform(a,b)生成一个[a,b]之间的随机小数</li><li>choice(seq)从序列seq中随机选择一个元素</li><li>shuffle(seq)将序列seq中元素随机排序，并返回打乱后的序列</li></ul><h2 id="组合数据类型"><a href="#组合数据类型" class="headerlink" title="组合数据类型"></a>组合数据类型</h2><h3 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h3>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS</title>
      <link href="blog/6541/"/>
      <url>blog/6541/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><ul><li>本文由思维导图转换而来</li><li><a href="https://share.weiyun.com/EkhVMzlL">链接</a> 密码：pisafq</li></ul></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200807222319.png" alt="css复习"></p>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML</title>
      <link href="blog/54626/"/>
      <url>blog/54626/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>h</p><blockquote><ul><li>思维导图转换而来</li><li><a href="https://share.weiyun.com/LELL98G5">链接</a> 密码：qerqkg</li></ul></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200807222339.png" alt="HTML&amp;CSS.png"></p>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>idea live template</title>
      <link href="blog/14383/"/>
      <url>blog/14383/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// itar：Iterate elements of array，操作顺序迭代数组</span></span><br><span class="line"><span class="comment">//1.定义一个数组</span></span><br><span class="line">String[] strings = <span class="keyword">new</span> String[];</span><br><span class="line"><span class="comment">//2.输入itar后会有提示，按`Enter`确认后会自动输出以下内容，默认是按`Tab`键快速进行光标切换</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strings.length; i++) &#123;</span><br><span class="line">  String string = strings[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ritar：Iterate elements of array in reverse order，反转迭代数组</span></span><br><span class="line">String[] strings = <span class="keyword">new</span> String[];</span><br><span class="line"><span class="comment">//输入ritar后会有提示，按`Enter`确认后会自动输出以下内容，默认是按`Tab`键进行光标快速切换</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = strings.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">  String string = strings[i];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iter：Iterate (for each..in)，ForEach迭代</span></span><br><span class="line">List&lt;String&gt; stringList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// 输入iter后会有提示，按`Enter`确认后会自动输出以下内容，默认是按`Tab`键进行光标快速切换</span></span><br><span class="line"><span class="keyword">for</span> (String s : stringList) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fori：Create iteration loop，含下标的普通迭代</span></span><br><span class="line"><span class="comment">//输入fori后会有提示，按`Enter`确认后会自动输出以下内容，默认是按`Tab`键进行光标快速切换</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ; i++) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// itli：Iterate elements of java.util.List，List迭代</span></span><br><span class="line">List&lt;String&gt; stringList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//输入itli后会有提示，按`Enter`确认后会自动输出以下内容，默认是按`Tab`键进行光标快速切换</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stringList.size(); i++) &#123;</span><br><span class="line">  String s =  stringList.get(i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// itco：Iterate elements of java.util.Collection，iterator迭代</span></span><br><span class="line">List&lt;String&gt; stringList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//输入itco后会有提示，按`Enter`确认后会自动输出以下内容，默认是按`Tab`键进行光标快速切换</span></span><br><span class="line"><span class="keyword">for</span> (Iterator&lt;String&gt; iterator = stringList.iterator(); iterator.hasNext(); ) &#123;</span><br><span class="line">  String next =  iterator.next();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="define-定义"><a href="#define-定义" class="headerlink" title="define (定义)"></a>define (定义)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// St</span></span><br><span class="line">String</span><br><span class="line"></span><br><span class="line"><span class="comment">// thr</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// psf</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// prsf</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// psfi</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// psfs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String</span><br><span class="line"></span><br><span class="line"><span class="comment">// geti：Inserts singleton method getInstance</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> $CLASS_NAME$ <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ifn：Inserts if null statement</span></span><br><span class="line"><span class="keyword">if</span> ($VAR$ == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inn：Inserts if not null statement</span></span><br><span class="line"><span class="keyword">if</span> ($VAR$ != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inst：Checks object type with instanceof and down-casts it</span></span><br><span class="line"><span class="keyword">if</span> ($EXPR$ <span class="keyword">instanceof</span> $TYPE$) &#123;</span><br><span class="line">$TYPE$ $VAR1$ = ($TYPE$)$EXPR$;</span><br><span class="line">$END$</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lazy：Performs lazy initialization</span></span><br><span class="line"><span class="keyword">if</span> ($VAR$ == <span class="keyword">null</span>) &#123;</span><br><span class="line">$VAR$ = <span class="keyword">new</span> $TYPE$();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lst：Fetches last element of an array</span></span><br><span class="line"><span class="comment">// mn：Sets lesser value to a variable</span></span><br><span class="line"><span class="comment">// mx：Sets greater value to a variable</span></span><br><span class="line"><span class="comment">// toar：Stores elements of java.util.Collection into array</span></span><br></pre></td></tr></table></figure><h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// psvm</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="print-打印"><a href="#print-打印" class="headerlink" title="print (打印)"></a>print (打印)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sout：Prints a string to System.out</span></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="comment">// souf：Prints a formatted string to System.out</span></span><br><span class="line">System.out.printf(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// serr：Prints a string to System.err</span></span><br><span class="line">System.err.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// soutm：Prints current class and method names to System.out</span></span><br><span class="line">System.out.println(<span class="string">&quot;className.methodName&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// soutv：Prints a value to System.out</span></span><br><span class="line">System.out.println(<span class="string">&quot;variable name = &quot;</span> + variable value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// soutp：Prints method parameter names and values to System.out</span></span><br><span class="line">System.out.println(<span class="string">&quot;parameter name = [&quot;</span> + parameter value + <span class="string">&quot;]&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- dep：dependency --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- pl：plugin --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- repo：repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span><span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span><span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- col：new column definition --&gt;</span></span><br><span class="line">$col$ $type$ $null$$END$</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- ins：insert rows into a table --&gt;</span></span><br><span class="line">insert into $table$ ($columns$) values ($END$);</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- sel：select all rows from a table --&gt;</span></span><br><span class="line">select * from $table$$END$;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- selc：select the number of specific rows in a table --&gt;</span></span><br><span class="line">select count(*) from $table$ $alias$ where $alias$.$END$;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- selw：select specific rows from a table --&gt;</span></span><br><span class="line">select * from $table$ $alias$ where $alias$.$END$;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- tab：new table definition --&gt;</span></span><br><span class="line">create table $table$ (</span><br><span class="line">$col$ $type$ $null$$END$</span><br><span class="line">);</span><br><span class="line">upd：update values in a table</span><br><span class="line"></span><br><span class="line">update $table_name$ set $col$ = $value$ where $END$;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
          <category> idea </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx</title>
      <link href="blog/58122/"/>
      <url>blog/58122/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>反向代理服务器位于用户与目标服务器之间，但是对于用户而言，反向代理服务器就相当于目标服务器，即用户直接访问反向代理服务器就可以获得目标服务器的资源。<br>同时，用户不需要知道目标服务器的地址，也无须在用户端作任何设定。反向代理服务器通常可用来作为Web加速，即使用反向代理作为Web服务器的前置机来降低网络和服务器的负载，提高访问效率。</p><blockquote><p><a href="https://www.zhihu.com/question/24723688">反向代理为何叫反向代理？</a></p></blockquote><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li>提高了内部服务器的安全（将反向代理作为公网访问地址，Web服务器是内网）</li><li>加快了对内部服务器的访问速度</li><li>节约了有限的IP资源</li></ol><h2 id="nginx使用"><a href="#nginx使用" class="headerlink" title="nginx使用"></a>nginx使用</h2><h3 id="安装jdk"><a href="#安装jdk" class="headerlink" title="安装jdk"></a>安装jdk</h3><h4 id="1-下载jdk文件"><a href="#1-下载jdk文件" class="headerlink" title="1. 下载jdk文件"></a>1. 下载jdk文件</h4><p>官网或者<a href="https://repo.huaweicloud.com/java/jdk/">华为镜像网站</a></p><h4 id="2-将文件上传到linux并解压"><a href="#2-将文件上传到linux并解压" class="headerlink" title="2. 将文件上传到linux并解压"></a>2. 将文件上传到linux并解压</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/java</span><br><span class="line">tar -zxvf jdk-8u201-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><h4 id="3-配置环境变量"><a href="#3-配置环境变量" class="headerlink" title="3. 配置环境变量"></a>3. 配置环境变量</h4><p>打开配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><p>在文件尾部配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># jdk1.8.0_201</span></span><br><span class="line"></span><br><span class="line">JAVA_HOME=/usr/<span class="built_in">local</span>/java/jdk1.8.0_201</span><br><span class="line">JRE_HOME=<span class="variable">$JAVA_HOME</span>/jre</span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$JRE_HOME</span>/bin</span><br><span class="line">CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar:<span class="variable">$JRE_HOME</span>/lib</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME JRE_HOME PATH CLASSPATH</span><br></pre></td></tr></table></figure><p>重新加载配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/guaprofile</span><br></pre></td></tr></table></figure><h4 id="4-检查是否安装成功"><a href="#4-检查是否安装成功" class="headerlink" title="4. 检查是否安装成功"></a>4. 检查是否安装成功</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><h3 id="安装tomcat"><a href="#安装tomcat" class="headerlink" title="安装tomcat"></a>安装tomcat</h3><h4 id="1-官网下载Linux版本"><a href="#1-官网下载Linux版本" class="headerlink" title="1. 官网下载Linux版本"></a>1. 官网下载Linux版本</h4><h4 id="2-上传文件并解压"><a href="#2-上传文件并解压" class="headerlink" title="2. 上传文件并解压"></a>2. 上传文件并解压</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/</span><br><span class="line">tar -zxvf apache-tomcat-9.0.7.tar.gz</span><br></pre></td></tr></table></figure><h4 id="3-tomcat配置环境变量"><a href="#3-tomcat配置环境变量" class="headerlink" title="3. tomcat配置环境变量"></a>3. tomcat配置环境变量</h4><p>打开配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><p>添加配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Tomcat9</span></span><br><span class="line"></span><br><span class="line">CATALINA_HOME=/usr/<span class="built_in">local</span>/tomcat9</span><br><span class="line"><span class="built_in">export</span> CATALINA_HOME</span><br></pre></td></tr></table></figure><p>重新加载文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h4 id="5-配置catalina-sh文件"><a href="#5-配置catalina-sh文件" class="headerlink" title="5. 配置catalina.sh文件"></a>5. 配置catalina.sh文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入配置文件夹</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$CATALINA_HOME</span>/bin</span><br><span class="line"><span class="comment"># 打开文件</span></span><br><span class="line">vim catalina.sh</span><br><span class="line"><span class="comment"># 在# OS specific support后添加配置</span></span><br><span class="line">CATALINA_HOME=/usr/<span class="built_in">local</span>/tomcat9</span><br><span class="line">JAVA_HOME=/usr/<span class="built_in">local</span>/java/jdk1.8.0_201</span><br></pre></td></tr></table></figure><h4 id="6-启动tomcat"><a href="#6-启动tomcat" class="headerlink" title="6. 启动tomcat"></a>6. 启动tomcat</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/tomcat9/bin/startup.sh</span><br></pre></td></tr></table></figure><h3 id="Tomcat设为自启"><a href="#Tomcat设为自启" class="headerlink" title="Tomcat设为自启"></a>Tomcat设为自启</h3><p>参考<a href="http://xqminfo.xyz/2020/08/02/%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1/Linux/Linux%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF/">linux设置Redis开机自启</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service内容</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=tomcat</span><br><span class="line">After=network.target</span><br><span class="line">  </span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">TimeoutSec=0</span><br><span class="line">ExecStart=/usr/<span class="built_in">local</span>/tomcat9/bin/startup.sh</span><br><span class="line">ExecReload=/usr/<span class="built_in">local</span>/tomcat9/bin/startup.sh -s reload</span><br><span class="line">ExecStop=/usr/<span class="built_in">local</span>/tomcat9/bin/startup.sh -s quit</span><br><span class="line">PrivateTmp=<span class="literal">true</span></span><br><span class="line">  </span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><h3 id="Nginx绑定Tomcat"><a href="#Nginx绑定Tomcat" class="headerlink" title="Nginx绑定Tomcat"></a>Nginx绑定Tomcat</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开nginx.conf文件,增加如下配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在#gzip on后配置upstream节点，这里节点名为“tomcat”</span></span><br><span class="line">  upstream tomcat&#123;</span><br><span class="line"><span class="comment"># tomcatIP地址，权重为1</span></span><br><span class="line">        server 192.168.184.135:8080 weight=1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  server&#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name localhost;</span><br><span class="line">        location / &#123;</span><br><span class="line">          <span class="comment">#指定反向代理为上面配置的那个upstream节点“tomcat”</span></span><br><span class="line">          proxy_pass http://tomcat;</span><br><span class="line">          proxy_redirect default;</span><br><span class="line">          <span class="comment">#设置超时时间</span></span><br><span class="line">          proxy_connect_timeout 10;</span><br><span class="line"></span><br><span class="line">          root html;</span><br><span class="line">          index index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>测试是否配置成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#测试配置文件修改是否正常</span></span><br><span class="line">/usr/<span class="built_in">local</span>/nginx/nginx -t</span><br><span class="line"><span class="comment">#重新加载</span></span><br><span class="line">/usr/<span class="built_in">local</span>/nginx/nginx -s reload</span><br></pre></td></tr></table></figure><p>配置完成</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ul><li><a href="https://www.zhihu.com/question/24723688">反向代理为何叫反向代理？</a></li><li><a href="https://www.cnblogs.com/Anker/p/6056540.html">正向代理与反向代理【总结】</a></li><li><a href="https://baike.baidu.com/item/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86">百度百科-反向代理</a></li><li><a href="https://cloud.tencent.com/developer/article/1538210">Linux安装JDK+Tomcat+MySQL及发布项目教程</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> nginx </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="blog/48230/"/>
      <url>blog/48230/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h2><ul><li>systemctl –version，查看版本。</li><li>whereis systemctl，查看位置。</li><li>systemctl list-unit-files，列出所有可用单元（服务）。</li><li>systemctl list-units，列出所有运行中的单元。</li><li>systemctl –failed，列出所有失败的单元。</li><li>systemctl list-unit-files | grep enable，查看自启动的软件。</li><li>systemctl is-enabled mysqld.service，查看某个单元是否开机启动。</li><li>systemctl status mysqld.service，查看某个单元的状态。</li><li>systemctl start mysqld.service，启动某个单元。</li><li>systemctl restart mysqld.service，重启某个单元。</li><li>systemctl stop mysqld.service，停止某个单元。</li><li>systemctl daemon-reload，修改了某个单元的配置文件后，重载配置文件。</li><li>systemctl reload mysqld.service，重载某个单元。</li><li>systemctl enable mysqld.service，设置开机自启动。</li><li>systemctl disable mysqld.service，关闭开机自启动。</li><li>systemctl kill mysqld，杀死单元。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ul><li><a href="https://www.jianshu.com/p/ca5ee5f7075c">CentOS7设置nginx开机自启动</a></li><li><a href="https://blog.csdn.net/m0_46422300/article/details/104645072">Linux 常用操作命令大全</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux设置Redis开机自启</title>
      <link href="blog/16460/"/>
      <url>blog/16460/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>初接触Linux，记录设置方法<br>本文以redis为例,但是方法是通用的</p></blockquote><h2 id="系统服务下创建service文件"><a href="#系统服务下创建service文件" class="headerlink" title="系统服务下创建service文件"></a>系统服务下创建service文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/lib/systemd/system/redis-server.service</span><br></pre></td></tr></table></figure><h2 id="写入内容"><a href="#写入内容" class="headerlink" title="写入内容"></a>写入内容</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=redis-server</span><br><span class="line">After=network.target</span><br><span class="line">  </span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">TimeoutSec=0</span><br><span class="line">ExecStart=/usr/<span class="built_in">local</span>/redis/src/redis  /usr/<span class="built_in">local</span>/redis/redis.conf</span><br><span class="line">ExecReload=/usr/<span class="built_in">local</span>/redis/src/redis  /usr/<span class="built_in">local</span>/redis/redis.conf -s reload</span><br><span class="line">ExecStop=/usr/<span class="built_in">local</span>/redis/src/redis  /usr/<span class="built_in">local</span>/redis/redis.conf -s quit</span><br><span class="line">PrivateTmp=<span class="literal">true</span></span><br><span class="line">  </span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>Description:描述服务<br>After:描述服务类别<br>[Service]服务运行参数的设置<br>Type=forking是后台运行的形式<br>TimeoutSec为不处理启动超时的情况<br>ExecStart为服务的具体运行命令,这里是redis的启动方式（redis+配置文件）<br>ExecReload为重启命令<br>ExecStop为停止命令<br>PrivateTmp=True表示给服务分配独立的临时空间</p><h2 id="设置开机自启"><a href="#设置开机自启" class="headerlink" title="设置开机自启"></a>设置开机自启</h2><p><code>systemctl enable redis-server.service</code></p><h2 id="重启redis-server"><a href="#重启redis-server" class="headerlink" title="重启redis-server"></a>重启redis-server</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pkill -9 redis-server</span><br><span class="line"></span><br><span class="line">systemctl start redis-server.service</span><br></pre></td></tr></table></figure><h2 id="查看redis状态"><a href="#查看redis状态" class="headerlink" title="查看redis状态"></a>查看redis状态</h2><p>systemctl status redis-server.service</p><p>可以看到状态为active</p><p>可以通过<code>systemctl list-unit-files | grep enable</code>查看自启动的软件，同时这个设置方法是通用的</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ul><li><a href="https://www.jianshu.com/p/ca5ee5f7075c">CentOS7设置nginx开机自启动</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列</title>
      <link href="blog/5151/"/>
      <url>blog/5151/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列。<br>队列的数据元素又称为队列元素。在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out）线性表。</p><h3 id="消息队列（Message-Queue）"><a href="#消息队列（Message-Queue）" class="headerlink" title="消息队列（Message Queue）"></a>消息队列（Message Queue）</h3><p>消息队列可以简单理解为把要传输的数据放在队列中。</p><p>消息队列是分布式系统中重要的组件，其通用的使用场景可以简单地描述为：</p><blockquote><p>当不需要立即获得结果，但是并发量又需要进行控制的时候，差不多就是需要使用消息队列的时候。</p></blockquote><p>消息队列主要解决了应用耦合、异步处理、流量削锋等问题。</p><p>当前使用较多的消息队列有RabbitMQ、RocketMQ、ActiveMQ、Kafka、ZeroMQ、MetaMq等，而部分数据库如Redis、Mysql以及phxsql也可实现消息队列的功能。</p><p>Tips：</p><ol><li>把数据放到消息队列叫做生产者</li><li>从消息队列里边取数据叫做消费者</li></ol><h4 id="AMQP和JMS"><a href="#AMQP和JMS" class="headerlink" title="AMQP和JMS"></a>AMQP和JMS</h4><p>AMQP，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制</p><p>JMS即Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。</p><h5 id="两者的区别和联系"><a href="#两者的区别和联系" class="headerlink" title="两者的区别和联系"></a>两者的区别和联系</h5><ul><li>JMS是定义了统一接口，对<strong>消息操作进行统一</strong>；AMQP通过规定协议<strong>统一数据交互的格式</strong></li><li>JMS限定了<strong>必须使用Java语言</strong>；AMQP只是协议，不规定实现方式，因此是<strong>跨语言</strong>的</li><li>JMS规定了两种消息模型（<strong>queue</strong>，<strong>topic</strong>）；而AMQP的模型更丰富</li></ul><h3 id="消息队列应用场景"><a href="#消息队列应用场景" class="headerlink" title="消息队列应用场景"></a>消息队列应用场景</h3><ul><li>应用耦合：多应用间通过消息队列对同一消息进行处理，避免调用接口失败导致整个过程失败；</li><li>异步处理：多应用对消息队列中同一消息进行处理，应用间并发处理消息，相比串行处理，减少处理时间；</li><li>限流削峰：广泛应用于秒杀或抢购活动中，避免流量过大导致应用系统挂掉的情况；</li><li>消息驱动的系统：系统分为消息队列、消息生产者、消息消费者，生产者负责产生消息，消费者(可能有多个)负责对消息进行处理；</li></ul><blockquote><p>举例：<a href="https://www.zhihu.com/question/54152397">消息队列（mq）是什么？</a></p></blockquote><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。<br>RabbitMQ服务器是由以高性能、健壮以及可伸缩性出名的 Erlang 语言编写的，而集群和故障转移是构建在开放电信平台框架上的。<br>所有主要的编程语言均有与代理接口通讯的客户端库。</p><!-- ### 下载安装 --><!-- [下载rabbitmq](https://www.rabbitmq.com/install-windows.html) --><!-- [官网安装教程](https://www.rabbitmq.com/install-rpm.html#package-cloud) --><h3 id="管理界面"><a href="#管理界面" class="headerlink" title="管理界面"></a>管理界面</h3><ul><li>Overview: 概览（RabbitMQ的基本信息）</li><li>Connections: “连接”就是生产者和消费者的连接情况；<br>不管生产者还是消费者，其实都是应用程序，都需要和rabbitmq服务器建立连接后才可以完成消息的生产和消费。</li><li>Channels: “通道”是建立在”连接”基础上的，消息的投递获取依赖通道。实际开发中”连接”应为全局变量，”通道”为线程级；</li><li>Exchange: 交换机，用来实现消息的路由</li><li>Queues: 队列，即消息队列，消息存放在队列中，等待消费，消费后被移除队列。查看队列中此时未被消费的数据条数。<br>下方可以查看队列有没有消费者（consumer）</li><li>端口：<ul><li>5672: RabbitMQ的编程语言客户端连接接口</li><li>15672: RabbitMQ管理界面连接接口</li><li>25672: RabbitMQ集群接口</li></ul></li></ul><h3 id="消息模型"><a href="#消息模型" class="headerlink" title="消息模型"></a>消息模型</h3><h4 id="基本消息模型"><a href="#基本消息模型" class="headerlink" title="基本消息模型"></a>基本消息模型</h4><p>基本消息模型包含：</p><ul><li>消息队列，类似邮箱，可以缓存消息，生产者向其中投递消息，消费者从其中取出消息</li><li>P：生产者</li><li>C：消费者</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/1.png" alt="1"></p><p>消息发送者生产消息发送到队列中，然后消息接收者从队列中取出并且消费消息。消息被消费以后，队列中不再有存储，所以消息接收者不可能消费到已经被消费的消息。</p><h4 id="工作队列-Work-Queues"><a href="#工作队列-Work-Queues" class="headerlink" title="工作队列(Work Queues)"></a>工作队列(Work Queues)</h4><ul><li>消息队列</li><li>P: 生产者</li><li>C1: 消费者1，假设完成速度较慢</li><li>C2: 消费者2，假设完成速度较快</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/2.png" alt="2"></p><p>工作队列（又称：任务队列——Task Queues）是为了避免等待一些占用大量资源、时间的操作。当我们把任务（Task）当作消息发送到队列中，一个运行在后台的工作者（worker）进程就会取出任务然后处理。当你运行多个工作者（workers），任务就会在它们之间共享，但是一个消息只会有一个工作者接收。</p><p>默认情况下，RabbitMQ将每个消息按顺序发送给下一个使用者。平均而言，每个消费者都会收到相同数量的消息。这种分发消息的方式称为循环。（处理任务的时间和接收任务的条数是不影响的，处理慢的服务器其实已经接收到了消息，只是堆积在那里）</p><p>为了避免处理过程中的消息丢失，所以引入了消息确认机制，具体见<br>下文。</p><h4 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布/订阅模式"></a>发布/订阅模式</h4><p>工作模式的假设是每一个消息都恰好交付给一个消费者。而发布/订阅模式是将一条消息传达给多个消费者</p><p>RabbitMQ消息传递模型的核心思想是生产者从不将任何消息直接发送到队列。实际上，生产者经常甚至根本不知道是否将消息传递到任何队列。</p><p>生产者将消息发送到交换机。由交换机来决定最终将消息送至哪些队列，具体的推送规则在定义交换机的时候指定。消费者如果想要获取消息，只需要将自己声明的队列绑定到交换机上就可以收到生产者发送到交换机的消息</p><p>交换类型有以下几种：</p><ul><li>direct: 路由</li><li>topic: 主题</li><li>headers: 表头</li><li>fanout: 广播</li></ul><h5 id="Fanout"><a href="#Fanout" class="headerlink" title="Fanout"></a>Fanout</h5><p>广播模式下，路由会将消息推送到所有绑定的队列</p><ul><li>P: 生产者</li><li>X: 交换机</li><li>C: 消费者</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/PHzM6Wcb7ABktfJ.png" alt="PHzM6Wcb7ABktfJ"></p><p>流程如下:</p><ol><li>可以有多个消费者</li><li>每个消费者有自己的queue（队列）</li><li>每个队列都要绑定到Exchange（交换机）</li><li>生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定。</li><li>交换机把消息发送给绑定过的所有队列</li><li>队列的消费者都能拿到消息。实现一条消息被多个消费者消费</li></ol><h5 id="Direct"><a href="#Direct" class="headerlink" title="Direct"></a>Direct</h5><p>在Direct模型下，队列与交换机的绑定，不能是任意绑定了，而是要指定一个路由键（路由key），消息的发送方在向Exchange发送消息时，也必须指定消息的路由键。</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/zy8uUeTcdOLikgX.png" alt="zy8uUeTcdOLikgX"></p><ul><li>P：生产者，向Exchange发送消息，发送消息时，会指定一个路由键。</li><li>X：Exchange（交换机），接收生产者的消息，然后把消息递交给与路由键完全匹配的队列</li><li>C1：消费者，其所在队列指定了需要路由键为 orange 的消息</li><li>C2：消费者，其所在队列指定了需要路由键为 black,green 的消息</li></ul><p>在这样的设置中，通过路由键<code>orange</code>发布到交换机的消息 将被推送到到队列C1。路由键为<code>black</code>或者<code>green</code>的消息将转到C2。所有其他消息将被丢弃。</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/WgrXGODvV2BCfIj.png" alt="WgrXGODvV2BCfIj"><br>多个路由可以使用同一个路由键，如上：C1,C2都绑定了<code>black</code>，带有<code>black</code>路由键的消息将推送到C1,C2。</p><h5 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h5><p>Topic 类型的 Exchange 与 Direct 相比，都是可以根据 RoutingKey 把消息路由到不同的队列。只不过 Topic 类型 Exchange 可以让队列在绑定RoutingKey的时候使用通配符！</p><p>通配符规则：</p><ul><li>#：匹配一个或多个词</li><li>*：匹配 1 个词</li></ul><h5 id="Headers"><a href="#Headers" class="headerlink" title="Headers"></a>Headers</h5><p>Headers和主题模式类似，区别在于：主题模式基于路由键，表头交换基于消息的header数据</p><h3 id="消息确认机制ACK"><a href="#消息确认机制ACK" class="headerlink" title="消息确认机制ACK"></a>消息确认机制ACK</h3><blockquote><p>默认情况下如果一个 消息 被消费者所正确接收则会被从 队列 中移除</p></blockquote><p>根据定义，使用消息传递代理的系统（例如RabbitMQ）是分布式的。所以不能保证发送的协议方法（消息）可以到达对等方或被其成功处理。</p><p>如果消费者没能成功接收到消息或者在处理消息的过程中，消费者的服务器在处理消息的时候出现异常，那么可能这条正在处理的消息就没有完成消息消费，数据就会丢失。因此发布者和消费者都需要一种机制来进行<strong>传递和处理确认</strong></p><p>从使用者到RabbitMQ的交付处理确认在消息传递协议中称为acknowledgements。对发布者的代理确认是一个称为发布者确认的协议扩展。</p><p>消息接收确认分为<strong>自动确认</strong>和<strong>手动确认</strong>两种</p><h4 id="自动确认"><a href="#自动确认" class="headerlink" title="自动确认"></a>自动确认</h4><p>在自动确认模式下，消息在发送后立即被视为已成功传递。使用此模式需要在<strong>更高的吞吐量</strong>（只要消费者可以跟上）和<strong>降低交付和消费者处理的安全性</strong>之间权衡。此模式通常称为“一劳永逸”。<br>与手动确认模式不同，如果使用者的TCP连接或通道在成功传递之前已经关闭，或者处理消息时发生异常，那么服务器发送的消息将丢失。因此，自动消息确认应该被认为是不安全的。</p><h4 id="手动确认"><a href="#手动确认" class="headerlink" title="手动确认"></a>手动确认</h4><p>手动确认可以解决自动确认的问题，但是它也意味着<strong>所有的消息在消费端获取到后必须有一个结果返回到服务端</strong>。如果未对接收到的消息进行确认，那么此消息在队列中的状态为<strong>Unacked</strong>，直到消费端连接中断后又变为<strong>Ready</strong>。<br>所有消费者（包括当前消费者）都无法对Unacked状态的消息进行二次消费，所以此类消息越多占用的内存也越多。而如果消息变为Ready状态，那么已经处理过这条消息的消费者可能会再次接收到这条消息并进行处理。</p><p>手动发送的确认可以是肯定的也可以是否定的，并且使用以下协议方法之一：</p><ul><li><code>basic.ack</code>用于肯定确认</li><li><code>basic.nack</code>用于否定确认（注意：这是AMQP 0-9-1的RabbitMQ扩展）</li><li><code>basic.reject</code>用于否定确认，但与basic.nack相比有一个限制</li></ul><p>肯定的确认只是指示RabbitMQ记录已传递的消息，可以将其丢弃。带有basic.reject的否定确认具有相同的效果。区别主要在语义上：肯定的确认假定消息已成功处理，而否定的消息则表示未处理传递但仍应删除。</p><blockquote><ul><li>参考TCP中的<a href="https://baike.baidu.com/item/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">百度百科-三次握手</a></li></ul></blockquote><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>条件：</p><ol><li>交换机持久化，声明<code>durable 为 true</code></li><li>队列持久化，声明<code>durable 为 true</code></li><li>消息持久化，声明<code>delivery_mode=2</code></li></ol><h4 id="原生代码"><a href="#原生代码" class="headerlink" title="原生代码"></a>原生代码</h4><p>交换机</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建连接mq的工厂对象</span></span><br><span class="line">ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line"><span class="comment">// 设置rabbitmq的主机</span></span><br><span class="line">connectionFactory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"><span class="comment">// 设置端口号</span></span><br><span class="line">connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line"><span class="comment">// 设置虚拟主机</span></span><br><span class="line">connectionFactory.setVirtualHost(<span class="string">&quot;/admin&quot;</span>);</span><br><span class="line"><span class="comment">// 设置访问虚拟主机的帐户密码</span></span><br><span class="line">connectionFactory.setUsername(<span class="string">&quot;shiming&quot;</span>);</span><br><span class="line">connectionFactory.setPassword(<span class="string">&quot;xqm?123456&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取连接对象</span></span><br><span class="line">Connection connection = connectionFactory.newConnection();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取连接的通道</span></span><br><span class="line">Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明交换机</span></span><br><span class="line"><span class="comment">// 三个参数分别为 交换器名、交换器类型、是否持久化</span></span><br><span class="line"><span class="comment">// channel.exchangeDeclare(&quot;exchange&quot;, &quot;topic&quot;, true);  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通道绑定对应消息队列</span></span><br><span class="line"><span class="comment">// 参数1：队列名称，如果队列不存在将自动创建</span></span><br><span class="line"><span class="comment">// 参数2：定义队列是否持久化 true 持久化</span></span><br><span class="line"><span class="comment">// exclusive：是否独占队列 true 独占</span></span><br><span class="line"><span class="comment">// autoDelete：是否在消费完成后自动删除队列 true 自动删除</span></span><br><span class="line"><span class="comment">// 参数5：额外附加参数</span></span><br><span class="line">channel.queueDeclare(<span class="string">&quot;hello&quot;</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布消息</span></span><br><span class="line"><span class="comment">// 参数1：交换机名称</span></span><br><span class="line"><span class="comment">// 参数2：队列名称</span></span><br><span class="line"><span class="comment">// 参数3：传递消息额外设置  MessageProperties.PERSISTENT_TEXT_PLAIN表示持久化</span></span><br><span class="line"><span class="comment">// 参数4：消息的具体内容</span></span><br><span class="line">channel.basicPublish(<span class="string">&quot;exchange&quot;</span>,<span class="string">&quot;hello&quot;</span>, MessageProperties.PERSISTENT_TEXT_PLAIN,<span class="string">&quot;hello rabbitmq&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">channel.close();</span><br><span class="line">connection.close();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="SpringBoot中使用"><a href="#SpringBoot中使用" class="headerlink" title="SpringBoot中使用"></a>SpringBoot中使用</h3><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ip地址</span></span><br><span class="line"><span class="string">spring.rabbitmq.host=127.0.0.1</span></span><br><span class="line"><span class="comment"># 端口号</span></span><br><span class="line"><span class="string">spring.rabbitmq.port=5672</span></span><br><span class="line"><span class="comment"># 帐户</span></span><br><span class="line"><span class="string">spring.rabbitmq.username=admin</span></span><br><span class="line"><span class="comment"># 密码</span></span><br><span class="line"><span class="string">spring.rabbitmq.password=123456</span></span><br><span class="line"><span class="comment"># 虚拟主机名</span></span><br><span class="line"><span class="string">spring.rabbitmq.virtual-host=/test</span></span><br></pre></td></tr></table></figure><p>阿里云服务器需要将5672端口号添加到安全组</p><h4 id="简单模型"><a href="#简单模型" class="headerlink" title="简单模型"></a>简单模型</h4><h5 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendController</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 使用RabbitTemplate,这提供了接收/发送等等方法</span></span><br><span class="line">  <span class="meta">@Autowired</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping(&quot;/sendMessage&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">sendDirectMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 生成信息</span></span><br><span class="line">    String messageData = <span class="string">&quot;test message, hello!&quot;</span>;</span><br><span class="line">    String createTime =</span><br><span class="line">        LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;messageData&quot;</span>, messageData);</span><br><span class="line">    map.put(<span class="string">&quot;createTime&quot;</span>, createTime);</span><br><span class="line">    <span class="comment">// 将消息携带绑定键值：Hello 发送到</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;Hello&quot;</span>, map);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;Hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recevier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Map testMessage)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Receiver消费者收到消息  : &quot;</span> + testMessage.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动项目调用接口就能看到信息了</p><h4 id="工作模型"><a href="#工作模型" class="headerlink" title="工作模型"></a>工作模型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者发送50条数据</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">sendDirectMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">      String messageData = <span class="string">&quot;test message, hello!&quot;</span>;</span><br><span class="line">      String createTime =</span><br><span class="line">          LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">      Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      map.put(<span class="string">&quot;messageData&quot;</span>, messageData);</span><br><span class="line">      map.put(<span class="string">&quot;createTime&quot;</span>, createTime);</span><br><span class="line">      map.put(<span class="string">&quot;order&quot;</span>,i);</span><br><span class="line">      <span class="comment">// 将消息携带绑定键值：TestDirectRouting 发送到交换机TestDirectExchange</span></span><br><span class="line">      rabbitTemplate.convertAndSend(<span class="string">&quot;Hello&quot;</span>, map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加消费者2</span></span><br><span class="line"> <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Map testMessage)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 模拟速度更慢的消费者</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Receiver2消费者收到消息  : &quot;</span> + testMessage.toString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行后可以看到虽然处理速度不同，但是处理的消息条数是一样的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ul><li><a href="https://baike.baidu.com/">百度百科</a></li><li><a href="https://blog.csdn.net/s2152637/article/details/98987333">消息队列——介绍，应用，功能及常见问题解决方案</a></li><li><a href="https://www.cnblogs.com/ityouknow/p/6120544.html">SpringBoot（八）：RabbitMQ衔接</a></li><li><a href="https://www.cnblogs.com/javalyy/p/8856731.html">消息队列及常见消息队列介绍</a></li><li><a href="https://www.rabbitmq.com/documentation.html">RabbitMQ文档</a></li><li><a href="https://baike.baidu.com/item/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">百度百科-三次握手</a><a href="https://blog.csdn.net/qq_43243541/article/details/83476002">RabbitMQ之五种消息模型</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> Message Queue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Message Queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows Terminal</title>
      <link href="blog/16571/"/>
      <url>blog/16571/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是闲来无事对电脑界面进行的优化（瞎整），性能优不优化不一定，界面更好看就完事了</p><h2 id="Windows-Terminal"><a href="#Windows-Terminal" class="headerlink" title="Windows Terminal"></a>Windows Terminal</h2><p>Windows 终端是一个面向命令行工具和 shell（如命令提示符、PowerShell 和适用于 Linux 的 Windows 子系统 (WSL)）用户的新式终端应用程序。 它的主要功能包括多个选项卡、窗格、Unicode 和 UTF-8 字符支持、GPU 加速文本呈现引擎，还可以用于创建你自己的主题并自定义文本、颜色、背景和快捷键绑定。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在微软商店即可下载Windows Terminal。</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/2020-11-13/20201113211524.png" alt="安装"></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>结果展示<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/2020-11-14/20201114104700.png" alt="成果"></p><h3 id="配置文件内容"><a href="#配置文件内容" class="headerlink" title="配置文件内容"></a>配置文件内容</h3><ul><li>“defaultProfile”：默认启动工具</li><li>“profiles”:<ul><li>“defaults”：通用配置</li><li>“list”：工具列表，powershell，cmd，ubuntu，mongodb，aliclound等</li></ul></li><li>“schemes”：配色方案</li></ul><h3 id="我的配置"><a href="#我的配置" class="headerlink" title="我的配置"></a>我的配置</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot;defaults&quot;: &#123;</span><br><span class="line">    <span class="comment">// Put settings here that you want to apply to all profiles.</span></span><br><span class="line">    <span class="comment">// 毛玻璃</span></span><br><span class="line">    &quot;useAcrylic&quot;: true,</span><br><span class="line">    <span class="comment">// 透明度</span></span><br><span class="line">    &quot;acrylicOpacity&quot;: 0.8,</span><br><span class="line">    <span class="comment">// 字体</span></span><br><span class="line">    &quot;fontFace&quot;: &quot;Sarasa Term SC&quot;,</span><br><span class="line">    <span class="comment">// 颜色主题</span></span><br><span class="line">    &quot;colorScheme&quot;: &quot;Gruvbox Dark&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>设置自己的工具，举例如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot;list&quot;:</span><br><span class="line"> [</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="attr">&quot;guid&quot;</span>: <span class="string">&quot;&#123;ef722f41-f5ef-4f6d-ab09-359f1cbb3530&#125;&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;PowerShell7&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;icon&quot;</span>: <span class="string">&quot;%SystemRoot%\\Installer\\&#123;05321FDB-BBA2-497D-99C6-C440E184C043&#125;\\PowerShellExe.ico&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;commandline&quot;</span>: <span class="string">&quot;D:\\PowerShell\\7\\pwsh.exe&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;startingDirectory&quot;</span>: <span class="string">&quot;.&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;hidden&quot;</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><blockquote><p>可以在<code>PowerShell</code>中输入<code>new-guid</code>获得uuid</p></blockquote><h4 id="SSH连接远程服务器"><a href="#SSH连接远程服务器" class="headerlink" title="SSH连接远程服务器"></a>SSH连接远程服务器</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;guid&quot;</span>: <span class="string">&quot;&#123;21cb279a-1e41-4fad-81a1-7deec7b33cd1&#125;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;AliClound&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;icon&quot;</span>: <span class="string">&quot;D:\\Download\\Documents\\AliCloud.ico&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;commandline&quot;</span>: <span class="string">&quot;powershell.exe ssh root@服务器公网ip&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;hidden&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上配置，即可连接远程服务器</p><h4 id="配色方案"><a href="#配色方案" class="headerlink" title="配色方案"></a>配色方案</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配色方案</span></span><br><span class="line">  &quot;schemes&quot;:[</span><br><span class="line">      &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Gruvbox Dark&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;black&quot;</span>: <span class="string">&quot;#1e1e1e&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;red&quot;</span>: <span class="string">&quot;#be0f17&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;green&quot;</span>: <span class="string">&quot;#868715&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;yellow&quot;</span>: <span class="string">&quot;#cc881a&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;blue&quot;</span>: <span class="string">&quot;#377375&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;purple&quot;</span>: <span class="string">&quot;#a04b73&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;cyan&quot;</span>: <span class="string">&quot;#578e57&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;white&quot;</span>: <span class="string">&quot;#978771&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;brightBlack&quot;</span>: <span class="string">&quot;#7f7061&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;brightRed&quot;</span>: <span class="string">&quot;#f73028&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;brightGreen&quot;</span>: <span class="string">&quot;#aab01e&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;brightYellow&quot;</span>: <span class="string">&quot;#f7b125&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;brightBlue&quot;</span>: <span class="string">&quot;#719586&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;brightPurple&quot;</span>: <span class="string">&quot;#c77089&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;brightCyan&quot;</span>: <span class="string">&quot;#7db669&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;brightWhite&quot;</span>: <span class="string">&quot;#e6d4a3&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;background&quot;</span>: <span class="string">&quot;#1e1e1e&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;foreground&quot;</span>: <span class="string">&quot;#e6d4a3&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><h4 id="设置背景"><a href="#设置背景" class="headerlink" title="设置背景"></a>设置背景</h4><p>将图片放进Terminal的素材文件夹<code>C:\Users\&#123;用户名&#125;\AppData\Local\Packages\Microsoft.WindowsTerminal_8wekyb3d8bbwe\RoamingState</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 背景图片</span></span><br><span class="line">    <span class="attr">&quot;backgroundImage&quot;</span>: <span class="string">&quot;ms-appdata:///roaming/goose.png&quot;</span>,</span><br><span class="line">    <span class="comment">// 设置背景图片伸缩模式为「按比例放大」</span></span><br><span class="line">    <span class="attr">&quot;backgroundImageStretchMode&quot;</span>: <span class="string">&quot;uniformToFill&quot;</span>,</span><br><span class="line">    <span class="comment">// 背景图片透明度</span></span><br><span class="line">    <span class="attr">&quot;backgroundImageOpacity&quot;</span>: <span class="number">0.6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我没有设置所以没有截图</p><h3 id="on-my-push"><a href="#on-my-push" class="headerlink" title="on-my-push"></a>on-my-push</h3><p>安装oh-my-push</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Install-Module posh-git -Scope CurrentUser</span><br><span class="line">Install-Module oh-my-posh -Scope CurrentUser</span><br><span class="line"></span><br><span class="line">Import-Module posh-git</span><br><span class="line">Import-Module oh-my-posh</span><br><span class="line">Set-Theme PowerLine</span><br></pre></td></tr></table></figure><p>以下命令将打开PowerShell的配置文件，如果没有就创建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(Test-Path -Path <span class="variable">$PROFILE</span> )) &#123; New-Item -Type File -Path <span class="variable">$PROFILE</span> -Force &#125;</span><br><span class="line">notepad <span class="variable">$PROFILE</span></span><br></pre></td></tr></table></figure><p>配置文件内容如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Import-Module posh-git</span><br><span class="line">Import-Module oh-my-posh</span><br><span class="line">Set-Theme Paradox</span><br></pre></td></tr></table></figure><p>配置完之后每次打开PowerShell都会自动加载主题</p><h3 id="PSReadline"><a href="#PSReadline" class="headerlink" title="PSReadline"></a>PSReadline</h3><p>PowerShell7自带PSReadline，旧版输入<code>notepad $profile</code>打开配置文件</p><p>输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-PSReadlineKeyHandler -Key Tab -Function MenuComplete</span><br></pre></td></tr></table></figure><p>即可实现tab触发模式</p><h3 id="管理员权限"><a href="#管理员权限" class="headerlink" title="管理员权限"></a>管理员权限</h3><p>在运行一些语句时，没有管理员权限经常报错。所以这里提供一种调用方法</p><p>PowerShell安装gsudo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PowerShell -Command <span class="string">&quot;Set-ExecutionPolicy RemoteSigned -scope Process; iwr -useb https://raw.githubusercontent.com/gerardog/gsudo/master/installgsudo.ps1 | iex&quot;</span></span><br></pre></td></tr></table></figure><p>如果语句无法运行，显示<code>The remote name could not be resolved: &#39;raw.githubusercontent.com&#39;</code></p><p>在host文件中添加<code>199.232.68.133 raw.githubusercontent.com</code>就能成功运行了</p><p>安装过程中会提示是否以sudo作为gsudo别名，根据个人需要选择。安装完后重启Terminal，在语句前加上<code>sudo</code>即可成功调用</p><p>也可以建立一个管理员权限的工具</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;commandline&quot;: &quot;C:\\Users\\lenovo\\apps\\gsudo\\sudo.exe D:\\PowerShell\\7\\pwsh.exe&quot;,</span><br></pre></td></tr></table></figure><p>commandline中按照自己的路径配置sudo.exe powershell.exe的路径即可</p><h3 id="右键点击"><a href="#右键点击" class="headerlink" title="右键点击"></a>右键点击</h3><p>空白处点击右键</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\Background\shell\wt]</span><br><span class="line">@&#x3D;&quot;Windows Terminal here&quot;</span><br><span class="line">&quot;Icon&quot;&#x3D;&quot;G:\\lenovo\\Pictures\\terminal\\terminal.ico&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\Background\shell\wt\command]</span><br><span class="line">@&#x3D;&quot;C:\\Users\\lenovo\\AppData\\Local\\Microsoft\\WindowsApps\\wt.exe&quot;</span><br></pre></td></tr></table></figure><p>文件位置自行修改</p><!-- 文件上点击右键<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\shell\wt]</span><br><span class="line">@&#x3D;&quot;Windows Terminal here&quot;</span><br><span class="line">&quot;Icon&quot;&#x3D;&quot;G:\\lenovo\\Pictures\\terminal\\terminal.ico&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\shell\wt\command]</span><br><span class="line">@&#x3D;&quot;C:\\Users\\lenovo\\AppData\\Local\\Microsoft\\WindowsApps\\wt.exe&quot;</span><br><span class="line">&#96;&#96;&#96; --&gt;</span><br><span class="line"></span><br><span class="line">### 整合Git</span><br><span class="line"></span><br><span class="line">PowerShell 是直接支持了 Git 操作的！只要你安装了 Git 环境。但是 Git Bash 带上的 GNU 工具包就没能直接支持了，像是 GPG 等。</span><br><span class="line"></span><br><span class="line">跟java一样，在path变量添加Git 文件夹下的位置 &#96;&#96;usr&#x2F;bin&#x2F;&#96;&#96;，再重启终端就都支持了。</span><br><span class="line"></span><br><span class="line">### 字体</span><br><span class="line"></span><br><span class="line">如果使用新宋体，可能会出现中文渲染失败，更换[更纱黑体](https:&#x2F;&#x2F;github.com&#x2F;be5invis&#x2F;Sarasa-Gothic&#x2F;releases)即可。点击链接下载安装，字体配置看上文。</span><br><span class="line"></span><br><span class="line">附全文配置</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;json</span><br><span class="line">&#x2F;&#x2F; This file was initially generated by Windows Terminal 1.4.3141.0</span><br><span class="line">&#x2F;&#x2F; It should still be usable in newer versions, but newer versions might have additional</span><br><span class="line">&#x2F;&#x2F; settings, help text, or changes that you will not see unless you clear this file</span><br><span class="line">&#x2F;&#x2F; and let us generate a new one for you.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; To view the default settings, hold &quot;alt&quot; while clicking on the &quot;Settings&quot; button.</span><br><span class="line">&#x2F;&#x2F; For documentation on these settings, see: https:&#x2F;&#x2F;aka.ms&#x2F;terminal-documentation</span><br><span class="line">&#123;</span><br><span class="line">    &quot;$schema&quot;: &quot;https:&#x2F;&#x2F;aka.ms&#x2F;terminal-profiles-schema&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;defaultProfile&quot;: &quot;&#123;31ae71c6-cdab-47ef-a052-8545d8e3ab22&#125;&quot;,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; You can add more global application settings here.</span><br><span class="line">    &#x2F;&#x2F; To learn more about global settings, visit https:&#x2F;&#x2F;aka.ms&#x2F;terminal-global-settings</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; If enabled, selections are automatically copied to your clipboard.</span><br><span class="line">    &quot;copyOnSelect&quot;: false,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; If enabled, formatted data is also copied to your clipboard</span><br><span class="line">    &quot;copyFormatting&quot;: false,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; A profile specifies a command to execute paired with information about how it should look and feel.</span><br><span class="line">    &#x2F;&#x2F; Each one of them will appear in the &#39;New Tab&#39; dropdown,</span><br><span class="line">    &#x2F;&#x2F;   and can be invoked from the commandline with &#96;wt.exe -p xxx&#96;</span><br><span class="line">    &#x2F;&#x2F; To learn more about profiles, visit https:&#x2F;&#x2F;aka.ms&#x2F;terminal-profile-settings</span><br><span class="line">    &quot;profiles&quot;:</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;defaults&quot;: &#123;</span><br><span class="line">            &#x2F;&#x2F; Put settings here that you want to apply to all profiles.</span><br><span class="line">            &quot;useAcrylic&quot;: true,</span><br><span class="line">            &quot;acrylicOpacity&quot;: 0.8,</span><br><span class="line">            &quot;fontFace&quot;: &quot;Sarasa Term SC&quot;,</span><br><span class="line">            &quot;colorScheme&quot;: &quot;Gruvbox Dark&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;list&quot;:</span><br><span class="line">        [</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F; Make changes here to the powershell.exe profile.</span><br><span class="line">                &quot;guid&quot;: &quot;&#123;61c54bbd-c2c6-5271-96e7-009a87ff44bf&#125;&quot;,</span><br><span class="line">                &quot;name&quot;: &quot;Windows PowerShell&quot;,</span><br><span class="line">                &quot;commandline&quot;: &quot;powershell.exe&quot;,</span><br><span class="line">                &quot;hidden&quot;: false</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F; Make changes here to the cmd.exe profile.</span><br><span class="line">                &quot;guid&quot;: &quot;&#123;0caa0dad-35be-5f56-a8ff-afceeeaa6101&#125;&quot;,</span><br><span class="line">                &quot;name&quot;: &quot;Command Prompt&quot;,</span><br><span class="line">                &quot;commandline&quot;: &quot;cmd.exe&quot;,</span><br><span class="line">                &quot;hidden&quot;: false</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;guid&quot;: &quot;&#123;b453ae62-4e3d-5e58-b989-0a998ec441b8&#125;&quot;,</span><br><span class="line">                &quot;hidden&quot;: true,</span><br><span class="line">                &quot;name&quot;: &quot;Azure Cloud Shell&quot;,</span><br><span class="line">                &quot;source&quot;: &quot;Windows.Terminal.Azure&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;guid&quot;:&quot;&#123;31ae71c6-cdab-47ef-a052-8545d8e3ab22&#125;&quot;,</span><br><span class="line">                &quot;name&quot;: &quot;PowerShell&quot;,</span><br><span class="line">                &quot;icon&quot;:&quot;%SystemRoot%\\Installer\\&#123;05321FDB-BBA2-497D-99C6-C440E184C043&#125;\\PowerShellExe.ico&quot;,</span><br><span class="line">                &quot;commandline&quot;:&quot;C:\\Soft\\PowerShell\\7\\pwsh.exe&quot;,</span><br><span class="line">                &quot;hidden&quot;:false</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;guid&quot;:&quot;&#123;2df9c171-af51-456c-a599-fd053f83db27&#125;&quot;,</span><br><span class="line">                &quot;name&quot;:&quot;AliCloud&quot;,</span><br><span class="line">                &quot;icon&quot;: &quot;D:\\Download\\Documents\\AliCloud.ico&quot;,</span><br><span class="line">                &quot;commandline&quot;: &quot;powershell.exe ssh root@服务器ip&quot;,</span><br><span class="line">                &quot;hidden&quot;: false</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Add custom color schemes to this array.</span><br><span class="line">    &#x2F;&#x2F; To learn more about color schemes, visit https:&#x2F;&#x2F;aka.ms&#x2F;terminal-color-schemes</span><br><span class="line">    &quot;schemes&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Gruvbox Dark&quot;,</span><br><span class="line">            &quot;black&quot;: &quot;#1e1e1e&quot;,</span><br><span class="line">            &quot;red&quot;: &quot;#be0f17&quot;,</span><br><span class="line">            &quot;green&quot;: &quot;#868715&quot;,</span><br><span class="line">            &quot;yellow&quot;: &quot;#cc881a&quot;,</span><br><span class="line">            &quot;blue&quot;: &quot;#377375&quot;,</span><br><span class="line">            &quot;purple&quot;: &quot;#a04b73&quot;,</span><br><span class="line">            &quot;cyan&quot;: &quot;#578e57&quot;,</span><br><span class="line">            &quot;white&quot;: &quot;#978771&quot;,</span><br><span class="line">            &quot;brightBlack&quot;: &quot;#7f7061&quot;,</span><br><span class="line">            &quot;brightRed&quot;: &quot;#f73028&quot;,</span><br><span class="line">            &quot;brightGreen&quot;: &quot;#aab01e&quot;,</span><br><span class="line">            &quot;brightYellow&quot;: &quot;#f7b125&quot;,</span><br><span class="line">            &quot;brightBlue&quot;: &quot;#719586&quot;,</span><br><span class="line">            &quot;brightPurple&quot;: &quot;#c77089&quot;,</span><br><span class="line">            &quot;brightCyan&quot;: &quot;#7db669&quot;,</span><br><span class="line">            &quot;brightWhite&quot;: &quot;#e6d4a3&quot;,</span><br><span class="line">            &quot;background&quot;: &quot;#1e1e1e&quot;,</span><br><span class="line">            &quot;foreground&quot;: &quot;#e6d4a3&quot;</span><br><span class="line">            &#125;</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Add custom actions and keybindings to this array.</span><br><span class="line">    &#x2F;&#x2F; To unbind a key combination from your defaults.json, set the command to &quot;unbound&quot;.</span><br><span class="line">    &#x2F;&#x2F; To learn more about actions and keybindings, visit https:&#x2F;&#x2F;aka.ms&#x2F;terminal-keybindings</span><br><span class="line">    &quot;actions&quot;:</span><br><span class="line">    [</span><br><span class="line">        &#x2F;&#x2F; Copy and paste are bound to Ctrl+Shift+C and Ctrl+Shift+V in your defaults.json.</span><br><span class="line">        &#x2F;&#x2F; These two lines additionally bind them to Ctrl+C and Ctrl+V.</span><br><span class="line">        &#x2F;&#x2F; To learn more about selection, visit https:&#x2F;&#x2F;aka.ms&#x2F;terminal-selection</span><br><span class="line">        &#123; &quot;command&quot;: &#123;&quot;action&quot;: &quot;copy&quot;, &quot;singleLine&quot;: false &#125;, &quot;keys&quot;: &quot;ctrl+c&quot; &#125;,</span><br><span class="line">        &#123; &quot;command&quot;: &quot;paste&quot;, &quot;keys&quot;: &quot;ctrl+v&quot; &#125;,</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Press Ctrl+Shift+F to open the search box</span><br><span class="line">        &#123; &quot;command&quot;: &quot;find&quot;, &quot;keys&quot;: &quot;ctrl+shift+f&quot; &#125;,</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Press Alt+Shift+D to open a new pane.</span><br><span class="line">        &#x2F;&#x2F; - &quot;split&quot;: &quot;auto&quot; makes this pane open in the direction that provides the most surface area.</span><br><span class="line">        &#x2F;&#x2F; - &quot;splitMode&quot;: &quot;duplicate&quot; makes the new pane use the focused pane&#39;s profile.</span><br><span class="line">        &#x2F;&#x2F; To learn more about panes, visit https:&#x2F;&#x2F;aka.ms&#x2F;terminal-panes</span><br><span class="line">        &#123; &quot;command&quot;: &#123; &quot;action&quot;: &quot;splitPane&quot;, &quot;split&quot;: &quot;auto&quot;, &quot;splitMode&quot;: &quot;duplicate&quot; &#125;, &quot;keys&quot;: &quot;alt+shift+d&quot; &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://zhuanlan.zhihu.com/p/133297347">如何打造好看还好用的 Windows Terminal</a><br><a href="https://www.zhihu.com/question/330813656/answer/829350121">Terminal配色</a><br><a href="https://sspai.com/post/59380">新生代 Windows 终端：Windows Terminal 的全面自定义</a><br><a href="https://blog.csdn.net/weixin_39858881/article/details/107026065">Windows Terminal 使用管理员身份创建标签页</a><br><a href="https://blog.csdn.net/qq_41061352/article/details/107140887">Scoop安装遇到 “raw.githubusercontent.com未能解析” 解决方案</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB</title>
      <link href="blog/51937/"/>
      <url>blog/51937/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="MongoDB概念"><a href="#MongoDB概念" class="headerlink" title="MongoDB概念"></a>MongoDB概念</h2><p>MongoDB 是一个基于分布式文件存储的数据库。由C++语言编写。旨在简化开发和为WEB应用提供可扩展的高性能数据存储解决方案。</p><p>MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，<strong>最像关系数据库的</strong>。他支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。</p><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><ul><li>高性能</li><li>丰富的查询语言</li><li>高可用性</li><li>水平可伸缩性</li><li>支持多种存储引擎</li></ul><h2 id="Window安装MongoDB"><a href="#Window安装MongoDB" class="headerlink" title="Window安装MongoDB"></a>Window安装MongoDB</h2><ol><li><p>官网下载<a href="https://www.mongodb.com/try/download/community?tck=docs_server">社区版</a></p></li><li><p>选择Custom即可自定义安装地址<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200807222718.png" alt="安装"></p></li><li><p>安装到服务<br>从MongoDB 4.0开始，您可以在安装过程中将MongoDB设置为Windows服务，也可以仅安装二进制文件。<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200807222733.png" alt="服务"><br>我的配置如上<br>选择以下任一项：</p><ol><li>以网络服务用户身份运行服务（默认）这是Windows内置的Windows用户帐户</li><li>以本地或域用户身份运行服务</li></ol><ul><li><strong>Service Name</strong>: 指定服务名称。默认名称为MongoDB。如果您已经拥有使用指定名称的服务，则必须选择另一个名称。</li><li><strong>Data Directory</strong>: 指定数据目录，它对应于 –dbpath。如果目录不存在，安装程序将创建目录并将目录访问权限设置为服务用户。</li><li><strong>Log Directory</strong>: 指定日志目录，它对应于 –logpath。如果目录不存在，安装程序将创建目录并将目录访问权限设置为服务用户。</li></ul><p>如果不将MongoDB配置为Windows服务，取消选中Install MongoD as a Service即可。</p></li><li><p>安装图形化界面，可以不安装（选择之后安装很慢）。</p></li></ol><p>安装成功</p><h3 id="安装失败"><a href="#安装失败" class="headerlink" title="安装失败"></a>安装失败</h3><p>如果配置出错可能会出现安装失败的情况，有两种解决方式</p><h4 id="命令行启动"><a href="#命令行启动" class="headerlink" title="命令行启动"></a>命令行启动</h4><p>在mongodb目录下创建data文件夹，在data中创建db文件夹</p><p>打开bin目录下的命令行（选中bin，shift+右键）输入<code>mongod --dbpath ../data/db</code>即可看到启动成功。<br>这是一次性的启动方法，每次启动都要这么启动，下面有永久启动的方法。</p><h4 id="安装服务"><a href="#安装服务" class="headerlink" title="安装服务"></a>安装服务</h4><p>如果服务启动失败,命令行输入<code>mongod.exe --remove</code>删除服务</p><p>建立几个文件夹和文件，<strong>必须创建，不然会出错</strong></p><ul><li><p>数据目录：D:\MongoDB\data\db</p></li><li><p>日志目录：D:\MongoDB\data\log</p></li><li><p>日志文件：D:\MongoDB\data\db\mongod.log</p></li><li><p>配置文件：D:\MongoDB\data\mongod.conf</p></li></ul><p>日志文件不需要写入内容，配置文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#数据库路径(根据自己安装的目录修改即可)</span><br><span class="line">dbpath&#x3D;D:\MongoDB\data\db</span><br><span class="line">#日志输出文件路径(根据自己安装的目录修改即可)</span><br><span class="line">logpath&#x3D;D:\MongoDB\data\db\mongod.log</span><br><span class="line">#错误日志采用追加模式</span><br><span class="line">logappend&#x3D;true</span><br><span class="line">#启用日志文件，默认启用</span><br><span class="line">journal&#x3D;true</span><br><span class="line">#这个选项可以过滤掉一些无用的日志信息，若需要调试使用请设置为false</span><br><span class="line">quiet&#x3D;true</span><br><span class="line">#端口号 默认为27017</span><br><span class="line">port&#x3D;27017</span><br></pre></td></tr></table></figure><p>跟之前一样，进入bin目录的命令行界面，输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据自己目录调整</span></span><br><span class="line">mongod.exe --config <span class="string">&quot;G:D:\MongoDB\data\mongod.conf&quot;</span> --install``</span><br></pre></td></tr></table></figure><p>输入net start MongoDB就启动成功了</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="数据库相关"><a href="#数据库相关" class="headerlink" title="数据库相关"></a>数据库相关</h3><table><thead><tr><th align="center">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">use DATABASE_NAME</td><td align="left">创建数据库</td></tr><tr><td align="center">show db</td><td align="left">查看当前数据库</td></tr><tr><td align="center">show dbs</td><td align="left">查看所有数据库</td></tr><tr><td align="center">db.dropDatabase()</td><td align="left">删除当前数据库</td></tr><tr><td align="center">db.collection.drop()</td><td align="left">删除集合</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换数据库：如果数据库不存在，在插入数据时创建数据库，否则切换到指定数据库。</span></span><br><span class="line">&gt; use example</span><br><span class="line">switched to db example</span><br><span class="line"><span class="comment"># 查看所有数据库</span></span><br><span class="line">&gt; show dbs</span><br><span class="line">admin   0.000GB</span><br><span class="line">config  0.000GB</span><br><span class="line"><span class="built_in">local</span>   0.000GB</span><br><span class="line"><span class="comment"># 查看当前数据库</span></span><br><span class="line">&gt; db</span><br><span class="line">example</span><br><span class="line"><span class="comment"># 插入数据</span></span><br><span class="line">&gt; db.example.insert(&#123;<span class="string">&quot;namme&quot;</span>:<span class="string">&quot;test&quot;</span>&#125;)</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nInserted&quot;</span> : 1 &#125;)</span><br><span class="line"><span class="comment"># 插入数据时，创建数据库</span></span><br><span class="line">&gt; show dbs</span><br><span class="line">admin    0.000GB</span><br><span class="line">config   0.000GB</span><br><span class="line">example  0.000GB</span><br><span class="line"><span class="built_in">local</span>    0.000GB</span><br><span class="line"><span class="comment"># 删除当前数据库</span></span><br><span class="line">&gt; db.dropDatabase()</span><br><span class="line">&#123; <span class="string">&quot;dropped&quot;</span> : <span class="string">&quot;example&quot;</span>, <span class="string">&quot;ok&quot;</span> : 1 &#125;</span><br><span class="line">&gt; show dbs</span><br><span class="line">admin   0.000GB</span><br><span class="line">config  0.000GB</span><br><span class="line"><span class="built_in">local</span>   0.000GB</span><br><span class="line"><span class="comment"># 删除集合</span></span><br><span class="line">&gt; db.test.drop()</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="插入文档"><a href="#插入文档" class="headerlink" title="插入文档"></a>插入文档</h3><table><thead><tr><th align="center">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">db.COLLECTION_NAME.insert(document)</td><td align="left">插入文档</td></tr><tr><td align="center">db.COLLECTION_NAME.find()</td><td align="left">查询集合</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;  db.col.insert(&#123;title: <span class="string">&#x27;MongoDB 教程&#x27;</span>,</span><br><span class="line">... description: <span class="string">&#x27;MongoDB 是一个 Nosql 数据库&#x27;</span>,</span><br><span class="line">... by: <span class="string">&#x27;MongoDB中文网&#x27;</span>,</span><br><span class="line">... url: <span class="string">&#x27;http://www.mongodb.org.cn&#x27;</span>,</span><br><span class="line">... tags: [<span class="string">&#x27;mongodb&#x27;</span>, <span class="string">&#x27;database&#x27;</span>, <span class="string">&#x27;NoSQL&#x27;</span>],</span><br><span class="line">... likes: 100</span><br><span class="line">... &#125;)</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nInserted&quot;</span> : 1 &#125;)</span><br><span class="line">&gt;  db.col.find()</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5f23753824b1e2c8709491ad&quot;</span>), <span class="string">&quot;title&quot;</span> : <span class="string">&quot;MongoDB 教程&quot;</span>, <span class="string">&quot;description&quot;</span> : <span class="string">&quot;MongoDB 是一个 Nosql 数据库&quot;</span>, <span class="string">&quot;by&quot;</span> : <span class="string">&quot;MongoDB中文网&quot;</span>, <span class="string">&quot;url&quot;</span> : <span class="string">&quot;http://www.mongodb.org.cn&quot;</span>, <span class="string">&quot;tags&quot;</span> : [ <span class="string">&quot;mongodb&quot;</span>, <span class="string">&quot;database&quot;</span>, <span class="string">&quot;NoSQL&quot;</span> ], <span class="string">&quot;likes&quot;</span> : 100 &#125;</span><br></pre></td></tr></table></figure><p>插入文档可以使用insert()也可以使用save(),两种的区别在于：</p><ol><li>insert(),指明_id的情况，如果主键不存在，正常插入。主键存在，则抛 org.springframework.dao.DuplicateKeyException 异常提示主键重复，不保存当前数据。</li><li>save(),指明_id的情况下，如果主键不存在，则正常插入。主键存在，则修改已存在数据。</li></ol><h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.collection.remove(</span><br><span class="line">  &lt;query&gt;,</span><br><span class="line">    &#123;</span><br><span class="line">      justOne: &lt;boolean&gt;,</span><br><span class="line">      writeConcern: &lt;document&gt;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><strong>query</strong> :（可选）删除的文档的条件。</li><li><strong>justOne</strong> : （可选）如果设为 true 或 1，则只删除一个文档。</li><li><strong>writeConcern</strong> :（可选）抛出异常的级别。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 插入两条数据</span></span><br><span class="line">&gt;db.col.insert(&#123;title: <span class="string">&#x27;MongoDB 教程&#x27;</span>, description: <span class="string">&#x27;MongoDB 是一个 Nosql 数据库&#x27;</span>,  by: <span class="string">&#x27;MongoDB中文网&#x27;</span>,    url: <span class="string">&#x27;http://www.mongodb.org.cn&#x27;</span>,  tags: [<span class="string">&#x27;mongodb&#x27;</span>, <span class="string">&#x27;database&#x27;</span>, <span class="string">&#x27;NoSQL&#x27;</span>],  likes: 100  &#125;)</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nInserted&quot;</span> : 1 &#125;)</span><br><span class="line"><span class="comment"># 删除数据</span></span><br><span class="line">&gt; db.col.remove(&#123;</span><br><span class="line">... <span class="string">&#x27;title&#x27;</span>:<span class="string">&#x27;MongoDB 教程&#x27;</span>&#125;)</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nRemoved&quot;</span> : 2 &#125;)</span><br><span class="line">&gt; db.col.find()</span><br><span class="line">...</span><br><span class="line"><span class="comment"># 删除一条数据</span></span><br><span class="line">&gt; db.col.remove(&#123;<span class="string">&#x27;title&#x27;</span>:<span class="string">&#x27;MongoDB 教程&#x27;</span>&#125;,<span class="literal">true</span>,<span class="literal">true</span>)</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nRemoved&quot;</span> : 1 &#125;)</span><br><span class="line">&gt; db.col.find()</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5f23917cfb7c6a540cbe1649&quot;</span>), <span class="string">&quot;title&quot;</span> : <span class="string">&quot;MongoDB 教程&quot;</span>, <span class="string">&quot;description&quot;</span> : <span class="string">&quot;MongoDB 是一个 Nosql 数据库&quot;</span>, <span class="string">&quot;by&quot;</span> : <span class="string">&quot;MongoDB中文网&quot;</span>, <span class="string">&quot;url&quot;</span> : <span class="string">&quot;http://www.mongodb.org.cn&quot;</span>, <span class="string">&quot;tags&quot;</span> : [ <span class="string">&quot;mongodb&quot;</span>, <span class="string">&quot;database&quot;</span>, <span class="string">&quot;NoSQL&quot;</span> ], <span class="string">&quot;likes&quot;</span> : 100 &#125;</span><br></pre></td></tr></table></figure><h3 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h3><p>updat()方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.collection.update(</span><br><span class="line">  &lt;query&gt;,</span><br><span class="line">  &lt;update&gt;,</span><br><span class="line">    &#123;</span><br><span class="line">      upsert: &lt;boolean&gt;,</span><br><span class="line">      multi: &lt;boolean&gt;,  </span><br><span class="line">      writeConcern: &lt;document&gt;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><strong>query</strong> : update的查询条件，类似sql update查询内where后面的。</li><li><strong>update</strong> : update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql update查询内set后面的。</li><li><strong>upsert</strong> : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。</li><li><strong>multi</strong> : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。</li><li><strong>writeConcern</strong> :可选，抛出异常的级别。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.col.update(&#123;<span class="string">&#x27;title&#x27;</span>:<span class="string">&#x27;MongoDB 教程&#x27;</span>&#125;,&#123;<span class="variable">$set</span>:&#123;<span class="string">&#x27;title&#x27;</span>:<span class="string">&#x27;MongoDB&#x27;</span>&#125;&#125;)</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nMatched&quot;</span> : 1, <span class="string">&quot;nUpserted&quot;</span> : 0, <span class="string">&quot;nModified&quot;</span> : 1 &#125;)   <span class="comment"># 输出信息  </span></span><br><span class="line">&gt; db.col.find().pretty()  </span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;56064f89ade2f21f36b03136&quot;</span>),  </span><br><span class="line">  <span class="string">&quot;title&quot;</span> : <span class="string">&quot;MongoDB&quot;</span>,</span><br><span class="line">  <span class="string">&quot;description&quot;</span> : <span class="string">&quot;MongoDB 是一个 Nosql 数据库&quot;</span>,  </span><br><span class="line">  <span class="string">&quot;by&quot;</span> : <span class="string">&quot;Mongodb中文网&quot;</span>,</span><br><span class="line">  <span class="string">&quot;url&quot;</span> : <span class="string">&quot;http://www.mongodb.org.cn&quot;</span>,</span><br><span class="line">  <span class="string">&quot;tags&quot;</span> : [</span><br><span class="line">        <span class="string">&quot;mongodb&quot;</span>,</span><br><span class="line">        <span class="string">&quot;database&quot;</span>,</span><br><span class="line">        <span class="string">&quot;NoSQL&quot;</span></span><br><span class="line">      ],</span><br><span class="line">  <span class="string">&quot;likes&quot;</span> : 100  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>save方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.collection.save(</span><br><span class="line">  &lt;document&gt;,</span><br><span class="line">  &#123;</span><br><span class="line">    writeConcern: &lt;document&gt;</span><br><span class="line">  &#125;  </span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><strong>document</strong> : 文档数据。</li><li><strong>writeConcern</strong> :可选，抛出异常的级别。</li></ul><p>使用与insert()基本相同</p>]]></content>
      
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
            <tag> NoSQl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis数据类型</title>
      <link href="blog/6834/"/>
      <url>blog/6834/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="五种基本数据类型"><a href="#五种基本数据类型" class="headerlink" title="五种基本数据类型"></a>五种基本数据类型</h2><p>Redis支持五种基础数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset（sorted set：有序集合）。三种特殊数据类型：geospatial（地理位置），hyperloglog（基数统计），bitmaps（位图场景）</p><h3 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String(字符串)"></a>String(字符串)</h3><table><thead><tr><th align="center">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">INCR key</td><td align="left">将 key 中储存的数字值增一</td></tr><tr><td align="center">DECR key</td><td align="left">将 key 中储存的数字值减一</td></tr><tr><td align="center">INCRBY key</td><td align="left">increment 将 key 所储存的值加上给定的增量值（increment）</td></tr><tr><td align="center">DECRBY key</td><td align="left">decrement key 所储存的值减去给定的减量值（decrement）</td></tr><tr><td align="center">STRLEN key</td><td align="left">返回 key 所储存的字符串值的长度。</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> string 1</span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 自增 1</span></span><br><span class="line">127.0.0.1:6379&gt; incr string</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"><span class="comment"># 自减 1</span></span><br><span class="line">127.0.0.1:6379&gt; decr string</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># 按变量增加</span></span><br><span class="line">127.0.0.1:6379&gt; incrby string 10</span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br><span class="line"><span class="comment"># 按变量减少</span></span><br><span class="line">127.0.0.1:6379&gt; decrby string 10</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; strlen key</span><br><span class="line">(<span class="built_in">integer</span>) 9</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">GETRANGE key start end</td><td align="left">返回 key 中字符串值的子字符</td></tr><tr><td align="center">SETRANGE key offset value</td><td align="left">用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key <span class="string">&quot;123456789&quot;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key</span><br><span class="line"><span class="string">&quot;123456789&quot;</span></span><br><span class="line"><span class="comment"># 获取字符串值的子字符串</span></span><br><span class="line">127.0.0.1:6379&gt; getrange key 0 3</span><br><span class="line"><span class="string">&quot;1234&quot;</span></span><br><span class="line"><span class="comment"># 返回key存储的字符串的长度</span></span><br><span class="line">127.0.0.1:6379&gt; getrange key 0 -1</span><br><span class="line"><span class="string">&quot;123456789&quot;</span></span><br><span class="line"><span class="comment"># 替换指定位置的字符串</span></span><br><span class="line">127.0.0.1:6379&gt; setrange key 2 xx</span><br><span class="line">(<span class="built_in">integer</span>) 9</span><br><span class="line">127.0.0.1:6379&gt; get key</span><br><span class="line"><span class="string">&quot;12xx56789</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">SETEX key seconds value</td><td align="left">将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)</td></tr><tr><td align="center">SETNX key value</td><td align="left">只有在 key 不存在时设置 key 的值</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。</span></span><br><span class="line">127.0.0.1:6379&gt; setex key 10 <span class="string">&quot;setex&quot;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl key</span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key1 <span class="string">&quot;set&quot;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">&quot;set&quot;</span></span><br><span class="line"><span class="comment"># 只有在 key 不存在时设置 key 的值。</span></span><br><span class="line">127.0.0.1:6379&gt; setnx key1 <span class="string">&quot;setnx&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">&quot;set&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key2 <span class="string">&quot;setnx&quot;</span>  </span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key2</span><br><span class="line"><span class="string">&quot;setnx&quot;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">MSET key value [key value …]</td><td align="left">同时设置一个或多个 key-value 对</td></tr><tr><td align="center">MSETNX key value [key value …]</td><td align="left">同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mset|msetnx</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时设置一个或多个 key-value 对</span></span><br><span class="line">127.0.0.1:6379&gt; mset k1 v1 k2 v2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;k2&quot;</span></span><br><span class="line">2) <span class="string">&quot;key1&quot;</span></span><br><span class="line">3) <span class="string">&quot;k1&quot;</span></span><br><span class="line">4) <span class="string">&quot;key2&quot;</span></span><br><span class="line"><span class="comment"># 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</span></span><br><span class="line">127.0.0.1:6379&gt; msetnx k1 v1 k2 v2</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">GETSET key value</td><td align="left">将给定 key 的值设为 value ，并返回 key 的旧值(old value)</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果不存在，则返回nil</span></span><br><span class="line">127.0.0.1:6379&gt; getset k v1</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get k</span><br><span class="line"><span class="string">&quot;v1&quot;</span></span><br><span class="line"><span class="comment"># 如果存在值，获取原来的值，并设置新的值</span></span><br><span class="line">127.0.0.1:6379&gt; getset k v2</span><br><span class="line"><span class="string">&quot;v1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get k</span><br><span class="line"><span class="string">&quot;v2&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置一个user:1 对象，值为json字符来保存一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># key设计：user:&#123;id&#125;:&#123;filed&#125;</span></span><br><span class="line">127.0.0.1:6379&gt; mset user:1:name zs user:1:age 2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; mget user:1:name user:1:age</span><br><span class="line">1) <span class="string">&quot;zs&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br></pre></td></tr></table></figure><h4 id="String其余命令"><a href="#String其余命令" class="headerlink" title="String其余命令"></a>String其余命令</h4><table><thead><tr><th align="center">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">SET key value</td><td align="left">设置指定 key 的值</td></tr><tr><td align="center">GET key</td><td align="left">获取指定 key 的值。</td></tr><tr><td align="center">MGET key1 [key2..]</td><td align="left">获取所有(一个或多个)给定 key 的值</td></tr><tr><td align="center">APPEND key value</td><td align="left">如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾</td></tr><tr><td align="center">PSETEX key milliseconds value</td><td align="left">这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位</td></tr><tr><td align="center">INCRBYFLOAT key increment</td><td align="left">将 key 所储存的值加上给定的浮点增量值（increment）</td></tr><tr><td align="center">GETBIT key offset</td><td align="left">对 key 所储存的字符串值，获取指定偏移量上的位(bit)</td></tr><tr><td align="center">SETBIT key offset value</td><td align="left">对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)</td></tr></tbody></table><p><strong>java中传递对象，需要将对象序列化(implements Serializable)。</strong><br>String类似的使用场景：</p><ul><li>计数器</li><li>统计多单位的数量</li><li>粉丝数</li><li>对象缓存存储</li></ul><h3 id="List-列表"><a href="#List-列表" class="headerlink" title="List(列表)"></a>List(列表)</h3><table><thead><tr><th align="center">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">LPUSH key value1 [value2]</td><td align="left">将一个或多个值插入到列表头部</td></tr><tr><td align="center">RPUSH key value1 [value2]</td><td align="left">将一个或多个值插入到列表尾部</td></tr><tr><td align="center">LPUSHX key value</td><td align="left">将一个值插入到已存在的列表头部</td></tr><tr><td align="center">RPUSHX key value</td><td align="left">将一个值插入到已存在的列表尾部</td></tr><tr><td align="center">LRANGE key start stop</td><td align="left">获取列表指定范围内的元素</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将一个或多个值插入到列表头部</span></span><br><span class="line">127.0.0.1:6379&gt; lpush key v1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; lpush key v2</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; Lpush key v3</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"><span class="comment"># 获取列表指定范围内的元素</span></span><br><span class="line">127.0.0.1:6379&gt; Lrange key 0 -1</span><br><span class="line">1) <span class="string">&quot;v3&quot;</span></span><br><span class="line">2) <span class="string">&quot;v2&quot;</span></span><br><span class="line">3) <span class="string">&quot;v1&quot;</span></span><br><span class="line"><span class="comment"># 将一个或多个值插入到列表尾部</span></span><br><span class="line">127.0.0.1:6379&gt; rpush key right</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange key 0 -1</span><br><span class="line">1) <span class="string">&quot;v3&quot;</span></span><br><span class="line">2) <span class="string">&quot;v2&quot;</span></span><br><span class="line">3) <span class="string">&quot;v1&quot;</span></span><br><span class="line">4) <span class="string">&quot;right&quot;</span></span><br><span class="line"><span class="comment"># 将一个值插入到已存在的列表头部</span></span><br><span class="line">127.0.0.1:6379&gt; Lpushx key v4</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; LRANGE key 0 -1</span><br><span class="line">1) <span class="string">&quot;v4&quot;</span></span><br><span class="line">2) <span class="string">&quot;v3&quot;</span></span><br><span class="line">3) <span class="string">&quot;v2&quot;</span></span><br><span class="line">4) <span class="string">&quot;v1&quot;</span></span><br><span class="line">5) <span class="string">&quot;right&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LPUSHX LPUSHX v5</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; LRANGE LPUSHX 0 -1</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line">127.0.0.1:6379&gt; lrange key 0 -1</span><br><span class="line">1) <span class="string">&quot;v4&quot;</span></span><br><span class="line">2) <span class="string">&quot;v3&quot;</span></span><br><span class="line">3) <span class="string">&quot;v2&quot;</span></span><br><span class="line">4) <span class="string">&quot;v1&quot;</span></span><br><span class="line">5) <span class="string">&quot;right&quot;</span></span><br><span class="line"><span class="comment"># 将一个值插入到已存在的列表尾部</span></span><br><span class="line">127.0.0.1:6379&gt; rpushx key rpushx</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; lrange key 0 -1</span><br><span class="line">1) <span class="string">&quot;v4&quot;</span></span><br><span class="line">2) <span class="string">&quot;v3&quot;</span></span><br><span class="line">3) <span class="string">&quot;v2&quot;</span></span><br><span class="line">4) <span class="string">&quot;v1&quot;</span></span><br><span class="line">5) <span class="string">&quot;right&quot;</span></span><br><span class="line">6) <span class="string">&quot;rpushx&quot;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">LPOP key</td><td align="left">移出并获取列表的第一个元素</td></tr><tr><td align="center">RPOP key</td><td align="left">移出并获取列表的最后一个元素</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 移出并获取列表的第一个元素</span></span><br><span class="line">127.0.0.1:6379&gt; lpop key</span><br><span class="line"><span class="string">&quot;v4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange key 0 -1</span><br><span class="line">1) <span class="string">&quot;v3&quot;</span></span><br><span class="line">2) <span class="string">&quot;v2&quot;</span></span><br><span class="line">3) <span class="string">&quot;v1&quot;</span></span><br><span class="line">4) <span class="string">&quot;right&quot;</span></span><br><span class="line">5) <span class="string">&quot;rpushx&quot;</span></span><br><span class="line"><span class="comment"># 移出并获取列表的最后一个元素</span></span><br><span class="line">127.0.0.1:6379&gt; rpop key</span><br><span class="line"><span class="string">&quot;rpushx&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange key 0 -1</span><br><span class="line">1) <span class="string">&quot;v3&quot;</span></span><br><span class="line">2) <span class="string">&quot;v2&quot;</span></span><br><span class="line">3) <span class="string">&quot;v1&quot;</span></span><br><span class="line">4) <span class="string">&quot;right&quot;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">LINDEX key index</td><td align="left">通过索引获取列表中的元素</td></tr><tr><td align="center">LLEN key</td><td align="left">获取列表长度</td></tr><tr><td align="center">LREM key count value</td><td align="left">移除列表中count个value值</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过索引获取列表中的元素</span></span><br><span class="line">127.0.0.1:6379&gt; lrange key 0 -1</span><br><span class="line">1) <span class="string">&quot;v3&quot;</span></span><br><span class="line">2) <span class="string">&quot;v2&quot;</span></span><br><span class="line">3) <span class="string">&quot;v1&quot;</span></span><br><span class="line">4) <span class="string">&quot;right&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lindex key 0</span><br><span class="line"><span class="string">&quot;v3&quot;</span></span><br><span class="line"><span class="comment"># 获取列表长度</span></span><br><span class="line">127.0.0.1:6379&gt; llen key</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line"><span class="comment"># 移除列表元素</span></span><br><span class="line">127.0.0.1:6379&gt; lrem key 1 v3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; lrange key 0 -1</span><br><span class="line">1) <span class="string">&quot;v2&quot;</span></span><br><span class="line">2) <span class="string">&quot;v1&quot;</span></span><br><span class="line">3) <span class="string">&quot;right&quot;</span></span><br></pre></td></tr></table></figure><h4 id="List其余命令"><a href="#List其余命令" class="headerlink" title="List其余命令"></a>List其余命令</h4><table><thead><tr><th align="center">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">LINSERT key BEFORE           / AFTER pivot value</td><td align="left">在列表的元素前或者后插入元素</td></tr><tr><td align="center">LSET key index value</td><td align="left">通过索引设置列表元素的值</td></tr><tr><td align="center">LTRIM key start stop</td><td align="left">对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</td></tr><tr><td align="center">BLPOP key1 [key2 ] timeout</td><td align="left">移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr><tr><td align="center">BRPOP key1 [key2 ] timeout</td><td align="left">移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr><tr><td align="center">BRPOPLPUSH list1 list2 timeout</td><td align="left">移除列表的最后一个元素，并将该元素添加到另一个列表并返回                           ； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</td></tr><tr><td align="center">RPOPLPUSH list1 list2</td><td align="left">移除列表的最后一个元素，并将该元素添加到另一个列表并返回</td></tr></tbody></table><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li>实际上是一个链表，before Node after，left，right都可以插入值</li><li>如果key不存在，创建新链表</li><li>如果key存在，新增内容</li><li>如果移除所有值（空链表），也代表不存在</li><li>在两边插入或者改动值，效率最高</li></ul><p>消息队列(LPUSH,RPOP),栈(LPUSH,LPOP)</p><h3 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set(集合)"></a>Set(集合)</h3><table><thead><tr><th align="center">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">SADD key member1 [member2]</td><td align="left">向集合添加一个或多个成员</td></tr><tr><td align="center">SMEMBERS key</td><td align="left">返回集合中的所有成员</td></tr><tr><td align="center">SISMEMBER key member</td><td align="left">判断 member 元素是否是集合 key 的成员</td></tr><tr><td align="center">SCARD key</td><td align="left">获取集合的成员数量</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 向集合添加一个或多个成员</span></span><br><span class="line">127.0.0.1:6379&gt; sadd <span class="built_in">set</span> m1 m2 m3</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"><span class="comment"># 返回集合中的所有成员</span></span><br><span class="line">127.0.0.1:6379&gt; smembers <span class="built_in">set</span></span><br><span class="line">1) <span class="string">&quot;m1&quot;</span></span><br><span class="line">2) <span class="string">&quot;m2&quot;</span></span><br><span class="line">3) <span class="string">&quot;m3&quot;</span></span><br><span class="line"><span class="comment"># 判断 member 元素是否是集合 key 的成员</span></span><br><span class="line">127.0.0.1:6379&gt; sismember <span class="built_in">set</span> m1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sismember <span class="built_in">set</span> m4</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"><span class="comment"># 获取集合的成员数量</span></span><br><span class="line">127.0.0.1:6379&gt; scard <span class="built_in">set</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">SREM key member1 [member2]</td><td align="left">移除集合中一个或多个成员</td></tr><tr><td align="center">SMOVE source destination member</td><td align="left">将 member 元素从 source 集合移动到 destination 集合</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 移除集合中一个或多个成员</span></span><br><span class="line">127.0.0.1:6379&gt; srem <span class="built_in">set</span> m1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers <span class="built_in">set</span></span><br><span class="line">1) <span class="string">&quot;m2&quot;</span></span><br><span class="line">2) <span class="string">&quot;m3&quot;</span></span><br><span class="line"><span class="comment"># 将 member 元素从 source 集合移动到 destination 集合</span></span><br><span class="line">127.0.0.1:6379&gt; smembers <span class="built_in">set</span></span><br><span class="line">1) <span class="string">&quot;m2&quot;</span></span><br><span class="line">2) <span class="string">&quot;m3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; smove <span class="built_in">set</span> set1 m2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers <span class="built_in">set</span></span><br><span class="line">1) <span class="string">&quot;m3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; smembers set1</span><br><span class="line">1) <span class="string">&quot;m2&quot;</span></span><br></pre></td></tr></table></figure><h4 id="Set其余命令"><a href="#Set其余命令" class="headerlink" title="Set其余命令"></a>Set其余命令</h4><table><thead><tr><th align="center">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">SDIFF key1 [key2]</td><td align="left">返回给定所有集合的差集</td></tr><tr><td align="center">SDIFFSTORE destination key1 [key2]</td><td align="left">返回给定所有集合的差集并存储在 destination 中</td></tr><tr><td align="center">SINTER key1 [key2]</td><td align="left">返回给定所有集合的交集</td></tr><tr><td align="center">SINTERSTORE destination key1 [key2]</td><td align="left">返回给定所有集合的交集并存储在 destination 中</td></tr><tr><td align="center">SUNION key1 [key2]</td><td align="left">返回所有给定集合的并集</td></tr><tr><td align="center">SUNIONSTORE destination key1 [key2]</td><td align="left">所有给定集合的并集存储在 destination 集合中</td></tr><tr><td align="center">SPOP key</td><td align="left">移除并返回集合中的一个随机元素</td></tr><tr><td align="center">SRANDMEMBER key [count]</td><td align="left">返回集合中一个或多个随机数</td></tr><tr><td align="center">SSCAN key cursor [MATCH pattern] [COUNT count]</td><td align="left">迭代集合中的元素</td></tr></tbody></table><p>并集，交集，差集<br>用于共同关注，共同爱好，二度好友等</p><h3 id="Hash-hash"><a href="#Hash-hash" class="headerlink" title="Hash(hash)"></a>Hash(hash)</h3><p>Map集合，key-map。这是的值是一个map集合。本质和String没有太大区别，还是一个key-value</p><table><thead><tr><th align="center">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">HSET key field value</td><td align="left">将哈希表 key 中的字段 field 的值设为 value 。</td></tr><tr><td align="center">HGET key field</td><td align="left">获取存储在哈希表中指定字段的值</td></tr><tr><td align="center">HMSET key field1 value1 [field2 value2 ]</td><td align="left">同时将多个field-value (域-值)对设置到哈希表 key 中。</td></tr><tr><td align="center">HGETALL key</td><td align="left">获取在哈希表中指定 key 的所有字段和值</td></tr><tr><td align="center">HMGET key field1 [field2]</td><td align="left">获取所有给定字段的值</td></tr><tr><td align="center">HDEL key field2 [field2]</td><td align="left">删除一个或多个哈希表字段</td></tr><tr><td align="center">HLEN key</td><td align="left">获取哈希表中字段的数量</td></tr><tr><td align="center">HEXISTS key field</td><td align="left">查看哈希表 key 中，指定的字段是否存在。</td></tr><tr><td align="center">HKEYS key</td><td align="left">获取所有哈希表中的字段</td></tr><tr><td align="center">HVALS key</td><td align="left">获取哈希表中所有值</td></tr><tr><td align="center">HINCRBY key field increment</td><td align="left">为哈希表 key 中的指定字段的整数值加上增量 increment 。</td></tr><tr><td align="center">HINCRBYFLOAT key field increment</td><td align="left">为哈希表 key 中的指定字段的浮点数值加上增量 increment 。</td></tr><tr><td align="center">HSETNX key field value</td><td align="left">只有在字段 field 不存在时，设置哈希表字段的值。</td></tr><tr><td align="center">HSCAN key cursor [MATCH pattern] [COUNT count]</td><td align="left">迭代哈希表中的键值对。</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset user:1 name zhangsan</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hget user:1 name</span><br><span class="line"><span class="string">&quot;zhangsan&quot;</span></span><br></pre></td></tr></table></figure><p>如上，hash可以用来保存变更的数据，尤其是用户对象之类的经常变动的信息<br>hash更适合对象的存储，String更适合字符串存储</p><h3 id="sorted-sets-有序集合"><a href="#sorted-sets-有序集合" class="headerlink" title="sorted sets(有序集合)"></a>sorted sets(有序集合)</h3><table><thead><tr><th align="center">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">ZADD key score1 member1 [score2 member2]</td><td align="left">向有序集合添加一个或多个成员，或者更新已存在成员的分数</td></tr><tr><td align="center">ZRANGE key start stop [WITHSCORES]</td><td align="left">通过索引区间返回有序集合成指定区间内的成员</td></tr><tr><td align="center">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT]</td><td align="left">返回有序集中指定分数区间内的成员，分数从低到高排</td></tr><tr><td align="center">ZREVRANGEBYSCORE key max min [WITHSCORES]</td><td align="left">返回有序集中指定分数区间内的成员，分数从高到低排序</td></tr><tr><td align="center">ZREM key member [member …]</td><td align="left">移除有序集合中的一个或多个成员</td></tr><tr><td align="center">ZCARD key</td><td align="left">获取有序集合的成员数</td></tr><tr><td align="center">ZCOUNT key min max</td><td align="left">计算在有序集合中指定区间分数的成员数</td></tr><tr><td align="center">ZINCRBY key increment member</td><td align="left">有序集合中对指定成员的分数加上增量 increment</td></tr><tr><td align="center">ZINTERSTORE destination numkeys key [key …]</td><td align="left">计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中</td></tr><tr><td align="center">ZLEXCOUNT key min max</td><td align="left">在有序集合中计算指定字典区间内成员数量</td></tr><tr><td align="center">ZRANGEBYLEX key min max [LIMIT offset count]</td><td align="left">通过字典区间返回有序集合的成员</td></tr><tr><td align="center">ZRANK key member</td><td align="left">返回有序集合中指定成员的索引</td></tr><tr><td align="center">ZREMRANGEBYLEX key min max</td><td align="left">移除有序集合中给定的字典区间的所有成员</td></tr><tr><td align="center">ZREMRANGEBYRANK key start stop</td><td align="left">移除有序集合中给定的排名区间的所有成员</td></tr><tr><td align="center">ZREMRANGEBYSCORE key min max</td><td align="left">移除有序集合中给定的分数区间的所有成员</td></tr><tr><td align="center">ZREVRANGE key start stop [WITHSCORES]</td><td align="left">返回有序集中指定区间内的成员，通过索引，分数从高到底</td></tr><tr><td align="center">ZREVRANK key member</td><td align="left">返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</td></tr><tr><td align="center">ZSCORE key member</td><td align="left">返回有序集中，成员的分数值</td></tr><tr><td align="center">ZUNIONSTORE destination numkeys key [key …]</td><td align="left">计算给定的一个或多个有序集的并集，并存储在新的 key 中</td></tr><tr><td align="center">ZSCAN key cursor [MATCH pattern] [COUNT count]</td><td align="left">迭代有序集合中的元素（包括元素成员和元素分值）</td></tr></tbody></table><p>set 排序 存储班级成绩表 工资表排序<br>消息的权重<br>排行榜应用实现 取 TOP N</p><h2 id="三种特殊数据类型"><a href="#三种特殊数据类型" class="headerlink" title="三种特殊数据类型"></a>三种特殊数据类型</h2><h3 id="geospatial-地理位置"><a href="#geospatial-地理位置" class="headerlink" title="geospatial(地理位置)"></a>geospatial(地理位置)</h3><p>朋友定位，附近的人，打车距离计算</p><p>Redis的Geo可以推算地理位置的信息，两地之间的距离，方圆几里的人</p><table><thead><tr><th align="center">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">GEOADD key longitude latitude member <br /> [longitude latitude member …]</td><td align="left">将指定的地理空间位置（经度，维度，名称）添加到指定的key中</td></tr><tr><td align="center">GEODIST key member1 member2 [unit]</td><td align="left">返回两个给定位置之间的距离。</td></tr><tr><td align="center">GEOPOS key member [member …]</td><td align="left">从key里返回所有指定名称元素的位置（经度，纬度）。</td></tr><tr><td align="center">GEOHASH key member [member …]</td><td align="left">返回一个或多个位置元素的 Geohash 表示。</td></tr><tr><td align="center">GEORADIUS key longitude latitude radius                            <br />       [WITHCOORD][WITHDIST][WITHHASH][COUNT count]</td><td align="left">以给定的经纬度为中心， 返回键包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素。</td></tr><tr><td align="center">GEORADIUSBYMEMBER key member radius <br /> [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count]</td><td align="left">以给定的元素找出位于指定范围内的元素</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 规则：两级无法直接添加，一般会下载城市数据，直接通过java程序一次性导入</span></span><br><span class="line"><span class="comment"># 添加地理空间位置（经度，维度，名称）到key中</span></span><br><span class="line">redis&gt; GEOADD Sicily 13.361389 38.115556 <span class="string">&quot;Palermo&quot;</span> 15.087269 37.502669 <span class="string">&quot;Catania&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"><span class="comment"># 查看指定位置之间的距离 m|km|mi|ft</span></span><br><span class="line"><span class="comment"># 如果两个位置之间的其中一个不存在， 那么命令返回空值</span></span><br><span class="line"><span class="comment"># m 米（默认单位）</span></span><br><span class="line"><span class="comment"># km 千米</span></span><br><span class="line"><span class="comment"># mi 英里</span></span><br><span class="line"><span class="comment"># ft 英尺</span></span><br><span class="line">redis&gt; GEODIST Sicily Palermo Catania</span><br><span class="line"><span class="string">&quot;166274.15156960039&quot;</span></span><br><span class="line"><span class="comment"># 以给定位置为中心指定半径中的所有位置 m|km|mi|ft</span></span><br><span class="line">redis&gt; GEORADIUS Sicily 15 37 100 km</span><br><span class="line">1) <span class="string">&quot;Catania&quot;</span></span><br><span class="line">redis&gt; GEORADIUS Sicily 15 37 200 km</span><br><span class="line">1) <span class="string">&quot;Palermo&quot;</span></span><br><span class="line">2) <span class="string">&quot;Catania&quot;</span></span><br><span class="line"><span class="comment"># 获取key中指定名称的位置（经度，维度）</span></span><br><span class="line">redis&gt; GEOPOS Sicily Palermo Catania NonExisting</span><br><span class="line">1) 1) <span class="string">&quot;13.361389338970184&quot;</span></span><br><span class="line">   2) <span class="string">&quot;38.115556395496299&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;15.087267458438873&quot;</span></span><br><span class="line">   2) <span class="string">&quot;37.50266842333162&quot;</span></span><br><span class="line">3) (nil)</span><br><span class="line"><span class="comment"># 返回指定元素附近位置 m|km|mi|ft</span></span><br><span class="line">redis&gt; GEOADD Sicily 13.361389 38.115556 <span class="string">&quot;Palermo&quot;</span> 15.087269 37.502669 <span class="string">&quot;Catania&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis&gt; GEORADIUSBYMEMBER Sicily Agrigento 100 km</span><br><span class="line">1) <span class="string">&quot;Agrigento&quot;</span></span><br><span class="line">2) <span class="string">&quot;Palermo&quot;</span></span><br><span class="line"><span class="comment"># 返回Geohash表示</span></span><br><span class="line">redis&gt; GEOHASH Sicily Palermo Catania</span><br><span class="line">1) <span class="string">&quot;sqc8b49rny0&quot;</span></span><br><span class="line">2) <span class="string">&quot;sqdtr74hyu0&quot;</span></span><br></pre></td></tr></table></figure><h4 id="Geo底层原理其实就是Zset，可以使用Zset命令操作Geo"><a href="#Geo底层原理其实就是Zset，可以使用Zset命令操作Geo" class="headerlink" title="Geo底层原理其实就是Zset，可以使用Zset命令操作Geo"></a>Geo底层原理其实就是Zset，可以使用Zset命令操作Geo</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GEOADD Sicily 13.361389 38.115556 <span class="string">&quot;Palermo&quot;</span> 15.087269 37.502669 <span class="string">&quot;Catania&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"><span class="comment"># 查看地图中所有元素</span></span><br><span class="line">127.0.0.1:6379&gt; zrange Sicily 0 -1</span><br><span class="line">1) <span class="string">&quot;Palermo&quot;</span></span><br><span class="line">2) <span class="string">&quot;Catania&quot;</span></span><br><span class="line"><span class="comment"># 移除指定元素</span></span><br><span class="line">127.0.0.1:6379&gt; zrem Sicily <span class="string">&quot;Palermo&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange Sicily 0 -1</span><br><span class="line">1) <span class="string">&quot;Catania&quot;</span></span><br></pre></td></tr></table></figure><h3 id="HyperLogLog-基数统计算法"><a href="#HyperLogLog-基数统计算法" class="headerlink" title="HyperLogLog(基数统计算法)"></a>HyperLogLog(基数统计算法)</h3><h4 id="基数"><a href="#基数" class="headerlink" title="基数"></a>基数</h4><p>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p><p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p><p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p><h5 id="实用：网站的UV-网站访问量-PV-页面访问量"><a href="#实用：网站的UV-网站访问量-PV-页面访问量" class="headerlink" title="实用：网站的UV(网站访问量),PV(页面访问量)"></a>实用：网站的UV(网站访问量),PV(页面访问量)</h5><p>传统的方式：使用set保留用户id，计算set中的元素数量作为判断<br>这个方式如果保留大量的用户id，就会比较麻烦。浪费空间</p><p>Redis的HyperLogLog：空间消耗低。0.81%错误率。在UV中可以忽略不计</p><p>允许容错，就使用HyperLogLog<br>不允许容错，就是用set</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><table><thead><tr><th align="center">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">PFADD key element [element …]</td><td align="left">添加指定元素到 HyperLogLog 中。</td></tr><tr><td align="center">PFCOUNT key [key …]</td><td align="left">返回给定 HyperLogLog 的基数估算值。</td></tr><tr><td align="center">PFMERGE destkey sourcekey [sourcekey …]</td><td align="left">将多个 HyperLogLog 合并为一个 HyperLogLog</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加指定元素到HyperLogLog中</span></span><br><span class="line">127.0.0.1:6379&gt; pfadd key a b c a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># 返回HyperLogLog的基数估算值</span></span><br><span class="line">127.0.0.1:6379&gt; pfcount key</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; pfadd key1 c d</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount key1</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"><span class="comment"># 将多个HyperLogLog合并为一个HyperLogLog</span></span><br><span class="line">127.0.0.1:6379&gt; pfmerge key key1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; pfcount key</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br></pre></td></tr></table></figure><h3 id="Bitmaps-位图"><a href="#Bitmaps-位图" class="headerlink" title="Bitmaps(位图)"></a>Bitmaps(位图)</h3><p>位存储<br>统计用户信息，活跃/不活跃，登录/未登录，打卡（两个状态）</p><p>Bitmaps 位图，数据结构。都是操作二进制位来记录，就只有0和1两个状态</p><table><thead><tr><th align="center">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">SETBIT key offset value</td><td align="left">设置key指定偏移量上的位</td></tr><tr><td align="center">GETBIT key offset</td><td align="left">获取key指定偏移量上的位</td></tr><tr><td align="center">BITCOUNT key [start end]</td><td align="left">获取key指定区间的1数量</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置key指定偏移量上的位</span></span><br><span class="line">127.0.0.1:6379&gt; setbit key 0 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"><span class="comment"># 获取key指定偏移量上的位</span></span><br><span class="line">127.0.0.1:6379&gt; getbit key 0</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit key 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit key 1 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"><span class="comment"># 获取区间内的1数量</span></span><br><span class="line">127.0.0.1:6379&gt; bitcount key</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ul><li><p><a href="https://www.redis.net.cn/">Redis中文网</a></p></li><li><p><a href="http://www.redis.cn/">Redis中文官网</a></p></li><li><p><a href="https://www.bilibili.com/video/BV1S54y1R7SB?p=27">【狂神说Java】Redis最新超详细版教程通俗易懂</a></p></li></ul></blockquote><a class="btn-beautify button--animated block blue right" href="https://www.shiming.online/blog/62112/"   title="Redis持久化"><i class="far fa-hand-point-right fa-fw"></i><span>Redis持久化</span></a>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NoSQL </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis缓存穿透，缓存击穿和雪崩</title>
      <link href="blog/48573/"/>
      <url>blog/48573/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透是指查询一个不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存。这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。</p><h3 id="穿透解决方案"><a href="#穿透解决方案" class="headerlink" title="穿透解决方案"></a>穿透解决方案</h3><ul><li>布隆过滤器<br> 布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先校验，不符合则丢弃，从而避免对底层查询系统的压力</li><li>缓存空对象<br> 在存储不命中后，即便返回的空对象也将其缓存起来，同时设置一个过期时间，之后访问这个数据会从缓存中获取，保护后端数据源<br> 但是这种方法存在两个问题：<ol><li>如果空值能够被缓存，意味着缓存需要更多的空间存储更多的键，因为其中可能有很多空值的键</li><li>即便对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间的不一致，对于保持一致性的业务可能有影响</li></ol></li></ul><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一key缓存，后者则是很多key。</p><p>缓存在某个时间点过期的时候，恰好在这个时间间隔对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p><h3 id="击穿解决方案"><a href="#击穿解决方案" class="headerlink" title="击穿解决方案"></a>击穿解决方案</h3><ul><li>设置热点数据永不过期<ol><li>从redis上看，确实没有设置过期时间，这就保证了，不会出现热点key过期问题，也就是“物理”不过期。</li><li>从功能上看，如果不过期，那不就成静态的了吗？所以我们把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建，也就是“逻辑”过期</li></ol></li><li>加互斥锁<br>分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，只能等待。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。</li><li>提前使用互斥锁<br>在value内部设置1个超时值(timeout1), timeout1比实际的memcache timeout(timeout2)小。当从cache读取到timeout1发现它已经过期时候，马上延长timeout1并重新设置到cache。然后再从数据库加载数据并设置到cache中。</li><li>资源保护<br>采用netflix的hystrix，可以做资源的隔离保护主线程池。</li></ul><table><thead><tr><th align="center">解决方案</th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">简单分布式互斥锁（mutex key）</td><td align="center">思路简单。 保证一致性</td><td align="center">代码复杂度增大。存在死锁的风险。存在线程池阻塞的风险            。</td></tr><tr><td align="center">“提前”使用互斥锁</td><td align="center">保证一致性</td><td align="center">同上</td></tr><tr><td align="center">不过期</td><td align="center">异步构建缓存。不会阻塞线程池</td><td align="center">不保证一致性 。代码复杂度增大(每个value都要维护一个timekey)。 占用一定的内存空间(每个value都要维护一个timekey)。</td></tr><tr><td align="center">资源隔离组件hystrix</td><td align="center">hystrix技术成熟，有效保证后端。  hystrix监控强大。</td><td align="center">部分访问存在降级策略。</td></tr></tbody></table><h2 id="雪崩"><a href="#雪崩" class="headerlink" title="雪崩"></a>雪崩</h2><p>缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。</p><h3 id="雪崩解决方案"><a href="#雪崩解决方案" class="headerlink" title="雪崩解决方案"></a>雪崩解决方案</h3><ul><li>Redis高可用<br>增设服务器，搭建集群</li><li>降级限流<br>在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。</li><li>数据预热<br>在正式部署前，将可能访问的数据先访问一遍，将大部分可能访问的数据加载在缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的失效时间，让缓存失效的时间点尽量均匀</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ul><li><p><a href="https://www.bilibili.com/video/BV1S54y1R7SB?p=28">【狂神说Java】Redis最新超详细版教程通俗易懂</a></p></li><li><p><a href="https://blog.csdn.net/zeb_perfect/article/details/54135506">缓存穿透，缓存击穿，缓存雪崩解决方案分析</a></p></li><li><p><a href="https://blog.csdn.net/fcvtb/article/details/89478554">【面试】redis缓存穿透、缓存击穿、缓存雪崩区别和解决方案</a></p></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NoSQL </tag>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis持久化</title>
      <link href="blog/62112/"/>
      <url>blog/62112/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>持久化的功能：Redis是内存数据库，数据都是存储在内存中，为了避免进程退出导致数据的永久丢失，需要定期将Redis中的数据以某种形式(数据或命令)从内存保存到硬盘；当下次Redis重启时，利用持久化文件实现数据恢复。除此之外，为了进行灾难备份，可以将持久化文件拷贝到一个远程位置。</p><p>Redis持久化分为<strong>RDB持久化和AOF持久化:前者将当前数据保存到硬盘，后者则是将每次执行的写命令保存到硬盘</strong>；由于AOF持久化的实时性更好，即当进程意外退出时丢失的数据更少，因此AOF是目前主流的持久化方式，不过RDB持久化仍然有其用武之地</p><h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><p>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。也是默认的持久化方式，这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump.rdb。当Redis重新启动时，可以读取快照文件恢复数据。</p><h3 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h3><p>对RDB来说，有手动触发和自动触发两种情况</p><h4 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h4><p>手动触发对应save和bgsave命令，两者都会生成RDB文件</p><ol><li><p>save<br>save命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在Redis服务器阻塞期间，服务器不能处理任何命令请求。<br>执行完成时候如果存在老的RDB文件，就把新的替代掉旧的。</p></li><li><p>bgsave<br>执行该命令时，Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。具体操作是Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。</p></li></ol><p>bgsave命令执行过程中，只有fork子进程时会阻塞服务器，而对于save命令，整个过程都会阻塞服务器，因此save已基本被废弃。此外，在自动触发RDB持久化时，Redis也会选择bgsave而不是save来进行持久化。</p><h4 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h4><p><code>save m n</code>表示m秒内数据集存在n次修改时，自动触发bgsave</p><p>配置文件如下：<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200807222806.png" alt="20200807222806"></p><p>触发机制：</p><ol><li>满足save的规则时，会自动触发RDB</li><li>从节点执行全量复制操作，主节点自动执行bgsave生成RDB文件并发送给子节点</li><li>执行debug reload命令重新加载Redis时，也会自动触发save操作。</li><li>执行flushall命令，也会生成rdb文件，但里面是空的</li><li>退出redis，也会产生rdb文件<br>备份就自动生成dump.rdb文件</li></ol><p><em>如果想关闭自动RDB持久化，在配置文件删除<code>save m n</code>的配置即可</em></p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>图片来自<a href="https://www.yisu.com/zixun/244053.html">学习Redis持久化</a><br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200807222816.png" alt="20200807222816"></p><ol><li>执行bgsave命令，Redis父进程判断当前是否存在正在执行的子进程，如RDB/AOF子进程，如果存在bgsave命令直接返回。主要是基于性能方面的考虑：两个并发的子进程同时执行大量的磁盘写操作，可能引起严重的性能问题。</li><li>父进程执行fork操作创建子进程，fork操作过程中父进程会阻塞，通过info stats命令查看latest_fork_usec选项，可以获取最近一个fork操作的耗时，单位为微秒。</li><li>父进程fork完成后，bgsave命令返回”Background saving started”信息并不再阻塞父进程，可以继续响应其他命令。</li><li>子进程创建RDB文件，根据父进程内存生成临时快照文件，完成对原有文件执行原子替换。执行lastsave命令可以获取最后一次生成RDB的时间，对应info统计的rdb_last_save_time选项。</li><li>进程发送信号给父进程表示完成，父进程更新统计信息，</li></ol><h3 id="恢复数据"><a href="#恢复数据" class="headerlink" title="恢复数据"></a>恢复数据</h3><ol><li><p>将rdb文件放在redis启动目录，，redis启动时会自动检查dump.rdb恢复其中的数据</p></li><li><p>查看需要存在的位置</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get dir</span><br><span class="line">1) <span class="string">&quot;dir&quot;</span></span><br><span class="line">2) <span class="string">&quot;/Redis&quot;</span></span><br><span class="line"><span class="comment"># 如果在这个目录下存在dump.rdb文件，启动就会自动恢复其中数据</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="RDB优缺点"><a href="#RDB优缺点" class="headerlink" title="RDB优缺点"></a>RDB优缺点</h3><ol><li><p>优点</p><ol><li>RDB是一个紧凑的二进制文件，它保存了redis 在某个时间点上的数据集。这种文件非常适合用于进行备份和灾难恢复。</li><li>生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。</li><li>RDB 在恢复大数据集的速度比 AOF 的恢复速度要快。</li></ol></li><li><p>缺点</p><ol><li>RDB方式数据没办法做到实时持久化/秒级持久化。因为bgsave每次运行都要执行fork操作创建子进程，属于重量级操作，如果不采用压缩算法(内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑)，频繁执行成本过高(影响性能)</li><li>RDB文件使用特定二进制格式保存，Redis版本演进过程中有多个格式的RDB版本，存在老版本Redis服务无法兼容新版RDB格式的问题(版本不兼容)</li><li>在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改(数据有丢失)</li></ol></li></ol><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li>数据备份</li><li>可容忍部分数据丢失</li><li>跨数据中心的容灾备份</li></ol><h2 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h2><p>RDB持久化是将进程数据写入文件，而AOF持久化(即Append Only File持久化)，则是将Redis执行的每次写命令记录到单独的日志文件中；当Redis重启时再次执行AOF文件中的命令来恢复数据。</p><p>与RDB相比，AOF的实时性更好，因此已成为主流的持久化方案。</p><p>配置文件如下<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200807222825.png" alt="20200807222825"><br>默认不开启，将appendonly 改为yes就开启了aof。<br>默认文件名是appendonly.aof。保存路径同RDB持久化方式一致。<br>如果aof文件有错位，这是redis是无法启动的，需要修改这个aof文件才能正常启动<br>redis提供了一个工具<code>redis-check-aof --fix</code>进行修复</p><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p>由于需要记录Redis的每条写命令，因此AOF不需要触发，<br>AOF的执行流程包括：</p><ul><li>命令追加(append)：将Redis的写命令追加到缓冲区aof_buf；</li><li>文件写入(write)和文件同步(sync)：根据不同的同步策略将aof_buf中的内容同步到硬盘；</li><li>文件重写(rewrite)：定期重写AOF文件，达到压缩的目的。</li></ul><h4 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h4><p>Redis先将写命令追加到缓冲区，而不是直接写入文件，主要是为了避免每次有写命令都直接写入硬盘，导致硬盘IO成为Redis负载的瓶颈。</p><p>命令追加的格式是Redis命令请求的协议格式，它是一种纯文本格式，具有兼容性好、可读性强、容易处理、操作简单避免二次开销等优点；具体格式略。在AOF文件中，除了用于指定数据库的select命令（如select 0 为选中0号数据库）是由Redis添加的，其他都是客户端发送来的写命令。</p><h4 id="文件写入和文件同步"><a href="#文件写入和文件同步" class="headerlink" title="文件写入和文件同步"></a>文件写入和文件同步</h4><p>Redis提供了多种AOF缓冲区同步文件策略，由参数appendfsync控制。</p><p>说明：<br>为了提高文件写入效率，在现代操作系统中，当用户调用write函数将数据写入文件时，操作系统通常会将数据暂存到一个内存缓冲区里，当缓冲区被填满或超过了指定时限后，才真正将缓冲区的数据写入到硬盘里。<br>这样的操作虽然提高了效率，但也带来了安全问题：如果计算机停机，内存缓冲区中的数据会丢失；因此系统同时提供了fsync、fdatasync等同步函数，可以强制操作系统立刻将缓冲区中的数据写入到硬盘里，从而确保数据的安全性</p><p>不同的含义：</p><ul><li>always：命令写入aof_buf后调用系统fsync操作同步到AOF文件，fsync完成后线程返回</li><li>no：命令写入aof_buf后调用系统write操作，不对AOF文件做fsync同步，同步硬盘操作由操作系统负责，通常同步周期最长30秒</li><li>everysec：命令写入aof_buf后调用系统write操作，write完成后线程返回。fsync同步文件操作由专门线程每秒调用一次。<br>everysec是前述两种策略的折中，是性能和数据安全性的平衡，因此是Redis的默认配置。</li></ul><h4 id="文件重写"><a href="#文件重写" class="headerlink" title="文件重写"></a>文件重写</h4><p>AOF采用文件追加方式，文件会越来越大。为避免出现此种情况，新增了重写机制,当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。<br>文件重写是指定期重写AOF文件，减小AOF文件的体积。需要注意的是，AOF重写是把Redis进程内的数据转化为写命令，同步到新的AOF文件；不会对旧的AOF文件进行任何读取、写入操作。</p><p>重写后的AOF文件为什么可以变小？有如下原因：</p><ol><li>进程内已经超时的数据不再写入文件</li><li>旧的AOF文件含有有效命令，如del key1、hdel key2、srem keys、set a111、set a222等。重写使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令。</li><li>多条写命令可以合并为一下，如：lpush list a、lpush list b、lpush list c可以转化为:lpush list a b c。为了防止单条命令过大造成客户端缓冲区溢出，对于list、set、hash、zset等类型操作，以64个元素为界拆分为多条。</li></ol><p>AOF重写降低了文件占用空间，除此之外，另一个目的是：更小的AOF文件可以更快被Redis加载。</p><h5 id="文件重写的触发机制"><a href="#文件重写的触发机制" class="headerlink" title="文件重写的触发机制"></a>文件重写的触发机制</h5><p>AOF重写过程可以手动触发和自动触发。</p><p>手动触发：直接调用bgrewriteaof命令，该命令的执行与bgsave有些类似：都是fork子进程进行具体的工作，且都只有在fork时阻塞。<br>自动触发：根据auto-aof-rewrite-min-size和auto-aof-rewrite-percentage参数确定自动触发时机</p><ul><li>auto-aof-rewrite-min-size：表示运行AOF重写时文件最小体积，默认 为64MB。</li><li>auto-aof-rewrite-percentage：代表当前AOF文件空间 （aof_current_size）和上一次重写后AOF文件空间（aof_base_size）的比值。</li></ul><p>自动触发时机：aof_current_size &gt; auto-aof-rewrite-minsize &amp;&amp;（aof_current_size-aof_base_size）/ aof_base_size &gt;= auto-aof-rewritepercentage</p><p>其中aof_current_size和aof_base_size可以在info Persistence统计信息中查看</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200807222836.png" alt="20200807222836"></p><h4 id="AOF优缺点"><a href="#AOF优缺点" class="headerlink" title="AOF优缺点"></a>AOF优缺点</h4><p>优点：</p><ol><li>备份机制更稳健，丢失数据概率更低</li><li>可读的日志文本，通过操作AOF稳健，可以处理误操作。</li><li>AOF日志文件没有任何磁盘寻址的开销，写入性能非常高，文件不容易破损。</li></ol><p>缺点：</p><ol><li>比起RDB更占用磁盘空间。</li><li>回复备份的速度慢。</li><li>每次读写同步的话，有一定的性能压力。</li><li>存在BUG，可能不能完全恢复一摸一样的数据。</li></ol><h3 id="RDB和AOF同时开启"><a href="#RDB和AOF同时开启" class="headerlink" title="RDB和AOF同时开启"></a>RDB和AOF同时开启</h3><p>RDB和AOF同时开启时，逻辑如下<br>图片来自<a href="https://www.cnblogs.com/zero-vic/p/13386676.html#autoid-2-3-0">redis之持久化</a><br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200807222851.png" alt="20200807222851"></p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><blockquote><ul><li><p><a href="https://www.cnblogs.com/zero-vic/p/13386676.html#autoid-0-0-0">redis之持久化</a></p></li><li><p><a href="https://www.yisu.com/zixun/244053.html">学习redis持久化</a></p></li><li><p><a href="https://www.cnblogs.com/kismetv/p/9137897.html#t1">深入学习redis</a></p></li><li><p><a href="https://www.bilibili.com/video/BV1S54y1R7SB?p=28">【狂神说Java】Redis最新超详细版教程通俗易懂</a></p></li></ul></blockquote><a class="btn-beautify button--animated block blue right" href="https://www.shiming.online/blog/48573/"   title="Redis三大问题"><i class="far fa-hand-point-right fa-fw"></i><span>Redis三大问题</span></a>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NoSQL </tag>
            
            <tag> Redis </tag>
            
            <tag> 持久化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="blog/27273/"/>
      <url>blog/27273/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="NoSQL介绍"><a href="#NoSQL介绍" class="headerlink" title="NoSQL介绍"></a>NoSQL介绍</h2><blockquote><p>NoSQL = Not Only SQL</p></blockquote><h3 id="为什么使用NoSQL"><a href="#为什么使用NoSQL" class="headerlink" title="为什么使用NoSQL"></a>为什么使用NoSQL</h3><p>关系型数据库：表格，行，列<br>随着互联网的高速发展，传统的关系型数据库在应付超大规模，超大流量以及高并发的时候力不从心</p><h4 id="大数据时代的3V和3高"><a href="#大数据时代的3V和3高" class="headerlink" title="大数据时代的3V和3高"></a>大数据时代的3V和3高</h4><ul><li>大数据3V(问题)<ul><li>海量Volume</li><li>多样Variety</li><li>实时Velocity</li></ul></li><li>互联网3高(性能)<ul><li>高并发</li><li>高可拓</li><li>高性能</li></ul></li></ul><a id="more"></a><h3 id="NoSQL特点"><a href="#NoSQL特点" class="headerlink" title="NoSQL特点"></a>NoSQL特点</h3><ol><li>方便扩展（数据之间没有关系）</li><li>快速读写（Redis一秒写8万次，读取11万次）</li><li>成本低廉（大部分分布式数据库都是开源）</li><li>数据类型是多样型的（不需要事先设计数据库）</li><li>传统的RDBMS和NoSQL<ul><li>传统的 RDBMS（关系型数据库管理系统）<ul><li>结构化组织</li><li>SQL</li><li>数据和关系都在单独的表中</li><li>严格的一致性</li><li>基础的事务</li><li>。。。。。。</li></ul></li><li>NoSQL<ul><li>不仅仅是数据</li><li>没有固定的查询语言</li><li>键值对存储，列存储，文档存储，图形数据库（社交关系）</li><li>最终一致性</li><li>CAP定理和BASE（异地多活）</li><li>高性能，高可用，高可扩</li><li>。。。。。。</li></ul></li></ul></li></ol><h3 id="NoSQL类型"><a href="#NoSQL类型" class="headerlink" title="NoSQL类型"></a>NoSQL类型</h3><h4 id="KV键值对"><a href="#KV键值对" class="headerlink" title="KV键值对"></a>KV键值对</h4><ul><li>新浪：Redis</li><li>美团：Redis+Tair</li><li>阿里，百度：Redis+memecache</li></ul><h4 id="文档型数据库"><a href="#文档型数据库" class="headerlink" title="文档型数据库"></a>文档型数据库</h4><ul><li>MongoDB<ul><li>MongoDB是一个基于分布式文件存储的数据库，C++编写，主要用来处理大量的文档</li><li>MongoDB是一个介于关系型数据库和非关系型数据库中中间的产品，MongoDB是非关系型数据库中功能最丰富，最像关系型数据库</li></ul></li><li>ConthDB</li></ul><h4 id="列存储数据库"><a href="#列存储数据库" class="headerlink" title="列存储数据库"></a>列存储数据库</h4><ul><li>HBase</li><li>分布式文件系统</li></ul><h4 id="图形关系数据"><a href="#图形关系数据" class="headerlink" title="图形关系数据"></a>图形关系数据</h4><p>社交关系，拓扑图</p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>缓存就是数据交换的缓冲区(又称作Cache)，当某一硬件要读取数据时，会首先从缓存中查找需要的数据，找到了则直接执行，找不到的话则从内存中查找。由于缓存的运行速度比内存快得多，故缓存的作用就是帮助硬件更快地运行。</p><p>因为缓存往往使用的是RAM(断电即掉的非永久性储存)，所以在用完后还是会把文件送到硬盘等存储器里永久存储。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Redis(REmote DIctionary Server) 远程字典服务是一个由Salvatore Sanfilippo写的key-value存储系统。<br>Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。<br>Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave（主从同步）。<br>它通常也被称为数据结构服务器</p><h4 id="Redis能做什么"><a href="#Redis能做什么" class="headerlink" title="Redis能做什么"></a>Redis能做什么</h4><ol><li>内存存储，持久化，内存中是断电即失，所以持久化很重要（rdb，aof）</li><li>效率高，可以用于告诉缓存</li><li>发布订阅系统</li><li>地图信息分析</li><li>计时器，计数器（浏览量）</li><li>。。。。。。</li></ol><h3 id="Redis基础知识"><a href="#Redis基础知识" class="headerlink" title="Redis基础知识"></a>Redis基础知识</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换数据库（Redis默认有16个数据库）</span></span><br><span class="line">127.0.0.1:6379&gt; select 3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有key</span></span><br><span class="line">127.0.0.1:6379[3]&gt; keys *</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清空数据库</span></span><br><span class="line">127.0.0.1:6379[3]&gt; flushdb</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清空全部数据库</span></span><br><span class="line">127.0.0.1:6379[3]&gt; flushall</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>Redis是单线程的<br>官方表示，Redis是基于内存操作，CPU不是Redis性能瓶颈，Redis的瓶颈是机器的内存和网络带宽。既然可以使用单线程，就是用单线程了。</p><h4 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h4><ol><li>高性能的服务器一定是多线程的</li><li>多线程（CPU上下文会切换）一定会比单线程快</li></ol><p>核心：Redis是将所有的数据全部存放在内存中，所以使用单线程去操作效率就是最高的，多线程（CPU会上下文切换：耗时），对于内存系统来说，如果没有上下文切换效率就是最高。</p><h3 id="Redis-Key命令"><a href="#Redis-Key命令" class="headerlink" title="Redis-Key命令"></a>Redis-Key命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置键值对</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> 1 test1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> 2 test2</span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 查询所有key</span></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;2&quot;</span></span><br><span class="line">2) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="comment"># 判断key是否存在</span></span><br><span class="line">127.0.0.1:6379&gt; exists 1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; exists 3</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"><span class="comment"># 移动key到指定数据库</span></span><br><span class="line">127.0.0.1:6379&gt; move 1 1</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="comment"># 设置key过期时间</span></span><br><span class="line">127.0.0.1:6379&gt; expire 2 10</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># 查询key剩余时间</span></span><br><span class="line">127.0.0.1:6379&gt; ttl 2</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; ttl 2</span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br><span class="line"><span class="comment"># 查看key的类型</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> 1</span><br><span class="line">string</span><br></pre></td></tr></table></figure><p><a href="https://www.redis.net.cn/order/">Redis中文网文档</a></p><h3 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h3><p>Redis事务本质：一组命令的集合。一个事务中的所有命令都会被序列化，在事务执行过程中，会按照顺序执行。<br>一次性，顺序性，排他性</p><p><strong>Redis事务没有隔离级别的概念。</strong><br>所有的命令在事务中，并没有被直接执行。只有发起执行命令的时候才会执行。</p><p><strong>Redis单条命令保证原子性，但是事务不保证原子性。</strong></p><p>Redis事务：</p><ul><li>开启事务(multi)</li><li>命令入队()</li><li>执行事务(exec)</li></ul><table><thead><tr><th align="center">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">MULTI</td><td align="left">标记一个事务块的开始</td></tr><tr><td align="center">EXEC</td><td align="left">执行所有事务块内的命令</td></tr><tr><td align="center">DISCARD</td><td align="left">取消事务，放弃执行事务块内的所有命令</td></tr><tr><td align="center">WATCH key [key …]</td><td align="left">监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断(<strong>乐观锁</strong>)</td></tr><tr><td align="center">UNWATCH</td><td align="left">取消 WATCH 命令对所有 key 的监视</td></tr></tbody></table><h4 id="正常执行事务"><a href="#正常执行事务" class="headerlink" title="正常执行事务"></a>正常执行事务</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启事务</span></span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 命令入队</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line"><span class="comment"># 执行事务</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">1) OK</span><br><span class="line">2) <span class="string">&quot;v1&quot;</span></span><br><span class="line">3) OK</span><br></pre></td></tr></table></figure><h4 id="放弃事务"><a href="#放弃事务" class="headerlink" title="放弃事务"></a>放弃事务</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启事务</span></span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 命令入队</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k4 v4</span><br><span class="line">QUEUED</span><br><span class="line"><span class="comment"># 放弃事务</span></span><br><span class="line">127.0.0.1:6379&gt; discard</span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 事务中的命令都不执行</span></span><br><span class="line">127.0.0.1:6379&gt; get k4</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h4 id="执行事务出错"><a href="#执行事务出错" class="headerlink" title="执行事务出错"></a>执行事务出错</h4><h5 id="编译型异常"><a href="#编译型异常" class="headerlink" title="编译型异常"></a>编译型异常</h5><p><strong>代码错误,事务中所有命令都不执行。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line"><span class="comment"># 错误命令</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k3</span><br><span class="line">(error) ERR wrong number of arguments <span class="keyword">for</span> <span class="string">&#x27;set&#x27;</span> <span class="built_in">command</span></span><br><span class="line"><span class="comment"># 执行事务报错</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br><span class="line"><span class="comment"># 事务中所有命令都不执行</span></span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h5 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h5><p><strong>如果事务队列中存在语法性错误,那么执行命令的时候,其他命令都是可以正常执行的,错误命令抛出。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 <span class="string">&quot;v1&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="comment"># 错误命令</span></span><br><span class="line">127.0.0.1:6379&gt; incr k1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line"><span class="comment"># 错误命令抛出，其余命令正常执行</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">1) OK</span><br><span class="line">2) (error) ERR value is not an <span class="built_in">integer</span> or out of range</span><br><span class="line">3) OK</span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line"><span class="string">&quot;v2&quot;</span></span><br></pre></td></tr></table></figure><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>Redis可以用watch代替java中的乐观锁</p><h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark [option] [option value]</span><br></pre></td></tr></table></figure><p>可选参数：</p><blockquote><p>来自Redis中文网</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200807222751.png" alt="参数"></p><h3 id="整合SpringBoot"><a href="#整合SpringBoot" class="headerlink" title="整合SpringBoot"></a>整合SpringBoot</h3><p>SpringBoot操作数据：Spring-data jpa jdbc mongodb redis</p><p>说明：在SpringBoot2.x之后，原来使用的jedis被替换为了lettuce<br>jdis：采用直连，多个线程操作的话是不安全的，可使用jdis pool连接池避免安全问题。更像BIO模式<br>lettuce：采用netty，实例可以在多个线程中进行共享，不存在线程不安全的情况。可以减少线程数据，更像NIO模式</p><h4 id="RedisTemplate系统配置"><a href="#RedisTemplate系统配置" class="headerlink" title="RedisTemplate系统配置"></a>RedisTemplate系统配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="comment">// 可用自定义配置类替换</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(</span></span><br><span class="line"><span class="meta">    name = &#123;&quot;redisTemplate&quot;&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">  <span class="comment">// 默认的RedisTemplate没有过多配置，redis对象都需要序列化</span></span><br><span class="line">  <span class="comment">// 两个泛型都是ObjecT类型，使用时需要前置转换</span></span><br><span class="line">    RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> RedisTemplate();</span><br><span class="line">    template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="keyword">public</span> StringRedisTemplate stringRedisTemplate</span><br><span class="line"><span class="comment">// 单独提出来的String类型Bean</span></span><br><span class="line">(RedisConnectionFactory redisConnectionFactory) <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">    StringRedisTemplate template = <span class="keyword">new</span> StringRedisTemplate();</span><br><span class="line">    template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>导入依赖</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 支持lettuce --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#redis 配置</span></span><br><span class="line"><span class="meta">spring.redis.database</span>=<span class="string">0</span></span><br><span class="line"><span class="comment"># Redis服务器地址</span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="comment"># Redis服务器连接端口</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="comment"># Redis服务器连接密码（默认为空）</span></span><br><span class="line"><span class="comment">#spring.redis.password=123456</span></span><br><span class="line"><span class="comment"># 连接池最大连接数（使用负值表示没有限制） 默认 8</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-active</span>=<span class="string">10</span></span><br><span class="line"><span class="comment"># 连接池最大阻塞等待时间（使用负值表示没有限制） 默认 -1</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-wait</span>=<span class="string">-1</span></span><br><span class="line"><span class="comment"># 连接池中的最大空闲连接 默认 8</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-idle</span>=<span class="string">5</span></span><br><span class="line"><span class="comment"># 连接池中的最小空闲连接 默认 0</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.min-idle</span>=<span class="string">1</span></span><br><span class="line"><span class="comment"># 连接超时时间（毫秒）</span></span><br><span class="line"><span class="meta">spring.redis.timeout</span>=<span class="string">3000</span></span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redisTemplate.opsForValue();<span class="comment">//操作字符串</span></span><br><span class="line">redisTemplate.opsForHash();<span class="comment">//操作hash</span></span><br><span class="line">redisTemplate.opsForList();<span class="comment">//操作list</span></span><br><span class="line">redisTemplate.opsForSet();<span class="comment">//操作set</span></span><br><span class="line">redisTemplate.opsForZSet();<span class="comment">//操作有序set</span></span><br></pre></td></tr></table></figure><p>操作与命令行操作一致</p><h5 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h5><blockquote><ul><li>来自<a href="https://www.bilibili.com/video/BV1S54y1R7SB?p=28">【狂神说Java】Redis最新超详细版教程通俗易懂</a></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">      RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;String, Object&gt;();</span><br><span class="line">      template.setConnectionFactory(factory);</span><br><span class="line">      Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">      ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">      om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">      om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">      jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">      StringRedisSerializer stringRedisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// key采用String的序列化方式</span></span><br><span class="line">      template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">      <span class="comment">// hash的key也采用String的序列化方式</span></span><br><span class="line">      template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">      <span class="comment">// value序列化方式采用jackson</span></span><br><span class="line">      template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">      <span class="comment">// hash的value序列化方式采用jackson</span></span><br><span class="line">      template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">      template.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> template;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ul><li><a href="https://www.bilibili.com/video/BV1S54y1R7SB">【狂神说Java】Redis最新超详细版教程通俗易懂</a></li><li><a href="https://www.redis.net.cn/">redis中文网</a></li></ul></blockquote><a class="btn-beautify button--animated block blue right" href="https://www.shiming.online/blog/6834/"   title="Redis数据类型"><i class="far fa-hand-point-right fa-fw"></i><span>Redis数据类型</span></a>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NoSQL </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常</title>
      <link href="blog/4876/"/>
      <url>blog/4876/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="异常处理的作用"><a href="#异常处理的作用" class="headerlink" title="异常处理的作用"></a>异常处理的作用</h2><ul><li>向用户通报错误</li><li>返回到一个安全的状态，并能执行一些命令</li><li>保存所有工作结果，并以妥善的方式退出</li></ul><h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><ul><li>输入错误</li><li>设备错误</li><li>物理限制</li><li>代码错误</li></ul><p>Java中异常对象都是派生于Throwable类的一个实例，如果内置的异常不能满足要求，用户可以创建自己的异常类</p><h2 id="异常结构简化示意图"><a href="#异常结构简化示意图" class="headerlink" title="异常结构简化示意图"></a>异常结构简化示意图</h2><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200807223425.png" alt="20200807223425"></p><p>Error类层级结构描述了Java运行时系统的内部错误和资源耗尽错误，应用程序不应该抛出这种类型的对象</p><p>Exception层次结构又派生为两类：</p><ul><li><code>RuntimeException</code>: 由程序错误导致的异常<ul><li>错误的类型转换<code>ClassCastException</code></li><li>数组访问越界<code>java.lang.ArrayIndexOutOfBoundsException</code></li><li>访问null指针<code>java.lang.NullPointerException</code></li><li>……</li></ul></li><li>其他异常: 由于像I/O错误这类错误导致的异常<ul><li>试图在文件尾部后面读取数据<code>IOException</code></li><li>试图打开一个不存在的文件<code>EOFException</code></li><li>试图根据给定的字符串查找Class对象，而这个字符串表示的类并不存在<code>FileNotFoundException</code></li><li>……</li></ul></li></ul><p>“如果出现RuntimeException异常，那么就一定是你的问题”  是一条相当有规则的道理</p><p>递归-堆栈溢出  </p><p><code>int a = new int[2000000000]</code>内存溢出（最简单的内存溢出）</p><h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><p><code>throws</code> 放置到方法头上<br><code>throw</code> 直接抛出一个异常</p><p>出现异常时判断异常类型，创建一个异常对象然后抛出。例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EOFException e = <span class="keyword">new</span> EOFException();</span><br><span class="line"><span class="keyword">throw</span> e;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> EOFException()</span><br></pre></td></tr></table></figure><h3 id="以下四种情况应当抛出异常"><a href="#以下四种情况应当抛出异常" class="headerlink" title="以下四种情况应当抛出异常"></a>以下四种情况应当抛出异常</h3><ol><li>调用一个抛出受查异常的方法</li><li>程序运行过程中发现错误，并且利用throw语句抛出一个受查异常</li><li>程序出现错误</li><li>Java虚拟机和运行时库出现的内部异常</li></ol><p>如果会出现前两种情况，应当根据<strong>异常规范（exception specification）</strong>，在方法的首部声明方法可能抛出的异常，如果可能抛出多个受查异常，应全部声明，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Image <span class="title">loadImage</span><span class="params">(String s)</span> <span class="keyword">throws</span> FileNotFoundException,EOFException</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是Java的内部错误（即从Error继承的错误）不需要声明，同样也不应该声明从RuntimeException继承的非受查异常，这些运行时错误完全在我们的掌控之中。应当花时间修正错误，而不是说明错误发生的可能性。</p><p><strong>总之，一个方法必须声明所有可能抛出的受查异常，而非受查异常要么不可控制，要么就应该避免发生。</strong></p><h3 id="catch语句抛出异常"><a href="#catch语句抛出异常" class="headerlink" title="catch语句抛出异常"></a>catch语句抛出异常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;<span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">&quot;database error: &quot;</span> + e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，ServletException用带有异常信息文本的构造器来构造</p><p>但是有另一种更好的将原始异常设为新异常”原因”的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">  Throwable se = <span class="keyword">new</span> ServletException(<span class="string">&quot;database error&quot;</span>);</span><br><span class="line">  se.initCause(e);</span><br><span class="line">  <span class="keyword">throw</span> se;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当捕获到异常时，就可以使用<code>Throwable e = se.getCause()</code>重新得到原始异常</p><p>这种包装技术可以让用户抛出子系统的高级异常，而不丢失原始异常（Java核心技术书中强烈推荐）</p><h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  code</span><br><span class="line">  more code</span><br><span class="line">&#125;<span class="keyword">catch</span> (ExceptionType e)&#123;</span><br><span class="line">  handle <span class="keyword">for</span> <span class="keyword">this</span> type</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在try语句块中的任何代码抛出了一个在catch子句中说明的异常，那么</p><ul><li>程序将跳过try语句块其他代码</li><li>程序将执行catch子句中的处理器代码</li></ul><p>如果没有抛出异常，那么程序将跳过catch语句<br>如果抛出一个没有声明的异常，那么程序将退出</p><p>可以使用<code>e.getMessage()</code>可以获取异常信息（如果有的话），或者使用<code>e.getClass().getName()</code>获取异常对象的实际类型</p><p><code>try catch</code>语句可以捕获多个异常，所以应该将异常从子类到父类排序，避免异常类型错误<br><em>注释：捕获多个异常时，异常变量隐含为final变量</em></p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p><strong>在方法内可以<code>throws exception</code> 而最终调用这个方法的人需要用<code>try catch</code>解决异常</strong> ，通常应该捕获那么知道如何处理的异常，而将那些不知道怎么处理的异常继续进行传递</p><h2 id="finally语句"><a href="#finally语句" class="headerlink" title="finally语句"></a>finally语句</h2><p>finally语句是一定会执行的方法，无论是否抛出异常（<strong>无论是否被catch语句声明</strong>）一共有三种情况：</p><ol><li>代码没有抛出异常：执行try语句，然后执行finally语句块</li><li>代码抛出一个在catch子句捕获的异常：执行try语句块中代码，直到报错为止。此刻，程序将跳过try语句块中剩余代码，转而去执行于该异常匹配的catch语句块中的代码，然后执行finally语句块</li><li>代码抛出一个未声明的异常：程序将执行try语句块中的代码直至有异常抛出，然后跳过try剩余代码执行finally子句中的语句，并将异常抛给代码的调用者</li></ol><p>建议解耦合<code>try/catch</code>和<code>try/finally</code>语句块，提高代码清晰度</p><p><strong>Tips:finally中的return语句将替换之前的return语句。</strong></p><h2 id="带资源的try语句"><a href="#带资源的try语句" class="headerlink" title="带资源的try语句"></a>带资源的try语句</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">open a resource</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  work with the resource</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  close the resource</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果资源属于一个实现了AutoCloseable接口的类，Java SE 7提供了一种快捷方式<br><code>void close() throws Exception</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(Scanner in = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;/user/words&quot;</span>),<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"> PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="string">&quot;out.txt&quot;</span>))&#123;</span><br><span class="line">  <span class="keyword">while</span>(in.hasNext())&#123;</span><br><span class="line">    out.println(in.next().toUpperCase());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，这个块可以调用多个资源，同时在正常退出或者存在一个异常时，都会调用<code>in.close()</code>方法,跟使用finally模块一样，</p><h2 id="使用异常机制的技巧"><a href="#使用异常机制的技巧" class="headerlink" title="使用异常机制的技巧"></a>使用异常机制的技巧</h2><ol><li>异常处理不能代替简单测试：异常处理更慢</li><li>不要过分细化异常：提高清晰度，降低代码量</li><li>利用异常层次结构</li><li>不要压制异常</li><li>在检测错误时，“苛刻”比放任好(优先选择抛出异常)</li><li>不要羞于传递异常</li></ol><p><em>Tips:5,6可以归纳为“早跑出，晚收获”.</em></p><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>在编写代码时，我们总是会做出一些假设，如果使用判断语句来验证假设，验证语句将会一直保留在程序中，即使测试完毕也不会自动删除。如果程序中存在大量的这种判断，会严重影响的程序执行速度。</p><p>断言（Assertion）是一种调试程序的方式。在Java中，使用assert关键字来实现断言。当代码发布时，assert语句将会自动地被移走</p><p>assert语句有两种形式：</p><ol><li><code>assert 条件;</code></li><li><code>assert 条件 : 表达式;</code></li></ol><p>这两种形式都会对条件进行检测，如果结果为false，则抛出一个<code>AssertionError</code>异常。在第二种形式中，表达式将传入<code>AssertionError</code>的构造器，并转换成一个消息字符串</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x = Math.abs(-<span class="number">123.45</span>);</span><br><span class="line">    <span class="keyword">assert</span> x &gt;= <span class="number">0</span>;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语句<code>assert x &gt;= 0;</code>即为断言，断言条件<code>x &gt;= 0</code>预期为<code>true</code>。如果计算结果为<code>false</code>，则断言失败，抛出<code>AssertionError</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> x &gt;= <span class="number">0</span> : <span class="string">&quot;x must &gt;= 0&quot;</span>;</span><br></pre></td></tr></table></figure><p>如果如上带上消息，断言失败的时候，AssertionError会带上消息<code>x must &gt;= 0</code>，更加便于调试。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ul><li>Java核心技术</li><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1264740093521088">廖雪峰的官方网站</a></li></ul></blockquote><a class="btn-beautify button--animated block blue right" href="https://www.shiming.online/blog/24227/"   title="多线程"><i class="far fa-hand-point-right fa-fw"></i><span>多线程</span></a>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程</title>
      <link href="blog/24227/"/>
      <url>blog/24227/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>通常,每一个任务称为一个线程,它是线程控制的简称。可以同时运行一个以上线程的程序被称为<strong>多线程程序</strong>。</p><h2 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h2><div class="note info flat"><p>此模块内容大部分来自<a href="https://www.cnblogs.com/goloving/p/9391074.html">博客园-并行与并发的区别</a></p></div><ul><li><strong>并行</strong>是指两个或者多个事件在<strong>同一时刻</strong>发生；而<strong>并发</strong>是指两个或多个事件在<strong>同一时间间隔</strong>发生。</li><li>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。</li><li>并行是在多台处理器上同时处理多个任务。如hadoop分布式集群。并发是在一台处理器上“同时”处理(实际上是交替执行)多个任务，</li></ul><p>所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>假设一个有三个学生需要辅导作业，帮每个学生辅导完作业是一个任务</p><ul><li>顺序执行：老师甲先帮学生A辅导，辅导完之后再取给B辅导，最后再去给C辅导，效率低下 ，很久才完成三个任务</li><li>并发：老师甲先给学生A去讲思路，A听懂了自己书写过程并且检查，而甲老师在这期间直接去给B讲思路，讲完思路再去给C讲思路，让B自己整理步骤。这样老师就没有空着，一直在做事情，很快就完成了三个任务。与顺序执行不同的是，顺序执行，老师讲完思路之后学生在写步骤，在这之后，老师是完全空着的，没做事的，所以效率低下。<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200812120307.png" alt="20200812120307"></li><li>并行：直接让三个老师甲、乙、丙三个老师“同时”给三个学生辅导作业，也完成的很快。<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200812120324.png" alt="20200812120324"></li></ul><blockquote><p>图片来自<a href="https://www.jianshu.com/p/cbf9588b2afb">简书-并发和并行的区别</a></p></blockquote><p>又或者：</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200812211947.png" alt="20200812211947"></p><blockquote><p>图片为Erlang 之父 Joe Armstrong举例</p></blockquote><p>并发 = 两个队列和一台咖啡机。<br>并行 = 两个队列和两台咖啡机。</p><h3 id="并行与并发总结"><a href="#并行与并发总结" class="headerlink" title="并行与并发总结"></a>并行与并发总结</h3><p>如果某个系统支持两个或者多个动作（Action）同时存在，那么这个系统就是一个并发系统。<br>如果某个系统支持两个或者多个动作同时执行，那么这个系统就是一个并行系统。<br>并发系统与并行系统这两个定义之间的关键差异在于“<strong>存在</strong>”这个词。</p><p>在并发程序中可以同时拥有两个或者多个线程。这意味着，如果程序在单核处理器上运行，那么这两个线程将交替地换入或者换出内存。这些线程是同时“存在”的——每个线程都处于执行过程中的某个状态。<br>如果程序能够并行执行，那么就一定是运行在多核处理器上。此时，程序中的每个线程都将分配到一个独立的处理器核上，因此可以同时运行。</p><p>我相信你已经能够得出结论——“并行”概念是“并发”概念的一个子集。也就是说，你可以编写一个拥有多个线程或者进程的并发程序，但如果没有多核处理器来执行这个程序，那么就不能以并行方式来运行代码。因此，凡是在求解单个问题时涉及多个执行流程的编程模式或者执行行为，都属于并发编程的范畴。</p><div class="note info flat"><p>摘自《并发的艺术》 — 〔美〕布雷谢斯</p></div><p>并发就是指代码逻辑上可以并行，有并行的潜力，但是不一定当前是真的以物理并行的方式运行。<strong>并发指的是代码的性质，并行指的是物理运行状态。</strong><br>顾名思义，并发强调的是一起出发，并行强调的是一起执行。并发的反义是顺序，并行的反义是串行。并发并行并不是互斥概念，只不过并发强调任务的抽象调度，并行强调任务的实际执行。</p><h2 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h2><p>进程是<strong>程序运行和资源分配的基本单位</strong>，一个程序至少有一个进程，一个进程至少有一个线程。</p><p>多进程中每个进程拥有自己<strong>独立</strong>的代码和数据空间（进程上下文），而多线程<strong>共享</strong>代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)。共享变量使线程之间的通信比进程之间的通信更有效，更容易。此外,在某些操作系统中,线程更”轻量级”,创建,撤销一个线程比启动新线程开销更小。</p><p>线程是进程的一个实体，是<strong>CPU调度和分派的基本单位</strong>，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。</p><ul><li>多进程是指操作系统能同时运行多个任务（程序）。</li><li>多线程是指在同一程序中有多个顺序流在执行。</li></ul><h2 id="使用多线程"><a href="#使用多线程" class="headerlink" title="使用多线程"></a>使用多线程</h2><p>在Java中创建一个线程有三种方法</p><ol><li><p>实现Java.lang.Runnable接口，重写run方法，启动：new Thread(this).start();</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DemoThread1 t1 = <span class="keyword">new</span> DemoThread1(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        DemoThread1 t2 = <span class="keyword">new</span> DemoThread1(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(t1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(t2).start();</span><br><span class="line">        <span class="comment">// 这样就启动两个线程</span></span><br><span class="line">        <span class="comment">// 注意：重复调用同一个对象的start()方法会抛出java.lang.IllegalThreadStateException异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoThread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoThread1</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>继承Java.lang.Thread类，重写run方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DemoThread2 t1 = <span class="keyword">new</span> DemoThread2(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        DemoThread2 t2 = <span class="keyword">new</span> DemoThread2(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// 启动两个线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoThread2</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现Callable接口，并与Future结合使用</p><p> 步骤：</p><ol><li><p>创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。</p></li><li><p>创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。</p></li><li><p>使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。</p></li><li><p>调用Tread对象的start()方法启动线程，调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现Callable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 重写call()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// FutureTask包装CallableTest对象</span></span><br><span class="line">        FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> CallableTest());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 的循环变量i的值&quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// 使用FutrueTask对象作为target创建新线程并调用</span></span><br><span class="line">                <span class="keyword">new</span> Thread(ft).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;子线程的返回值：&quot;</span> + ft.get());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Thread1类通过实现Runnable接口，使得该类有了多线程类的特征。<code>run()</code>方法是多线程程序的一个约定。所有的多线程代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。<br>在启动多线程的时候，需要先通过Thread类的构造方法<code>Thread(Runnable target)</code> 构造出对象，然后调用Thread对象的<code>start()</code>方法来运行多线程代码。<br>实际上所有的多线程代码都是通过运行Thread的<code>start()</code>方法来运行的。因此，不管是扩展Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。</p><div class="note primary flat"><p>main方法其实也是线程，在java中所有线程都是同时启动的，至于什么时候，谁先执行，看谁先得到CPU的资源。<br>在java中，每个程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。</p></div><div class="note warning flat"><p>Thread实现了Runnable接口并进行了扩展，而Thread和Runnable的实质是实现的关系，不是同类东西，所以Runnable或Thread本身没有可比性。<br>参考<a href="https://blog.csdn.net/zhaojianting/article/details/97664370">彻底理解Runnable和Thread的区别</a></p></div><h3 id="Thread类中常用的方法"><a href="#Thread类中常用的方法" class="headerlink" title="Thread类中常用的方法"></a>Thread类中常用的方法</h3><ol><li>sleep(long millis)在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）</li><li>join():指等待t线程终止。也可以理解为将t线程合并到当前线程来，等待t线程结束后再往下执行。相当于方法调用</li><li>yield():暂停当前正在执行的线程对象，并执行其他线程。</li><li>setPriority(): 更改线程的优先级。</li><li>interrupt():中断某个线程，这种结束方式比较粗暴，如果t线程打开了某个资源还没来得及关闭也就是run方法还没有执行完就强制结束线程，会导致资源无法关闭</li></ol><p>还有两个Object类的方法</p><ol><li>wait()：使当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。</li><li>notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。</li></ol><h4 id="wait-和sleep-区别"><a href="#wait-和sleep-区别" class="headerlink" title="wait()和sleep()区别"></a>wait()和sleep()区别</h4><p>sleep()方法是<strong>线程类（Thread）的静态方法</strong>，调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。<br>因为sleep() 是static静态的方法，他<strong>不能改变</strong>对象的机锁，当一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是对象的机锁没有被释放，<strong>其他线程依然无法访问这个对象</strong>。</p><p>wait()：wait()是<strong>Object类的方法</strong>，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时<strong>释放</strong>对象的机锁，使得<strong>其他线程能够访问</strong>，可以通过notify，notifyAll方法来唤醒等待的线程</p><h4 id="notify-和notifyAll-区别"><a href="#notify-和notifyAll-区别" class="headerlink" title="notify()和notifyAll()区别"></a>notify()和notifyAll()区别</h4><ul><li>如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。</li><li>当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。<br>也就是说，调用了notify后只有一个线程会从等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争。</li><li>优先级高的线程竞争到对象锁的概率大（唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势），假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。<br>而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。</li></ul><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>多线程与多进程都分为五个阶段</p><ul><li>创建（new）：新创建了一个线程对象。</li><li>就绪（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。<br>该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。</li><li>运行（Running）：就绪状态的线程获取了CPU，执行程序代码</li><li>阻塞（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：<ol><li>等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持有的锁)</li><li>同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。</li><li>其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁）</li></ol></li><li>死亡（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200812143242.png" alt="生命周期"></p><h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><p>每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。<br>Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。<br>默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。<br>具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。</p><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><h3 id="为什么要同步"><a href="#为什么要同步" class="headerlink" title="为什么要同步"></a>为什么要同步</h3><p>在大多数实际的多线程应用中，两个或两个以上线程需要共享对统一数据的存取。如果两个线程同时修改一个对象，可能就是使对象状态混乱，引起程序错误。<br>同步存取就是为了避免这个问题</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><ol><li>同步方法<br>有synchronized关键字修饰的方法。 由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。</li><li>同步代码块<br>有synchronized关键字修饰的语句块。 被该关键字修饰的语句块会自动被加上内置锁，从而实现同步。<code>synchronized(this)&#123;/*区块*/&#125;</code>，它的作用域是当前对象；</li><li>使用特殊域变量(volatile)实现线程同步</li><li>使用重入锁(Lock)实现线程同步</li><li>使用局部变量(ThreadLocal)实现线程同步</li><li>使用阻塞队列(LinkedBlockingQueue)实现线程同步</li><li>使用原子变量(Atomic)实现线程同步</li></ol><blockquote><p>具体使用参考<a href="https://www.cnblogs.com/XHJT/p/3897440.html">java笔记–关于线程同步（7种同步方式）</a></p></blockquote><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><p>关键字synchronized的作用是实现线程间的同步。它的工作是对同步的代码加锁,使得每一次,只能有一个线程进入同步块,从而保证线程间的安全性。</p><ol><li>synchronized修饰方法时，只要一个线程访问了此对象其中的一个synchronized方法，其它线程不能同时访问这个对象中任何一个synchronized方法。但是，不同的对象实例的synchronized方法是不相干扰的。也就是说，其它线程照样可以同时访问相同类的另一个对象实例中的synchronized方法。锁是当前实例对象。</li><li>synchronized修饰类的静态方法时，对此类的所有实例对象起作用。锁是当前类的class对象</li><li>无论synchronized关键字加在方法上还是对象上，它取得的锁都是对象，而不是把一段代码或函数当作锁――而且同步方法很可能还会被其他线程的对象访问。</li><li>synchronized关键字是不能继承的，也就是说，基类的方法synchronized f(){} 在继承类中并不自动是synchronized f(){}，而是变成了f(){}。继承类需要你显式的指定它的某个方法为synchronized方法</li></ol><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。<br>是操作系统层面的一个错误，是进程死锁的简称，最早在 1965 年由 Dijkstra 在研究银行家算法时提出的，它是计算机操作系统乃至整个并发程序设计领域最难处理的问题之一。</p><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><p>产生死锁的必要条件：</p><ul><li>互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。</li><li>请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。</li><li>环路等待条件：在发生死锁时，必然存在一个进程–资源的环形链。</li></ul><h3 id="解决死锁的方法"><a href="#解决死锁的方法" class="headerlink" title="解决死锁的方法"></a>解决死锁的方法</h3><p>预防死锁：</p><ul><li>资源一次性分配：一次性分配所有资源，这样就不会再有请求了。（破坏请求条件）</li><li>只要有一个资源得不到分配，也不给这个进程分配其他的资源。（破坏请求保持条件）</li><li>可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）。</li><li>资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）。</li></ul><div class="note info flat"><p>在并发程序中，避免了逻辑中出现复数个线程互相持有对方线程所需要的独占锁的的情况，就可以避免死锁。</p></div><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><blockquote><p>来自<a href="https://cloud.tencent.com/developer/article/1628870">面试官：什么是死锁？如何解决死锁？写一段死锁的代码吧！</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_1 = <span class="string">&quot;lock1&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_2 = <span class="string">&quot;lock2&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (DeadLock.LOCK_1) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 锁住 lock1&quot;</span>);</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        <span class="keyword">synchronized</span> (DeadLock.LOCK_2) &#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 锁住 lock2&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (DeadLock.LOCK_2) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 锁住 lock2&quot;</span>);</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        <span class="keyword">synchronized</span> (DeadLock.LOCK_1) &#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 锁住 lock1&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，启动了两个线程，在每个线程中都要获得DeadLock.LOCK_1和DeadLock.LOCK_2，其中</p><ul><li>threadA，先获取DeadLock.LOCK_1，再获取DeadLock.LOCK_2</li><li>threadB，先获取DeadLock.LOCK_2，再获取DeadLock.LOCK_1</li></ul><p>当threadA获取到DeadLock.LOCK_1之后，就要去获取DeadLock.LOCK_2，而DeadLock.LOCK_2则是先被threadB获取了，因此threadA就需要等待threadB释放DeadLock.LOCK_2之后才能继续执行。<br>但是threadB在获取到DeadLock.LOCK_2之后，却是在等待threadA释放DeadLock.LOCK_1，因此这就形成了“循环等待条件”，从而形成了死锁。<br>想要解决这个死锁很简单，我们只需要让threadA和threadB获取DeadLock.LOCK_1和DeadLock.LOCK_2的顺序相同即可，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_1 = <span class="string">&quot;lock1&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_2 = <span class="string">&quot;lock2&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (DeadLock.LOCK_1) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 锁住 lock1&quot;</span>);</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        <span class="keyword">synchronized</span> (DeadLock.LOCK_2) &#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 锁住 lock2&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (DeadLock.LOCK_1) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 锁住 lock2&quot;</span>);</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        <span class="keyword">synchronized</span> (DeadLock.LOCK_2) &#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 锁住 lock1&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>创建一个线程很简单，但是线程过多会带来调度开销，进而影响缓存局部性和整体性能。如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p><p>而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。<br>线程池不仅能够保证内核的充分利用，还能防止过分调度。线程池可以根据系统的承受能力，调整线程池中工作线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。</p><div class="note info flat"><p>线程池使用方法见<a href="https://www.jianshu.com/p/7ab4ae9443b9">Java线程池的使用</a></p></div><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ul><li>Java核心技术</li><li><a href="https://blog.csdn.net/evankaka/article/details/44153709">Java多线程学习（吐血超详细总结）</a></li><li><a href="https://www.zhihu.com/question/33515481">知乎-并发与并行的区别是什么？</a></li><li><a href="https://www.cnblogs.com/goloving/p/9391074.html">博客园-并行与并发的区别</a></li><li><a href="https://www.jianshu.com/p/cbf9588b2afb">简书-并发和并行的区别</a></li><li><a href="https://www.jianshu.com/p/7ab4ae9443b9">Java线程池的使用</a></li><li><a href="https://www.jianshu.com/p/44125bb12ebf">死锁是什么？如何避免死锁？</a></li><li><a href="https://cloud.tencent.com/developer/article/1628870">面试官：什么是死锁？如何解决死锁？写一段死锁的代码吧！</a></li><li><a href="https://www.cnblogs.com/XHJT/p/3897440.html">java笔记–关于线程同步（7种同步方式）</a></li><li><a href="https://www.cnblogs.com/liyanyan665/p/11359758.html">实现Callable接口，并与Future结合使用</a></li></ul></blockquote><a class="btn-beautify button--animated block blue right" href="https://www.shiming.online/blog/895e9db/"   title="线程同步"><i class="far fa-hand-point-right fa-fw"></i><span>线程同步</span></a>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
          <category> 线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前后端传递参数</title>
      <link href="blog/52912/"/>
      <url>blog/52912/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>正常情况下传递给后端的是<code>application/x-www-form-urlencoded</code>格式，后端可以直接接收<br>但是传递对象时，需要以json格式来传递（<code>application/json</code>），前端需要设置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">contentType: <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">data: <span class="built_in">JSON</span>.stringify(data),</span><br></pre></td></tr></table></figure><p>同时，后端需要用@RequestBody作用在参数上来接受<br>例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/deleteAll&quot;)</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">deleteAll</span><span class="params">(<span class="meta">@RequestBody</span> Vip vip)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>后端返回JSON格式数据可以使用<code>@RestController</code></p><p><code>@RestController</code>等价于<code>@Controller</code>+<code>@ResponseBody</code></p>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>knife4j</title>
      <link href="blog/14614/"/>
      <url>blog/14614/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>这是对官网内容的一份总结，是对官网内容的整理</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://gitee.com/xiaoym/knife4j">knife4j</a>是<code>springfox-swagger</code>的增强UI实现，为Java开发者在使用Swagger的时候，能拥有一份简洁、强大的接口文档体验,前身是swagger-bootstrap-ui<br><a href="https://doc.xiaominfo.com/knife4j">官方指南</a></p><h2 id="SpringBoot中使用"><a href="#SpringBoot中使用" class="headerlink" title="SpringBoot中使用"></a>SpringBoot中使用</h2><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><ol><li><p>在pom.xml中添加依赖</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>knife4j-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--在引用时请在maven中央仓库搜索最新版本号--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>添加配置文件<code>SwaggerConfiguration.java</code></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.github.xiaoymin.knife4j.spring.annotations.EnableKnife4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Import;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;</span><br><span class="line"><span class="keyword">import</span> springfox.bean.validators.configuration.BeanValidatorPluginsConfiguration;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.PathSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.RequestHandlerSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.Contact;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="meta">@EnableKnife4j</span></span><br><span class="line"><span class="meta">@Import(BeanValidatorPluginsConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(value = &quot;defaultApi2&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">defaultApi2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Docket docket = <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                <span class="comment">//分组名称</span></span><br><span class="line">                .groupName(<span class="string">&quot;2.X版本&quot;</span>)</span><br><span class="line">                .select()</span><br><span class="line">                <span class="comment">//这里指定Controller扫描包路径</span></span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.swagger.bootstrap.ui.demo.new2&quot;</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> docket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                .title(<span class="string">&quot;knife4j&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;knife4j文档&quot;</span>)</span><br><span class="line">                .termsOfServiceUrl(<span class="string">&quot;&quot;</span>)</span><br><span class="line">                .contact(<span class="string">&quot;失铭&quot;</span>)</span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><table><thead><tr><th align="left">注解</th><th align="center">说明</th></tr></thead><tbody><tr><td align="left">EnableSwagger2</td><td align="center">该注解是Springfox-swagger框架提供的使用Swagger注解，该注解必须加</td></tr><tr><td align="left">EnableKnife4j</td><td align="center">该注解是knife4j提供的增强注解,Ui提供了例如动态参数、参数过滤、接口排序等增强功能,如果你想使用这些增强功能就必须加该注解，否则可以不用加</td></tr></tbody></table><p>这俩个注解也可以加在Application文件而不加在config中</p><p><strong>如上配置如果出错看下文。</strong></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="启动增强模式"><a href="#启动增强模式" class="headerlink" title="启动增强模式"></a>启动增强模式</h3><ol><li>使用<code>@EnableKnife4j</code>注解</li><li>访问<code>http://host:port/doc.html#/plus</code></li></ol><h3 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h3><p>knife4j有7种请求方式</p><ul><li>GET</li><li>POST</li><li>PUT</li><li>DELETE</li><li>PATCH</li><li>OPTIONS</li><li>HEAD</li></ul><h3 id="给接口加上作者"><a href="#给接口加上作者" class="headerlink" title="给接口加上作者"></a>给接口加上作者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@ApiSupport(author = &quot;xshiming&quot;,order = 2)</span></span><br><span class="line"><span class="meta">@Api(value = &quot;knife4j&quot;,tags = &quot;knife4j测试&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例：<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200807223353.png" alt="20200807223353"></p><p>使用@ApiSupport即可为模块设置author(作者)和order(排序)</p><h3 id="接口排序"><a href="#接口排序" class="headerlink" title="接口排序"></a>接口排序</h3><p>目前有两种排序方式</p><ul><li>controller排序</li><li>controller下的接口排序</li></ul><h4 id="tags分组排序"><a href="#tags分组排序" class="headerlink" title="tags分组排序"></a>tags分组排序</h4><ol><li><p>使用<code>@ApiSupport</code>排序</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Api(tags = &quot;2.0.3版本-20200312&quot;)</span></span><br><span class="line"><span class="meta">@ApiSupport(order = 284)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/nxew203&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Api203Constroller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>@ApiSort</code>排序</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Api(tags = &quot;2.0.2版本-20200226&quot;)</span></span><br><span class="line"><span class="meta">@ApiSort(286)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/nxew202&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Api202Controller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>@Api</code>的<code>position</code>属性排序</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Api(tags = &quot;2.0.2版本-20200226&quot;,position = 286)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/nxew202&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Api202Controller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方推荐：@ApiSupport&gt;@ApiSort&gt;@Api</p><h4 id="tag下接口排序"><a href="#tag下接口排序" class="headerlink" title="tag下接口排序"></a>tag下接口排序</h4><p>使用<code>@ApiOperationSupport</code>中的<code>order</code>字段排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperationSupport(order = 33)</span></span><br><span class="line"><span class="meta">@ApiOperation(value = &quot;忽略参数值-Form类型&quot;)</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/ex&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Rest&lt;LongUser&gt; <span class="title">findAll</span><span class="params">(LongUser longUser)</span> </span>&#123;</span><br><span class="line">    Rest&lt;LongUser&gt; r=<span class="keyword">new</span> Rest&lt;&gt;();</span><br><span class="line">    r.setData(longUser);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="过滤请求参数"><a href="#过滤请求参数" class="headerlink" title="过滤请求参数"></a>过滤请求参数</h3><h4 id="一级参数"><a href="#一级参数" class="headerlink" title="一级参数"></a>一级参数</h4><p>过滤实体类中不需要的属性</p><ul><li>过滤单个属性<code>ignoreParameters=&#123;&quot;id&quot;&#125;</code></li><li>过滤多层次属性<code>&#123;&quot;uptModel.id&quot;,&quot;uptModel.uptPo.id&quot;&#125;</code></li><li>过滤列表中属性<code>ignoreParameters=&#123;&quot;uptModel.uptPo[0].id&quot;&#125;</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(value = &quot;新增Model接口1&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperationSupport(ignoreParameters = &#123;&quot;id&quot;,&quot;orderDate.id&quot;&#125;)</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/insertMode1l&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Rest&lt;UptModel&gt; <span class="title">insertModel1</span><span class="params">(UptModel uptModel)</span></span>&#123;</span><br><span class="line">    Rest&lt;UptModel&gt; r =<span class="keyword">new</span> Rest&lt;&gt;();</span><br><span class="line">    r.setData(uptModel);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="json格式"><a href="#json格式" class="headerlink" title="json格式"></a>json格式</h4><p>json格式需要加上参数名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(value = &quot;新增Model接口&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperationSupport(ignoreParameters = &#123;&quot;uptModel.id&quot;,&quot;uptModel.name&quot;,&quot;uptModel.orderDate.id&quot;&#125;)</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/insertModel&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Rest&lt;UptModel&gt; <span class="title">insertModel</span><span class="params">(<span class="meta">@RequestBody</span> UptModel uptModel)</span></span>&#123;</span><br><span class="line">    Rest&lt;UptModel&gt; r =<span class="keyword">new</span> Rest&lt;&gt;();</span><br><span class="line">    r.setData(uptModel);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="包含请求参数"><a href="#包含请求参数" class="headerlink" title="包含请求参数"></a>包含请求参数</h3><p>与过滤请求参数取反，使用自定义增强注解<code>ApiOperationSupport</code>中的<code>includeParameters</code>属性,可以强制包含要显示的参数.去除多余的参数显示</p><p>示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperationSupport(order = 40,includeParameters = &#123;&quot;ignoreLabels&quot;,&quot;longUser.ids&quot;&#125;)</span></span><br><span class="line"><span class="meta">@ApiOperation(value = &quot;包含参数值-Form类型1&quot;)</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/ex1c&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Rest&lt;IgnoreP1&gt; <span class="title">findAllc12</span><span class="params">(IgnoreP1 ignoreP1)</span> </span>&#123;</span><br><span class="line">    Rest&lt;IgnoreP1&gt; r=<span class="keyword">new</span> Rest&lt;&gt;();</span><br><span class="line">    r.setData(ignoreP1);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>json格式与过滤请求参数相同，需要加上参数名称</p><h3 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h3><p>用Map或者JSONObject接收或者返回数据时，显示参数注释</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/createOrder426&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(value = &quot;jdk-HashMap-动态创建显示参数-无@RequestBody&quot;)</span></span><br><span class="line"><span class="meta">@DynamicParameters(name = &quot;CreateOrderHashMapModel&quot;,properties = &#123;</span></span><br><span class="line"><span class="meta">        @DynamicParameter(name = &quot;&quot;,value = &quot;注解id&quot;,example = &quot;X000111&quot;,required = true,dataTypeClass = Integer.class),</span></span><br><span class="line"><span class="meta">        @DynamicParameter(name = &quot;name3&quot;,value = &quot;订单编号-gson&quot;),</span></span><br><span class="line"><span class="meta">        @DynamicParameter(name = &quot;name1&quot;,value = &quot;订单编号1-gson&quot;),</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Rest&lt;HashMap&gt; <span class="title">createOrder1235332</span><span class="params">(<span class="meta">@RequestBody</span> HashMap map)</span></span>&#123;</span><br><span class="line">    Rest&lt;HashMap&gt; r=<span class="keyword">new</span> Rest&lt;&gt;();</span><br><span class="line">    r.setData(map);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@DynamicParameters中有一个name属性,该值可以理解为一个类名,如果你赋予name属性值,那么请保证全局唯一,或者干脆不赋值,交给Knife4j自动生成一个全局唯一的name值</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>不建议使用动态参数接收，从接口类传递Map等动态参数到service层，代码可读性和维护性都大大降低，不能简单直接的表达出需要那些参数</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>请求参数缓存：如果后端有默认值，缓存不会产生，而对于未设置默认值的方法，将缓存上一次输入的数据</li><li>动态请求参数：任意数量的请求参数</li><li>版本控制：后端新增接口或者接口编辑后，在ui界面显示更新标志（蓝色徽标）</li><li>到处离线文档：可以导出为Markdown，html，word，pdf四种格式</li><li>清除缓存：解决灵异问题</li><li>搜索Api：搜索接口地址，接口名称，接口描述</li><li>自定义host:跨域</li><li>访问权限控制：生产环境时屏蔽swagger：<code>knife4j.production=true</code></li><li>自定义文档：自定义md文件扩充系统说明  <a href="https://doc.xiaominfo.com/knife4j/self-doc.html">官网说明</a></li></ul><h2 id="Swagger常用注解"><a href="#Swagger常用注解" class="headerlink" title="Swagger常用注解"></a>Swagger常用注解</h2><h3 id="1-Api"><a href="#1-Api" class="headerlink" title="1. @Api"></a>1. @Api</h3><p>@Api作用在类上，说明一个类的作用。标记一个Controller类作为Swagger资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Api(value = &quot;/user&quot;, description = &quot;Description about user&quot;)</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">属性名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">value</td><td align="center">帮助理解，无意义</td></tr><tr><td align="center">tags</td><td align="center">ui界面模块名</td></tr><tr><td align="center">description</td><td align="center">对类的描述</td></tr></tbody></table><h3 id="2-ApiOperation"><a href="#2-ApiOperation" class="headerlink" title="2. @ApiOperation"></a>2. @ApiOperation</h3><p>@ApiOperation作用在方法上，说明方法的作用，每一个url资源的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(value = &quot;value值&quot;, notes = &quot;说明&quot;,httpMethod = &quot;GET&quot;)</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">属性名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">value</td><td align="center">方法的用途、作用</td></tr><tr><td align="center">notes</td><td align="center">接口说明</td></tr><tr><td align="center">httpMethod</td><td align="center">接口请求方式</td></tr><tr><td align="center">response</td><td align="center">接口返回参数类型</td></tr></tbody></table><p><em>@ApiOperation中httpMethod的请求方式和@RequestMapping中method的请求方式不同，swagger则优先读取@ApiOperation中的请求方式.</em></p><h3 id="3-ApiParam"><a href="#3-ApiParam" class="headerlink" title="3. @ApiParam()"></a>3. @ApiParam()</h3><p>@ApiParam()用于方式方法，是对参数的说明，与Controller中的方法并列使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title">createUser</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@ApiParam(value = &quot;Created user object&quot;, required = true)</span>  User user)</span></span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">属性名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">name</td><td align="center">参数名</td></tr><tr><td align="center">value</td><td align="center">说明</td></tr><tr><td align="center">required</td><td align="center">是否必填</td></tr></tbody></table><p><em>该注解如果用于实体类的方法中，则涉及该类的所有接口，对应的属性都会受相关的控制。</em></p><h3 id="4-ApiImplicitParam"><a href="#4-ApiImplicitParam" class="headerlink" title="4. @ApiImplicitParam()"></a>4. @ApiImplicitParam()</h3><p>@ApiImplicitParam()用于方法，表示单独的请求参数</p><table><thead><tr><th align="center">属性名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">name</td><td align="center">参数名</td></tr><tr><td align="center">value</td><td align="center">参数说明</td></tr><tr><td align="center">dataTyp</td><td align="center">数据类型,只有String/Integer</td></tr><tr><td align="center">defaultValue</td><td align="center">默认值</td></tr><tr><td align="center">require</td><td align="center">是否必要</td></tr><tr><td align="center">paramType</td><td align="center">参数位置</td></tr><tr><td align="center">example</td><td align="center">举例说明</td></tr></tbody></table><h3 id="5-ApiImplicitParams"><a href="#5-ApiImplicitParams" class="headerlink" title="5. @ApiImplicitParams()"></a>5. @ApiImplicitParams()</h3><p>@ApiImplicitParams()用于方法，包含多个@ApiImplicitParam()</p><h3 id="6-ApiModel"><a href="#6-ApiModel" class="headerlink" title="6. @ApiModel"></a>6. @ApiModel</h3><p>@ApiModel用于类</p><h3 id="7-ApiModelProperty"><a href="#7-ApiModelProperty" class="headerlink" title="7. @ApiModelProperty()"></a>7. @ApiModelProperty()</h3><p>@ApiModelProperty()用于方法，字段，表示对model属性的说明或者数据操作更改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiModelProperty(value = &quot;名称&quot;, name=&quot;name2&quot;,dataType = &quot;Java.lang.Integer&quot;)</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">属性名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">value</td><td align="center">字段</td></tr><tr><td align="center">name</td><td align="center">重写属性名字</td></tr><tr><td align="center">dataType</td><td align="center">重写属性类型</td></tr><tr><td align="center">required</td><td align="center">是否必填</td></tr><tr><td align="center">example</td><td align="center">举例说明</td></tr><tr><td align="center">hidden</td><td align="center">隐藏</td></tr></tbody></table><h3 id="8-ApiIgnore"><a href="#8-ApiIgnore" class="headerlink" title="8. @ApiIgnore()"></a>8. @ApiIgnore()</h3><p>@ApiIgnore用于类，方法，方法参数，不在Swagger上显示</p><h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><p>我在使用2.0.3版本knife4j时，后台接收参数运行程序控制台会报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.context.ApplicationContextException: Failed to start bean <span class="string">&#x27;documentationPluginsBootstrapper&#x27;</span>; nested exception is com.google.common.util.concurrent.ExecutionError: java.lang.NoSuchMethodError: com.google.common.collect.FluentIterable.concat(Ljava/lang/Iterable;Ljava/lang/Iterable;)Lcom/google/common/collect/FluentIterable;</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.validation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>validation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.0.0.Alpha6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>搜到的原因是因为hibernate和validation版本冲突，所以上面两个依赖任选其一更新即可</p><h2 id="使用Swagger2"><a href="#使用Swagger2" class="headerlink" title="使用Swagger2"></a>使用Swagger2</h2><p>因为上诉错误，所以改用Swagger2</p><p>将knife4j依赖修改为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-bootstrap-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>删去配置文件中的knife4j注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableKnife4j</span></span><br><span class="line"><span class="meta">@Import(BeanValidatorPluginsConfiguration.class)</span></span><br></pre></td></tr></table></figure><p>如上配置，Swagger2就可以正常使用</p>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RESTful </tag>
            
            <tag> 开发 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建</title>
      <link href="blog/26832/"/>
      <url>blog/26832/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h2><p>安装git，nodejs，hexo</p><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><blockquote><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/896067074338496">git安装</a><br><a href="https://www.jianshu.com/p/414ccd423efc">详细教程</a></p></blockquote><p>设置用户名和邮箱</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;github用户名&quot;</span><br><span class="line">git config --global user.email &quot;github邮箱&quot;</span><br></pre></td></tr></table></figure><h3 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h3><p>下载后默认配置一路确定</p><p><code>node -v</code>和<code>npm -v</code>检查是否安装成功</p><p>设置淘宝镜像<br><code>npm config set registry https://registry.npm.taobao.org</code><br>检查是否更换成功<br><code>npm config get registry</code>结果为：<code>https://registry.npm.taobao.org/</code></p><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>打开命令行<br><code>npm install -g hexo</code></p><a id="more"></a><h2 id="开始搭建"><a href="#开始搭建" class="headerlink" title="开始搭建"></a>开始搭建</h2><h3 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h3><p>在创建的Hexo文件夹上打开命令行（shift+右键），输入：<code>hexo init</code></p><p>创建成功后输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo new my_first_blog&#x2F;&#x2F;新建个人页面</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>就可以本地访问”localhost:4000”网址访问博客</p><h3 id="绑定Github"><a href="#绑定Github" class="headerlink" title="绑定Github"></a>绑定Github</h3><p>Github新建仓库，仓库名为”用户名.github.io”<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200807222452.png" alt="创建仓库"></p><p>修改根目录下的_config.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:github用户名/github用户名.github.io.git</span></span><br><span class="line">  <span class="string">(例：git@github.com:XShiMing/XShiMing.github.io.git）</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>安装git部署插件</p><p><code>npm install hexo-deployer-git --save</code></p><p>部署到git</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>初次连接需要输入用户名和密码</p><h4 id="一键发布"><a href="#一键发布" class="headerlink" title="一键发布"></a>一键发布</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.hexo &#39;!hexo clean;hexo g;hexo d&#39;</span><br></pre></td></tr></table></figure><p>之后就可以直接在gitbash内使用<code>git hexo</code>一键发布了</p><h4 id="设置SSH连接"><a href="#设置SSH连接" class="headerlink" title="设置SSH连接"></a>设置SSH连接</h4><p>使用SSH密钥可以避免发布时需要输入密码的情况</p><p>在Git Bash中输入<code>ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;</code>生成密钥（直接三个回车，不需要密码）<br>输入<code>cd ~/.ssh</code>进入密钥文件夹<br>输入<code>cat id_rsa.pub</code>即可显示id_rsa.pub内容，将内容全部复制</p><p>打开<a href="https://github.com/settings/keys">Github_settings_keys</a>页面,新建new SSH Key<br>Title随意，key为刚复制的值，最后点击Add SSH Key</p><p>打开Git Bash页面，输入<code>ssh git@github.com</code>，敲入yes回车<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200807222506.png" alt="生成ssh"><br>如上则成功</p><h2 id="Hexo-Github-pages"><a href="#Hexo-Github-pages" class="headerlink" title="Hexo+Github-pages"></a>Hexo+Github-pages</h2><h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><h3 id="域名购买"><a href="#域名购买" class="headerlink" title="域名购买"></a>域名购买</h3><p>在<a href="www.namesilo.com">namesilo.com</a>注册完善信息后购买域名，点击右上Manage My Domains,<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200807222527.png" alt="解析域名"><br>选中域名点击ChangeNameservers更改DNS解析器,<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200807222539.png" alt="更改dns"><br>我使用的是DNSPOD解析<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200807222552.png" alt="dnspod"></p><blockquote><p>在namesilo购买域名之后备案或者办理其他事务较麻烦，也可以在腾讯购买域名</p></blockquote><h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><p>登录DNSPOD设置</p><ol><li>连接到github</li><li>连接到自己的github私有库</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">185.199.108.153</span><br><span class="line">185.199.109.153</span><br><span class="line">185.199.110.153</span><br><span class="line">185.199.111.153</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200807222607.png" alt="ip"></p><h3 id="Github绑定域名"><a href="#Github绑定域名" class="headerlink" title="Github绑定域名"></a>Github绑定域名</h3><p>在博客source目录下创建CNAME文件（保存为所有类型）写入自己的域名<br>部署到github，点击项目setting，下滑找到Custom domain修改<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200807222621.png" alt="修改域名"></p><blockquote><p><em>配置完后可能需要等待一段时间才能生效</em></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis Generator</title>
      <link href="blog/21968/"/>
      <url>blog/21968/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>生成pojo,mapper.java.mapper.xml文件（包含基础增删改查），提交工作效率，解决繁琐的消逝</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="1-pom-xml导入插件"><a href="#1-pom-xml导入插件" class="headerlink" title="1. pom.xml导入插件"></a>1. pom.xml导入插件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Mybatis Dynamic Sql 依赖，可以不添加 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;dependency&gt;</span></span><br><span class="line"><span class="comment">    &lt;groupId&gt;org.mybatis.dynamic-sql&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">    &lt;artifactId&gt;mybatis-dynamic-sql&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">    &lt;version&gt;1.1.4&lt;/version&gt;</span></span><br><span class="line"><span class="comment">&lt;/dependency&gt; --&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置文件的位置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configurationFile</span>&gt;</span>src/main/resources/generatorConfig.xml</span><br><span class="line">        <span class="tag">&lt;/<span class="name">configurationFile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">verbose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">verbose</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">overwrite</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overwrite</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="1-在resources目录下创建generatorConfig-xml文件"><a href="#1-在resources目录下创建generatorConfig-xml文件" class="headerlink" title="1. 在resources目录下创建generatorConfig.xml文件"></a>1. 在resources目录下创建generatorConfig.xml文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--导入属性配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;datasource.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定数据库驱动的jdbc驱动jar包的位置 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    &lt;classPathEntry location=&quot;$&#123;db.driverLocation&#125;&quot; /&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- context 是逆向工程的主要配置信息 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- id：起个名字 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- targetRuntime：设置生成的文件适用于那个 mybatis 版本</span></span><br><span class="line"><span class="comment">    1.4.0默认使用MyBatis Dynamic SQL</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;default&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;mybatis3simple&quot;</span> &gt;</span></span><br><span class="line">        <span class="comment">&lt;!--optional,旨在创建class时，对注释进行控制--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suppressDate&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suppressAllComments&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 生成的Java文件的编码 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;javaFileEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;utf-8&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 格式化java代码--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;javaFormatter&quot;</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">value</span>=<span class="string">&quot;org.mybatis.generator.api.dom.DefaultJavaFormatter&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 格式化XML代码--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;xmlFormatter&quot;</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">value</span>=<span class="string">&quot;org.mybatis.generator.api.dom.DefaultXmlFormatter&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--jdbc的数据库连接--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span></span></span><br><span class="line"><span class="tag">                <span class="attr">driverClass</span>=<span class="string">&quot;$&#123;jdbc.driverClass&#125;&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">connectionURL</span>=<span class="string">&quot;$&#123;jdbc.connectionURL&#125;&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">userId</span>=<span class="string">&quot;$&#123;jdbc.userId&#125;&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">password</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--非必须，类型处理器，在数据库类型和java类型之间的转换控制--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 默认情况下数据库中的 decimal，bigInt 在 Java 对应是 sql 下的 BigDecimal 类 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 不是 double 和 long 类型 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 使用常用的基本类型代替 sql 包下的引用类型 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;forceBigDecimals&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- targetPackage：生成的实体类所在的包 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- targetProject：生成的实体类所在的硬盘位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.sx.sc.pojo&quot;</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">targetProject</span>=<span class="string">&quot;./src/main/java&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 是否允许子包 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 是否对modal添加构造函数 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;constructorBased&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 是否清理从数据库中查询出的字符串左右两边的空白字符 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;trimStrings&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 建立modal对象是否不可改变 即生成的modal对象不会有setter方法，只有构造方法 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;immutable&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- targetPackage 和 targetProject：生成的 mapper 文件的包和位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;mappers&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">targetProject</span>=<span class="string">&quot;./src/main/resources&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 针对数据库的一个配置，是否把 schema 作为字包名 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- targetPackage 和 targetProject：生成的 interface 文件的包和位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span></span></span><br><span class="line"><span class="tag">                             <span class="attr">targetPackage</span>=<span class="string">&quot;com.sx.sc.mapper&quot;</span></span></span><br><span class="line"><span class="tag">                             <span class="attr">targetProject</span>=<span class="string">&quot;./src/main/java&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 针对 oracle 数据库的一个配置，是否把 schema 作为字包名 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;vip&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Vip&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--下划线转驼峰,设置为true就使用原本字段名--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;useActualColumnNames&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-生成datasource-properties文件"><a href="#3-生成datasource-properties文件" class="headerlink" title="3.生成datasource.properties文件"></a>3.生成datasource.properties文件</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!--</span> <span class="string">8.0以上版本连接方法 --&gt;</span></span><br><span class="line"><span class="meta">jdbc.driverClass</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.connectionURL</span>=<span class="string">jdbc:mysql://localhost:3306/mysql?serverTimezone=UTC</span></span><br><span class="line"><span class="meta">jdbc.userId</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure><h3 id="4-生成文件"><a href="#4-生成文件" class="headerlink" title="4.. 生成文件"></a>4.. 生成文件</h3><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200807223405.png" alt="20200807223405"></p><h3 id="5-Mybatis-Dynamic-SQL版本使用方法"><a href="#5-Mybatis-Dynamic-SQL版本使用方法" class="headerlink" title="5. Mybatis Dynamic SQL版本使用方法"></a>5. Mybatis Dynamic SQL版本使用方法</h3><p>MyBatis Dynamic SQL 是生成动态 SQL 语句的框架，可把它看作是一个类型安全的 SQL 模板库，另外还支持 MyBatis3 和 Spring JDBC 模板。</p><p>该库将生成格式化为由 MyBatis 或 Spring 使用的完整 DELETE，INSERT，SELECT 和 UPDATE 语句。</p><p>最常见的用例是生成语句和一组匹配的参数，这些参数可以被 MyBatis 直接使用。该库还将生成与 Spring JDBC 模板兼容的语句和参数对象。</p><p>该库通过实现一个类似 SQL 的 DSL 来创建一个对象，该对象包含完整的 SQL 语句以及该语句所需的任何参数。SQL 语句对象可以被 MyBatis 直接用作映射器方法的参数。</p><p>该模式下<strong>不再生成 XML，不再生成 Example 类</strong>。文档里也推荐：join 操作要用到的 resultMap 应该是 XML 文件中的唯一元素。</p><p>暂无-学习中</p><h2 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h2><p>在数据库更改字段后，如果使用MybatisGenerator生成文件，mapper文件会被覆盖，写过的方法需要重新编写。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ol><li>在mapper中建立一个extend包，建立xxMapperExtends接口，在这个接口内书写自己的方法,最后xxMapper文件继承这个接口就可以实现分离，如：<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200807222915.png" alt="20200807222915"></li><li>resource目录结构如下<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200807222922.png" alt="20200807222922"></li><li>mybatis设置中的配置路径<br><code>mybatis.mapper-locations=classpath:mybatis/*/*.xml</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> 工具 </tag>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Home</title>
      <link href="blog/1739/"/>
      <url>blog/1739/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>网站内容是我在学习工程中对于官网，专业书籍，他人技术博客，面试题的整合而来的学习笔记。</p><h2 id="Java学习路线"><a href="#Java学习路线" class="headerlink" title="Java学习路线"></a>Java学习路线</h2><blockquote><p>Java部分学习笔记是我按照知乎<a href="https://www.zhihu.com/people/zhang-xu-guang-21">沈世均</a>发布的文章<a href="https://zhuanlan.zhihu.com/p/84032726">Java学习路线图</a>学习的笔记。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200807222410.png" alt="java学习.jpg"></p><p>其他笔记部分是学习课程所作，部分是实习中学习扩展的知识</p><h2 id="资源网站"><a href="#资源网站" class="headerlink" title="资源网站"></a>资源网站</h2><p>这是保留的一些网站，有些参考网站没找到，待补充</p><blockquote><ul><li><a href="https://www.jianshu.com/p/81937ae795fd">泛型</a></li><li><a href="https://www.jianshu.com/p/24af4f3ab046">List的Stream流操作</a></li><li><a href="https://blog.csdn.net/kongmin_123/article/details/82048392">Spring Bean的作用域</a></li><li><a href="https://blog.csdn.net/wuskzuo/article/details/79186144">[MyBatis]-resultMap结果映射集详解</a></li><li><a href="https://www.cnblogs.com/pqchao/p/6558688.html">redis配置文件详解</a></li><li><a href="https://hutool.cn/">Hutool</a></li><li><a href="https://deerchao.cn/tutorials/regex/regex.htm">正则表达式30分钟入门教程</a></li><li><a href="https://refactoringguru.cn/design-patterns">设计模式</a></li><li><a href="https://www.cnblogs.com/linbudu/p/11367763.html">MarkDown语法总结</a></li><li><a href="https://cloud.tencent.com/developer/article/1538210">Linux安装JDK+Tomcat+MySQL及发布项目教程</a></li><li><a href="https://blog.csdn.net/m0_46422300/article/details/104645072">Linux常用操作命令大全</a></li></ul></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Maven</title>
      <link href="blog/38008/"/>
      <url>blog/38008/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Maven概念"><a href="#Maven概念" class="headerlink" title="Maven概念"></a>Maven概念</h2><p>Maven 翻译为”专家”、”内行”，是 Apache 下的一个纯 Java 开发的开源项目。<br>基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。<br>Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。<br>Maven 也可被用于构建和管理各种项目，例如 C#，Ruby，Scala 和其他语言编写的项目。Maven 曾是 Jakarta 项目的子项目，现为由 Apache 软件基金会主持的独立 Apache 项目。</p><h2 id="领域"><a href="#领域" class="headerlink" title="领域"></a>领域</h2><ul><li>简化构建过程</li><li>提供统一的构建系统</li><li>提供优质的项目信息</li><li>鼓励更好的开发实践</li></ul><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p>Maven 的本地仓库，在安装 Maven 后并不会创建，它是在第一次执行 maven 命令的时候才被创建。<br>运行 Maven 的时候，Maven 所需要的任何构件都是直接从本地仓库获取的。如果本地仓库没有，它会首先尝试从远程仓库下载构件至本地仓库，然后再使用本地仓库的构件。</p><h2 id="POM-xml"><a href="#POM-xml" class="headerlink" title="POM.xml"></a>POM.xml</h2><p>POM 中可以指定以下配置：</p><ul><li>项目依赖</li><li>插件</li><li>执行目标</li><li>项目构建 profile</li><li>项目版本</li><li>项目开发者列表</li><li>相关邮件列表信息</li></ul><p>modelVersion<br>指定了当前Maven模型的版本号，对于Maven2和Maven3来说，它只能是4.0.0</p><p>groupId<br>类似package，公司名倒过来</p><p>artifactId<br>groupId下一个功能的命名，或者说是项目名</p><p>version<br>版本号，SNAPSHOT意为快照，说明该项目还在开发中，是不稳定的版本。<br>结构为:主版本号.次版本号.增量版本号-&lt;里程碑版本&gt;</p><p><strong>groupId、artifactId、version三个元素生成了一个Maven项目的坐标.</strong></p><p>packaging<br>项目产生的构件类型，例如jar、war、ear、pom。</p><p>description<br>描述，通常用于版权说明</p><p>properties<br>定义一些变量，可以在dependency中引用</p><p>dependencyManagement<br>一般只出现在父pom里面，继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和 artifact ID信息），<br>如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID 匹配到这里的依赖，并使用这里的依赖信息。</p><p>dependency<br>Type<br>默认jar</p><p>Scope<br>定义在哪个阶段使用，以及会不会打到包(jar包,war包等)里面去</p><p>compile 编译(默认)<br>表示被依赖项目需要参与当前项目的编译，还有后续的测试，运行周期也参与其中，是一个比较强的依赖。打包的时候通常需要包含进去</p><p>test 测试<br>依赖项目仅仅参与测试相关的工作，包括测试代码的编译和执行，不会被打包，例如：junit</p><p>provided<br>打包的时候可以不用包进去，别的设施会提供。事实上该依赖理论上可以参与编译，测试，运行等周期。相当于compile，但是打包阶段做了exclude操作</p><p>runtime<br>表示被依赖项目无需参与项目的编译，不过后期的测试和运行周期需要其参与。与compile相比，跳过了编译而已。例如JDBC驱动，适用运行和测试阶段</p><p>system<br>从参与度来说，和provided相同，不过被依赖项不会从maven仓库下载，而是从本地文件系统拿。需要添加systemPath的属性来定义路径</p><h3 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a>依赖传递</h3><p>A–&gt;B–&gt;C。当前项目为A，A依赖于B，B依赖于C。当C是test或者provided时，C直接被丢弃，A不依赖C； 否则A依赖C</p><h3 id="依赖仲裁"><a href="#依赖仲裁" class="headerlink" title="依赖仲裁"></a>依赖仲裁</h3><p>最短路径原则 A-&gt;B-&gt;C-&gt;common1.1.jar A-&gt;common1.0.jar那么A最终会依赖common1.0.jar</p><p>加载先后原则<br>A-&gt;B<br>A-&gt;C<br>B-&gt;common1.0.jar<br>C-&gt;common1.1.jar<br>A同时依赖B和C，那么B和C谁先加载，就依赖谁的common.jar</p><p>依赖排除<br>任何可传递的依赖都可以通过 “exclusion” 元素被排除在外。举例说明，A 依赖 B， B 依赖 C，因此 A 可以标记 C 为 “被排除的”</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200807222003.png" alt="maven生命周期"></p><p>Maven定义了三套生命周期：clean、default、site，每个生命周期都包含了一些阶段（phase）。<br>三套生命周期相互独立，但各个生命周期中的phase却是有顺序的，且后面的phase依赖于前面的phase。执行某个phase时，其前面的phase会依顺序执行，但不会触发另外两套生命周期中的任何phase。</p><h3 id="clean生命周期"><a href="#clean生命周期" class="headerlink" title="clean生命周期"></a>clean生命周期</h3><ul><li>pre-clean ：执行清理前的工作；</li><li>clean ：清理上一次构建生成的所有文件(target)；</li><li>post-clean ：执行清理后的工作</li></ul><h3 id="default（build）生命周期"><a href="#default（build）生命周期" class="headerlink" title="default（build）生命周期"></a>default（build）生命周期</h3><p>Maven 的主要生命周期，被用于构建应用，有23 个阶段。default生命周期是最核心的，它包含了构建项目时真正需要执行的所有步骤。</p><ul><li>process-resources ：复制和处理资源文件到target目录，准备打包；</li><li>compile ：编译项目的源代码；</li><li>test-compile ：编译测试源代码；</li><li>test ：运行测试代码；</li><li>package ：打包成jar或者war或者其他格式的分发包；</li><li>install ：将打好的包安装到本地仓库，供其他项目使用；</li><li>deploy ：将打好的包安装到远程仓库，供其他项目使用；</li></ul><h3 id="site生命周期"><a href="#site生命周期" class="headerlink" title="site生命周期"></a>site生命周期</h3><p>Maven Site 插件一般用来创建新的报告文档、部署站点等</p><ul><li>pre-site：执行一些需要在生成站点文档之前完成的工作</li><li>site：生成项目的站点文档</li><li>post-site： 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备</li><li>site-deploy：将生成的站点文档部署到特定的服务器上</li></ul><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。<br>对于单元测试中单元的含义，一般来说，要根据实际情况去判定其具体含义，如C语言中单元指一个函数，Java里单元指一个类，图形化的软件中可以指一个窗口或一个菜单等。<br>总的来说，单元就是人为规定的最小的被测功能模块。单元测试是在软件开发过程中要进行的最低级别的测试活动，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试。</p><p>JUnit 是一个 Java 编程语言的单元测试框架。JUnit 在测试驱动的开发方面有很重要的发展，是起源于 JUnit 的一个统称为 xUnit 的单元测试框架之一</p><a class="btn-beautify button--animated block blue right" href="https://www.shiming.online/blog/8981/"   title="SpringCore"><i class="far fa-hand-point-right fa-fw"></i><span>SpringCore</span></a>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet</title>
      <link href="blog/55715/"/>
      <url>blog/55715/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Servlet概念"><a href="#Servlet概念" class="headerlink" title="Servlet概念"></a>Servlet概念</h2><p>Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为  来自 Web 浏览器或其他 HTTP 客户端的请求  和 HTTP 服务器上的数据库或应用程序  之间的中间层。(处理请求和响应)</p><p>Java Servlet 通常情况下与使用 CGI（Common Gateway Interface，公共网关接口）实现的程序可以达到异曲同工的效果。但是相比于 CGI，Servlet 有以下几点优势：</p><ul><li>性能明显更好。<br>Servlet 在 Web 服务器的地址空间内执行。这样它就没有必要再创建一个单独的进程来处理每个客户端请求。</li><li>Servlet 是独立于平台的，因为它们是用 Java 编写的。<br>服务器上的 Java 安全管理器执行了一系列限制，以保护服务器计算机上的资源。因此，Servlet 是可信的。</li><li>Java 类库的全部功能对 Servlet 来说都是可用的。它可以通过 sockets 和 RMI 机制与 applets、数据库或其他软件进行交互。<br>Servlet 架构</li></ul><p>下图显示了 Servlet 在 Web 应用程序中的位置。</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200807222056.png" alt="servlet位置"></p><h2 id="Servlet-任务"><a href="#Servlet-任务" class="headerlink" title="Servlet 任务"></a>Servlet 任务</h2><p>Servlet 执行以下主要任务：</p><ul><li>读取客户端（浏览器）发送的显式的数据。这包括网页上的 HTML 表单，或者也可以是来自 applet 或自定义的 HTTP 客户端程序的表单。</li><li>读取客户端（浏览器）发送的隐式的 HTTP 请求数据。这包括 cookies、媒体类型和浏览器能理解的压缩格式等等。</li><li>处理数据并生成结果。这个过程可能需要访问数据库，执行 RMI 或 CORBA 调用，调用 Web 服务，或者直接计算得出对应的响应。</li><li>发送显式的数据（即文档）到客户端（浏览器）。该文档的格式可以是多种多样的，包括文本文件（HTML 或 XML）、二进制文件（GIF 图像）、Excel 等。</li><li>发送隐式的 HTTP 响应到客户端（浏览器）。这包括告诉浏览器或其他客户端被返回的文档类型（例如 HTML），设置 cookies 和缓存参数，以及其他类似的任务。</li></ul><h2 id="Servlet-包"><a href="#Servlet-包" class="headerlink" title="Servlet 包"></a>Servlet 包</h2><p>Java Servlet 是运行在带有支持 Java Servlet 规范的解释器的 web 服务器上的 Java 类。<br>Servlet 可以使用 javax.servlet 和 javax.servlet.http 包创建，它是 Java 企业版的标准组成部分，Java 企业版是支持大型开发项目的 Java 类库的扩展版本<br>这些类实现 Java Servlet 和 JSP 规范。<br>Java Servlet 就像任何其他的 Java 类一样已经被创建和编译。在您安装 Servlet 包并把它们添加到您的计算机上的 Classpath 类路径中之后，您就可以通过 JDK 的 Java 编译器或任何其他编译器来编译 Servlet。</p><h2 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h2><p>Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程：</p><ul><li>Servlet 通过调用 init () 方法进行初始化。<br>init 方法被设计成只调用一次。它在第一次创建 Servlet 时被调用，在后续每次用户请求时不再调用。可以在方法简单地创建或加载一些数据，这些数据将被用于 Servlet 的整个生命周期。</li><li>Servlet 调用 service() 方法来处理客户端的请求。<br>service() 方法是执行我们业务逻辑的主要方法。每次有请求到达Servlet时,执行该方法 。</li><li>Servlet 通过调用 destroy() 方法终止（结束）。<br>destroy() 方法只会被调用一次，在Servlet 容器关闭时执行 ,此时Servlet 生命周期结束。</li><li>最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。</li></ul><h2 id="Filter和Listener"><a href="#Filter和Listener" class="headerlink" title="Filter和Listener"></a>Filter和Listener</h2><h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><p>实现了javax.servlet.Filter接口，因此一定要实现javax.servlet包的Filter接口的三个方法init()、doFilter()、destroy()，空实现也行。Filter不像Servlet，它不能产生一个请求或者响应，它只是修改对某一资源的请求，或者修改对某一资源的响应。在启动服务器时会加载过滤器的实例，并调用init()方法来初始化实例；当每一次请求时都只调用方法doFilter()进行处理；停止服务器时调用destroy()方法，销毁实例。</p><h3 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h3><p>Servlet,Filter都是针对url之类的，而Listener是针对对象的操作的，如session的创建，session.setAttribute的发生，在这样的事件发生时做一些事情。<br>Tomcat和Servlet容器<br>Servlet容器主要是JavaWeb应用提供运行时环境，所以也可以称之为JavaWeb应用容器，或者Servlet/JSP容器。Servlet容器主要负责管理Servlet、JSP的生命周期以及它们的共享数据。</p><h2 id="JSP和Servlet区别"><a href="#JSP和Servlet区别" class="headerlink" title="JSP和Servlet区别"></a>JSP和Servlet区别</h2><p>JSP：</p><ul><li>JSP是 Servlet 的扩展，本质上还是 Servlet</li><li>每个 JSP 页面就是一个 Servlet 实例</li><li>JSP 页面会被 Web 容器编译成 Servlet，Servlet 再负责响应用户请求</li></ul><p>区别：</p><ol><li>Servlet在Java代码中可以通过HttpServletResponse对象动态输出HTML内容。</li><li>JSP是在静态HTML内容中嵌入Java代码，然后Java代码在被动态执行后生成HTML内容。</li></ol><div class="note info flat"><ul><li>JSP就是在html里面写java代码，servlet就是在java里面写html代码</li><li>JSP更注重前端显示，servlet更注重模型和业务逻辑。</li></ul></div><a class="btn-beautify button--animated block blue right" href="https://www.shiming.online/blog/4780/"   title="SpringMVC"><i class="far fa-hand-point-right fa-fw"></i><span>SpringMVC</span></a>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> Java Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC</title>
      <link href="blog/4780/"/>
      <url>blog/4780/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。</p><ul><li>Model（模型）是应用程序中用于处理应用程序数据逻辑的部分。<br>  通常模型对象负责在数据库中存取数据。</li><li>View（视图）是应用程序中处理数据显示的部分。<br>  通常视图是依据模型数据创建的。</li><li>Controller（控制器）是应用程序中处理用户交互的部分。<br>  通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。</li></ul><p>MVC的目的是将Model和View的实现代码分离，从而使同一个程序可以使用不同的表现形式。对于同一批数据（Model），可以通过不同的View以不同的形式展示给用户。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="Servlet3-0之前"><a href="#Servlet3-0之前" class="headerlink" title="Servlet3.0之前"></a>Servlet3.0之前</h3><p>步骤</p><ol><li>添加依赖</li><li>配置spring-config.xml</li><li>配置视图解析器</li><li>配置DispatcherServlet</li></ol><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>当Tomcat启动时，就会创建DispatcherServlet的对象，并且，DispatcherServlet会读取所配置的spring-configs.xml文件，以加载Spring环境，后续，DispatcherServlet将接收所有以.do为后缀的请求！</p><h3 id="路径映射"><a href="#路径映射" class="headerlink" title="路径映射"></a>路径映射</h3><ul><li>一个action配置多个URL映射<br><code>@RequestMapping(value=&#123;“/index”, “/hello”&#125;, method = &#123;RequestMethod.GET&#125;)</code></li><li>URL请求参数映射<br><code>@RequestMapping(value=&quot;/detail/&#123;id&#125;&quot;, method = &#123;RequestMethod.GET&#125;)</code><br>通过<code>@PathVariable(value=&quot;id&quot;) Integer id</code>接收</li><li>URL通配符映射“？”表示1个字符，“*”表示匹配多个字符，“**”表示匹配0个或多个路径<br>SpringMVC会按照最长匹配优先原则（即映射配置中哪个匹配的最多）来匹配。</li><li>URL正则表达式映射Spring MVC还支持正则表达式方式的映射配置</li></ul><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><ul><li>@RequestParam，绑定单个请求数据，可以是URL中的数据，表单提交的数据或上传的文件；可以和@RequestBody同用</li><li>@PathVariable，绑定URL模板变量值；</li><li>@CookieValue，绑定Cookie数据；</li><li>@RequestHeader，绑定请求头数据；</li><li>@ModelAttribute，绑定数据到Model；</li><li>@SessionAttributes，绑定数据到Session；</li><li>@RequestBody，用来处理Content-Type不是application/x-www-form-urlencoded编码的内容，例如application/json, application/xml等；</li><li>@RequestPart，绑定“multipart/data”数据，并可以根据数据类型进项对象转换；</li></ul><h4 id="RequestBody-和-RequestParam的区别"><a href="#RequestBody-和-RequestParam的区别" class="headerlink" title="@RequestBody 和 @RequestParam的区别"></a>@RequestBody 和 @RequestParam的区别</h4><h5 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h5><p>用来处理Content-Type: 为 application/x-www-form-urlencoded编码的内容。（Http协议中，如果不指定Content-Type，则默认传递的参数就是application/x-www-form-urlencoded类型）</p><p>RequestParam可以接受简单类型的属性，也可以接受对象类型。<br>实质是将Request.getParameter() 中的Key-Value参数Map利用Spring的转化机制ConversionService配置，转化成参数接收对象或字段。</p><h5 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h5><p>处理HttpEntity传递过来的数据，一般用来处理非Content-Type: application/x-www-form-urlencoded编码格式的数据。</p><p>GET请求中，因为没有HttpEntity，所以@RequestBody并不适用。<br>POST请求中，通过HttpEntity传递的参数，必须要在请求头中声明数据的类型Content-Type，SpringMVC通过使用HandlerAdapter 配置的HttpMessageConverters来解析HttpEntity中的数据，然后绑定到相应的bean上。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>在GET请求中，不能使用@RequestBody。<br>在POST请求，可以使用@RequestBody和@RequestParam，但是如果使用@RequestBody，对于参数转化的配置必须统一。<br>RequestBody和RequestParam同时使用时，RequestParam等于get传输，加在url上。</p><h2 id="SpringMVC运行流程"><a href="#SpringMVC运行流程" class="headerlink" title="SpringMVC运行流程"></a>SpringMVC运行流程</h2><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200819205025.png" alt="20200819205025"></p><ol><li>用户发送请求至前端控制器DispatcherServlet。</li><li>DispatcherServlet收到请求调用HandlerMapping处理器映射器。</li><li>处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</li><li>DispatcherServlet调用HandlerAdapter处理器适配器。</li><li>HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。</li><li>Controller执行完成返回ModelAndView。</li><li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。</li><li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器。</li><li>ViewReslover解析后返回具体View。</li><li>ispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。</li><li>DispatcherServlet响应用户。</li></ol><h2 id="实现REST"><a href="#实现REST" class="headerlink" title="实现REST"></a>实现REST</h2><p>RESTful即Representational State Transfer （资源）“表现层状态转换”。RESTful不是一种标准，而是一种设计风格。<br>优点: 结构清晰、符合标准、易于理解、扩展方便<br>RESTful本质上是一种分布式系统的应用层解决方案，它的主要作用是充分并正确利用HTTP协议的特性，规范资源获取的URL路径。<br>通俗地讲，RESTful风格的设计允许将参数通过URL拼接传到服务端，目的是让URL看起来更简洁实用。并且对于不同操作，要指定不同的HTTP方法（POST/GET/PUT/DETELE）。<br>可以这么说，只要是具有上述相关约束条件和原则的应用程序或设计就可以被称为RESTful风格的应用。</p><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>URI: /资源名称/资源标识  HTTP请求方式区分资源CRUD操作</p><table><thead><tr><th align="center"></th><th align="center">普通CRUD(uri来区分操作)</th><th align="center">RESTfulCRUD</th></tr></thead><tbody><tr><td align="center">查询</td><td align="center">getEmp</td><td align="center">emps–GET</td></tr><tr><td align="center">添加</td><td align="center">addEmp</td><td align="center">emps–POST</td></tr><tr><td align="center">修改</td><td align="center">updateEmp?id=xxx</td><td align="center">emps/{id}–PUT</td></tr><tr><td align="center">删除</td><td align="center">deleteEmp?id=xxx</td><td align="center">emps/{id}–DELETE</td></tr></tbody></table><p>如上：uri中不应该包含动词，只能有名词，并且名词中也应该使用复数。实现者应使用相应的Http动词GET、POST、PUT、PATCH、DELETE、HEAD来操作这些资源即可</p><h3 id="返回数据格式"><a href="#返回数据格式" class="headerlink" title="返回数据格式"></a>返回数据格式</h3><p>对于合法的请求应该统一返回数据格式，这里演示的是json</p><ul><li>code——包含一个整数类型的HTTP响应状态码。</li><li>status——包含文本：”success”，”fail”或”error”。HTTP状态响应码在500-599之间为”fail”，在400-499之间为”error”，其它均为”success”（例如：响应状态码为1XX、2XX和3XX）。这个根据实际情况其实是可要可不要的。</li><li>message——当状态值为”fail”和”error”时有效，用于显示错误信息。参照国际化（il8n）标准，它可以包含信息号或者编码，可以只包含其中一个，或者同时包含并用分隔符隔开。</li><li>data——包含响应的body。当状态值为”fail”或”error”时，data仅包含错误原因或异常名称、或者null也是可以的</li></ul><p>成功：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;status&quot;</span>: <span class="string">&quot;successs&quot;</span>,</span><br><span class="line">  <span class="string">&quot;code&quot;</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="string">&quot;message&quot;</span>: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">  <span class="string">&quot;data&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;userName&quot;</span>: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">16</span>,</span><br><span class="line">    <span class="string">&quot;address&quot;</span>: <span class="string">&quot;beijing&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>失败：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;status&quot;</span>: <span class="string">&quot;fail&quot;</span>,</span><br><span class="line">  <span class="string">&quot;code&quot;</span>: <span class="number">401</span>,</span><br><span class="line">  <span class="string">&quot;message&quot;</span>: <span class="string">&quot;error  message&quot;</span>,</span><br><span class="line">  <span class="string">&quot;data&quot;</span>: <span class="keyword">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="REST配置"><a href="#REST配置" class="headerlink" title="REST配置"></a>REST配置</h3><p>修改路径配置，过滤所有请求类型的请求至前端控制器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="静态资源访问"><a href="#静态资源访问" class="headerlink" title="静态资源访问"></a>静态资源访问</h3><ul><li><p>原因：<br>由于JavaWeb的保护机制，WEB-INF文件夹下的文件不可以直接访问，但配置拦截后所有静态资源访问都会被拦截；</p></li><li><p>解决方法：</p><ul><li><p>单个放行：在SpringMVC的核心配置文件中使用<a href="mvc:resource">mvc:resource</a>标签配置静态资源的解析路径，将需要加载的静态资源的URI路径配置在标签中，然后配置该URI映射的真实资源路径。例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 静态资源的解析，包括：js/css/img... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">&quot;/js/&quot;</span> <span class="attr">mapping</span>=<span class="string">&quot;/js/**&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">&quot;/css/&quot;</span> <span class="attr">mapping</span>=<span class="string">&quot;/css/**&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">&quot;/img/&quot;</span> <span class="attr">mapping</span>=<span class="string">&quot;/img/**&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>当在SpringMVC的核心配置文件中配置了静态资源文件的解析路径后，前端控制器就会根据请求URL中的具体子路径来映射出静态资源的真实路径，然后为前端反馈真实的静态资源信息。</p></li><li><p>全部放行：在SpringMVC的核心配置文件中使用<code>&lt;mvc:default-servlet-handler/&gt;</code>配置默认的Servlet处理器。<br>该配置将在SpringMVC上下文中定义一个DefaultServletHttpRequestHandler，它会对进入DispatcherServlet前端控制器的请求进行筛查，如果发现是没有经过映射的请求，就将该请求交由Web应用服务器默认的Servlet处理，如果不是静态资源的请求，才由DispatcherServlet前端控制器继续处理。此时就可以将请求中的静态资源与其他业务请求分开处理，从而正常地返回静态资源信息。<br><code>&lt;mvc:default-servlet-handler/&gt;</code></p></li></ul></li></ul><h2 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h2><p>当系统启动的时候会将所有权限信息加入到Map集合，URL作为key，有此权限访问该URL的角色作为value；然后具体某个用户登录的时候会首先获取其对应的角色，存到session中；当该用户访问某个具体的URL时会进行角色判断其是否由此权限进行访问</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>定义拦截器</p><!-- 定义拦截器，判断登陆 --><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**/*.js&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.xqm.filter.LoginInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><p>定义一个类在启动的时候加载所有功能对应的权限</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorityCache</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; Authority_MAP = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line"><span class="comment">// 如1-交易所  2-机构管理员 24-表示仓库机构有权限</span></span><br><span class="line"><span class="comment">//定义访问网页需要的权限</span></span><br><span class="line">Authority_MAP.put(<span class="string">&quot;/warehouse/init&quot;</span>, <span class="string">&quot;,1,24,29&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义拦截方法继承HandlerInterceptorAdapter并重写其三个方法，在Controller之前执行</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/kebi007/article/details/102927209">面试官：你连RESTful都不知道我怎么敢要你？</a></p><a class="btn-beautify button--animated block blue right" href="https://www.shiming.online/blog/56612/"   title="SSM搭建"><i class="far fa-hand-point-right fa-fw"></i><span>SSM搭建</span></a>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> RESTful </tag>
            
            <tag> 权限控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM搭建</title>
      <link href="blog/56612/"/>
      <url>blog/56612/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200807222302.png" alt="ssm结构"></p><ol><li>修改web.xml配置文件的内容</li><li>添加mybatis、spring_mvc、spring_config的xml文件，放置在资源文件夹根目录，也可以在这里创建分别的目录</li><li>把mybatis的mapper.xml文件放置到资源文件夹中，不再与pojo同包</li><li>创建controller、pojo、service包，分别创建controller类、pojo对象和接口、service类（选：common:常量类，dto：返回对象类，utils：工具类）</li></ol><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-expression<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.json<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>json<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>20180130<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">--Jstl依赖--</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>taglibs<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>standard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">--插件lombok依赖--</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="修改web-xml文件"><a href="#修改web-xml文件" class="headerlink" title="修改web.xml文件"></a>修改web.xml文件</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;3.1&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--Spring核心监听器 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--在服务器启动时加载Spring容器，且只会加载一次 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring_config.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--配置springmvc --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置初始化参数：作用是配置SpringMVC配置文件的位置和名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring_mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--配置由Spring 提供的针对中文乱码的编码过滤器 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 编码过滤器 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="导入spring-mvc-xml文件"><a href="#导入spring-mvc-xml文件" class="headerlink" title="导入spring_mvc.xml文件"></a>导入spring_mvc.xml文件</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--1.开启Springioc 自动扫描注解包  只对mvc的包做扫描  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;xqm.controller&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--2. 开启注解，对jackson数据支持 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--放行静态资源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--3.配置视图解析器  --&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 配置视图解析器:如何把handle方法返回值解析为实际的物理视图</span></span><br><span class="line"><span class="comment">         name=&quot;prefix&quot;代表前面的目录，为空代表根目录  name=&quot;suffix&quot;代表返回的地址为后缀为.JSP的文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>PS：这里的scan扫描需要单独说明一下，为什么只扫描了mvc的包：<br>在使用注解处理的时候，需要注意一点，web服务器启动的时候，spring-mvc.xml会优先于spring.xml启动，如果工程整包被扫描，那么service会优先于事务先启动，这样就导致事务无法注入管理。<br>所以这里只能扫描mvc包，然后在spring.xml文件中扫描service包，这样就是先启动spring的事务管理注入，再注入service，最后注入controller，这个时候，事务才进入了spring 的IOC管理。结论就是：为了避免这种问题出现，需要在spring_mvc.xml中只扫描controller的包，而在spring.xml的配置中只扫描service的包是否被spring的IOC管理，可以在调用批量增、删、改的时候，通过后台打印查看，没有管理的提示是：<br><em>JDBC Connection [com.mysql.jdbc.JDBC4Connection@7103e78b] will not be managed by Spring</em><br>并且每操作一次数据库，都会创建一个新的session，所以当某一条数据出错时，不会回滚。</p><p>如果纳入管理的提示是：<br><em>JDBC Connection [com.mysql.jdbc.JDBC4Connection@29fd1532]will be managed by Spring</em><br>并且每次操作不会创建新的session，所以当某一条数据出错时，会回滚所有提交内容。</p><p>还有两种情况需要在配置的时候注意:<br>(1)如果只在spring的配置扫描所有包，mvc将无法请求对应的controller；<br>(2)如果在mvc中配置了controller的扫描，在spring的配置中扫描所有包，会出现controller被创建两次；<br>新改动（serivice添加<code>@Transactional</code>注解）事务回滚</p><p>PS：事务需要在spring.xml文件进行配置，后面的spring.xml文件中会注释说明</p><h2 id="spring-mvc-xml中添加json返回编码UTF-8"><a href="#spring-mvc-xml中添加json返回编码UTF-8" class="headerlink" title="spring_mvc.xml中添加json返回编码UTF-8"></a>spring_mvc.xml中添加json返回编码UTF-8</h2><p>如果返回json时，可能在页面得到的json数据会出现乱码，这时候，有两种解决方案，一种是在@RequestMapping中添加属性：<br>produces = {“application/json;charset=UTF-8”}<br>比如下面的效果：<br>@RequestMapping(value=”/login”,produces = {“application/json;charset=UTF-8”})<br>但是这样会在每一个RequestMapping中添加此属性，如果都是这样编写会显得很臃肿，所以我们有一种统一的处理办法，在spring_mvc.xml中添加下面的代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;utf8Charset&quot;</span> <span class="attr">class</span>=<span class="string">&quot;java.nio.charset.Charset&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">factory-method</span>=<span class="string">&quot;forName&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;utf8Charset&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="导入spring-config-xml文件"><a href="#导入spring-config-xml文件" class="headerlink" title="导入spring_config.xml文件"></a>导入spring_config.xml文件</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--1. 配置数据源:阿里数据源  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/ssm&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--2. 配置mybatis的SqlSession的工厂: SqlSessionFactoryBean dataSource:引用数据源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--dataSource属性指定要用到的连接池--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--configLocation属性指定mybatis的核心配置文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis.xml&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 自动扫描mapping.xml文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mapper/*.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--3. 自动扫描mybatis中mapper接口包，</span></span><br><span class="line"><span class="comment">           并且自动注入第二项创建的sessionfactory，初始化所有的mapper接口对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xqm.mapper &quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--4. 扫描service注解 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;xqm.service&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--5. 配置事务管理器  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--6. 开启注解进行事务管理   transaction-manager：引用上面定义的事务管理器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span> /&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="导入mybatis-xml文件"><a href="#导入mybatis-xml文件" class="headerlink" title="导入mybatis.xml文件"></a>导入mybatis.xml文件</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--如果value为true的时候，当返回内容为空时，那么返回的是一个空的对象，而不是null</span></span><br><span class="line"><span class="comment">            如果这里的value为false(默认值)，mybatis在没有查询到内容的时候返回null--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;returnInstanceForEmptyRow&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--显示sql语句，此行配置如果删除，则不在后台显示SQL语句--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>PS：引入mybatis.xml只是为了添加辅助参数配置项，比如显示sql或者控制返回空值等，如果项目中不需要这些配置，直接可以删除掉此文件</p><h2 id="创建mapper文件夹下mapper-xml文件"><a href="#创建mapper文件夹下mapper-xml文件" class="headerlink" title="创建mapper文件夹下mapper.xml文件"></a>创建mapper文件夹下mapper.xml文件</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;UTF-8&#x27;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;xqm.mapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="创建java部分内容"><a href="#创建java部分内容" class="headerlink" title="创建java部分内容"></a>创建java部分内容</h2><p>@Controller注解，在对应的方法上，视图解析器可以解析return 的jsp,html页面，并且跳转到相应页面<br>若返回json等内容到页面，则需要加@ResponseBody注解</p><p>@RestControllerr注解相当于@ResponseBody ＋ @Controller合在一起的作用。Controller中的方法无法返回jsp页面，或者html</p><a class="btn-beautify button--animated block blue right" href="https://www.shiming.online/blog/3a66a386/"   title="Session和Cookie"><i class="far fa-hand-point-right fa-fw"></i><span>Session和Cookie</span></a>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Layui</title>
      <link href="blog/21817/"/>
      <url>blog/21817/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><p>输入框需要设置name属性才能从data.field中提取</p><h2 id="数据表格"><a href="#数据表格" class="headerlink" title="数据表格"></a>数据表格</h2><p>json数据需要设置code = 0 ，count = ？，且data需要为List类型<br>修改静态修改data数据是在弹窗关闭后，所以提交后台数据需要使用获得的数据，不可以直接提交data</p><h3 id="弹出层"><a href="#弹出层" class="headerlink" title="弹出层"></a>弹出层</h3><p>需要定义layer</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">layui.use(<span class="string">&#x27;layer&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">  <span class="keyword">var</span> layer = layui.layer;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> Layui </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown文法</title>
      <link href="blog/492/"/>
      <url>blog/492/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="共六级"><a href="#共六级" class="headerlink" title="共六级"></a>共六级</h6><blockquote><p>引用</p></blockquote><p><strong>加粗</strong><br><em>斜体</em></p><h3 id="图片和链接"><a href="#图片和链接" class="headerlink" title="图片和链接"></a>图片和链接</h3><ul><li>图片 <img src= "/img/loading.gif" data-lazy-src="%E5%9B%BE%E7%89%87url" alt="图片信息"></li><li>链接 <a href="%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80">链接标题</a></li></ul><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">requires_authorization</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">somefunc</span>(<span class="params">param1=<span class="string">&#x27;&#x27;</span>, param2=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;A docstring&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> param1 &gt; param2: <span class="comment"># interesting</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;Greater&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> (param2 - param1 + <span class="number">1</span>) <span class="keyword">or</span> <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>message = <span class="string">&#x27;&#x27;&#x27;interpreter</span></span><br><span class="line"><span class="string"><span class="meta">... </span>prompt&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h3><p><code>import  java</code></p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><table><thead><tr><th align="left">Item</th><th align="right">Value</th><th align="center">Qty</th></tr></thead><tbody><tr><td align="left">左对齐</td><td align="right">右对齐</td><td align="center">居中</td></tr><tr><td align="left">Phone</td><td align="right">12 USD</td><td align="center">12</td></tr><tr><td align="left">Pipe</td><td align="right">1 USD</td><td align="center">234</td></tr></tbody></table><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ol><li>标题1</li></ol><ul><li>-号无序</li></ul><!-- + 无序列表 --><!-- * 无序列表 --><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><hr><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p>加两个空格换行<br>两个空格加回车空行</p><h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h3><h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p><strong>MD001 - Heading levels should only increment by one level at a time</strong><br>标题级数每次只能扩大1, 也就是不能隔级创建标题（从1级到6级的顺序）</p><p><strong>MD002 - First heading should be a top level heading</strong><br>文档的第一个标题必须是最高级的标题（标题等级1级到6级逐渐降低）</p><p>参数：<br>“level”：指定最高级标题的级数，默认是1</p><p><strong>MD003 - Heading style</strong><br>整篇文档要采用一致的标题格式</p><p>参数：<br>“style”：字符串，指定文档标题的格式，有(“consistent”, “atx”, “atx_closed”, “setext”, “setext_with_atx”, “setext_with_atx_closed”)五种，默认是”consistent”，也就是整篇文档一致</p><p>标题格式必须统一，一般不能混用，但”setext_with_atx”, “setext_with_atx_closed”格式可以在”setext”格式二级标题后接着使用”atx”或”atx_closed”格式的标题</p><p><strong>MD004 - Unordered list style</strong><br>整篇文档定义无序列表的格式要一致</p><p>参数：<br>“style”：字符串，指定无序列表的定义格式，有(“consistent”, “asterisk”, “plus”, “dash”, “sublist”)五种，分别表示“定义时符号前后一致”，“用星号定义”，“用加号定义”，“用减号定义”，“定义多重列表时用不同的符号定义”，默认是”consistent”</p><p><strong>MD005 - Inconsistent indentation for list items at the same level</strong><br>同一级的列表缩进必须一致<br>在有序列表中，前面的数字序号可以左对齐，也可以右对齐</p><p><strong>MD006 - Consider starting bulleted lists at the beginning of the line</strong><br>1级列表不能缩进</p><p><strong>MD007 - Unordered list indentation</strong><br>无序列表嵌套缩进时默认采用两个空格</p><p>参数：<br>“ident”：指定无序列表嵌套时缩进的空格数，默认是2</p><p><strong>MD009 - Trailing spaces</strong><br>行尾最多可以添加两个空格，超过会给出警告，两个空格正好可以用于换行</p><p>参数：<br>“br_spaces”：指定在行尾可以添加的空格数目，空格数目建议大于等于2，如果小于2，会默认为0，也就是不允许任何行尾的空格<br>“list_item_empty_lines”：字符串，指定在列表中是否(true or false)用默认的空格数缩进空行，有的解释器会要求列表中的空行要缩进</p><p><strong>MD010 - Hard tabs</strong><br>不能使用tab键缩进，要使用空格</p><p>参数：<br>“code_blocks”：指定本条规则在代码块里是否(true or false)生效</p><p><strong>MD011 - Reversed link syntax</strong><br>检查内联形式的链接的创建方式是否错误，中括号和圆括号是否用对</p><p><strong>MD012 - Multiple consecutive blank lines</strong><br>文档中不能有连续的空行，在代码块中此规则不会生效</p><p>参数：<br>“maximum”：指定文档中可以连续的最多空行数，默认值是1</p><p><strong>MD013 - Line length</strong><br>默认行的最大长度是80，此规则对代码块、表格、标题也生效</p><p>参数：<br>“line_length”：指定行的最大长度，默认是80<br>“heading_line_length”：指定标题行的最大长度，默认是80<br>“code_blocks”：指定规则是否(true or false)对代码块生效，默认true<br>“tables”：指定规则是否(true or false)对表格生效，默认true<br>“hesdings”：指定规则是否(true or false)对标题生效，默认true</p><p><strong>MD014 - Dollar signs used before commands without showing output</strong><br>在代码块中，终端命令前不需要有美元符号($)<br>如果代码块中既有终端命令，也有命令的输出，则终端命令前可以有美元符号($)，如：</p><p>在”atx”格式的标题中，#号和文字间需用一个空格隔开</p><p><strong>MD019 - Multiple spaces after hash on atx style heading</strong><br>在”atx”格式的标题中，#号和文字间只能用一个空格隔开，不能有多余的空格</p><p><strong>MD020 - No space inside hashes on closed atx style</strong> heading<br>在”closed_atx”格式的标题中，文字和前后的#号之间需用一个空格隔开</p><p><strong>MD021 - Multiple spaces inside hashes on closed atx style heading</strong><br>在”closed_atx”格式的标题中，文字和前后的#号之间只能用一个空格隔开，不能有多余的空格</p><p><strong>MD022 - Headings should be surrounded by blank lines</strong><br>标题行的上下行必须都是空行</p><p>参数：<br>“lines_above”：指定标题行上方的空行数，默认为1，可以设为更大或0<br>“lines_below”：指定标题行下方的空行数，默认为1，可以设为更大或0</p><p>注意当此处的空行设为比1大的数时，规则MD012的设置也要改</p><p><strong>MD023 - Headings must start at the beginning of the line</strong><br>标题行不能缩进</p><p><strong>MD024 - Multiple headings with the same content</strong><br>文档不能有内容重复的标题</p><p>参数：<br>“siblings_only”：默认为false，设为true时，不同标题下的子标题内容可以重复</p><p><strong>MD025 - Multiple top level headings in the same document</strong><br>同一文档只能有一个最高级的标题，默认是只能有一个1级标题</p><p>参数：<br>“level”：指定文档最高级的标题，默认是1<br>“front_matter_title”：字符串，指定在文档开头处的front matter中的标题，这个标题将作为整篇文档的最高级标题，如果文档中再次出现最高级标题，将会给出警告，另外，如果不想在front matter中指定标题，就把本参数的值设置为””</p><p><strong>MD026 - Trailing punctuation in heading</strong><br>标题行末尾不能有以下标点符号：”.,;:!?”</p><p>参数：<br>“punctuation”：字符串，指定标题行尾不能有的标点符号，默认是”.,;:!?”</p><p>此规则默认的是英文的标点符号，中文标点符号不在规则之内</p><p><strong>MD027 - Multiple spaces after blockquote symbol</strong><br>创建引用区块时，右尖括号 ( &gt; ) 和文字之间有且只能有一个空格</p><p><strong>MD028 - Blank line inside blockquote</strong><br>两个引用区块间不能仅用一个空行隔开或者同一引用区块中不能有空行，如果一行中没有内容，则这一行要用&gt;开头</p><p><strong>MD029 - Ordered list item prefix</strong><br>有序列表的前缀序号格式必须只用1或者从1开始的加1递增数字(“one_or_ordered”)</p><p>参数：<br>“style”：字符串，指定前缀序号的格式，(“one”,”ordered”,”one_or_ordered”,”zero”)，分别表示只用1做前缀，用从1开始的加1递增数字做前缀，只用1或者从1开始的加1递增数字做前缀，只用0做前缀，默认值是”one_or_ordered”</p><p>本条规则支持在前缀序号中补0，以实现对齐，如：</p><p><strong>MD030 - Spaces after list markers</strong><br>列表（有序、无序）的前缀符号和文字之间用1个空格隔开<br>在列表嵌套或者同一列表项中有多个段落时，无序列表缩进两个空格，有序列表缩进3个空格</p><p>参数：<br>“ul_single”,”ol_single”,”ul_multi”,”ol_multi”：分别规定无序列表单个段落，有序列表单个段落，无序列表多个段落，有序列表多个段落的前缀符号和文字之间的空格数，默认是1</p><p><strong>MD031 - Fenced code blocks should be surrounded by blank lines</strong><br>单独的代码块前后需要用空行隔开（除非是在文档开头或末尾），否则有些解释器不会解释为代码块</p><p><strong>MD032 - Lists should be surrounded by blank lines</strong><br>列表（有序、无序）前后需要用空行隔开，否则有些解释器不会解释为列表<br>列表的缩进必须一致，否则会警告</p><p><strong>MD033 - Inline HTML</strong><br>文档中不允许使用HTML语句</p><p>参数：<br>“allowed_elements”：自定义允许的元素，是一个字符串数组，默认是空(empty)</p><p><strong>MD034 - Bare URL used</strong><br>单纯的链接地址需要用尖括号 (&lt;&gt;) 包裹，否则有些解释器不会解释为链接</p><p><strong>MD035 - Horizontal rule style</strong><br>创建水平线时整篇文档要统一(consistent)，要和文档中第一次创建水平线使用的符号一致</p><p>参数：<br>“style”：字符串，指定创建水平线的方式，值有：(“consistent”,”***”,”—“,”___”)，默认是”consistent”</p><p><strong>MD036 - Emphasis used instead of a heading</strong><br>不能用强调代替标题</p><p>参数：<br>“punctuation”：字符串，指定用于结尾的标点符号，以此符号结尾的强调不会被视为以强调代替标题，默认值是”.,;:!?”</p><p>此规则会检查只包含强调的单行段落，如果这种段落不是以指定的标点符号结尾，则会被视为以强调代替标题，会给出警告</p><p><strong>MD037 - Spaces inside emphasis markers</strong><br>用于创建强调的符号和强调的的文字之间不能有空格</p><p><strong>MD038 - Spaces inside code span elements</strong><br>当用单反引号创建代码段的时候，单反引号和它们之间的代码不能有空格<br>如果要把单反引号嵌入到代码段的首尾，创建代码段的单反引号和嵌入的单反引号间要有一个空格隔开</p><p><strong>MD039 - Spaces inside link text</strong><br>链接名和包围它的中括号之间不能有空格，但链接名中间可以有空格，如：<a href="http://www.baidu.com/" title="百 度">百 度</a></p><p><strong>MD040 - Fenced code blocks should have a language specified</strong><br>单独的代码块（此处是指上下用三个反引号包围的代码块）应该指定代码块的编程语言，这一点有助于解释器对代码进行代码高亮</p><p><strong>MD041 - First line in file should be a top level heading</strong><br>文档的第一个非空行应该是文档最高级的标题，默认是1级标题</p><p>参数：<br>“level”：指定文档最高级的标题，默认是1<br>“front_matter_title”：字符串，指定在文档开头处的front matter中的标题，这个标题将作为整篇文档的最高级标题，另外，如果不想在front matter中指定标题，就把本参数的值设置为””</p><p><strong>MD042 - No empty links</strong><br>链接的地址不能为空</p><p><strong>MD043 - Required heading structure</strong><br>要求标题遵循一定的结构，默认是没有规定的结构(“null”)</p><p>参数：<br>“headings”：字符串数组，指定标题需要遵循的结构，默认是”null”，可以自行指定结构，如；</p><p>星号(*)表示对应的标题是可选的，没有强制要求，本条具体可以参照MD043</p><p><strong>MD044 - Proper names should have the correct capitalization</strong><br>指定一些名称，会检查它是否有正确的大写</p><p>参数：<br>“names”：字符串数组，指定要检查需要大写的名称，默认是空(“null”)<br>“code_blocks”：指定本规则是否(true or false)对代码块生效，默认是true<br>一些经常使用的名称可以使用本规则防止其拼写错误，比如JavaScript中字母J和S需要大写，就可以写到参数”names”中，防止写错</p><p><strong>MD045 - Images should have alternate text (alt text)</strong><br>图片链接必须包含描述文本（alt text）</p><p><strong>MD046 - Code block style</strong><br>整篇文档采用一致的代码格式</p><p>参数：<br>“style”: 字符串，指定代码块定义格式，有（”consistent”,”fenced”,”indented”）三种，分别代表：文档上下文一致，使用三个反引号隔开，使用缩进，默认是上下文一致</p><p><strong>MD047 - Files should end with a single newline character</strong><br>文档需用一个空行结尾</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis &quot;#&quot; 和 &quot;$&quot; 区别</title>
      <link href="blog/397/"/>
      <url>blog/397/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Mybatis中sql语句共有三种执行方式</p><table><thead><tr><th align="center">选项</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">STATEMENT</td><td align="center">直接操作sql，不进行预编译，获取数据：$–Statement</td></tr><tr><td align="center">PREPARED</td><td align="center">预处理，参数，进行预编译，获取数据：#–PreparedStatement</td></tr><tr><td align="center">CALLABLE</td><td align="center">执行存储过程—CallableStatement</td></tr></tbody></table><p>MyBatis默认使用PREPARED方式，即<code>#&#123;&#125;</code>。</p><ol><li><p>传入的参数在SQL中显示不同<br> 使用<code>$&#123;&#125;</code>方式传入的参数，mybatis不会对它进行特殊处理，而使用<code>#&#123;&#125;</code>传进来的参数，mybatis默认会将其当成字符串。可能在赋值给如<code>id=#&#123;id&#125;</code>和<code>id=$&#123;id&#125;</code>看不出多大区别，但是作为表名或字段参数时可以明显看出，<br> 例：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">selec * from #&#123;table&#125;;</span><br><span class="line">- 解析后为：<span class="keyword">select</span> * <span class="keyword">from</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> $&#123;<span class="keyword">table</span>&#125;;</span><br><span class="line">- 解析后为：<span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span>;</span><br></pre></td></tr></table></figure><p> 前者转换为字符串，会查询失败。所以对于传入分组(order)字段或者排序字段(order)，应使用${},避免出现<code>order by &quot;id&quot;</code>等情况。</p></li><li><p>#和$在预编译处理中是不一样的。<br>#类似jdbc中的PreparedStatement，对于传入的参数，在预处理阶段会使用?代替，比如：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">id</span> = ?;</span><br></pre></td></tr></table></figure><p> 真正查询时才会带入参数，而而${}则是简单的替换</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>传入的参数在SQL中显示不同</li><li><code>#&#123;&#125;</code>可以防止sql注入，能使用<code>#&#123;&#125;</code>的地方应该使用<code>#&#123;&#125;</code></li><li><code>$&#123;&#125;</code>方式一般用于传递数据库对象，例：表名，字段名，甚至sql语句</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ul><li><a href="https://blog.csdn.net/zymx14/article/details/78067452">mybatis中的#和$的区别</a></li></ul></blockquote><a class="btn-beautify button--animated block blue right" href="https://www.shiming.online/blog/60c9167b/"   title="MyBatis分页"><i class="far fa-hand-point-right fa-fw"></i><span>MyBatis分页</span></a>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="blog/40121/"/>
      <url>blog/40121/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note error flat"><p>本篇博客内容只包含极少内容，仅供参考</p></div><h2 id="Java概念"><a href="#Java概念" class="headerlink" title="Java概念"></a>Java概念</h2><p>Java之父：詹姆斯·高斯林</p><h3 id="JDK-和-JRE-区别"><a href="#JDK-和-JRE-区别" class="headerlink" title="JDK 和 JRE 区别"></a>JDK 和 JRE 区别</h3><ul><li>JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。</li><li>JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。</li></ul><p>JDK包含JRE和编译器javac，还包含很多 java 程序调试和分析的工具。JRE（Java运行时环境）包含虚拟机但是不包含编译器。<br>简单来说：如果需要运行 java 程序，只需安装 JRE ，如果需要编写 java 程序，则需要安装 JDK。</p><h2 id="Java安装与配置"><a href="#Java安装与配置" class="headerlink" title="Java安装与配置"></a>Java安装与配置</h2><p>Java -version：检测jdk是否安装<br>javac：检测环境变量<br>环境变量：</p><ul><li>新建系统变量：<ul><li>JAVA_HOME</li><li>jdk路径，例：C:\Java\jdk1.8.0_241<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200831131039.png" alt="20200831131039"></li></ul></li><li>系统变量path添加：<ul><li>%JAVA_HOME%/bin</li><li>%JAVA_HOME%/jre/bin<br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200831131115.png" alt="20200831131115"></li></ul></li></ul><p>特性</p><table><thead><tr><th align="center">编号</th><th align="center">名称</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">简单性</td></tr><tr><td align="center">2</td><td align="center">面向对象</td></tr><tr><td align="center">3</td><td align="center">分布式</td></tr><tr><td align="center">4</td><td align="center">健壮性</td></tr><tr><td align="center">5</td><td align="center">安全性</td></tr><tr><td align="center">6</td><td align="center">体系结构中立</td></tr><tr><td align="center">7</td><td align="center">可移植性</td></tr><tr><td align="center">8</td><td align="center">解释型</td></tr><tr><td align="center">9</td><td align="center">高性能</td></tr><tr><td align="center">10</td><td align="center">多线程</td></tr><tr><td align="center">11</td><td align="center">动态性</td></tr></tbody></table><h2 id="基本语言程序结构"><a href="#基本语言程序结构" class="headerlink" title="基本语言程序结构"></a>基本语言程序结构</h2><h3 id="基本变量类型"><a href="#基本变量类型" class="headerlink" title="基本变量类型"></a>基本变量类型</h3><p>Java是一种强类型语言。必须为每一个变量声明一种类型。在Java中，一共有8 种基本类型(primitivetype), 其中有4种整型(byte,short,int,long)、2种浮点类型(float,double)、1种用于表示Unicode编码的字符单元的字符类型char和1种用于表示真值的boolean类型。</p><p>在java中，整形的范围和运行java的平台无关，而c和c++和机器有关</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>Java中的基本数据类型只有8个，而除了基本数据类型和枚举类型都是引用类型。所以String是引用类型。</p><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><table><thead><tr><th align="center">方法名</th><th align="center">代码</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">charAt()</td><td align="center">char charAt(int index )</td><td align="center">返回指定索引处的字符</td></tr><tr><td align="center">indexOf(String str,int fromIndex)</td><td align="center">int indexOf()</td><td align="center">返回与 字符串匹配的第一个子串的位置，从0或者fromIndex开始，如果不存在，返回-1</td></tr><tr><td align="center">replace()</td><td align="center">String replace(char oldChar, char newChar)</td><td align="center">用newChar替换oldChar</td></tr><tr><td align="center">trim()</td><td align="center">String                  trim()</td><td align="center">去除字符串两端空白。</td></tr><tr><td align="center">split()</td><td align="center">String[] split(String regex[, int limit])</td><td align="center">用匹配的表达式分割字符串</td></tr><tr><td align="center">getBytes()</td><td align="center">byte[] getBytes()</td><td align="center">返回字符串的 byte 类型数组。</td></tr><tr><td align="center">length()</td><td align="center">int length()</td><td align="center">返回字符串长度。</td></tr><tr><td align="center">toLowerCase()</td><td align="center">String toLowerCase()</td><td align="center">将字符串转成小写字母。</td></tr><tr><td align="center">toUpperCase()</td><td align="center">String toUpperCase()</td><td align="center">将字符串转成大写字符。</td></tr><tr><td align="center">substring()</td><td align="center">String s =”hello”.substring(0,3);</td><td align="center">截取字符串  s = “hel” 即从0到2，不包括3</td></tr><tr><td align="center">+</td><td align="center">String s = a+b;</td><td align="center">用+拼接字符串</td></tr><tr><td align="center">join()</td><td align="center">String all = String.join(“/“,”S”,”M”,”L”,”XL”)</td><td align="center">all = “S/M/L/XL”; 分隔符连接字符串</td></tr><tr><td align="center">equals()</td><td align="center">str.equals(str1);</td><td align="center">判断字符串是否相等，不可使用==</td></tr></tbody></table><p>字符串是常量，它们的值在创建之后不能更改。StringBuffer,StringBuilder支持可变的字符串。</p><h4 id="空串-“”-和-null"><a href="#空串-“”-和-null" class="headerlink" title="空串 “” 和 null"></a>空串 “” 和 null</h4><ul><li>空串 “” 是长度为0的字符串。可以使用以下代码检查一个字符串是否为空：<br><code>if (str.length() == 0) /if (str .equals(&quot;&quot;))</code></li><li>空串是一个Java对象,有自己的串长度(0)和内容（空）。  </li><li>null表示目前没有任何对象与该变量关联，用str == null判断  </li></ul><h4 id="和-equals-区别"><a href="#和-equals-区别" class="headerlink" title="== 和 equals 区别"></a>== 和 equals 区别</h4><h5 id=""><a href="#" class="headerlink" title="=="></a>==</h5><p>基本类型和引用类型的 == 作用效果不同，具体如下：</p><ul><li><strong>基本类型</strong>：比较值是否相同</li><li><strong>引用类型</strong>：比较引用(内存地址值)是否相同</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">&quot;String&quot;</span>;</span><br><span class="line">String b = <span class="string">&quot;String&quot;</span>;</span><br><span class="line">String c = <span class="keyword">new</span> String(<span class="string">&quot;String&quot;</span>);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">System.out.println(a == b);</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">System.out.println(a == c);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">System.out.println(a.equals(b));</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">System.out.println(a.equals(c));</span><br></pre></td></tr></table></figure><p>因为a和b指向一个同一个引用，所以<code>a == b</code>结果为true，而new String()方法重写开辟了内存空间，所以<code>a == c</code>结果为false，而equals比较的是值，所以结果为true</p><blockquote><p>字符串的分配和其他对象分配一样，是需要消耗高昂的时间和空间的，而且字符串我们使用的非常多。JVM为了提高性能和减少内存的开销，在实例化字符串的时候进行了一些优化：使用字符串常量池。每当我们创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。</p></blockquote><div class="note warning flat"><p>由于String字符串的不可变性我们可以十分肯定常量池中一定不存在两个相同的字符串。<br>反而言之，因为需要实现常量池，所以String使用final修饰，即String字符串的不可变。</p></div><h5 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h5><p>equals方法是Object类的一个方法，Java当中所有的类都是继承于Object这个超类。<br>equals 本质上就是 ==，比较引用是否相同。只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。</p><p>JDK1.8 Object类equals方法源码如下，即返回结果取决于两个对象的使用==判断结果。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际使用中，一般会重写定义的class的equals方法，如JDK1.8 java.lang.String类的equals源码如下。<br>即两个字符串使用 == 相等或者两个字符串的所有组成字符都相等返回true，其他情况返回false。这里就定义String根据equals方法判断是否相等的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    String anotherString = (String) anObject;</span><br><span class="line">    <span class="keyword">int</span> n = value.length;</span><br><span class="line">    <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">      <span class="keyword">char</span> v1[] = value;</span><br><span class="line">      <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在之前的例子中，<code>a.equals(b)</code>和<code>a.equals(c)</code>比较的是a和b的值是相同，a和c的值是否相同，所以结果都为true。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>== 的作用：<ul><li>基本类型：比较值是否相等</li><li>引用类型：比较内存地址值是否相等</li></ul></li><li>equals 的作用:<ul><li>引用类型：默认情况下，比较内存地址值是否相等。可以按照需求逻辑，重写对象的equals方法。</li></ul></li></ul><h4 id="StringBuffer和StirngBuilder"><a href="#StringBuffer和StirngBuilder" class="headerlink" title="StringBuffer和StirngBuilder"></a>StringBuffer和StirngBuilder</h4><p>操作字符串的类有：String、StringBuffer、StringBuilder。</p><p>String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。</p><p>StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。</p><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>if,while(),do while(),for( ; ; ),switch()</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>类是构造对象的蓝图和模板<br>一个java文件可以有无限个类，每个类的权限修饰符只能是public或者没有权限修饰符<br>类中可以创建类<br>方法中不能创建方法<br>方法中可以创建类（不能被外部调用，为方法而存在，只能在方法中调用）<br>方法中的类可以再创建类  </p><p>main不是关键字  </p><p>匿名内部类企业中不允许新建方法，也不允许创建新属性  </p><h3 id="静态属性和方法"><a href="#静态属性和方法" class="headerlink" title="静态属性和方法"></a>静态属性和方法</h3><p>每个类中只有一个静态域，所有对象都调用的同一个值，而每个对象都拥有自己的实例域<br>静态方法不能调用实例，只能调用静态方法  </p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>调用多态对象中的属性时，会调用当前对象的属性值（左侧）  </p><h4 id="多态中属性的隐藏"><a href="#多态中属性的隐藏" class="headerlink" title="多态中属性的隐藏"></a>多态中属性的隐藏</h4><p>属性的隐藏，在继承中，隐藏的是父类的属性，在多态中，隐藏的是子类的属性值  </p><p>类类型转换，必须保证是某一个父类的对象强转为子类的对象  </p><p>多态创建的对象，只拥有当前类型（左侧父类类型）的属性名和对象<br>当调用属性名的时候，取出的值，是当前对象的值<br>当调用方法的时候，会检查子类是否重写，如果重写，会调用子类重写的方法<br>形参只能传当前类型和当前类型的子类类型  </p><p>自动转换：子类对象赋值给父类类型对象<br>强制转换：父类类型对象赋值给子类类型对象<br>多态中的强转，必须存在继承关系  </p><p>不论是类的继承还是接口的继承，都只能单一继承<br>类与类，接口和接口之前不能相互继承  </p><h3 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h3><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><p>java提供了很多修饰符，主要分为访问修饰符和非访问修饰符两类<br>修饰符用来定义类、方法或者变量，通常放在语句的最前端。</p><h5 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h5><p>Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。</p><ul><li>default (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</li><li>private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）</li><li>public : 对所有类可见。使用对象：类、接口、变量、方法</li><li>protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。</li></ul><h5 id="非访问修饰符"><a href="#非访问修饰符" class="headerlink" title="非访问修饰符"></a>非访问修饰符</h5><ul><li>static：用于修饰静态方法和静态变量</li><li>final：修饰类，方法和变量<ul><li>final 修饰的类叫最终类，该类不能被继承。</li><li>final 修饰的方法不能被重写。</li><li>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</li></ul></li><li>abstract：创建抽象类和抽象方法</li><li>synchronized 和 volatile：主要用于线程的编程</li></ul><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><code>public enum size&#123;small,medium,large,extra_large&#125;</code><br>枚举类型是一个类，在比较两个枚举类型时，永远不需要调用equials，直接使用“==”就可以。<br>所有枚举类型都是enum的子类，最有用的是toString,返回枚举常量名(<code>Size.small.toString()返回字符串”small”</code>)。<br>toString的逆方法是valueof()（ <code>Size s = Enum.valueof(Size.class,”small”)</code> 将s设置为Size.small）。<br>有一个静态的values方法，返回一个包括全部枚举值的数组（<code>Size[] values = Size.values()</code>）。<br>ordinal方法返回位置</p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><blockquote><p><a href="https://baike.baidu.com/item/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/6015990">JAVA反射（reflection）机制</a>是指在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。这种动态获取程序信息以及动态调用对象的功能称为Java语言的反射机制。反射被视为动态语言的关键。</p></blockquote><p>能够分析类能力的程序称为反射。反射机制可以用来  </p><ul><li>在运行时分析类的能力</li><li>在运行时查看对象</li><li>实现通用的数组操作代码</li><li>利用Method对象</li></ul><h2 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h2><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类往往用来表征对问题领域进行分析、设计中得出的抽象概念，是对一系列看上去不同，但是本质上相同的具体概念的抽象。</p><p>在Java语言中使用abstract class来定义抽象类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h4><p>Abstract 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。<br>抽象方法的具体实现由它的子类确定，抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">computePay</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="抽象类总结"><a href="#抽象类总结" class="headerlink" title="抽象类总结"></a>抽象类总结</h4><ul><li>抽象类不能被实例化。</li><li>抽象类不一定要有抽象方法，但是抽象方法必须定义在抽象类中。</li><li>任何抽象类的子类必须重写父类的抽象方法或者定义自己为抽象类。</li><li>抽象类不能用final修饰，因为抽象类定义出来就是让其他类继承的，用fianl修饰就不能被继承，编译器中也会提示错误信息。</li><li>构造方法，类方法(static修饰)不能声明为抽象方法</li></ul><blockquote><p>抽象类和普通类的区别:</p><ul><li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li><li>抽象类不能直接实例化，普通类可以直接实例化。</li></ul></blockquote><h3 id="接口的定义和实现"><a href="#接口的定义和实现" class="headerlink" title="接口的定义和实现"></a>接口的定义和实现</h3><p>接口是公开的，不能有私有的方法或变量，接口中的所有方法都没有方法体，通过关键字interface实现。接口中的所有方法都自动属于public  </p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>将类声明为实现给定的接口 implement<br>对接口中的所有方法进行定义  </p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>接口不是类，不能使用new运算符实例化一个接口，但是能声明接口的变量，接口变量必须引用实现了接口的类对象，接口中的域自动设为<code>public static final</code><br>jdk8.0之前接口中只能定义抽象方法，在jdk8.0之后可以定义实现方法（加上关键字default修饰）<br>抽象类的定义和实现</p><h3 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h3><p>接口是对动作的抽象，抽象类是对根源的抽象。<br>抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。比如，男人，女人，这两个类（如果是类的话……），他们的抽象类是人。说明，他们都是人。</p><p>人可以吃东西，狗也可以吃东西，你可以把“吃东西”定义成一个接口，然后让这些类去实现它.</p><p>所以，在高级语言上，一个类只能继承一个类（抽象类）(正如人不可能同时是生物和非生物)，但是可以实现多个接口(吃饭接口、走路接口)。</p><blockquote><p>举例来自<a href="https://www.cnblogs.com/yongjiapei/p/5494894.html">接口和抽象类有什么区别</a></p></blockquote><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><ol><li>都不能被实例化</li><li>接口的实现类或抽象类的子类都只有实现了接口或抽象类中的抽象方法后才能实例化。</li></ol><h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ol><li>接口只有定义，不能有方法的实现，java 1.8中可以定义default方法体，而抽象类可以有定义与实现，方法可在抽象类中实现。</li><li>实现接口的关键字为implements，继承抽象类的关键字为extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。</li><li>接口强调特定功能的实现，而抽象类强调所属关系。</li><li>接口成员变量默认为public static final，必须赋初值，不能被修改；其所有的成员方法都是public、abstract的。抽象类中成员变量默认default，可在子类中被重新定义，也可被重新赋值；抽象方法被abstract修饰，不能被private、static、synchronized和native等修饰，必须以分号结尾，不带花括号。</li><li>接口被用于常用的功能，便于日后维护和添加删除，而抽象类更倾向于充当公共类的角色，不适用于日后重新对立面的代码修改。功能需要累积时用抽象类，不需要累积时用接口。</li></ol><h2 id="发布与部署"><a href="#发布与部署" class="headerlink" title="发布与部署"></a>发布与部署</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>JAR（Java ARchive，Java 归档）是一种与平台无关的文件格式，可将多个文件合成一个文件。<br>用户可将多个 Java applet 及其所需组件（.class 文件、图像和声音）绑定到 JAR 文件中，而后作为单个的简单 HTTP（Hypertext Tranfer Protocal，超文本传输协议）事务下载到浏览器中，从而大大提高下载速度。<br>JAR 格式也支持压缩，从而减小了文件的大小，进一步缩短下载时间。另外，applet 编写者也可在 JAR 文件中用数字签名的方式签写各项以确认其来源。<br>它用 Java 编写，可与现有的 applet 代码完全向后兼容且可充分扩展。</p><p>JAR 文件就是 Java Archive File，顾名思意，它的应用是与 Java 息息相关的，是 Java 的一种文档格式。<br>JAR 文件非常类似 ZIP 文件——准确的说，它就是 ZIP 文件，所以叫它文件包。<br>JAR 文件与 ZIP 文件唯一的区别就是在 JAR 文件的内容中，包含了一个 META-INF/MANIFEST.MF 文件，这个文件是在生成 JAR 文件的时候自动创建的</p><p>Jar文件是跨平台的</p><h3 id="创建jar"><a href="#创建jar" class="headerlink" title="创建jar"></a>创建jar</h3><p>创建一个可执行 JAR 很容易。首先将所有应用程序代码放到一个目录中。假设应用程序中的主类是 <code>com.mycompany.myapp.Sample</code> 。您要创建一个包含应用程序代码的 JAR 文件并标识出主类。为此，在某个位置(不是在应用程序目录中)创建一个名为 manifest 的文件，并在其中加入以下一行：<br><code>Main-Class: com.mycompany.myapp.Sample</code> 然后，像这样创建 JAR 文件：<br><code>jar cmf manifest ExecutableJar.jar application-dir</code></p><h3 id="引用jar"><a href="#引用jar" class="headerlink" title="引用jar"></a>引用jar</h3><p>修改manifest文件，如果有多个jar包需要引用的情况：<br><code>Class-Path: lib/some.jar lib/some2.jar</code><br>每个单独的jar用空格隔开就可以了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ul><li>java核心技术</li><li><a href="https://blog.csdn.net/meism5/article/details/89029475">== 和 equals 的区别</a></li><li><a href="https://cloud.tencent.com/developer/article/1674024">Java String 理解</a></li><li><a href="https://mp.weixin.qq.com/s/IBbD3CmVWsTL9ymHg6gGGA">Java 208 道面试题：第一模块答案</a></li><li><a href="https://blog.csdn.net/zhangquan2015/article/details/82808399">java中接口和抽象类的区别</a></li></ul></blockquote><a class="btn-beautify button--animated block blue right" href="https://www.shiming.online/blog/4509351/"   title="Java集合"><i class="far fa-hand-point-right fa-fw"></i><span>Java集合</span></a>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议</title>
      <link href="blog/8564/"/>
      <url>blog/8564/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="HTTP协议概念"><a href="#HTTP协议概念" class="headerlink" title="HTTP协议概念"></a>HTTP协议概念</h2><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。<br>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。<br>HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。<br>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</p><h2 id="HTTP特性"><a href="#HTTP特性" class="headerlink" title="HTTP特性"></a>HTTP特性</h2><p>HTTP 协议构建于 TCP/IP 协议之上，是一个应用层协议，默认端口号是 80<br>HTTP 是<strong>无连接无状态</strong>的</p><h2 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h2><h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><p>HTTP 协议是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范。规范把 HTTP 请求分为三个部分：状态行、请求头、消息主体。类似于下面这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">method</span>&gt;</span> <span class="tag">&lt;<span class="name">request-URL</span>&gt;</span> <span class="tag">&lt;<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">headers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">entity-body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>HTTP 定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。<br><strong>URL全称是资源描述符,我们可以这样认为：一个URL地址，它用于描述一个网络上的资源.</strong><br>而 HTTP 中的GET，POST，PUT，DELETE就对应着对这个资源的查，增，改，删4个操作。</p><p><strong>GET 用于信息获取，而且应该是安全的和幂等的。</strong></p><p>所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。</p><p>幂等的意味着对同一URL 的多个请求应该返回同样的结果。</p><p>GET 请求报文示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /books/?sex=man&amp;name=Professional HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)</span><br><span class="line">Gecko/20050225 Firefox/1.0.1</span><br><span class="line">Connection: Keep-Alive</span><br></pre></td></tr></table></figure><p>POST 表示可能修改变服务器上的资源的请求。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST /books/ HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)</span><br><span class="line">Gecko/20050225 Firefox/1.0.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 40</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">sex=man&amp;name=Professional  </span><br></pre></td></tr></table></figure><p>注意:<br>GET 可提交的数据量受到URL长度的限制，HTTP 协议规范没有对 URL 长度进行限制。这个限制是特定的浏览器及服务器对它的限制<br>理论上讲，POST 是没有大小限制的，HTTP 协议规范也没有进行大小限制，出于安全考虑，服务器软件在实现时会做一定限制<br>参考上面的报文示例，可以发现 GET 和 POST 数据内容是一模一样的，只是位置不同，一个在 URL 里，一个在 HTTP 包的包体里</p><h3 id="POST-提交数据的方式"><a href="#POST-提交数据的方式" class="headerlink" title="POST 提交数据的方式"></a>POST 提交数据的方式</h3><p>HTTP 协议中规定 POST 提交的数据必须在 body 部分中，但是协议中没有规定数据使用哪种编码方式或者数据格式。实际上，开发者完全可以自己决定消息主体的格式，只要最后发送的 HTTP 请求满足上面的格式就可以。</p><p>但是，数据发送出去，还要服务端解析成功才有意义。一般服务端语言如 PHP、Python 等，以及它们的 framework，都内置了自动解析常见数据格式的功能。服务端通常是根据请求头（headers）中的 Content-Type 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。所以说到 POST 提交数据方案，包含了 Content-Type 和消息主体编码方式两部分。下面就正式开始介绍它们：</p><h4 id="application-x-www-form-urlencoded"><a href="#application-x-www-form-urlencoded" class="headerlink" title="application/x-www-form-urlencoded"></a>application/x-www-form-urlencoded</h4><p>这是最常见的 POST 数据提交方式。浏览器的原生<code>&lt;form&gt;</code>表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。上个小节当中的例子便是使用了这种提交方式。可以看到 body 当中的内容和 GET 请求是完全相同的。</p><h4 id="multipart-form-data"><a href="#multipart-form-data" class="headerlink" title="multipart/form-data"></a>multipart/form-data</h4><p>这又是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 <code>&lt;form&gt;</code>表单的 enctype 等于 multipart/form-data。直接来看一个请求示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">POST http://www.example.com HTTP/1.1</span><br><span class="line">Content-Type:multipart/form-data;boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundaryrGKCBY7qhFd3TrwA</span><br><span class="line">Content-Disposition: form-data; name=&quot;text&quot;</span><br><span class="line"></span><br><span class="line">title</span><br><span class="line">------WebKitFormBoundaryrGKCBY7qhFd3TrwA</span><br><span class="line">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;chrome.png&quot;</span><br><span class="line">Content-Type: image/png</span><br><span class="line"></span><br><span class="line">PNG ... content of chrome.png ...</span><br><span class="line">------WebKitFormBoundaryrGKCBY7qhFd3TrwA--</span><br></pre></td></tr></table></figure><p>这个例子稍微复杂点。首先生成了一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。然后 Content-Type 里指明了数据是以 multipart/form-data 来编码，本次请求的 boundary 是什么内容。<br>消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 –boundary 开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 –boundary– 标示结束。关于 multipart/form-data 的详细定义，请前往 RFC1867 查看（或者相对友好一点的 MDN 文档）。</p><p>这种方式一般用来上传文件，各大服务端语言对它也有着良好的支持。</p><p>上面提到的这两种 POST 数据的方式，都是浏览器原生支持的，而且现阶段标准中原生 <code>&lt;form&gt;</code> 表单也只支持这两种方式（通过 <code>&lt;form&gt;</code> 元素的 enctype 属性指定，默认为 application/x-www-form-urlencoded。其实 enctype 还支持 text/plain，不过用得非常少）。</p><p>随着越来越多的 Web 站点，尤其是 WebApp，全部使用 Ajax 进行数据交互之后，我们完全可以定义新的数据提交方式，例如 application/json，text/xml，乃至 application/x-protobuf 这种二进制格式，只要服务器可以根据 Content-Type 和 Content-Encoding 正确地解析出请求，都是没有问题的。</p><h3 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h3><p>HTTP 响应与 HTTP 请求相似，HTTP响应也由3个部分构成，分别是：</p><ul><li>状态行</li><li>响应头(Response Header)</li><li>响应正文</li></ul><p>状态行由协议版本、数字形式的状态代码、及相应的状态描述，各元素之间以空格分隔。</p><table><thead><tr><th align="center">分类</th><th align="center">分类描述</th></tr></thead><tbody><tr><td align="center">1**</td><td align="center">信息，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td align="center">2**</td><td align="center">成功，操作被成功接收并处理</td></tr><tr><td align="center">3**</td><td align="center">重定向，需要进一步的操作以完成请求</td></tr><tr><td align="center">4**</td><td align="center">客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td align="center">5**</td><td align="center">服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><p>常见的状态码有如下几种：</p><ul><li>200 OK 客户端请求成功</li><li>301 Moved Permanently 请求永久重定向</li><li>302 Moved Temporarily 请求临时重定向</li><li>304 Not Modified 文件未修改，可以直接使用缓存的文件。</li><li>400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。</li><li>401 Unauthorized 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用</li><li>403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因</li><li>404 Not Found 请求的资源不存在，例如，输入了错误的URL</li><li>500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。</li><li>503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。</li></ul><p>下面是一个HTTP响应的例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line"></span><br><span class="line">Server:Apache Tomcat/5.0.12</span><br><span class="line">Date:Mon,6Oct2003 13:23:42 GMT</span><br><span class="line">Content-Length:112</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>...</span><br></pre></td></tr></table></figure><h3 id="条件-GET"><a href="#条件-GET" class="headerlink" title="条件 GET"></a>条件 GET</h3><p>HTTP 条件 GET 是 HTTP 协议为了减少不必要的带宽浪费，提出的一种方案。详见 RFC2616 。</p><p>1.HTTP 条件 GET 使用的时机？</p><p>客户端之前已经访问过某网站，并打算再次访问该网站。</p><p>2.HTTP 条件 GET 使用的方法？</p><p>客户端向服务器发送一个包询问是否在上一次访问网站的时间后是否更改了页面，如果服务器没有更新，显然不需要把整个网页传给客户端，客户端只要使用本地缓存即可，如果服务器对照客户端给出的时间已经更新了客户端请求的网页，则发送这个更新了的网页给用户。</p><p>下面是一个具体的发送接受报文示例：</p><p>客户端发送请求：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1  </span><br><span class="line">Host: www.sina.com.cn:80  </span><br><span class="line">If-Modified-Since:Thu, 4 Feb 2010 20:39:13 GMT  </span><br><span class="line">Connection: Close  </span><br></pre></td></tr></table></figure><p>第一次请求时，服务器端返回请求数据，之后的请求，服务器根据请求中的 If-Modified-Since 字段判断响应文件没有更新，如果没有更新，服务器返回一个 304 Not Modified响应，告诉浏览器请求的资源在浏览器上没有更新，可以使用已缓存的上次获取的文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 304 Not Modified  </span><br><span class="line">Date: Thu, 04 Feb 2010 12:38:41 GMT  </span><br><span class="line">Content-Type: text/html  </span><br><span class="line">Expires: Thu, 04 Feb 2010 12:39:41 GMT  </span><br><span class="line">Last-Modified: Thu, 04 Feb 2010 12:29:04 GMT  </span><br><span class="line">Age: 28  </span><br><span class="line">X-Cache: HIT from sy32-21.sina.com.cn  </span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure><p>如果服务器端资源已经更新的话，就返回正常的响应。</p><h3 id="GET与POST的区别"><a href="#GET与POST的区别" class="headerlink" title="GET与POST的区别"></a>GET与POST的区别</h3><p>GET请求</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /books/?sex=man&amp;name=Professional HTTP/1.1</span><br><span class="line">Host: www.wrox.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)</span><br><span class="line">Gecko/20050225 Firefox/1.0.1</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意最后一行是空行</p><p>POST请求</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: www.wrox.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)</span><br><span class="line">Gecko/20050225 Firefox/1.0.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 40</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line"></span><br><span class="line">name=Professional%20Ajax&amp;publisher=Wiley</span><br></pre></td></tr></table></figure><p>1.GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&amp;连接；例 如：login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0 %E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。</p><p>POST提交：把提交的数据放置在是HTTP包的包体中。</p><p>因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变</p><p>2.传输数据的大小：首先声明：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。</p><p>而在实际开发中存在的限制主要有：</p><p>GET:特定浏览器和服务器对URL长度有限制，例如 IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。</p><p>因此对于GET提交时，传输数据就会受到URL长度的限制。</p><p>POST:由于不是通过URL传值，理论上数据不受限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。</p><p>3.安全性</p><p>POST的安全性要比GET的安全性高。比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为:<br>(1)登录页面有可能被浏览器缓存；<br>(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery(CSRF)攻击</p><p>4.Http get,post,soap协议都是在http上运行的</p><p>（1）get：请求参数是作为一个key/value对的序列（查询字符串）附加到URL上的<br>查询字符串的长度受到web浏览器和web服务器的限制（如IE最多支持2048个字符），不适合传输大型数据集同时，它很不安全</p><p>（2）post：请求参数是在http标题的一个不同部分（名为entity body）传输的，这一部分用来传输表单信息，因此必须将Content-type设置为:application/x-www-form- urlencoded。post设计用来支持web窗体上的用户字段，其参数也是作为key/value对传输。<br>但是：它不支持复杂数据类型，因为post没有定义传输数据结构的语义和规则。</p><p>（3）soap：是http post的一个专用版本，遵循一种特殊的xml消息格式<br>Content-type设置为: text/xml 任何数据都可以xml化。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li><p>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中.</p></li><li><p>GET提交的数据大小有限制（因为<strong>浏览器</strong>对URL的长度有限制），而POST方法提交的数据没有限制.</p></li><li><p>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。</p></li><li><p>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.</p></li></ol><h2 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h2><p>简介<br>HttpClient是Apache Jakarta Common下的子项目，用来提供高效的、最新的、功能丰富的支持HTTP协议的客户端编程工具包，并且它支持HTTP协议最新的版本和建议。HttpClient已经应用在很多的项目中，比如Apache Jakarta上很著名的另外两个开源项目Cactus和HTMLUnit都使用了HttpClient。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol><li>基于标准、纯净的java语言。实现了Http1.0和Http1.1</li><li>以可扩展的面向对象的结构实现了Http全部的方法（GET, POST, PUT, DELETE, HEAD, OPTIONS, and TRACE）。</li><li>支持HTTPS协议。</li><li>通过Http代理建立透明的连接。</li><li>利用CONNECT方法通过Http代理建立隧道的https连接。</li><li>Basic, Digest, NTLMv1, NTLMv2, NTLM2 Session, SNPNEGO/Kerberos认证方案。</li><li>插件式的自定义认证方案。</li><li>便携可靠的套接字工厂使它更容易的使用第三方解决方案。</li><li>连接管理器支持多线程应用。支持设置最大连接数，同时支持设置每个主机的最大连接数，发现并关闭过期的连接。</li><li>自动处理Set-Cookie中的Cookie。</li><li>插件式的自定义Cookie策略</li><li>Request的输出流可以避免流中内容直接缓冲到socket服务器。</li><li>Response的输入流可以有效的从socket服务器直接读取相应内容。</li><li>在http1.0和http1.1中利用KeepAlive保持持久连接。</li><li>直接获取服务器发送的response code和 headers。</li><li>设置连接超时的能力。</li><li>实验性的支持http1.1 response caching。</li><li>源代码基于Apache License 可免费获取。</li></ol><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>使用HttpClient发送请求、接收响应很简单，一般需要如下几步即可。</p><ol><li>创建HttpClient对象。</li><li>创建请求方法的实例，并指定请求URL。如果需要发送GET请求，创建HttpGet对象；如果需要发送POST请求，创建HttpPost对象。</li><li>如果需要发送请求参数，可调用HttpGet、HttpPost共同的setParams(HetpParams params)方法来添加请求参数；对于HttpPost对象而言，也可调用setEntity(HttpEntity entity)方法来设置请求参数。</li><li>调用HttpClient对象的execute(HttpUriRequest request)发送请求，该方法返回一个HttpResponse。</li><li>调用HttpResponse的getAllHeaders()、getHeaders(String name)等方法可获取服务器的响应头；调用HttpResponse的getEntity()方法可获取HttpEntity对象，该对象包装了服务器的响应内容。程序可通过该对象获取服务器的响应内容。</li><li>释放连接。无论执行方法是否成功，都必须释放连接</li></ol><a class="btn-beautify button--animated block blue right" href="https://www.shiming.online/blog/55715/"   title="Servlet"><i class="far fa-hand-point-right fa-fw"></i><span>Servlet</span></a>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> Java Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> GET和POST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCore</title>
      <link href="blog/8981/"/>
      <url>blog/8981/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="依赖注入和控制反转"><a href="#依赖注入和控制反转" class="headerlink" title="依赖注入和控制反转"></a>依赖注入和控制反转</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>紧密耦合的代码难以测试，难以复用，难以理解，但是耦合是必须的</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>通过DI，对象的依赖关系将由系统中负责协调各对象的第三方插件在创建对象时设定。对象无需自行创建或管理他们的依赖关系（IOC和DI是同一个概念的不同角度描述）</p><blockquote><p>来自<a href="https://www.iteye.com/blog/jinnianshilongnian-1413846">IoC 之 2.1 IoC基础 ——跟我学Spring3</a></p></blockquote><h4 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h4><p>IOC (Inversion of Control），即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，IOC意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。</p><ul><li><strong>谁控制谁，控制什么</strong>：传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IOC是有专门一个容器来创建这些对象，即由IOC容器来控制对象的创建；谁控制谁？当然是IOC容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括文件等）。</li><li><strong>为何是反转，哪些方面反转了</strong>：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。</li></ul><p>传统javaSE程序设计：</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200807221921.png" alt="依赖注入"></p><p>IOC：</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200807221859.png" alt="传统设计"></p><p>IOC能做什么：IOC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IOC/DI思想中，应用程序就变成被动的了，被动的等待IOC容器来创建并注入它所需要的资源了。</p><p>IOC很好的体现了面向对象设计法则之一 – 好莱坞法则：“别找我们，我们找你”；即由IOC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。</p><h4 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h4><p>DI(Dependency Injection)，即“依赖注入”是组件之间依赖关系由容器在运行期决定。形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p><ul><li>谁依赖于谁：当然是应用程序依赖于IOC容器；</li><li>为什么需要依赖：应用程序需要IOC容器来提供对象需要的外部资源；</li><li>谁注入谁：很明显是IOC容器注入应用程序某个对象，应用程序依赖的对象；</li><li>注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。</li></ul><h5 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h5><p>1：<a href="https://www.iteye.com/blog/jinnianshilongnian-1413846">IOC和DI</a><br>2：<a href="https://www.cnblogs.com/dongbeifeng/p/inversion-of-control-containers-and-the-dependency-injection-pattern.html">Martin Fowler依赖注入(中文版)</a>  </p><h5 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h5><p>IOC是从对象的角度出发，将自己需要的类交给IOC容器，相对于传统的Java开发来说由对象自身控制转变为容器控制，所以是控制反转，而DI是另一个角度的说法。而IOC的目的最终还是降低耦合性，将组件的配置与使用分离开。</p><p>例：有两个包A，B分别由两个程序员编写，在B中有一个Person接口 ，在A中定义：<code>Person person = null</code> 这是A只依赖于B，因为没有实际赋值，而<code>Person person = new Student()</code> 就把Student实例注入到对象person中，所以通过new关键字创建对象就是最常见的依赖注入方法，这是传统Java开发中的方法；而IOC将A需要的依赖提交给IOC容器，容器再将Student注入到A，由IOC容器控制.</p><p>IOC是一种开发思想，DI是一种开发实现</p><p><strong>控制的什么被反转了？获得依赖对象的方式反转了。</strong></p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h3><p>将被依赖对象通过构造函数的参数注入给依赖对象，并且在初始化对象的时候注入。</p><ul><li>优点：<br>对象初始化完成后便可获得可使用的对象。</li><li>缺点：<br>当需要注入的对象很多时，构造器参数列表将会很长；<br>不够灵活。若有多种注入方式，每种方式只需注入指定几个依赖，那么就需要提供多个重载的构造函数，麻烦。</li></ul><h3 id="setter方法注入"><a href="#setter方法注入" class="headerlink" title="setter方法注入"></a>setter方法注入</h3><p>通过调用成员变量提供的setter函数将被依赖对象注入给依赖类。</p><ul><li>优点：<br>灵活。可以选择性地注入需要的对象。</li><li>缺点：<br>依赖对象初始化完成后由于尚未注入被依赖对象，因此还不能使用。</li></ul><h3 id="接口注入"><a href="#接口注入" class="headerlink" title="接口注入"></a>接口注入</h3><p>依赖类必须要实现指定的接口，然后实现该接口中的一个函数，该函数就是用于依赖注入。该函数的参数就是要注入的对象。</p><ul><li>优点<br>接口注入中，接口的名字、函数的名字都不重要，只要保证函数的参数是要注入的对象类型即可。</li><li>缺点：<br>侵入性太强，不建议使用。</li></ul><h2 id="Xml装配bean"><a href="#Xml装配bean" class="headerlink" title="Xml装配bean"></a>Xml装配bean</h2><p>Spring有三种装配方式，优先使用隐式的Bean发现机制和自动装配，其次使用在Java中进行装配，最后再使用在XML中进行装配。</p><p>在 Spring 实例化 Bean 的过程中，首先会调用默认的构造方法实例化 Bean 对象，然后通过 Java 的反射机制调用 setXxx() 方法进行属性的注入。因此，设值注入要求一个 Bean 的对应类必须满足以下两点要求。</p><ul><li>必须提供一个默认的无参构造方法。</li><li>必须为需要注入的属性提供对应的 setter 方法。</li></ul><p>使用设值注入时，在 Spring 配置文件中，需要使用<code>&lt;bean&gt;</code> 元素的子元素 <code>&lt;property&gt;</code> 元素为每个属性注入值。而使用构造注入时，在配置文件中，主要使用 <code>&lt;constructor-arg&gt;</code> 标签定义构造方法的参数，可以使用其 value 属性（或子元素）设置该参数的值。</p><h3 id="隐式的Bean发现机制和自动装配"><a href="#隐式的Bean发现机制和自动装配" class="headerlink" title="隐式的Bean发现机制和自动装配"></a>隐式的Bean发现机制和自动装配</h3><p>见后文注解装配和自动装配</p><h3 id="在-Java-的接口和类中实现配置"><a href="#在-Java-的接口和类中实现配置" class="headerlink" title="在 Java 的接口和类中实现配置"></a>在 Java 的接口和类中实现配置</h3><p>在Spring的Java配置类中对SpringBean进行配置</p><p>使用 @Bean 注解将方法返回的实例对象添加到上下文中<br>在@Bean返回的实例对象中可以通过构造器注入传入相关依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.jimisun&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(myArticle());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyArticle <span class="title">myArticle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyArticle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在-XML-文件中显式配置"><a href="#在-XML-文件中显式配置" class="headerlink" title="在 XML 文件中显式配置"></a>在 XML 文件中显式配置</h3><h4 id="通过构造函数注入"><a href="#通过构造函数注入" class="headerlink" title="通过构造函数注入"></a>通过构造函数注入</h4><ul><li>无参构造函数注入 — 默认</li><li>有参构造函数注入 — 需要自己设置</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;account&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.gxa.pojo.Account&quot;</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        name : 属性名称</span></span><br><span class="line"><span class="comment">        value ：赋值</span></span><br><span class="line"><span class="comment">        type : 属性类型</span></span><br><span class="line"><span class="comment">        index ：参数索引位置</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--&lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;FFDSS&quot;&gt;&lt;/constructor-arg&gt;--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;double&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1000&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="通过setter方法注入"><a href="#通过setter方法注入" class="headerlink" title="通过setter方法注入"></a>通过setter方法注入</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userServiceImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.gxa.service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDaoImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.gxa.dao.impl.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> UserDaoImpl dao;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDao</span><span class="params">(UserDaoImpl dao)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dao = dao;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;================&quot;</span>);</span><br><span class="line">    dao.findUser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UserDaoImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    System.out.println(<span class="string">&quot;====dao层中的无参构造器==&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;=======dao层查询数据=======&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring概述"><a href="#Spring概述" class="headerlink" title="Spring概述"></a>Spring概述</h2><p>Spring 是一个开源框架，是为了解决企业应用程序开发复杂性而创建的。<br>Spring 框架是一个分层架构，由 7 个定义良好的模块组成。<br>Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式</p><h2 id="Spring组件"><a href="#Spring组件" class="headerlink" title="Spring组件"></a>Spring组件</h2><p>组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200807221625.png" alt="spring组件"></p><ul><li>核心容器:核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转 （IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。</li><li>Spring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。</li><li>Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。</li><li>Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。</li><li>Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。</li><li>Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</li><li>Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。</li></ul><p>Spring 框架的功能可以用在任何 J2EE 服务器中，大多数功能也适用于不受管理的环境。Spring 的核心要点是：支持不绑定到特定 J2EE 服务的可重用业务和数据访问对象。毫无疑问，这样的对象可以在不同 J2EE 环境 （Web 或 EJB）、独立应用程序、测试环境之间重用。</p><p>DI使相互协作的软件组合保持松散耦合，面向切面编程允许你把遍布应用各处的功能分离出来形成可重用的组件，保证pojo的简单性</p><h3 id="Spring容器"><a href="#Spring容器" class="headerlink" title="Spring容器"></a>Spring容器</h3><p>Spring有两个核心接口：BeanFactory和ApplicationContext，其中ApplicationContext是BeanFactory的子接口。它们都可以代表Spring容器。Spring容器是生成Bean实例的工厂，并管理容器中的Bean。Bean是Spring管理的基本单元。</p><h3 id="Spring-BeanFactory-容器"><a href="#Spring-BeanFactory-容器" class="headerlink" title="Spring BeanFactory 容器"></a>Spring BeanFactory 容器</h3><p>这是一个最简单的容器，它主要的功能是为依赖注入 （DI） 提供支持，主要目的是向后兼容已经存在的和那些 Spring 整合在一起的第三方框架。<br>在 Spring 中，有大量对 BeanFactory 接口的实现。其中，最常被使用的是 XmlBeanFactory 类。这个容器从一个 XML 文件中读取配置元数据，由这些元数据来生成一个被配置化的系统或者应用。<br>在资源宝贵的移动设备或者基于 applet 的应用当中， BeanFactory 会被优先选择。否则，一般使用的是 ApplicationContext，除非你有更好的理由选择 BeanFactory。</p><h3 id="Spring-ApplicationContext-容器"><a href="#Spring-ApplicationContext-容器" class="headerlink" title="Spring ApplicationContext 容器"></a>Spring ApplicationContext 容器</h3><p>Application Context 是 spring 中较高级的容器。和 BeanFactory 类似，它可以加载配置文件中定义的 bean，将所有的 bean 集中在一起，当有请求的时候分配 bean。<br>另外，它增加了企业所需要的功能，比如，从属性文件中解析文本信息和将事件传递给所指定的监听器。<br>ApplicationContext 包含 BeanFactory 所有的功能，一般情况下，相对于 BeanFactory，ApplicationContext 会更加优秀。</p><h4 id="最常被使用的-ApplicationContext-接口实现"><a href="#最常被使用的-ApplicationContext-接口实现" class="headerlink" title="最常被使用的 ApplicationContext 接口实现"></a>最常被使用的 ApplicationContext 接口实现</h4><p>FileSystemXmlApplicationContext：该容器从 XML 文件中加载已被定义的 bean。在这里，你需要提供给构造器 XML 文件的完整路径。<br>ClassPathXmlApplicationContext：该容器从 XML 文件中加载已被定义的 bean。在这里，你不需要提供 XML 文件的完整路径，只需正确配置 CLASSPATH 环境变量即可，因为，容器会从 CLASSPATH 中搜索 bean 配置文件。<br>WebXmlApplicationContext：该容器会在一个 web 应用程序的范围内加载在 XML 文件中已被定义的 bean。</p><h2 id="SpringBean生命周期"><a href="#SpringBean生命周期" class="headerlink" title="SpringBean生命周期"></a>SpringBean生命周期</h2><h3 id="一．生命周期流程图"><a href="#一．生命周期流程图" class="headerlink" title="一．生命周期流程图"></a>一．生命周期流程图</h3><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200807221652.png" alt="spring生命周期1"><br><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200807221743.png" alt="spirng生命周期2"></p><p>若容器注册了以上各种接口，程序那么将会按照以上的流程进行。</p><h3 id="二．各种接口方法分类"><a href="#二．各种接口方法分类" class="headerlink" title="二．各种接口方法分类"></a>二．各种接口方法分类</h3><p>Bean的完整生命周期经历了各种方法调用，这些方法可以划分为以下几类：</p><ul><li>Bean自身的方法：这个包括了Bean本身调用的方法和通过配置文件中<code>&lt;bean&gt;</code>的init-method和destroy-method指定的方法</li><li>Bean级生命周期接口方法：这个包括了BeanNameAware、BeanFactoryAware、InitializingBean和DiposableBean这些接口的方法</li><li>容器级生命周期接口方法：这个包括了InstantiationAwareBeanPostProcessor 和 BeanPostProcessor 这两个接口实现，一般称它们的实现类为“后处理器”。</li><li>工厂后处理器接口方法：这个包括了AspectJWeavingEnabler, ConfigurationClassPostProcessor, CustomAutowireConfigurer等等非常有用的工厂后处理器　　接口的方法。工厂后处理器也是容器级的。在应用上下文装配配置文件之后立即调用。</li></ul><h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><p>Spring 容器可以在不使用<code>&lt;constructor-arg&gt;</code>和<code>&lt;property&gt;</code>元素的情况下自动装配相互协作的 bean 之间的关系，这有助于减少编写一个大的基于 Spring 的应用程序的 XML 配置的数量。</p><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><ul><li><p>no<br>  这是默认的设置，它意味着没有自动装配，你应该使用显式的bean引用来连线。你不用为了连线做特殊的事。</p></li><li><p>byName<br>  由属性名自动装配。Spring 容器看到在 XML 配置文件中 bean 的自动装配的属性设置为 byName。然后尝试匹配，并且将它的属性与在配置文件中被定义为相同名称的 beans 的属性进行连接。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Role myRole;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;  </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myRole&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.viewscenes.netsupervisor.entity.Role&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1001&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;管理员&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.viewscenes.netsupervisor.entity.User&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>byType<br>  由属性数据类型自动装配。Spring 容器看到在 XML 配置文件中 bean 的自动装配的属性设置为 byType。然后如果它的类型匹配配置文件中的一个确切的 bean 名称，它将尝试匹配和连接属性的类型。如果存在不止一个这样的 bean，则一个致命的异常将会被抛出。</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.viewscenes.netsupervisor.entity.Role&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1001&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;管理员&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.viewscenes.netsupervisor.entity.User&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  如果使用byType，Role Bean的ID都可以省去。</p></li><li><p>constructor</p><p>  类似于 byType，但该类型适用于构造函数参数类型。如果在容器中没有一个构造函数参数类型的 bean，则一个致命错误将会发生。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Role role;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Role role)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.role = role;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;user&quot; class=&quot;com.viewscenes.netsupervisor.entity.User&quot; &lt;autowire=&quot;constructor&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>autodetect<br>  Spring首先尝试通过 constructor 使用自动装配来连接，如果它不执行，Spring 尝试通过 byType 来自动装配。过时方法，Spring3.0之后不再支持</p></li><li><p>默认自动装配<br>  默认情况下，default-autowire属性被设置为none，标示所有的Bean都不使用自动装配，除非Bean上配置了autowire属性。如果你需要为所有的Bean配置相同的autowire属性，有个办法可以简化这一操作。在根元素Beans上增加属性default-autowire=”byType”</p></li></ul><h3 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h3><ol><li><p>强制性<br> 默认情况下，它具有强制契约特性，其所标注的属性必须是可装配的。如果没有Bean可以装配到Autowired所标注的属性或参数中，那么你会看到NoSuchBeanDefinitionException的异常信息。</p><p> 如果我们不确定属性是否可以装配，可以这样来使用Autowired。<br> <code>@Autowired(required=false)</code></p></li><li><p>装配策略</p><ul><li>默认按照类型装配<br>关键点是<code>findAutowireCandidates</code>这个方法</li><li>按照名称装配<br>如果查到多个实例，<code>determineAutowireCandidate</code>方法就是关键。它来确定一个合适的Bean返回。其中一部分就是按照Bean的名称来匹配。</li></ul><p> <strong>@Autowired默认使用byType来装配属性，如果匹配到类型的多个实例，再通过byName来确定Bean。</strong></p></li><li><p>主和优先级<br> 通过byType可能会找到多个实例的Bean。然后再通过byName来确定一个合适的Bean，如果通过名称也确定不了呢？<br> 还是<code>determineAutowireCandidate</code>这个方法，它还有两种方式来确定。</p><ul><li>Primary<br> 它的作用是看Bean上是否包含@Primary注解，如果包含就返回。当然了，你不能把多个Bean都设置为@Primary，不然你会得到NoUniqueBeanDefinitionException这个异常。</li><li>Priority<br> 你也可以在Bean上配置@Priority注解，它有个int类型的属性value，可以配置优先级大小。数字越小的，就被优先匹配。同样的，你也不能把多个Bean的优先级配置成相同大小的数值，否则NoUniqueBeanDefinitionException异常照样出来找你。<br> 最后，有一点需要注意。Priority的包在javax.annotation.Priority;，如果想使用它还要引入一个坐标。</li></ul></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.annotation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.annotation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li><p>优点<br>变量方式注入非常简洁，没有任何多余代码，非常有效的提高了java的简洁性。即使再多几个依赖一样能解决掉这个问题。</p></li><li><p>缺点</p><ol><li>你不能使用属性注入的方式构建不可变对象。</li><li>你的类和依赖容器强耦合，不能在容器外使用。</li><li>你的类不能绕过反射（例如单元测试的时候）进行实例化，必须通过依赖容器才能实例化。</li><li>实际的依赖被隐藏在外面，不是在构造方法或者其它方法里面反射的。</li><li>一个类经常会有超过10个的依赖。如果使用构造方法的方式注入的话，构造方法会有10个参数，明显有点蠢。但是如果使用属性注入的话就没有这样的限制。但是一个类有很多的依赖，是一个危险的标志，因为很有可能这个类完成了超过一件事，违背了单一职责原则。</li></ol></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>变量方式注入应该尽量避免，使用set方式注入或者构造器注入，这两种方式的选择就要看这个类是强制依赖的话就用构造器方式，选择依赖的话就用set方法注入。</p><h2 id="注解装配"><a href="#注解装配" class="headerlink" title="注解装配"></a>注解装配</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>从 Spring 2.5 开始就可以使用注解来配置依赖注入。而不是采用 XML 来描述一个 bean 连线，你可以使用相关类，方法或字段声明的注解，将 bean 配置移动到组件类本身。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    使用注解之前，我们要先导入4+2+aop的jar包</span></span><br><span class="line"><span class="comment">    同时引入约束 beans+context </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--组件扫描：Spring容器会扫描这个包里所有类，从类的注解信息中获取Bean的信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;xqm”/&gt;</span></span></span><br></pre></td></tr></table></figure><p>注解方式装配Bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Component取代<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">@Component(“id”) 取代 <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>除了@Component外，Spring提供了三个功能和@Component等效的注解。<br>它们一般用于web项目，对DAO，service，web层进行注解，所以也称为Bean的衍生注解。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Repository ：dao层</span><br><span class="line">@Service：service层</span><br><span class="line">@Controller：web层</span><br></pre></td></tr></table></figure><h3 id="装配总结"><a href="#装配总结" class="headerlink" title="装配总结"></a>装配总结</h3><ol><li>被注解的java类当做Bean实例，Bean实例的名称默认是Bean类的首字母小写，其他部分不变。@Service也可以自定义Bean名称，但是必须是唯一的！</li><li>尽量使用对应组件注解的类替换@Component注解，在spring未来的版本中，@Controller，@Service，@Repository会携带更多语义。并且便于开发和维护！</li></ol><h3 id="其余常用注解"><a href="#其余常用注解" class="headerlink" title="其余常用注解"></a>其余常用注解</h3><p>一．介绍<br>@Autowired：属于Spring 的org.springframework.beans.factory.annotation包下,可用于为类的属性、构造器、方法进行注值<br>@Resource：不属于spring的注解，而是来自于JSR-250位于java.annotation包下，使用该annotation为目标bean指定协作者Bean。<br>@PostConstruct 和 @PreDestroy 方法 实现初始化和销毁bean之前进行的操作</p><p>二．@Component vs @Configuration and @Bean<br>Bean注解主要用于方法上，有点类似于工厂方法，当使用了@Bean注解，我们可以连续使用多种定义bean时用到的注解，譬如用@Qualifier注解定义工厂方法的名称，用@Scope注解定义该bean的作用域范围，譬如是singleton还是prototype等。</p><p>Spring 中新的 Java 配置支持的核心就是@Configuration 注解的类。这些类主要包括 @Bean 注解的方法来为 Spring 的 IoC 容器管理的对象定义实例，配置和初始化逻辑。</p><p>使用@Configuration 来注解类表示类可以被 Spring 的 IoC 容器所使用，作为 bean 定义的资源。</p><p>三．spring MVC模块注解</p><ol><li><p>web模块<br>@Controller ：表明该类会作为与前端作交互的控制层组件，通过服务接口定义的提供访问应用程序的一种行为，解释用户的输入，将其转换成一个模型然后将试图呈献给用户。<br>@RequestMapping ： 这个注解用于将url映射到整个处理类或者特定的处理请求的方法。可以只用通配符！<br>@RequestMapping 既可以作用在类级别，也可以作用在方法级别。当它定义在类级别时，标明该控制器处理所有的请求都被映射到 /favsoft 路径下。@RequestMapping中可以使用 method 属性标记其所接受的方法类型，如果不指定方法类型的话，可以使用 HTTP GET/POST 方法请求数据，但是一旦指定方法类型，就只能使用该类型获取数据。<br>@RequestParam ：将请求的参数绑定到方法中的参数上，有required参数，默认情况下，required=true，也就是改参数必须要传。如果改参数可以传可不传，可以配置required=false。<br>@PathVariable ： 该注解用于方法修饰方法参数，会将修饰的方法参数变为可供使用的uri变量（可用于动态绑定）。<br>@PathVariable中的参数可以是任意的简单类型，如int, long, Date等等。Spring会自动将其转换成合适的类型或者抛出 TypeMismatchException异常。当然，我们也可以注册支持额外的数据类型。<br>@PathVariable支持使用正则表达式，这就决定了它的超强大属性，它能在路径模板中使用占位符，可以设定特定的前缀匹配，后缀匹配等自定义格式。<br>@RequestBody ： @RequestBody是指方法参数应该被绑定到HTTP请求Body，常用于接收json数据<br>@ResponseBody ： @ResponseBody与@RequestBody类似，它的作用是将返回类型直接输入到HTTP response body中。常用于返回json数据<br>@RestController ：控制器实现了REST的API，只为服务于JSON，XML或其它自定义的类型内容，@RestController用来创建REST类型的控制器，与@Controller类型。@RestController就是这样一种类型，它避免了你重复的写@RequestMapping与@ResponseBody。<br>@ModelAttribute ：@ModelAttribute可以作用在方法或方法参数上，当它作用在方法上时，标明该方法的目的是添加一个或多个模型属性（model attributes）。该方法支持与@RequestMapping一样的参数类型，但并不能直接映射成请求。控制器中的@ModelAttribute方法会在@RequestMapping方法调用之前而调用。</p></li><li><p>事务注解<br>在处理dao层或service层的事务操作时，譬如删除失败时的回滚操作。使用**@Transactional** 作为注解</p></li></ol><h2 id="切面编程"><a href="#切面编程" class="headerlink" title="切面编程"></a>切面编程</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>AOP 即 Aspect Oriented Program 面向切面编程<br>面向切面编程的思想里面，把功能分为核心业务功能，和周边功能。周边功能在 Spring 的面向切面编程AOP思想里，即被定义为切面<br>在面向切面编程AOP的思想里面，核心业务功能和切面功能分别独立进行开发，然后把切面功能和核心业务功能 “编织” 在一起，这就叫AOP</p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>将横切关注点和业务逻辑分离。AOP能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性</p><p>DI有助于应用对象之间的解耦，而AOP可以实现横切关注点与它们所影响的对象之间的解耦。</p><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul><li>切面，Aspect:关注点—所有功能总称</li><li>连接点，join point:程序执行过程中的某一点</li><li>建议，Advice:AOP框架在特定的连接点上执行的动作</li><li>切入点，Pointcut:一系列连接点的集合</li><li>目标对象，Target Object：要被代理的对象</li><li>AOP代理，AOP Proxy:AOP框架创建的对象，Spring中的AOP代理包含JDK动态代理和CGLIB代理，前者为接口代理（实现接口的目标代理），后者为类代理</li><li>引入，Introduction:简单说就是AOP中的方法</li></ul><h3 id="Spring对AOP的支持"><a href="#Spring对AOP的支持" class="headerlink" title="Spring对AOP的支持"></a>Spring对AOP的支持</h3><p>Spring中AOP代理由Spring的IOC容器负责生成、管理，其依赖关系也由IOC容器负责管理。因此，AOP代理可以直接使用容器中的其它bean实例作为目标，这种关系可由IOC容器的依赖注入提供。Spring创建代理的规则为：</p><ol><li>默认使用Java动态代理来创建AOP代理，这样就可以为任何接口实例创建代理了</li><li>当需要代理的类不是代理接口的时候，Spring会切换为使用CGLIB代理，也可强制使用CGLIB</li></ol><p>AOP编程其实是很简单的事情，纵观AOP编程，程序员只需要参与三个部分：</p><ol><li>定义普通业务组件</li><li>定义切入点，一个切入点可能横切多个业务组件</li><li>定义增强处理，增强处理就是在AOP框架为普通业务组件织入的处理动作<br>所以进行AOP编程的关键就是定义切入点和定义增强处理，一旦定义了合适的切入点和增强处理，AOP框架将自动生成AOP代理，即：代理对象的方法=增强处理+被代理对象的方法。</li></ol><h3 id="基于注解配置的AOP"><a href="#基于注解配置的AOP" class="headerlink" title="基于注解配置的AOP"></a>基于注解配置的AOP</h3><ol><li><p>导入相关的jar包</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring-aop-3.2.5.RELEASE.jar   【spring3.2源码】</span><br><span class="line">aopalliance.jar  【spring2.5源码/lib/aopalliance】</span><br><span class="line">aspectjweaver.jar【spring2.5源码/lib/aspectj】或【aspectj-1.8.2\lib】</span><br><span class="line">aspectjrt.jar【spring2.5源码/lib/aspectj】或【aspectj-1.8.2\lib】</span><br></pre></td></tr></table></figure> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置文件applicationContext.xml<br>注意：<br>1、先引入aop命名空间,和schema<br> 2、再配置Aop的动态代理</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">      http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用注解时要开启注解扫描 要扫描的包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;cn.itcast.e_aop_anno&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开启aop注解方式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用注解<br>注解</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span> 指定一个类为切面类</span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(* cn.itcast.e_aop_anno.*.*(..))&quot;)</span>  指定切入点表达式</span><br><span class="line"><span class="meta">@Before(&quot;pointCut_()&quot;)</span>  前置通知: 目标方法之前执行</span><br><span class="line"><span class="meta">@After(&quot;pointCut_()&quot;)</span>后置通知：目标方法之后执行（始终执行）</span><br><span class="line"><span class="meta">@AfterReturning(&quot;pointCut_()&quot;)</span>返回后通知： 执行方法结束前执行(异常不执行)</span><br><span class="line"><span class="meta">@AfterThrowing(&quot;pointCut_()&quot;)</span>异常通知:  出现异常时候执行</span><br><span class="line"><span class="meta">@Around(&quot;pointCut_()&quot;)</span>环绕通知： 环绕目标方法执行</span><br></pre></td></tr></table></figure></li><li><p>示例<br>AOP代理类LogAop.java</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.After;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用Spring创建AOP类</span></span><br><span class="line"><span class="comment"> * 在创建AOP时应该加入<span class="doctag">@Aspect</span> <span class="doctag">@Component</span></span></span><br><span class="line"><span class="comment"> * AOP默认是面向接口的编程</span></span><br><span class="line"><span class="comment"> * 在AOP中支持CGLIB方和JDK方式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> admin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAop</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 指定切入点表达式： 拦截哪些方法； 即为哪些类生成代理对象</span></span><br><span class="line">  <span class="comment">// 解释@Pointcut(&quot;execution(* cn.itcast.e_aop_anno.*.*(..))&quot;)</span></span><br><span class="line">  <span class="comment">// @Pointcut(&quot;execution(* (切入点表达式固定写法)cn.itcast.e_aop_anno(表示包).类名(可以用*表示包下所有的类).方法名(可以用*表示类下所有的方法)(参数)表示参数可以用..</span></span><br><span class="line">  <span class="meta">@Pointcut(&quot;execution(* cn.itcast.e_aop_anno.*.*(..))&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut_</span><span class="params">()</span></span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// @Before(&quot;execution(* cn.itcast.e_aop_anno.*.*(..))&quot;)每个方法需要写相同的引用，所以将相同的部分抽取到一个空的方法中pointCut_(),</span></span><br><span class="line">  <span class="comment">// 前置通知 : 在执行目标方法之前执行</span></span><br><span class="line">  <span class="meta">@Before(&quot;pointCut_()&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;开始事务/异常&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 后置/最终通知：在执行目标方法之后执行  【无论是否出现异常最终都会执行】</span></span><br><span class="line">  <span class="meta">@After(&quot;pointCut_()&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;提交事务/关闭&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回后通知： 在调用目标方法结束后执行 【出现异常不执行】</span></span><br><span class="line">  <span class="meta">@AfterReturning(&quot;pointCut_()&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;afterReturning()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异常通知： 当目标方法执行异常时候执行此关注点代码</span></span><br><span class="line">  <span class="meta">@AfterThrowing(&quot;pointCut_()&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;afterThrowing()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 环绕通知：环绕目标方式执行</span></span><br><span class="line">  <span class="meta">@Around(&quot;pointCut_()&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;环绕前....&quot;</span>);</span><br><span class="line">    pjp.proceed();  <span class="comment">// 执行目标方法</span></span><br><span class="line">    System.out.println(<span class="string">&quot;环绕后....&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目标对象类一：实现接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span>   <span class="comment">// 加入容器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> <span class="keyword">implements</span> <span class="title">IUserDao</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----核心业务：保存！！！------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目标对象类二：没有实现接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标对象*/</span></span><br><span class="line"><span class="meta">@Component</span>   <span class="comment">// 加入容器</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderDao</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----核心业务：保存！！！------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">测试类</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ApplicationContext ac =</span><br><span class="line">        <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;cn/itcast/e_aop_anno/bean.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目标对象有实现接口，spring会自动选择“JDK代理”</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testApp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        IUserDao userDao = (IUserDao) ac.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">        System.out.println(userDao.getClass());<span class="comment">//$Proxy001  </span></span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目标对象没有实现接口， spring会用“cglib代理”</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCglib</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        OrderDao orderDao = (OrderDao) ac.getBean(<span class="string">&quot;orderDao&quot;</span>);</span><br><span class="line">        System.out.println(orderDao.getClass());</span><br><span class="line">        orderDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">　　　　开始事务/异常</span><br><span class="line"></span><br><span class="line">　　　　-----核心业务：保存！！！------</span><br><span class="line"></span><br><span class="line">　　　　提交事务/关闭</span><br></pre></td></tr></table></figure><h4 id="基于配置xml配置文件的方式"><a href="#基于配置xml配置文件的方式" class="headerlink" title="基于配置xml配置文件的方式"></a>基于配置xml配置文件的方式</h4><ol><li><p>导入相关的jar包</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>aop命名空间</p></li><li><p>aop配置<br>配置切面类 （重复执行代码形成的类）<br>aop配置 拦截哪些方法 / 拦截到方法后应用通知代码</p></li></ol><p>applicationContext.xml的Aop配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- dao 实例   在这里配置后就不用在类中使用注解 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.itcast.f_aop_xml.UserDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;orderDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.itcast.f_aop_xml.OrderDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 切面类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;aop&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.itcast.f_aop_xml.Aop&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Aop配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义一个切入点表达式： 拦截哪些方法 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* cn.itcast.f_aop_xml.*.*(..))&quot;</span> <span class="attr">id</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 切面 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;aop&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 环绕通知 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;around&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 前置通知： 在目标方法调用前执行 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;begin&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 后置通知： --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 返回后通知 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;afterReturning&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 异常通知 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;afterThrowing&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><a class="btn-beautify button--animated block blue right" href="https://www.shiming.online/blog/8564/"   title="HTTP协议"><i class="far fa-hand-point-right fa-fw"></i><span>HTTP协议</span></a>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 依赖注入和控制反转 </tag>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
