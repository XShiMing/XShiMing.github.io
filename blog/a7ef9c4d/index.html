<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java面试题 | 失铭的日记</title><meta name="keywords" content="面试"><meta name="author" content="失铭"><meta name="copyright" content="失铭"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="整理自各面试题博客和牛客网面经  toString 和 String.valueOf()的区别将对象转为字符串常用三种方法：(String) xxx, xxx.toString(), String.valueOf(xxx)  (String) ：强制转换，将object转成String类型的值。使用这种方法时，需要注意的是类型必须能转成String类型。否则容易抛出CalssCastExcept">
<meta property="og:type" content="article">
<meta property="og:title" content="Java面试题">
<meta property="og:url" content="https://shiming.best/blog/a7ef9c4d/index.html">
<meta property="og:site_name" content="失铭的日记">
<meta property="og:description" content="整理自各面试题博客和牛客网面经  toString 和 String.valueOf()的区别将对象转为字符串常用三种方法：(String) xxx, xxx.toString(), String.valueOf(xxx)  (String) ：强制转换，将object转成String类型的值。使用这种方法时，需要注意的是类型必须能转成String类型。否则容易抛出CalssCastExcept">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://image.shiming.online/guidao/pic-88.jpg">
<meta property="article:published_time" content="2021-02-26T05:37:39.000Z">
<meta property="article:modified_time" content="2021-02-26T05:37:39.000Z">
<meta property="article:author" content="失铭">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://image.shiming.online/guidao/pic-88.jpg"><link rel="shortcut icon" href="https://image.shiming.online/background/favicon.ico"><link rel="canonical" href="https://shiming.best/blog/a7ef9c4d/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-02-26 13:37:39'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><link rel="stylesheet" href="/css/background.css"><link rel="stylesheet" href="/css/gdt.css"><link rel="stylesheet" href="/css/foot.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1995009_krak2073t6f.css"><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="失铭的日记" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="https://image.shiming.online/background/info.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">101</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">51</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">36</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-32shejimoshi"></i><span> 设计模式</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/blog/41682/"><i class="fa-fw iconfont icon-dashujukeshihuaico--copy"></i><span> 设计模式</span></a></li><li><a class="site-page" href="/blog/8f9f2030/"><i class="fa-fw iconfont icon-chuangjian"></i><span> 创建型模式</span></a></li><li><a class="site-page" href="/blog/620ff0b5/"><i class="fa-fw iconfont icon-jiegou"></i><span> 结构型模式</span></a></li><li><a class="site-page" href="/blog/e55dcfb0/"><i class="fa-fw iconfont icon-hangwei"></i><span> 行为型模式</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-lianjie"></i><span> 链接库</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-shoucang"></i><span> 收藏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-qita1"></i><span> 其他</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw iconfont icon-GoogleMaterialicmusicnotepx"></i><span> 音乐</span></a></li><li><a class="site-page" href="/2020/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></li></ul></div></div></div></div><div id="body-wrap"><header class="no-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">失铭的日记</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-32shejimoshi"></i><span> 设计模式</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/blog/41682/"><i class="fa-fw iconfont icon-dashujukeshihuaico--copy"></i><span> 设计模式</span></a></li><li><a class="site-page" href="/blog/8f9f2030/"><i class="fa-fw iconfont icon-chuangjian"></i><span> 创建型模式</span></a></li><li><a class="site-page" href="/blog/620ff0b5/"><i class="fa-fw iconfont icon-jiegou"></i><span> 结构型模式</span></a></li><li><a class="site-page" href="/blog/e55dcfb0/"><i class="fa-fw iconfont icon-hangwei"></i><span> 行为型模式</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-lianjie"></i><span> 链接库</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-shoucang"></i><span> 收藏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-qita1"></i><span> 其他</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw iconfont icon-GoogleMaterialicmusicnotepx"></i><span> 音乐</span></a></li><li><a class="site-page" href="/2020/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></li></ul></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Java面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-02-26T05:37:39.000Z" title="发表于 2021-02-26 13:37:39">2021-02-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-02-26T05:37:39.000Z" title="更新于 2021-02-26 13:37:39">2021-02-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%85%B6%E4%BB%96/">其他</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%85%B6%E4%BB%96/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">41.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>136分钟</span></span></div></div></div><article class="post-content" id="article-container"><blockquote>
<p>整理自各面试题博客和牛客网面经</p>
</blockquote>
<h3 id="toString-和-String-valueOf-的区别"><a href="#toString-和-String-valueOf-的区别" class="headerlink" title="toString 和 String.valueOf()的区别"></a>toString 和 String.valueOf()的区别</h3><p>将对象转为字符串常用三种方法：(String) xxx, xxx.toString(), String.valueOf(xxx)</p>
<ol>
<li><strong>(String)</strong> ：强制转换，将object转成String类型的值。使用这种方法时，需要注意的是类型必须能转成String类型。否则容易抛出CalssCastException异常</li>
<li><strong>toString()</strong> ：在使用时要注意，必须保证转换的对象不是null值，否则将抛出NullPointerException异常。采用这种方法时，通常派生类会覆盖Object里的toString（）方法。</li>
<li><strong>String.valueOf()</strong> ：String的静态方法，避免了前两个的不足和缺点。在内部加了非空判断，不会抛出空指针异常，但是需要注意：<strong>对象为null时，会转换成字符串”null”，而不是 null ！</strong>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (obj == <span class="keyword">null</span>) ? <span class="string">&quot;null&quot;</span> : obj.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h3><p><strong>override（重写）：</strong></p>
<ul>
<li>方法名、参数、返回值相同。</li>
<li>子类方法不能缩小父类方法的访问权限。</li>
<li>子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。</li>
<li>存在于父类和子类之间。</li>
<li>方法被定义为final不能被重写。</li>
</ul>
<p><strong>overload（重载）：</strong></p>
<ul>
<li>参数类型、个数、顺序至少有一个不相同。</li>
<li>不能重载只有返回值不同的方法名。</li>
<li>存在于父类和子类、同类中。</li>
</ul>
<h3 id="Comparator与Comparable有什么区别？"><a href="#Comparator与Comparable有什么区别？" class="headerlink" title="Comparator与Comparable有什么区别？"></a>Comparator与Comparable有什么区别？</h3><ul>
<li>Comparable是排序接口；若一个类实现了Comparable接口，就意味着“该类支持排序”。</li>
<li>而Comparator是比较器；我们若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。</li>
<li>Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。</li>
</ul>
<h3 id="int和Integer-有什么区别，还有Integer缓存的实现"><a href="#int和Integer-有什么区别，还有Integer缓存的实现" class="headerlink" title="int和Integer 有什么区别，还有Integer缓存的实现"></a>int和Integer 有什么区别，还有Integer缓存的实现</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/guodongdidi/p/6953217.html">int和Integer的区别</a></p>
<h3 id="数组的特点？底层如何定位到数组中的元素？数组的内存空间是连续的吗？"><a href="#数组的特点？底层如何定位到数组中的元素？数组的内存空间是连续的吗？" class="headerlink" title="数组的特点？底层如何定位到数组中的元素？数组的内存空间是连续的吗？"></a>数组的特点？底层如何定位到数组中的元素？数组的内存空间是连续的吗？</h3><p>数组查询快，增删慢。数组底层是一块连续的内存空间，访问地址时根据内存块的首地址根据公式确定访问下标对应地址。</p>
<ul>
<li>Java中数组的引用放于栈内存中，而实际数据放于堆内存中。</li>
<li>如果数组是引用类型数组，则堆内存中对应地址则指向对应对象。</li>
<li>多维数组其实也是一维数组，每一格都指向下一层数组。例如二维数组存放行的一维数组，每一格指向列的一维数组。</li>
</ul>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="Spring和SpringBoot的关系"><a href="#Spring和SpringBoot的关系" class="headerlink" title="Spring和SpringBoot的关系"></a>Spring和SpringBoot的关系</h3><p>Spring框架为开发Java应用程序提供了全面的基础架构支持。而随着Spring的发展，在部署Spring项目时需要配置大量的xml文件。而SpringBoot则是对Spring的扩展，简化了配置流程，能更快，更高效的开发应用。</p>
<h3 id="SpringBoot的自动装配原理"><a href="#SpringBoot的自动装配原理" class="headerlink" title="SpringBoot的自动装配原理"></a>SpringBoot的自动装配原理</h3><p>spring.factories文件内容</p>
<h3 id="对象比较有几种方式？"><a href="#对象比较有几种方式？" class="headerlink" title="对象比较有几种方式？"></a>对象比较有几种方式？</h3><ol>
<li><p>重写Object类的equals（）方法；</p>
</li>
<li><p>实现Comparable接口，并实现compareTo（）方法；</p>
</li>
<li><p>定义一个单独的对象比较器，继承自Comparator接口，实现compare（）方法。</p>
</li>
</ol>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="两种引擎的区别"><a href="#两种引擎的区别" class="headerlink" title="两种引擎的区别"></a>两种引擎的区别</h3><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="为什么需要分布式锁？"><a href="#为什么需要分布式锁？" class="headerlink" title="为什么需要分布式锁？"></a>为什么需要分布式锁？</h3><p>在单机情况下，本地锁就能满足多线程要求，而在集群环境中，本地锁无法在多个服务间生效。这时候保证数据的一致性就需要在分布式锁实现。</p>
<h3 id="Redlock算法"><a href="#Redlock算法" class="headerlink" title="Redlock算法"></a>Redlock算法</h3><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><p><img src= "/img/loading.gif" data-lazy-src="https://xqm-oss.oss-cn-beijing.aliyuncs.com/blog/20200828150219.png" alt="四次挥手"></p>
<p><a target="_blank" rel="noopener" href="https://shiming.online/blog/84a7ac10/#%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B%E9%9C%80%E8%A6%81%E5%93%AA%E4%BA%9B%E5%8D%8F%E8%AE%AE">四次挥手</a></p>
<h3 id="为什么需要等待2MSL"><a href="#为什么需要等待2MSL" class="headerlink" title="为什么需要等待2MSL"></a>为什么需要等待2MSL</h3><ol>
<li>保证客户端发送的最后一个 ACK 报文段能够到达服务端。<br>这个 ACK 报文段有可能丢失，使得处于 LAST-ACK 状态的 B 收不到对已发送的 FIN+ACK 报文段的确认，服务端超时重传 FIN+ACK 报文段，而客户端能在 2MSL 时间内收到这个重传的 FIN+ACK 报文段，接着客户端重传一次确认，重新启动 2MSL 计时器，最后客户端和服务端都进入到 CLOSED 状态。<br>若客户端在 TIME-WAIT 状态不等待一段时间，而是发送完 ACK 报文段后立即释放连接，则无法收到服务端重传的 FIN+ACK 报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到 CLOSED 状态。</li>
<li>防止 “已失效的连接请求报文段” 出现在本连接中。<br>客户端在发送完最后一个 ACK 报文段后，再经过 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。</li>
</ol>
<h2 id="牛客面经"><a href="#牛客面经" class="headerlink" title="牛客面经"></a>牛客面经</h2><p>作者：Codefool0307<br>链接：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/543857?type=2&amp;order=0&amp;pos=8&amp;page=1&amp;channel=-1&amp;source_id=discuss_tag_nctrack">https://www.nowcoder.com/discuss/543857?type=2&amp;order=0&amp;pos=8&amp;page=1&amp;channel=-1&amp;source_id=discuss_tag_nctrack</a><br>来源：牛客网</p>
<h2 id="1：Java特性"><a href="#1：Java特性" class="headerlink" title="1：Java特性"></a>1：Java特性</h2><h3 id="1-1：Java特点"><a href="#1-1：Java特点" class="headerlink" title="1-1：Java特点"></a>1-1：Java特点</h3><ol>
<li>简单性</li>
<li>面向对象</li>
<li>分布式</li>
<li>健壮性</li>
<li>安全性</li>
<li>体系结构中立</li>
<li>可移植性</li>
<li>解释型</li>
<li>高性能</li>
<li>多线程</li>
<li>动态性</li>
</ol>
<h3 id="1-2：JVM-JRE-JDK-JIT"><a href="#1-2：JVM-JRE-JDK-JIT" class="headerlink" title="1-2：JVM\JRE\JDK\JIT"></a>1-2：JVM\JRE\JDK\JIT</h3><ul>
<li>JDK：<code>Java Development Kit</code> 的简称，Java 开发工具包，提供了 Java 的开发环境和运行环境。</li>
<li>JRE：<code>Java Runtime Environment</code> 的简称，Java 运行环境，为 Java 的运行提供了所需环境。</li>
<li>JVM：<code>Java Virtual Machine</code>，Java虚拟机</li>
<li>JIT：<code>Just-In-Time Compiler</code>，即时编译器</li>
</ul>
<p>JDK包含JRE和编译器Javac，还包含很多 Java 程序调试和分析的工具。JRE（Java运行时环境）包含虚拟机但是不包含编译器。<br>简单来说：如果需要运行 Java 程序，只需安装 JRE ，如果需要编写 Java 程序，则需要安装 JDK。</p>
<h3 id="1-3：变量的初始化顺序"><a href="#1-3：变量的初始化顺序" class="headerlink" title="1-3：变量的初始化顺序"></a>1-3：变量的初始化顺序</h3><ol>
<li>父类静态代码块</li>
<li>子类静态代码块</li>
<li>父类成员代码块</li>
<li>父类构造函数</li>
<li>子类成员代码块</li>
<li>子类构造函数</li>
</ol>
<p>静态代码块和非静态代码块按顺序加载</p>
<h3 id="1-4：⾯向过程性能⽐⾯向对象⾼"><a href="#1-4：⾯向过程性能⽐⾯向对象⾼" class="headerlink" title="1-4：⾯向过程性能⽐⾯向对象⾼"></a>1-4：⾯向过程性能⽐⾯向对象⾼</h3><p>因为类加载过程需要实例化，比较消耗资源，但是面向对象的特征又使得程序易维护，易复用，易扩展。</p>
<p>但是面向过程也需要分配内存，计算内存偏移量，Java性能差的主要原因并不是因为它是面向对象语言，而是Java是半编译语言，最终的执行代码并不是可以直接被CPU执行的二进制机械码。而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定比Java好。</p>
<h3 id="1-5：持久化对象三种状态"><a href="#1-5：持久化对象三种状态" class="headerlink" title="1-5：持久化对象三种状态"></a>1-5：持久化对象三种状态</h3><p>瞬态，持久化，托管</p>
<h2 id="2：Java基础-面对对象-OOP"><a href="#2：Java基础-面对对象-OOP" class="headerlink" title="2：Java基础-面对对象(OOP)"></a>2：Java基础-面对对象(OOP)</h2><h3 id="2-1：面向对象的原则"><a href="#2-1：面向对象的原则" class="headerlink" title="2-1：面向对象的原则"></a>2-1：面向对象的原则</h3><ol>
<li>单一职责原则（Single Responsibility Principle）<br>每一个类应该专注于做一件事情。</li>
<li>里氏替换原则（Liskov Substitution Principle）<br>超类存在的地方，子类是可以替换的。</li>
<li>依赖倒置原则（Dependence Inversion Principle）<br>实现尽量依赖抽象，不依赖具体实现。</li>
<li>接口隔离原则（Interface Segregation Principle）<br>应当为客户端提供尽可能小的单独的接口，而不是提供大的总的接口。</li>
<li>迪米特法则（Law Of Demeter）<br>又叫最少知识原则，一个软件实体应当尽可能少的与其他实体发生相互作用。</li>
<li>开闭原则（Open Close Principle）<br>面向扩展开放，面向修改关闭。</li>
<li>组合/聚合复用原则（Composite/Aggregate Reuse Principle CARP）<br>尽量使用合成/聚合达到复用，尽量少用继承。原则： 一个类中有另一个类的对象。</li>
</ol>
<h3 id="2-2：Java类以及类的成员"><a href="#2-2：Java类以及类的成员" class="headerlink" title="2-2：Java类以及类的成员"></a>2-2：Java类以及类的成员</h3><h4 id="2-2-1：属性"><a href="#2-2-1：属性" class="headerlink" title="2-2-1：属性"></a>2-2-1：属性</h4><h5 id="2-2-1-1：属性与局部变量的相同点、不同点"><a href="#2-2-1-1：属性与局部变量的相同点、不同点" class="headerlink" title="2-2-1-1：属性与局部变量的相同点、不同点"></a>2-2-1-1：属性与局部变量的相同点、不同点</h5><ol>
<li>属性直接声明在类里边，方法外边的变量为属性变量，直接声明在方法里边的变量为局部变量</li>
<li>属性变量有默认值，在使用之前不要求一定赋值，局部变量没有默认值，在使用之前一定要被赋值</li>
<li>属性变量可以有权限修饰符修饰，局部变量不能用权限修饰符修饰</li>
<li>属性变量的作用范围在整个类中，局部变量的作用范围在所属代码段中</li>
<li>属性变量可以由static修饰，局部变量不能由static修饰</li>
</ol>
<h4 id="2-2-2：Java基础-构造器"><a href="#2-2-2：Java基础-构造器" class="headerlink" title="2-2-2：Java基础-构造器"></a>2-2-2：Java基础-构造器</h4><h4 id="2-2-2-1：⼀个类的构造⽅法的作⽤是什么"><a href="#2-2-2-1：⼀个类的构造⽅法的作⽤是什么" class="headerlink" title="2-2-2-1：⼀个类的构造⽅法的作⽤是什么"></a>2-2-2-1：⼀个类的构造⽅法的作⽤是什么</h4><p>完成对象的初始化</p>
<h4 id="2-2-2-2：构造⽅法有哪些特性？"><a href="#2-2-2-2：构造⽅法有哪些特性？" class="headerlink" title="2-2-2-2：构造⽅法有哪些特性？"></a>2-2-2-2：构造⽅法有哪些特性？</h4><p>无返回值，不可重写，不可以用<code>static</code>，<code>synchronized</code>，<code>abstart</code>，<code>final</code>修饰。方法名和类名相同</p>
<h4 id="2-2-2-3：构造方法可不可以被重写和重载"><a href="#2-2-2-3：构造方法可不可以被重写和重载" class="headerlink" title="2-2-2-3：构造方法可不可以被重写和重载"></a>2-2-2-3：构造方法可不可以被重写和重载</h4><p>构造方法可以重载，不可以重写</p>
<h4 id="2-2-2-4：构造函数能用private修饰吗"><a href="#2-2-2-4：构造函数能用private修饰吗" class="headerlink" title="2-2-2-4：构造函数能用private修饰吗"></a>2-2-2-4：构造函数能用private修饰吗</h4><p>构造方法可以用private修饰，保证只有内部方法可以通过这个构造</p>
<h3 id="2-3：面对对象三大特性"><a href="#2-3：面对对象三大特性" class="headerlink" title="2-3：面对对象三大特性"></a>2-3：面对对象三大特性</h3><blockquote>
<p>来自维基百科：面向对象程序设计（英语：Object-oriented programming，缩写：OOP）是种具有对象概念的编程典范，同时也是一种程序开发的抽象方针。它可能包含数据、属性、代码与方法。对象则指的是类（class）的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性，对象里的程序可以访问及经常修改对象相关联的数据。在面向对象程序编程里，计算机程序会被设计成彼此相关的对象。</p>
</blockquote>
<h4 id="2-3-1：封装"><a href="#2-3-1：封装" class="headerlink" title="2-3-1：封装"></a>2-3-1：封装</h4><ul>
<li>封装（数据安全）：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。</li>
</ul>
<h5 id="2-3-1-1：封装的应用场景"><a href="#2-3-1-1：封装的应用场景" class="headerlink" title="2-3-1-1：封装的应用场景"></a>2-3-1-1：封装的应用场景</h5><ol>
<li>控制访问范围</li>
<li>代码复用</li>
<li>隐藏实现细节</li>
</ol>
<h4 id="2-3-2：继承"><a href="#2-3-2：继承" class="headerlink" title="2-3-2：继承"></a>2-3-2：继承</h4><h5 id="2-3-2-1：什么是继承"><a href="#2-3-2-1：什么是继承" class="headerlink" title="2-3-2-1：什么是继承"></a>2-3-2-1：什么是继承</h5><ul>
<li>继承（代码复用）：在已存在的类的基础上扩展新类，提高代码的复用，程序的可维护性，节省大量创建新类的时间，提高效率。</li>
</ul>
<h5 id="2-3-2-2：继承的应用场景"><a href="#2-3-2-2：继承的应用场景" class="headerlink" title="2-3-2-2：继承的应用场景"></a>2-3-2-2：继承的应用场景</h5><p>对现存场景修改，维护</p>
<h4 id="2-3-3：多态"><a href="#2-3-3：多态" class="headerlink" title="2-3-3：多态"></a>2-3-3：多态</h4><ul>
<li>多态（动态绑定）：多态是同一个行为具有多个不同表现形式或形态的能力。</li>
</ul>
<h5 id="2-3-3-1：多态的必要条件（实现方式、机制）"><a href="#2-3-3-1：多态的必要条件（实现方式、机制）" class="headerlink" title="2-3-3-1：多态的必要条件（实现方式、机制）"></a>2-3-3-1：多态的必要条件（实现方式、机制）</h5><ol>
<li>继承（实现）</li>
<li>重写</li>
<li>父类引用指向子类实例</li>
</ol>
<h5 id="2-3-3-2：多态的好处"><a href="#2-3-3-2：多态的好处" class="headerlink" title="2-3-3-2：多态的好处"></a>2-3-3-2：多态的好处</h5><p>在不同情形可以更方便的调用不同方法，设计模式就经常使用多态来实现。通过实现同一接口的不同具体实现，来调用方法名相同但是具体效果不同的方法。</p>
<h5 id="2-3-3-3：多态的例子"><a href="#2-3-3-3：多态的例子" class="headerlink" title="2-3-3-3：多态的例子"></a>2-3-3-3：多态的例子</h5><p>策略模式，状态模式，设计模式基本都有多态</p>
<h3 id="2-4：抽象"><a href="#2-4：抽象" class="headerlink" title="2-4：抽象"></a>2-4：抽象</h3><h4 id="2-4-1：Java-抽象类可以有构造函数吗？作用是什么"><a href="#2-4-1：Java-抽象类可以有构造函数吗？作用是什么" class="headerlink" title="2-4-1：Java 抽象类可以有构造函数吗？作用是什么"></a>2-4-1：Java 抽象类可以有构造函数吗？作用是什么</h4><p>抽象类可以有构造函数，虽然抽象类不能实例化，但是子类可以通过父类构造函数初始化父类属性。</p>
<h4 id="2-4-2：Java-抽象类可以实现接口吗？-它们需要实现所有的方法吗"><a href="#2-4-2：Java-抽象类可以实现接口吗？-它们需要实现所有的方法吗" class="headerlink" title="2-4-2：Java 抽象类可以实现接口吗？ 它们需要实现所有的方法吗"></a>2-4-2：Java 抽象类可以实现接口吗？ 它们需要实现所有的方法吗</h4><p>抽象类可以实现接口，不需要实现所有因为，因为抽象类自身也有抽象方法</p>
<h4 id="2-4-3：Java-抽象类可以是-final-的吗"><a href="#2-4-3：Java-抽象类可以是-final-的吗" class="headerlink" title="2-4-3：Java 抽象类可以是 final 的吗"></a>2-4-3：Java 抽象类可以是 final 的吗</h4><p>不可以，因为抽象类就是用来继承的</p>
<h4 id="2-4-4：Java-抽象类可以有-static-方法吗"><a href="#2-4-4：Java-抽象类可以有-static-方法吗" class="headerlink" title="2-4-4：Java 抽象类可以有 static 方法吗"></a>2-4-4：Java 抽象类可以有 static 方法吗</h4><p>可以</p>
<h4 id="2-4-5：可以创建抽象类的实例吗（new-类）"><a href="#2-4-5：可以创建抽象类的实例吗（new-类）" class="headerlink" title="2-4-5：可以创建抽象类的实例吗（new 类）"></a>2-4-5：可以创建抽象类的实例吗（new 类）</h4><p>不可以</p>
<h4 id="2-4-6：抽象类必须有抽象方法吗"><a href="#2-4-6：抽象类必须有抽象方法吗" class="headerlink" title="2-4-6：抽象类必须有抽象方法吗"></a>2-4-6：抽象类必须有抽象方法吗</h4><p>不一定，只是无论有没有抽象方法抽象类都不能实例化</p>
<h4 id="2-4-7：何时选用抽象类而不是接口"><a href="#2-4-7：何时选用抽象类而不是接口" class="headerlink" title="2-4-7：何时选用抽象类而不是接口"></a>2-4-7：何时选用抽象类而不是接口</h4><p>接口被用于常用的功能，便于日后维护和添加删除，而抽象类更倾向于充当公共类的角色，不适用于日后重新对立面的代码修改。功能需要累积时用抽象类，不需要累积时用接口。</p>
<h4 id="2-4-8：Java中的抽象方法是什么"><a href="#2-4-8：Java中的抽象方法是什么" class="headerlink" title="2-4-8：Java中的抽象方法是什么"></a>2-4-8：Java中的抽象方法是什么</h4><p>用<code>abstract</code>修饰的没有方法体的方法。</p>
<h4 id="2-4-9：Java抽象类中可以包含main方法吗"><a href="#2-4-9：Java抽象类中可以包含main方法吗" class="headerlink" title="2-4-9：Java抽象类中可以包含main方法吗"></a>2-4-9：Java抽象类中可以包含main方法吗</h4><p>可以</p>
<h3 id="2-5：面对对象区别"><a href="#2-5：面对对象区别" class="headerlink" title="2-5：面对对象区别"></a>2-5：面对对象区别</h3><h4 id="2-5-1：接⼝和抽象类的区别"><a href="#2-5-1：接⼝和抽象类的区别" class="headerlink" title="2-5-1：接⼝和抽象类的区别"></a>2-5-1：接⼝和抽象类的区别</h4><p>相同点：</p>
<ol>
<li>都不能被实例化</li>
<li>接口的实现类或抽象类的子类都只有实现了接口或抽象类中的抽象方法后才能实例化。</li>
</ol>
<p>不同点：</p>
<ol>
<li>接口只有定义，不能有方法的实现，Java 1.8中可以定义default方法体，而抽象类可以有定义与实现，方法可在抽象类中实现。</li>
<li>实现接口的关键字为implements，继承抽象类的关键字为extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。</li>
<li>接口强调特定功能的实现，而抽象类强调所属关系。</li>
<li>接口成员变量默认为public static final，必须赋初值，不能被修改；其所有的成员方法都是public、abstract的。抽象类中成员变量默认default，可在子类中被重新定义，也可被重新赋值；抽象方法被abstract修饰，不能被private、static、synchronized和native等修饰，必须以分号结尾，不带花括号。</li>
<li>接口被用于常用的功能，便于日后维护和添加删除，而抽象类更倾向于充当公共类的角色，不适用于日后重新对立面的代码修改。功能需要累积时用抽象类，不需要累积时用接口。</li>
</ol>
<h4 id="2-5-2：继承和实现区别"><a href="#2-5-2：继承和实现区别" class="headerlink" title="2-5-2：继承和实现区别"></a>2-5-2：继承和实现区别</h4><p>一个类只能继承一个类，但是能实现多个接口</p>
<h4 id="2-5-3：为什么要设计接口、抽象类还有实现类"><a href="#2-5-3：为什么要设计接口、抽象类还有实现类" class="headerlink" title="2-5-3：为什么要设计接口、抽象类还有实现类"></a>2-5-3：为什么要设计接口、抽象类还有实现类</h4><p>设计模式中的桥接模式其实就是将一个类的复杂属性用抽象类和接口拆分。例如红球，篮球，红色正方体，蓝色正方体，将球和正方体拆分为抽象类形状，颜色拆分为接口。通过这种方式使代码易维护，易扩展，易复用。</p>
<h3 id="2-6-Java基础-关键字"><a href="#2-6-Java基础-关键字" class="headerlink" title="2-6.Java基础-关键字"></a>2-6.Java基础-关键字</h3><h4 id="2-6-1-通过反射访问private成员和方法，既然能访问为什么要private？"><a href="#2-6-1-通过反射访问private成员和方法，既然能访问为什么要private？" class="headerlink" title="2-6-1: 通过反射访问private成员和方法，既然能访问为什么要private？"></a>2-6-1: 通过反射访问private成员和方法，既然能访问为什么要private？</h4><p>private并不是严格的代码安全，只是提供一般情况下的封装，做到不暴露细节。</p>
<h4 id="2-6-2：static关键字"><a href="#2-6-2：static关键字" class="headerlink" title="2-6-2：static关键字"></a>2-6-2：static关键字</h4><h5 id="2-6-2-1：static使用场景"><a href="#2-6-2-1：static使用场景" class="headerlink" title="2-6-2-1：static使用场景"></a>2-6-2-1：static使用场景</h5><ol>
<li>修饰成员变量和成员方法</li>
<li>静态代码块</li>
<li>修饰类(只能修饰内部类)</li>
<li>静态导包(用来导入类中的静态资源，1.5之后的新特性)</li>
</ol>
<h5 id="2-6-2-2：静态⽅法和实例⽅法有何不同"><a href="#2-6-2-2：静态⽅法和实例⽅法有何不同" class="headerlink" title="2-6-2-2：静态⽅法和实例⽅法有何不同"></a>2-6-2-2：静态⽅法和实例⽅法有何不同</h5><ol>
<li>外部调用方法时，可以直接通过类型调用静态方法，而实例方法必须用对象调用</li>
<li>静态方法内部不能调用实例变量和实例方法。而实例方法都可以。</li>
</ol>
<h5 id="2-6-2-3：静态变量和实例变量的区别？"><a href="#2-6-2-3：静态变量和实例变量的区别？" class="headerlink" title="2-6-2-3：静态变量和实例变量的区别？"></a>2-6-2-3：静态变量和实例变量的区别？</h5><p>静态变量属于类，实例变量属于对象。</p>
<h5 id="2-6-2-4：static方法可以访问非static方法或变量吗"><a href="#2-6-2-4：static方法可以访问非static方法或变量吗" class="headerlink" title="2-6-2-4：static方法可以访问非static方法或变量吗?"></a>2-6-2-4：static方法可以访问非static方法或变量吗?</h5><p>不可以</p>
<h4 id="2-6-3：final关键字"><a href="#2-6-3：final关键字" class="headerlink" title="2-6-3：final关键字"></a>2-6-3：final关键字</h4><h5 id="2-6-3-1：final关键字使用场景"><a href="#2-6-3-1：final关键字使用场景" class="headerlink" title="2-6-3-1：final关键字使用场景"></a>2-6-3-1：final关键字使用场景</h5><ol>
<li>final修饰类，表示类不可继承</li>
<li>final修饰方法，表示方法不可重写</li>
<li>final修饰常量，表示常亮不可更改，必须显式初始化。但是常亮如果式引用类型，只是引用不能改变，对象属性可以改变。</li>
</ol>
<h5 id="2-6-3-2：final-finally-finalize-的区别。"><a href="#2-6-3-2：final-finally-finalize-的区别。" class="headerlink" title="2-6-3-2：final, finally, finalize 的区别。"></a>2-6-3-2：final, finally, finalize 的区别。</h5><ol>
<li>final是修饰符，用来修饰类，方法，常亮</li>
<li>finally是代码块，用于执行try-catch的收尾</li>
<li>finalize是垃圾回收方法，用于进行垃圾回收</li>
</ol>
<h5 id="2-6-3-3：使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？"><a href="#2-6-3-3：使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？" class="headerlink" title="2-6-3-3：使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？"></a>2-6-3-3：使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？</h5><p>引用不能边，对象属性可以改变</p>
<h4 id="2-6-4：this关键字和super关键字"><a href="#2-6-4：this关键字和super关键字" class="headerlink" title="2-6-4：this关键字和super关键字"></a>2-6-4：this关键字和super关键字</h4><p>this关键字调用本对象，super调用父类</p>
<h4 id="2-6-5：transient关键字"><a href="#2-6-5：transient关键字" class="headerlink" title="2-6-5：transient关键字"></a>2-6-5：transient关键字</h4><p>transient关键字用于不参与序列化</p>
<h3 id="2-7-Java基础-重载与重写"><a href="#2-7-Java基础-重载与重写" class="headerlink" title="2-7.Java基础-重载与重写"></a>2-7.Java基础-重载与重写</h3><h4 id="2-7-1：重载与重写"><a href="#2-7-1：重载与重写" class="headerlink" title="2-7-1：重载与重写"></a>2-7-1：重载与重写</h4><p>重载发生在一个类中，同一个方法根据传入数据的不同，做出不同的处理<br>重写发生在父类和子类中，传入数据相同，返回值相同。</p>
<table>
<thead>
<tr>
<th align="center">区别点</th>
<th align="center">重载</th>
<th align="center">重写</th>
</tr>
</thead>
<tbody><tr>
<td align="center">发生范围</td>
<td align="center">同一个类</td>
<td align="center">子类</td>
</tr>
<tr>
<td align="center">参数列表</td>
<td align="center">必须修改</td>
<td align="center">不能修改</td>
</tr>
<tr>
<td align="center">返回类型</td>
<td align="center">可修改</td>
<td align="center">子类更小或相等</td>
</tr>
<tr>
<td align="center">异常</td>
<td align="center">可修改</td>
<td align="center">更小或相等</td>
</tr>
<tr>
<td align="center">访问修饰符</td>
<td align="center">可修改</td>
<td align="center">子类访问范围更大或相等</td>
</tr>
<tr>
<td align="center">发生阶段</td>
<td align="center">编译器</td>
<td align="center">运行期</td>
</tr>
</tbody></table>
<blockquote>
<p>返回类型为void或基础类型不可修改，引用类型可以使用子类</p>
</blockquote>
<h4 id="2-7-2：Java-中是否可以覆盖-override-一个-private-或者是-static-的方法？"><a href="#2-7-2：Java-中是否可以覆盖-override-一个-private-或者是-static-的方法？" class="headerlink" title="2-7-2：Java 中是否可以覆盖(override)一个 private 或者是 static 的方法？"></a>2-7-2：Java 中是否可以覆盖(override)一个 private 或者是 static 的方法？</h4><p>不可以</p>
<ul>
<li>private方法只有父类能访问，子类不能访问。所以不能重写</li>
<li>static方法是编译时绑定，重写是运行时绑定，形式上可以重写，但是实际上不起作用</li>
</ul>
<h3 id="2-8-Java基础-值传递与引用传递"><a href="#2-8-Java基础-值传递与引用传递" class="headerlink" title="2-8.Java基础-值传递与引用传递"></a>2-8.Java基础-值传递与引用传递</h3><h4 id="2-8-1：值传递与引用传递的概念"><a href="#2-8-1：值传递与引用传递的概念" class="headerlink" title="2-8-1：值传递与引用传递的概念"></a>2-8-1：值传递与引用传递的概念</h4><ol>
<li>值传递（pass by value）是指在调用函数时将实际参数<strong>复制</strong>一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</li>
<li>引用传递（pass by reference）是指在调用函数时将实际参数的地址<strong>直接</strong>传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</li>
</ol>
<h4 id="2-8-2：值传递与引用传递的实例举证"><a href="#2-8-2：值传递与引用传递的实例举证" class="headerlink" title="2-8-2：值传递与引用传递的实例举证"></a>2-8-2：值传递与引用传递的实例举证</h4><p>基础类型就是值传递，引用类型例如数组，字符串也是值传递，是将引用复制一份传递个方法。</p>
<h3 id="2-9-Java基础-深拷贝与浅拷贝"><a href="#2-9-Java基础-深拷贝与浅拷贝" class="headerlink" title="2-9.Java基础-深拷贝与浅拷贝"></a>2-9.Java基础-深拷贝与浅拷贝</h3><h4 id="2-9-1：深拷贝与浅拷贝"><a href="#2-9-1：深拷贝与浅拷贝" class="headerlink" title="2-9-1：深拷贝与浅拷贝"></a>2-9-1：深拷贝与浅拷贝</h4><ul>
<li>如果类中属性有自定义引用类型，浅拷贝只拷贝引用，不拷贝引用指向的对象。浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝</li>
<li>深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝（例：JSON.parse()和JSON.stringify()，但是此方法无法复制函数类型）</li>
</ul>
<h4 id="2-9-2：浅拷贝方法"><a href="#2-9-2：浅拷贝方法" class="headerlink" title="2-9-2：浅拷贝方法"></a>2-9-2：浅拷贝方法</h4><p>实现Cloneable接口，重写clone方法。</p>
<h4 id="2-9-3：深拷贝方法"><a href="#2-9-3：深拷贝方法" class="headerlink" title="2-9-3：深拷贝方法"></a>2-9-3：深拷贝方法</h4><p>实现Cloneable接口，重写clone方法法将属性对象也调用clone方法。或者实现Serializable接口</p>
<h4 id="2-9-4：赋值和浅拷贝的区别"><a href="#2-9-4：赋值和浅拷贝的区别" class="headerlink" title="2-9-4：赋值和浅拷贝的区别"></a>2-9-4：赋值和浅拷贝的区别</h4><p>赋值时直接将引用影响堆内存，浅拷贝的问题是只是复制一个引用</p>
<h3 id="2-10-equals与hashcode"><a href="#2-10-equals与hashcode" class="headerlink" title="2-10 equals与hashcode"></a>2-10 equals与hashcode</h3><h4 id="2-10-1：为什么要重写hashcode与equals"><a href="#2-10-1：为什么要重写hashcode与equals" class="headerlink" title="2-10-1：为什么要重写hashcode与equals"></a>2-10-1：为什么要重写hashcode与equals</h4><p>因为hashcode和equals方法是Object类的方法，如果不重写equals()，则会直接比较引用。源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">    return (this &#x3D;&#x3D; obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，如果不充写equals()方法则二者不可能相等。而hashcode和equals的关系是：</p>
<ol>
<li>hashcode不等，equals()一定不等</li>
<li>hashcode相等，equasl()也不一定相等</li>
<li>equasl()相等，hashcode一定相等</li>
<li>equasl()不等，hashcode也一定不等</li>
</ol>
<p>这四条定义是为了保证HashMap这一类使用hash的类计算不出错。虽然重写equals()方法不重写hashCode()方法也不会报错。<br>但是在HashMap的比较中，是根据hashcode先比较，在使用equals()进行比较。如果不重写hashCode()方法有极大概率永远也不会相等。那么HashMap就废掉了。</p>
<h4 id="2-10-2：重写equals不重写hashcode会出现什么问题"><a href="#2-10-2：重写equals不重写hashcode会出现什么问题" class="headerlink" title="2-10-2：重写equals不重写hashcode会出现什么问题"></a>2-10-2：重写equals不重写hashcode会出现什么问题</h4><p>HashMap无法比较，无法get</p>
<h4 id="2-10-3：为什么两个对象有相同的hashcode值，它们也不一定是相等的？"><a href="#2-10-3：为什么两个对象有相同的hashcode值，它们也不一定是相等的？" class="headerlink" title="2-10-3：为什么两个对象有相同的hashcode值，它们也不一定是相等的？"></a>2-10-3：为什么两个对象有相同的hashcode值，它们也不一定是相等的？</h4><p>不重写的时候，hashcode是根据jvm内存地址经过运算而来，所以一般是不相等的。而重写后根据重写后的规则才可能相同。</p>
<h4 id="2-10-4：阿里关于hashcode和equals的处理规则"><a href="#2-10-4：阿里关于hashcode和equals的处理规则" class="headerlink" title="2-10-4：阿里关于hashcode和equals的处理规则"></a>2-10-4：阿里关于hashcode和equals的处理规则</h4><p>关于hashCode和equals的处理，遵循如下规则：</p>
<ol>
<li>只要覆写equals，就必须覆写hashCode。</li>
<li>因为Set存储的是不重复的对象，依据hashCode和equals进行判断，所以Set存储的对象必须覆写这两种方法。 </li>
<li>如果自定义对象作为Map的键，那么必须覆写hashCode和equals。</li>
</ol>
<h4 id="2-10-5：hashcode和equals源码写一下"><a href="#2-10-5：hashcode和equals源码写一下" class="headerlink" title="2-10-5：hashcode和equals源码写一下"></a>2-10-5：hashcode和equals源码写一下</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hashcode是个native方法</p>
<h3 id="2-11-i-与-i的问题"><a href="#2-11-i-与-i的问题" class="headerlink" title="2-11 i++与++i的问题"></a>2-11 i++与++i的问题</h3><h4 id="2-11-1：i-和-i的区别，及其线程安全问题"><a href="#2-11-1：i-和-i的区别，及其线程安全问题" class="headerlink" title="2-11-1：i++和++i的区别，及其线程安全问题"></a>2-11-1：i++和++i的区别，及其线程安全问题</h4><p>i++是调用i的值，再+1，++i是先+1，让调用i的值。这两个都是线程不安全的。</p>
<p><code>i++</code>其实是取值，运算，赋值三步操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> temp = i</span><br><span class="line">temp+<span class="number">1</span></span><br><span class="line">i = temp</span><br></pre></td></tr></table></figure>

<p>如果a,b两个线程同时进行i++，a先读取i的值为100，随后切换线程b读取i的值也为100。然后a进行100+1并赋值，b也进行100+1并赋值。最后的结果为i=101，实际运算结果为i=102。</p>
<h4 id="2-11-2：i-和-i是否为原子操作"><a href="#2-11-2：i-和-i是否为原子操作" class="headerlink" title="2-11-2：i++和++i是否为原子操作"></a>2-11-2：i++和++i是否为原子操作</h4><p>不是</p>
<h4 id="2-11-3：如何实现i-和-i的原子性呢？"><a href="#2-11-3：如何实现i-和-i的原子性呢？" class="headerlink" title="2-11-3：如何实现i++和++i的原子性呢？"></a>2-11-3：如何实现i++和++i的原子性呢？</h4><p>atomic包</p>
<h3 id="2-12-数据类型"><a href="#2-12-数据类型" class="headerlink" title="2-12 数据类型"></a>2-12 数据类型</h3><h4 id="2-12-1：八种数据类型是什么？"><a href="#2-12-1：八种数据类型是什么？" class="headerlink" title="2-12-1：八种数据类型是什么？"></a>2-12-1：八种数据类型是什么？</h4><p>byte，short，int，lone，float，double，char，boolean</p>
<h5 id="2-12-1-1：Java为什么除了基本数据类型还要有引用数据类型"><a href="#2-12-1-1：Java为什么除了基本数据类型还要有引用数据类型" class="headerlink" title="2-12-1-1：Java为什么除了基本数据类型还要有引用数据类型"></a>2-12-1-1：Java为什么除了基本数据类型还要有引用数据类型</h5><p>Java是面向对象语言，准确来说是只有引用类型的，而基础数据类型是为了减少资源消耗，加快运行速度推出的。</p>
<h5 id="2-12-1-2：String为什么不是基本数据类型"><a href="#2-12-1-2：String为什么不是基本数据类型" class="headerlink" title="2-12-1-2：String为什么不是基本数据类型"></a>2-12-1-2：String为什么不是基本数据类型</h5><p>String内部其实是个char[]数组，所以是引用类型</p>
<h5 id="2-12-1-2：引用类型有哪几种"><a href="#2-12-1-2：引用类型有哪几种" class="headerlink" title="2-12-1-2：引用类型有哪几种"></a>2-12-1-2：引用类型有哪几种</h5><p>除了基础类型都是引用类型</p>
<h5 id="2-12-2：数据类型的范围"><a href="#2-12-2：数据类型的范围" class="headerlink" title="2-12-2：数据类型的范围"></a>2-12-2：数据类型的范围</h5><ul>
<li>byte：一个字节，-2^7-1<del>2^7，-128</del>127</li>
<li>short：两个字节，-2^15-1<del>2^15，-32768</del>32767</li>
<li>int：四个字节，-2^31-1<del>2^31，-2147483648</del>2147483647</li>
<li>long：八个字节，-2^63-1<del>2^63，-9223372036854774808</del>9223372036854774807</li>
<li>float：四个字节，3.402823e+38 ~ 1.401298e-45</li>
<li>double：八个字节，1.797693e+308~ 4.9000000e-324</li>
<li>char：两个字节</li>
<li>boolean：四个字节</li>
</ul>
<h5 id="2-12-2-1：为什么byte类型是-128-127"><a href="#2-12-2-1：为什么byte类型是-128-127" class="headerlink" title="2-12-2-1：为什么byte类型是-128~+127"></a>2-12-2-1：为什么byte类型是-128~+127</h5><ol>
<li>计算机中负数是用补码的形式保存、并用它参与加减法运算的，减法会被转换为加法，计算机中没有减法运算。</li>
<li>反码是为了解决减法运算，补码是为了解决反码产生的±0的问题。参考(<a target="_blank" rel="noopener" href="https://blog.csdn.net/boatalways/article/details/17027573">https://blog.csdn.net/boatalways/article/details/17027573</a>)</li>
<li>对人而言二进制所代表的值一定是从原码求出的，开头如果是1的二进制，一定要说明其是原码、反码还是补码。</li>
<li>在原码、反码、补码相互转换以及求对应的十进制求值时，符号位是绝不参与的，但是在加减过程中，是参与位运算的。</li>
<li>计算机中规定了+0对应的二进制就是0，那么-0就没有意义了，必须找一个数和它对应。</li>
<li>byte的最小值-128、short的最小值-32768、int的最小值-2147483648都是用对应的-0的原码来进行表示，这是人为规定的、人为规定的、人为规定的。但是这么规定又很巧妙，妙在上述10中的三点。</li>
</ol>
<h4 id="2-12-3：自动拆装箱"><a href="#2-12-3：自动拆装箱" class="headerlink" title="2-12-3：自动拆装箱"></a>2-12-3：自动拆装箱</h4><h5 id="2-12-3-1：为什么要有自动拆装箱"><a href="#2-12-3-1：为什么要有自动拆装箱" class="headerlink" title="2-12-3-1：为什么要有自动拆装箱"></a>2-12-3-1：为什么要有自动拆装箱</h5><p>基础类型是为了使运算更快，而包装类型是为了使基础类型具有类的特性。有了这两样东西有时候就需要进行转换，所以就有了自动拆装箱。</p>
<h5 id="2-12-3-2：自动拆装箱的原理"><a href="#2-12-3-2：自动拆装箱的原理" class="headerlink" title="2-12-3-2：自动拆装箱的原理"></a>2-12-3-2：自动拆装箱的原理</h5><p>自动装箱都是通过包装类的 <code>valueOf()</code> 方法来实现的.自动拆箱都是通过包装类对象的 <code>xxxValue()</code> 来实现的。</p>
<h5 id="2-12-3-3：自动拆装箱使用场景"><a href="#2-12-3-3：自动拆装箱使用场景" class="headerlink" title="2-12-3-3：自动拆装箱使用场景"></a>2-12-3-3：自动拆装箱使用场景</h5><ol>
<li>将基础类型放入集合 - 自动装箱</li>
<li>包装类型和基本类型的大小比较 - 自动拆箱</li>
<li>包装类型的运算 - 自动拆箱</li>
<li>三目运算符的使用 - 自动拆箱</li>
<li>函数参数与返回值</li>
</ol>
<h5 id="2-12-3-4：自动拆装箱带来的问题"><a href="#2-12-3-4：自动拆装箱带来的问题" class="headerlink" title="2-12-3-4：自动拆装箱带来的问题"></a>2-12-3-4：自动拆装箱带来的问题</h5><ol>
<li>因为包装类型是对象，缓存范围(-128-127)之外的比较需要使用equals</li>
<li>有些场景会自动拆装箱，如果包装类型为null，自动拆箱可能会抛出NPE错误</li>
<li>循环中大量拆装箱，浪费资源</li>
</ol>
<h4 id="2-12-4：Integer缓存机制"><a href="#2-12-4：Integer缓存机制" class="headerlink" title="2-12-4：Integer缓存机制"></a>2-12-4：Integer缓存机制</h4><h5 id="2-12-4-1：int与Integer区别"><a href="#2-12-4-1：int与Integer区别" class="headerlink" title="2-12-4-1：int与Integer区别"></a>2-12-4-1：int与Integer区别</h5><ol>
<li>一个是基础类型，一个是包装类型</li>
<li>Integer变量必须实例化后才能使用；int变量不需要；</li>
<li>Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值</li>
<li>Integer的默认值是null；int的默认值是0。</li>
<li>int可以用<code>==</code>比较，而Integer在缓存池范围内可以用<code>==</code>，范围外必须用equals()</li>
</ol>
<h4 id="2-12-5：String转出int型，-判断能不能转？-如何转？"><a href="#2-12-5：String转出int型，-判断能不能转？-如何转？" class="headerlink" title="2-12-5：String转出int型， 判断能不能转？ 如何转？"></a>2-12-5：String转出int型， 判断能不能转？ 如何转？</h4><p>Integer.parseInt();<br>Integer.valueOf();</p>
<h4 id="2-12-6：short-s1-1-s1-s1-1-有什么错-short-s1-1-s1-1-有什么错"><a href="#2-12-6：short-s1-1-s1-s1-1-有什么错-short-s1-1-s1-1-有什么错" class="headerlink" title="2-12-6：short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1+=1;有什么错?"></a>2-12-6：short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1+=1;有什么错?</h4><p>  因为<code>s1+1</code>会自动进行类型转换，变为int型，而<code>+=</code>是Java规定的运算符，所以不会报错。</p>
<h2 id="3：各种集合家族"><a href="#3：各种集合家族" class="headerlink" title="3：各种集合家族"></a>3：各种集合家族</h2><h3 id="3-1：Collection集合框架"><a href="#3-1：Collection集合框架" class="headerlink" title="3-1：Collection集合框架"></a>3-1：Collection集合框架</h3><h4 id="3-1-2：并发集合框架"><a href="#3-1-2：并发集合框架" class="headerlink" title="3-1-2：并发集合框架"></a>3-1-2：并发集合框架</h4><p>List,Set,Queue</p>
<h3 id="3-2-Hashmap"><a href="#3-2-Hashmap" class="headerlink" title="3-2.Hashmap"></a>3-2.Hashmap</h3><h4 id="3-2-1：hashmap的数据结构"><a href="#3-2-1：hashmap的数据结构" class="headerlink" title="3-2-1：hashmap的数据结构"></a>3-2-1：hashmap的数据结构</h4><p>数组+链表，链表容量为9时转化为红黑树，扩容时小于等于6退化为链表</p>
<h4 id="3-2-1：扩容死循环问题"><a href="#3-2-1：扩容死循环问题" class="headerlink" title="3-2-1：扩容死循环问题"></a>3-2-1：扩容死循环问题</h4><p>jdk1.8以前链表扩容是加入到链表首，而1.8是加入到链表尾，已经不会出现这个问题</p>
<h4 id="3-2-2：链表插入法"><a href="#3-2-2：链表插入法" class="headerlink" title="3-2-2：链表插入法"></a>3-2-2：链表插入法</h4><h5 id="3-2-2-1：头插法"><a href="#3-2-2-1：头插法" class="headerlink" title="3-2-2-1：头插法"></a>3-2-2-1：头插法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node.next = head;</span><br><span class="line">head = node;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-2-2：尾插法"><a href="#3-2-2-2：尾插法" class="headerlink" title="3-2-2-2：尾插法"></a>3-2-2-2：尾插法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tail.next = node;</span><br><span class="line">tail = node;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-3：红黑树的引入"><a href="#3-2-3：红黑树的引入" class="headerlink" title="3-2-3：红黑树的引入"></a>3-2-3：红黑树的引入</h4><h5 id="3-2-3-1：HashMap为什么要树化"><a href="#3-2-3-1：HashMap为什么要树化" class="headerlink" title="3-2-3-1：HashMap为什么要树化?"></a>3-2-3-1：HashMap为什么要树化?</h5><p>在最坏的情况下，查询效率从O(1)变为线性的O(n)，而红黑树就是为了解决这个问题。红黑树能保证最坏情况也有O(logn)的时间复杂度。</p>
<h5 id="3-2-3-2：hashmap树化门槛及作用"><a href="#3-2-3-2：hashmap树化门槛及作用" class="headerlink" title="3-2-3-2：hashmap树化门槛及作用"></a>3-2-3-2：hashmap树化门槛及作用</h5><p>链表长度大于8就会进行树化，是为了保证最坏情况的时间复杂度</p>
<h5 id="3-2-3-3：为什么不把链表全部换为红黑树"><a href="#3-2-3-3：为什么不把链表全部换为红黑树" class="headerlink" title="3-2-3-3：为什么不把链表全部换为红黑树"></a>3-2-3-3：为什么不把链表全部换为红黑树</h5><p>只有数据很多的情况下才需要红黑树，因为红黑树所消耗的资源和链表更大，而时间消耗也不会差太多。</p>
<h5 id="3-2-3-4：为什么是使用红黑树而不是AVL树？"><a href="#3-2-3-4：为什么是使用红黑树而不是AVL树？" class="headerlink" title="3-2-3-4：为什么是使用红黑树而不是AVL树？"></a>3-2-3-4：为什么是使用红黑树而不是AVL树？</h5><p>avl树的自平衡占用资源太多，比红黑树更加严格。</p>
<h5 id="3-2-3-5：为什么不用二叉查找树代替，而选择红黑树"><a href="#3-2-3-5：为什么不用二叉查找树代替，而选择红黑树" class="headerlink" title="3-2-3-5：为什么不用二叉查找树代替，而选择红黑树"></a>3-2-3-5：为什么不用二叉查找树代替，而选择红黑树</h5><p>二叉查找树也会存在最坏情况O(n)的时间复杂度，所以在二叉查找树和avl树之间做一个平衡，选择了红黑树</p>
<h4 id="3-2-4：HashMap为什么可以插入空值"><a href="#3-2-4：HashMap为什么可以插入空值" class="headerlink" title="3-2-4：HashMap为什么可以插入空值?"></a>3-2-4：HashMap为什么可以插入空值?</h4><p>HashMap中如果<code>key == null</code>，那么key的hash为0，而HashTable中会直接抛出空指针异常。</p>
<h4 id="3-2-5：JDK8中hashmap的改变"><a href="#3-2-5：JDK8中hashmap的改变" class="headerlink" title="3-2-5：JDK8中hashmap的改变"></a>3-2-5：JDK8中hashmap的改变</h4><p>扩容机制和红黑树</p>
<h4 id="3-3-2：put操作"><a href="#3-3-2：put操作" class="headerlink" title="3-3-2：put操作"></a>3-3-2：put操作</h4><h4 id="3-3-3：HashMap的get操作"><a href="#3-3-3：HashMap的get操作" class="headerlink" title="3-3-3：HashMap的get操作"></a>3-3-3：HashMap的get操作</h4><h5 id="3-3-3-1：手写get方法"><a href="#3-3-3-1：手写get方法" class="headerlink" title="3-3-3-1：手写get方法"></a>3-3-3-1：手写get方法</h5><h5 id="3-3-3-2：hashmap的get和put操作的时间复杂度"><a href="#3-3-3-2：hashmap的get和put操作的时间复杂度" class="headerlink" title="3-3-3-2：hashmap的get和put操作的时间复杂度"></a>3-3-3-2：hashmap的get和put操作的时间复杂度</h5><p>最好为O(1)，最外为O(n)</p>
<h4 id="3-3-4：hashmap的String类型如何计算hashcode的"><a href="#3-3-4：hashmap的String类型如何计算hashcode的" class="headerlink" title="3-3-4：hashmap的String类型如何计算hashcode的"></a>3-3-4：hashmap的String类型如何计算hashcode的</h4><p>和其他对象，调用对象的hashCode()和高位进行<code>&amp;</code>运算，结果就是HashMap中的hash</p>
<p>String源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// hash为内部属性，初始值为0</span></span><br><span class="line">      <span class="keyword">int</span> h = hash;</span><br><span class="line">      <span class="comment">// 未设置hash时计算</span></span><br><span class="line">      <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">              h = <span class="number">31</span> * h + val[i];</span><br><span class="line">          &#125;</span><br><span class="line">          hash = h;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> h;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>如上，String的hash计算方法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</span><br></pre></td></tr></table></figure>

<h4 id="3-3-5：hashmap容量"><a href="#3-3-5：hashmap容量" class="headerlink" title="3-3-5：hashmap容量"></a>3-3-5：hashmap容量</h4><h5 id="3-3-5-1：HashMap中-tab-length-1-amp-hash作用"><a href="#3-3-5-1：HashMap中-tab-length-1-amp-hash作用" class="headerlink" title="3-3-5-1：HashMap中(tab.length - 1) &amp; hash作用"></a>3-3-5-1：HashMap中(tab.length - 1) &amp; hash作用</h5><p>确定数组下标，其实就是对hash进行取余运算</p>
<h5 id="3-3-5-2：为什么默认初始化桶数组大小"><a href="#3-3-5-2：为什么默认初始化桶数组大小" class="headerlink" title="3-3-5-2：为什么默认初始化桶数组大小"></a>3-3-5-2：为什么默认初始化桶数组大小</h5><p>避免容量太小频繁扩容</p>
<h5 id="3-3-5-3：hashmap为什么是2的次幂"><a href="#3-3-5-3：hashmap为什么是2的次幂" class="headerlink" title="3-3-5-3：hashmap为什么是2的次幂"></a>3-3-5-3：hashmap为什么是2的次幂</h5><p>这是为了更方便的确定数组下标，因为HashMap是对hash进行位运算代替取余，而这一步的前提就是容量时2的幂</p>
<h5 id="3-3-5-4：什么时候扩容"><a href="#3-3-5-4：什么时候扩容" class="headerlink" title="3-3-5-4：什么时候扩容"></a>3-3-5-4：什么时候扩容</h5><p>当前元素数量大于（容量*影响因子）</p>
<h5 id="3-3-5-6：reHash（重散列）过程"><a href="#3-3-5-6：reHash（重散列）过程" class="headerlink" title="3-3-5-6：reHash（重散列）过程"></a>3-3-5-6：reHash（重散列）过程</h5><p>如果是单节点，直接重新计算hash，置于计算结果处，如果是链表或者红黑树，根据<code>hash &amp; oldCap == 0</code> 确定是原位置还是<code>j+oldCap</code>位置，具体解释见-&gt;<a target="_blank" rel="noopener" href="https://shiming.online/blog/a2a7cca8/#resize-%E6%89%A9%E5%AE%B9">HashMap扩容</a>。红黑树重散列后会判断是否需要退化为链表，是否需要重新建立红黑树</p>
<h5 id="3-3-5-7：该容量如何变化"><a href="#3-3-5-7：该容量如何变化" class="headerlink" title="3-3-5-7：该容量如何变化"></a>3-3-5-7：该容量如何变化</h5><p>容量小于最大容量是，直接*2，如果大于最大容量，会将负载因子设为<code>Integer.MAX_VALUE</code>，不在扩容</p>
<h5 id="3-3-5-8：这种变化会带来什么问题"><a href="#3-3-5-8：这种变化会带来什么问题" class="headerlink" title="3-3-5-8：这种变化会带来什么问题"></a>3-3-5-8：这种变化会带来什么问题</h5><p>jdk1.8以前在并发情况下可能会出现链表循环。而jdk1.8已经不会了</p>
<h5 id="3-3-5-9：扩容的几个参数"><a href="#3-3-5-9：扩容的几个参数" class="headerlink" title="3-3-5-9：扩容的几个参数"></a>3-3-5-9：扩容的几个参数</h5><p>oldCap,threshold,loadFactor</p>
<h5 id="3-3-5-10：HashMap-的-table-的容量如何确定"><a href="#3-3-5-10：HashMap-的-table-的容量如何确定" class="headerlink" title="3-3-5-10：HashMap 的 table 的容量如何确定"></a>3-3-5-10：HashMap 的 table 的容量如何确定</h5><p>直接根据容量建立数组</p>
<h5 id="3-3-5-11：loadFactor-是什么"><a href="#3-3-5-11：loadFactor-是什么" class="headerlink" title="3-3-5-11：loadFactor 是什么"></a>3-3-5-11：loadFactor 是什么</h5><p>负载因子，是HashMap对内存和时间效率的一种权衡。它之所以是0.75f，是因为它是内存和时间效率之间的一种经验值，更大虽然内存占用更少，但是hash冲突可能性增加，时间消耗更大；更小虽然hash冲突可能性减少，时间消耗更少，但是内存占用更多。</p>
<h5 id="3-3-5-12：为什么在JDK1-7的时候是先进行扩容后进行插入，而在JDK1-8的时候则是先插入后进行扩容的呢"><a href="#3-3-5-12：为什么在JDK1-7的时候是先进行扩容后进行插入，而在JDK1-8的时候则是先插入后进行扩容的呢" class="headerlink" title="3-3-5-12：为什么在JDK1.7的时候是先进行扩容后进行插入，而在JDK1.8的时候则是先插入后进行扩容的呢"></a>3-3-5-12：为什么在JDK1.7的时候是先进行扩容后进行插入，而在JDK1.8的时候则是先插入后进行扩容的呢</h5><h5 id="3-3-5-13：JDK1-8链表转化为红黑树的阈值是8-而不是7或者不是20呢"><a href="#3-3-5-13：JDK1-8链表转化为红黑树的阈值是8-而不是7或者不是20呢" class="headerlink" title="3-3-5-13：JDK1.8链表转化为红黑树的阈值是8,而不是7或者不是20呢"></a>3-3-5-13：JDK1.8链表转化为红黑树的阈值是8,而不是7或者不是20呢</h5><p>转化为红黑树的前提其实是HashMap数组长度大于等于64后才会转换，而理想情况下，在随机哈希码下，哈希表中节点的频率遵循泊松分布，而根据统计，忽略方差，列表长度为K的期望出现的次数是以下的结果，可以看到其实在为8的时候概率就已经很小了，再往后调整并没有很大意义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* <span class="number">0</span>:    <span class="number">0.60653066</span></span><br><span class="line">* <span class="number">1</span>:    <span class="number">0.30326533</span></span><br><span class="line">* <span class="number">2</span>:    <span class="number">0.07581633</span></span><br><span class="line">* <span class="number">3</span>:    <span class="number">0.01263606</span></span><br><span class="line">* <span class="number">4</span>:    <span class="number">0.00157952</span></span><br><span class="line">* <span class="number">5</span>:    <span class="number">0.00015795</span></span><br><span class="line">* <span class="number">6</span>:    <span class="number">0.00001316</span></span><br><span class="line">* <span class="number">7</span>:    <span class="number">0.00000094</span></span><br><span class="line">* <span class="number">8</span>:    <span class="number">0.00000006</span></span><br></pre></td></tr></table></figure>

<h5 id="3-3-5-14：插入一万个元素之后会不会扩容，扩容扩多少"><a href="#3-3-5-14：插入一万个元素之后会不会扩容，扩容扩多少" class="headerlink" title="3-3-5-14：插入一万个元素之后会不会扩容，扩容扩多少"></a>3-3-5-14：插入一万个元素之后会不会扩容，扩容扩多少</h5><p>其实时根据最大容量的设置来计算的，HashMap默认最大容量为1^30，如果容量大于这个值就不会扩容</p>
<h4 id="3-3-6：hash函数"><a href="#3-3-6：hash函数" class="headerlink" title="3-3-6：hash函数"></a>3-3-6：hash函数</h4><h5 id="3-3-6-1：hash-的实现"><a href="#3-3-6-1：hash-的实现" class="headerlink" title="3-3-6-1：hash 的实现"></a>3-3-6-1：hash 的实现</h5><p>如果key为null，则hash值为0，否则见key的hash和（hash&gt;&gt;&gt;16)的结果进行<code>^</code>运算，避免低位相似高位不同的情况，通过这种散列运算使得hash分布更加均匀，再对hash取余的到下标</p>
<h5 id="3-3-6-2：为什么要用异或运算符？"><a href="#3-3-6-2：为什么要用异或运算符？" class="headerlink" title="3-3-6-2：为什么要用异或运算符？"></a>3-3-6-2：为什么要用异或运算符？</h5><p>如果使用<code>&amp;</code>或者<code>|</code>运算，结果会更加偏向0或1，而<code>^</code>能保证在0到1之间分布更加均匀</p>
<h5 id="3-3-6-3：哈希冲突的解决方法"><a href="#3-3-6-3：哈希冲突的解决方法" class="headerlink" title="3-3-6-3：哈希冲突的解决方法"></a>3-3-6-3：哈希冲突的解决方法</h5><ol>
<li>开放定址法<br>如果hash冲突，以hash进行下一次运算，知道不冲突为止</li>
<li>再hash法<br>通过不同函数构建不同hash，选择一个不冲突的</li>
<li>链地址法<br>将冲突的hash添加到链表中</li>
<li>建立公共溢出区<br>分为基本表和溢出表，凡是和基础表冲突的都添加到溢出区中</li>
</ol>
<p>HashMap使用的就是链地址法</p>
<h5 id="3-3-6-4：一致性hash和普通hash区别"><a href="#3-3-6-4：一致性hash和普通hash区别" class="headerlink" title="3-3-6-4：一致性hash和普通hash区别"></a>3-3-6-4：一致性hash和普通hash区别</h5><p>普通hash：每个ip,或者uri进行hash 计算得到一个数值，然后用这个数值除以整个节点数量取余。<br>普通Hash算法有一个明显的劣势：即当node数发生变化（增加、移除）后，数据项会被重新“打散”，导致大部分数据项不能落到原来的节点上，从而导致大量数据需要迁移。例如HashMap容量变化需要重hash。</p>
<blockquote>
<p>一致性hash：先构造一个长度为2^32的整数环（这个环被称为一致性Hash环），根据节点名称的Hash值（其分布为[0, 2^32-1]）将服务器节点放置在这个Hash环上（例如下图的a\b\c\d），然后根据数据的Key值计算得到其Hash值（其分布也为[0, 2^32-1]），接着在Hash环上顺时针查找距离这个Key值的Hash值最近的服务器节点，完成Key到服务器的映射查找。</p>
</blockquote>
<p>这种算法解决了普通余数Hash算法伸缩性差的问题，可以保证在上线、下线服务器的情况下尽量有多的请求命中原来路由到的服务器。</p>
<p>当然，万事不可能十全十美，一致性Hash算法比普通的余数Hash算法更具有伸缩性，但是同时其算法实现也更为复杂。</p>
<h5 id="3-3-6-5：扰动函数以及作用"><a href="#3-3-6-5：扰动函数以及作用" class="headerlink" title="3-3-6-5：扰动函数以及作用"></a>3-3-6-5：扰动函数以及作用</h5><p>扰动函数即hash的散列运算。通过这个方法减少hash冲突，避免低位相似高位不同的hashcode下标相同。</p>
<h4 id="3-3-7：hashmap线程问题"><a href="#3-3-7：hashmap线程问题" class="headerlink" title="3-3-7：hashmap线程问题"></a>3-3-7：hashmap线程问题</h4><h5 id="3-3-7-1：线程安全的Map"><a href="#3-3-7-1：线程安全的Map" class="headerlink" title="3-3-7-1：线程安全的Map"></a>3-3-7-1：线程安全的Map</h5><p>Hashtable(每个方法都用synchronized修饰),ConcurrentHashMap(分段加锁)</p>
<h4 id="3-3-8：HashMap引用"><a href="#3-3-8：HashMap引用" class="headerlink" title="3-3-8：HashMap引用"></a>3-3-8：HashMap引用</h4><h5 id="3-3-8-1：为什么hashmap中String、integer包装类适合作为key"><a href="#3-3-8-1：为什么hashmap中String、integer包装类适合作为key" class="headerlink" title="3-3-8-1：为什么hashmap中String、integer包装类适合作为key"></a>3-3-8-1：为什么hashmap中String、integer包装类适合作为key</h5><p>因为 String、Integer 等包装类是 final 类型的，具有不可变性，而且已经重写了 equals() 和 hashCode() 方法。不可变性保证了计算 hashCode() 后键值的唯一性和缓存特性，不会出现放入和获取时哈希码不同的情况且读取哈希值的高效性，此外官方实现的 equals() 和 hashCode() 都是严格遵守相关规范的，不会出现错误。</p>
<h5 id="3-3-8-2：如果想要一个key对应多个Value的话，怎么设计Map"><a href="#3-3-8-2：如果想要一个key对应多个Value的话，怎么设计Map" class="headerlink" title="3-3-8-2：如果想要一个key对应多个Value的话，怎么设计Map"></a>3-3-8-2：如果想要一个key对应多个Value的话，怎么设计Map</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,HashSet&lt;String&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>即key随意存放，value用set来存放多个value</p>
<h5 id="3-3-8-3：创建一个对象HashMap-lt-Integer-Integer-gt-map-new-HashMap-lt-gt-先put-10-1-然后get-new-Long-10-结果是多少？"><a href="#3-3-8-3：创建一个对象HashMap-lt-Integer-Integer-gt-map-new-HashMap-lt-gt-先put-10-1-然后get-new-Long-10-结果是多少？" class="headerlink" title="3-3-8-3：创建一个对象HashMap&lt;Integer,Integer&gt; map=new HashMap&lt;&gt;先put(10,1),然后get(new Long(10))结果是多少？"></a>3-3-8-3：创建一个对象HashMap&lt;Integer,Integer&gt; map=new HashMap&lt;&gt;先put(10,1),然后get(new Long(10))结果是多少？</h5><p>结果就是1，因为HashMap内部的比较方法使用<code>==</code>和equals()同时进行比较，只要有一个满足条件都可以</p>
<h5 id="3-3-8-4：使用final-static修饰集合Hashmap会产生什么影响"><a href="#3-3-8-4：使用final-static修饰集合Hashmap会产生什么影响" class="headerlink" title="3-3-8-4：使用final static修饰集合Hashmap会产生什么影响"></a>3-3-8-4：使用final static修饰集合Hashmap会产生什么影响</h5><p>必须要显式初始化，而且HashMap不能修改引用。就和正常用final修饰对象相同。</p>
<h5 id="3-3-8-5：JDK的Hashmap与Redis的Hashmap的区别"><a href="#3-3-8-5：JDK的Hashmap与Redis的Hashmap的区别" class="headerlink" title="3-3-8-5：JDK的Hashmap与Redis的Hashmap的区别"></a>3-3-8-5：JDK的Hashmap与Redis的Hashmap的区别</h5><p>JDK使用数组+链表+红黑树解决，而Redis使用数组+链表。链表插入时，JDK为了避免线程不安全的问题使用尾插法，而Redis使用头插法。</p>
<p>Redis的Hash底层有两个哈希表，扩容时会通过渐进性复制逐渐将ht[0]的值复制到ht[1]中，再释放ht[0]并将ht[1]设为ht[0]。</p>
<h4 id="3-3-9：ConcurrentHashMap数据结构"><a href="#3-3-9：ConcurrentHashMap数据结构" class="headerlink" title="3-3-9：ConcurrentHashMap数据结构"></a>3-3-9：ConcurrentHashMap数据结构</h4><h5 id="3-3-9-1：ConcurrentHashMap的底层实现"><a href="#3-3-9-1：ConcurrentHashMap的底层实现" class="headerlink" title="3-3-9-1：ConcurrentHashMap的底层实现"></a>3-3-9-1：ConcurrentHashMap的底层实现</h5><p>其实jdk1.8中，HashMap和ConcurrentHashMap底层数据结构是相似的。都是数组+链表+红黑树。<br>只是在一些关键操作利用cas和synchronized加锁，例如数组扩容，插入节点，平衡红黑树等等。在Hashtable中是直接对类加锁，而ConcurrentHashMap是锁数组中的头节点。同一个链表获取锁会竞争同一节点。同时，因为树平衡可能会切换根节点，所以单独列了一个TreeBin用于树的并发控制</p>
<h5 id="3-3-9-2：为什么ConcurrentHashMap（Hashtable）为何不支持null键和null值"><a href="#3-3-9-2：为什么ConcurrentHashMap（Hashtable）为何不支持null键和null值" class="headerlink" title="3-3-9-2：为什么ConcurrentHashMap（Hashtable）为何不支持null键和null值"></a>3-3-9-2：为什么ConcurrentHashMap（Hashtable）为何不支持null键和null值</h5><p>ConcurrentHashMap不支持null键和null值是因为：无法分辨get(key)返回的null是未找到还是value本来就是vnull。即：</p>
<ul>
<li>这个key从来没有在map中映射过，也就是不存在这个key；</li>
<li>这个key是真实存在的，只是在设置key的value值的时候，设置为null了；</li>
</ul>
<p>ConcurrentHashmap和Hashtable都是支持并发的，这样会有一个问题，当你通过get(k)获取对应的value时，如果获取到的是null时，你无法判断，它是put（k,v）的时候value为null，还是这个key从来没有做过映射。HashMap是非并发的，可以通过contains(key)来做这个判断。而支持并发的Map在调用m.contains（key）和m.get(key),m可能已经不同了。</p>
<h5 id="3-3-9-3：分段锁原理"><a href="#3-3-9-3：分段锁原理" class="headerlink" title="3-3-9-3：分段锁原理"></a>3-3-9-3：分段锁原理</h5><p>ConcurrentHashMap锁的是node节点，因为每一个对应位置的节点都竞争的是同一个锁，所以能保证线程安全，而在其他地方使用cas来保证数据的安全。</p>
<h5 id="3-3-9-4：为什么要使用内置锁synchronized来代替重入锁-ReentrantLock？"><a href="#3-3-9-4：为什么要使用内置锁synchronized来代替重入锁-ReentrantLock？" class="headerlink" title="3-3-9-4：为什么要使用内置锁synchronized来代替重入锁 ReentrantLock？"></a>3-3-9-4：为什么要使用内置锁synchronized来代替重入锁 ReentrantLock？</h5><ul>
<li>锁粒度降低了</li>
<li>官方对synchronized进行了优化和升级，使得synchronized不那么“重”了</li>
<li>在大数据量的操作下，对基于API的ReentractLock进行操作会有更大的内存开销</li>
</ul>
<h5 id="3-3-9-5：Hashmap与ConcurrentHashMap中put的区别"><a href="#3-3-9-5：Hashmap与ConcurrentHashMap中put的区别" class="headerlink" title="3-3-9-5：Hashmap与ConcurrentHashMap中put的区别"></a>3-3-9-5：Hashmap与ConcurrentHashMap中put的区别</h5><p>其实区别不大，只是ConcurrentHashMap的初始化方法不同，而后如果正在扩容，会先帮助扩容再加锁添加节点</p>
<h5 id="3-3-9-6：手写ConcurrentHashMap的get操作"><a href="#3-3-9-6：手写ConcurrentHashMap的get操作" class="headerlink" title="3-3-9-6：手写ConcurrentHashMap的get操作"></a>3-3-9-6：手写ConcurrentHashMap的get操作</h5><p>和HashMap的get操作没有区别，只是用cas来取值。同时ConcurrentHashMap的Node结构的val和next是用<code>volatile</code>修饰的。</p>
<h5 id="3-3-9-7：什么时候会发生扩容机制"><a href="#3-3-9-7：什么时候会发生扩容机制" class="headerlink" title="3-3-9-7：什么时候会发生扩容机制"></a>3-3-9-7：什么时候会发生扩容机制</h5><h5 id="3-3-9-8：hashmap与ConcurrentHashMap中扩容的区别"><a href="#3-3-9-8：hashmap与ConcurrentHashMap中扩容的区别" class="headerlink" title="3-3-9-8：hashmap与ConcurrentHashMap中扩容的区别"></a>3-3-9-8：hashmap与ConcurrentHashMap中扩容的区别</h5><h5 id="3-3-9-10：为什么-ConcurrentHashMap-比-Hashtable-效率要高？"><a href="#3-3-9-10：为什么-ConcurrentHashMap-比-Hashtable-效率要高？" class="headerlink" title="3-3-9-10：为什么 ConcurrentHashMap 比 Hashtable 效率要高？"></a>3-3-9-10：为什么 ConcurrentHashMap 比 Hashtable 效率要高？</h5><p>因为ConcurrentHashMap每次锁的是一个节点，粒度更小，而Hashtable是用<code>synchronized</code>修饰方法，相等于锁了整个实例</p>
<h5 id="3-3-9-11：ConcurrentHashMap-的并发度是什么？"><a href="#3-3-9-11：ConcurrentHashMap-的并发度是什么？" class="headerlink" title="3-3-9-11：ConcurrentHashMap 的并发度是什么？"></a>3-3-9-11：ConcurrentHashMap 的并发度是什么？</h5><p>默认为16，即16个线程同时操作，也可以通过构造方法自行设置，但是会自动扩容为2的幂</p>
<h3 id="3-4：TreeMap"><a href="#3-4：TreeMap" class="headerlink" title="3-4：TreeMap"></a>3-4：TreeMap</h3><h4 id="3-4-1：TreeMap数据结构"><a href="#3-4-1：TreeMap数据结构" class="headerlink" title="3-4-1：TreeMap数据结构"></a>3-4-1：TreeMap数据结构</h4><p>红黑树</p>
<h4 id="3-4-2：TreeMap使用场景"><a href="#3-4-2：TreeMap使用场景" class="headerlink" title="3-4-2：TreeMap使用场景"></a>3-4-2：TreeMap使用场景</h4><p>在实际使用中，如果更新图时不需要保持图中元素的顺序，就使用 HashMap，如果需要保持图中元素的插入顺序或者访问顺序，就使用 LinkedHashMap，如果需要使图按照键值排序，就使用 TreeMap。</p>
<h3 id="3-5-LinkedHashMap"><a href="#3-5-LinkedHashMap" class="headerlink" title="3-5.LinkedHashMap"></a>3-5.LinkedHashMap</h3><h4 id="3-5-1：LinkedHashMap数据结构"><a href="#3-5-1：LinkedHashMap数据结构" class="headerlink" title="3-5-1：LinkedHashMap数据结构"></a>3-5-1：LinkedHashMap数据结构</h4><p>HashMap的基础上加上链表，维护插入顺序</p>
<h3 id="3-7-Hashtable"><a href="#3-7-Hashtable" class="headerlink" title="3-7.Hashtable"></a>3-7.Hashtable</h3><h4 id="3-7-1：Hashtable数据结构"><a href="#3-7-1：Hashtable数据结构" class="headerlink" title="3-7-1：Hashtable数据结构"></a>3-7-1：Hashtable数据结构</h4><p>数组+链表，使用synchronized修饰方法</p>
<h3 id="3-8：ArrayLlist"><a href="#3-8：ArrayLlist" class="headerlink" title="3-8：ArrayLlist"></a>3-8：ArrayLlist</h3><h4 id="3-8-1：ArrayList数据结构"><a href="#3-8-1：ArrayList数据结构" class="headerlink" title="3-8-1：ArrayList数据结构"></a>3-8-1：ArrayList数据结构</h4><p>ArrayList底层其实就是数组，访问因为就是访问数组所以速度快，而扩容，删除则是将数组元素进行复制</p>
<h4 id="3-8-2：数组-Array-和列表-ArrayList-有什么区别？"><a href="#3-8-2：数组-Array-和列表-ArrayList-有什么区别？" class="headerlink" title="3-8-2：数组(Array)和列表(ArrayList)有什么区别？"></a>3-8-2：数组(Array)和列表(ArrayList)有什么区别？</h4><ol>
<li>Array 可以容纳基本类型和对象，而 ArrayList 只能容纳对象。</li>
<li>Array 是指定大小的，而 ArrayList 大小不是固定的。</li>
<li>Array 没有提供 ArrayList 那么多功能，比如 addAll、removeAll 和 iterator 等。</li>
</ol>
<h4 id="3-8-3：ArrayList扩容机制"><a href="#3-8-3：ArrayList扩容机制" class="headerlink" title="3-8-3：ArrayList扩容机制"></a>3-8-3：ArrayList扩容机制</h4><p>一般情况下，每次扩容会增加原容量一般的大小。然后将原数组复制到新数组中。而如果没有设定初始容量，则会从10开始。</p>
<h4 id="3-8-4：ArrayList的add操作"><a href="#3-8-4：ArrayList的add操作" class="headerlink" title="3-8-4：ArrayList的add操作"></a>3-8-4：ArrayList的add操作</h4><p>先调用扩容方法，保证能容纳size+1个数组，如果是尾部加入，直接复制，如果是中间插入，就将插入位置开始的数组往后移。</p>
<h4 id="3-8-5：Arraylist初始大小以及扩容大小"><a href="#3-8-5：Arraylist初始大小以及扩容大小" class="headerlink" title="3-8-5：Arraylist初始大小以及扩容大小"></a>3-8-5：Arraylist初始大小以及扩容大小</h4><p>设定了初始容量，就按照初始容量扩容，没有设定初始容量，默认为10。每次扩容会增加原容量一半的值，即（oldCap&gt;&gt;1)</p>
<h4 id="3-8-6：那如何解决ArrayList线程不安全问题呢？"><a href="#3-8-6：那如何解决ArrayList线程不安全问题呢？" class="headerlink" title="3-8-6：那如何解决ArrayList线程不安全问题呢？"></a>3-8-6：那如何解决ArrayList线程不安全问题呢？</h4><ol>
<li>使用Vector类</li>
<li>使用<code>Collections.synchronizedList</code>方法</li>
<li>CopyOnWriteArrayList</li>
</ol>
<h3 id="3-9：vector"><a href="#3-9：vector" class="headerlink" title="3-9：vector"></a>3-9：vector</h3><h4 id="3-9-1：vector数据结构"><a href="#3-9-1：vector数据结构" class="headerlink" title="3-9-1：vector数据结构"></a>3-9-1：vector数据结构</h4><p>数组</p>
<h4 id="3-9-2：扩容机制"><a href="#3-9-2：扩容机制" class="headerlink" title="3-9-2：扩容机制"></a>3-9-2：扩容机制</h4><h3 id="3-10：Linkedlist"><a href="#3-10：Linkedlist" class="headerlink" title="3-10：Linkedlist"></a>3-10：Linkedlist</h3><h4 id="3-10-1：Linkedlist数据结构"><a href="#3-10-1：Linkedlist数据结构" class="headerlink" title="3-10-1：Linkedlist数据结构"></a>3-10-1：Linkedlist数据结构</h4><p>数组的基础上使用链表维护</p>
<h3 id="3-11：HashSet"><a href="#3-11：HashSet" class="headerlink" title="3-11：HashSet"></a>3-11：HashSet</h3><h4 id="3-11-1：HashSet数据结构"><a href="#3-11-1：HashSet数据结构" class="headerlink" title="3-11-1：HashSet数据结构"></a>3-11-1：HashSet数据结构</h4><p>其实就是HashMap，将数组作为HashMap的key存储、</p>
<h4 id="3-11-2：HashSet的内存泄漏"><a href="#3-11-2：HashSet的内存泄漏" class="headerlink" title="3-11-2：HashSet的内存泄漏"></a>3-11-2：HashSet的内存泄漏</h4><p>因为HashMap使用数据的hash来定位，如果set中存放数据，重写hashCode方法后，属性变更导致hash也改变，使得后续修改无法作用在原对象上，但是HashMap中的引用依然存在，不会进行垃圾回收</p>
<h4 id="3-11-3：HashSet如何保证线程安全"><a href="#3-11-3：HashSet如何保证线程安全" class="headerlink" title="3-11-3：HashSet如何保证线程安全"></a>3-11-3：HashSet如何保证线程安全</h4><p>Collections.synchronizedSet</p>
<h3 id="3-12：TreeSet"><a href="#3-12：TreeSet" class="headerlink" title="3-12：TreeSet"></a>3-12：TreeSet</h3><h4 id="3-12-1：TreeSet数据结构"><a href="#3-12-1：TreeSet数据结构" class="headerlink" title="3-12-1：TreeSet数据结构"></a>3-12-1：TreeSet数据结构</h4><p>TreeMap</p>
<h3 id="3-13：LinkedHashSet"><a href="#3-13：LinkedHashSet" class="headerlink" title="3-13：LinkedHashSet"></a>3-13：LinkedHashSet</h3><h4 id="3-13-1：LinkedHashSet数据结构"><a href="#3-13-1：LinkedHashSet数据结构" class="headerlink" title="3-13-1：LinkedHashSet数据结构"></a>3-13-1：LinkedHashSet数据结构</h4><p>LinkedHashMap</p>
<h3 id="3-14-线程安全-非线程安全的集合"><a href="#3-14-线程安全-非线程安全的集合" class="headerlink" title="3-14.线程安全/非线程安全的集合"></a>3-14.线程安全/非线程安全的集合</h3><ul>
<li>Vector：就比 Arraylist 多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在 web 应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。</li>
<li>Stack：堆栈类，先进后出。</li>
<li>Hashtable：就比 hashmap 多了个线程安全。</li>
<li>Enumeration：枚举，相当于迭代器</li>
</ul>
<h3 id="3-15：Java基础-集合-集合大比较"><a href="#3-15：Java基础-集合-集合大比较" class="headerlink" title="3-15：Java基础-集合-集合大比较"></a>3-15：Java基础-集合-集合大比较</h3><h4 id="3-15-1：set和list、map的区别"><a href="#3-15-1：set和list、map的区别" class="headerlink" title="3-15-1：set和list、map的区别"></a>3-15-1：set和list、map的区别</h4><ul>
<li>set存放的不可重复的数据集</li>
<li>list存放可重复数据</li>
<li>map存放键值对，键不可重复，值可以</li>
</ul>
<h4 id="3-15-2：Arraylist、Linkedlist区别和适用场景"><a href="#3-15-2：Arraylist、Linkedlist区别和适用场景" class="headerlink" title="3-15-2：Arraylist、Linkedlist区别和适用场景"></a>3-15-2：Arraylist、Linkedlist区别和适用场景</h4><p>最明显的区别是 ArrrayList 底层的数据结构是数组，支持随机访问，查询快，增删慢；线程不安全，效率高。<br>而 LinkedList 的底层数据结构是双向循环链表，不支持随机访问，查询慢，增删快；线程不安全，效率高。使用下标访问一个元素，ArrayList 的时间复杂度是 O (1)，而 LinkedList 是 O (n)。</p>
<h4 id="3-15-3：HashMap、Treemap、LinkedHashMap区别和适用场景"><a href="#3-15-3：HashMap、Treemap、LinkedHashMap区别和适用场景" class="headerlink" title="3-15-3：HashMap、Treemap、LinkedHashMap区别和适用场景"></a>3-15-3：HashMap、Treemap、LinkedHashMap区别和适用场景</h4><p>在实际使用中，如果更新map时不需要保持map中元素的顺序，就使用 HashMap，如果需要保持map中元素的插入顺序或者访问顺序，就使用 LinkedHashMap，如果需要使map按照键值排序，就使用 TreeMap。</p>
<h3 id="3-16：Collections"><a href="#3-16：Collections" class="headerlink" title="3-16：Collections"></a>3-16：Collections</h3><h4 id="3-16-1：Collection与Collections的区别"><a href="#3-16-1：Collection与Collections的区别" class="headerlink" title="3-16-1：Collection与Collections的区别"></a>3-16-1：Collection与Collections的区别</h4><ul>
<li>Java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection 接口在 Java 类库中有很多具体的实现。Collection 接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有 List 与 Set。</li>
<li>Collections 则是集合类的一个工具类 / 帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</li>
</ul>
<h2 id="4：IO"><a href="#4：IO" class="headerlink" title="4：IO"></a>4：IO</h2><h3 id="4-1：IO流"><a href="#4-1：IO流" class="headerlink" title="4-1：IO流"></a>4-1：IO流</h3><blockquote>
<ul>
<li>Byte（字节）是计算机操作数据的最小单位由8位bit组成 取值（-128-127）</li>
<li>Char（字符）是用户的可读写的最小单位，在Java里面由16位bit组成 取值（0-65535）</li>
</ul>
</blockquote>
<h4 id="4-1-1：为何还要有字符流"><a href="#4-1-1：为何还要有字符流" class="headerlink" title="4-1-1：为何还要有字符流"></a>4-1-1：为何还要有字符流</h4><p>在各种编码中，一个英文字符就是一个字节。如果只有英文就不会有问题，但是中文一般会占据多个字节。比如Java标准采用的Unicode编码中就占用两个字节，UTF-8中占用三个字节，如果不知道字符编码，一次读取一个字节，可能就会将一个字符的多个字节分割开，导致乱码。</p>
<p>字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p>
<h4 id="4-1-2：字节流和字符流区别"><a href="#4-1-2：字节流和字符流区别" class="headerlink" title="4-1-2：字节流和字符流区别"></a>4-1-2：字节流和字符流区别</h4><ul>
<li>字节流操作的基本单位为字节，字符流操作的基本单元为Unicode单元。</li>
<li>字节流默认不使用缓冲区，字符流使用缓冲区</li>
<li>字节流通常用处理二进制数据，实际上它可以处理任意类型的数据，但它不支持直接写入或读取Unicode马原；字符流通常用于处理文本数据，它支持写入和读取Unicode码元。</li>
</ul>
<h3 id="4-2：BIO-NIO-AIO"><a href="#4-2：BIO-NIO-AIO" class="headerlink" title="4-2：BIO\NIO\AIO"></a>4-2：BIO\NIO\AIO</h3><h4 id="4-2-1：BIO-NIO-AIO定义"><a href="#4-2-1：BIO-NIO-AIO定义" class="headerlink" title="4-2-1：BIO\NIO\AIO定义"></a>4-2-1：BIO\NIO\AIO定义</h4><ul>
<li>BIO：同步并阻塞IO,数据的读取写入必须阻塞在一个线程内等待其完成.使用多线程解决多个客户端访问请求.</li>
<li>NIO：NIO 与原来的 I/O 有同样的作用和目的, 而NIO是支持同步非阻塞的.</li>
<li>AIO：异步非阻塞IO</li>
</ul>
<h4 id="4-2-2：BIO与NIO的区别"><a href="#4-2-2：BIO与NIO的区别" class="headerlink" title="4-2-2：BIO与NIO的区别"></a>4-2-2：BIO与NIO的区别</h4><ol>
<li>BIO是同步非阻塞的,而NIO支持同步阻塞和同步非阻塞两种模式</li>
<li>BIO面向流,而NIO面向缓冲区(Buffer oriented).BIO中是将数据直接写入或者读取到Stream对象中,而NIO所有数据都是通过缓冲区处理.在读取数据时,直接冲缓冲区读取,写入数据时,写入到缓冲区.</li>
<li>NIO通过Channel(通道)进行读写,通道是双向的,可以读也可以写,而流的读写是单向的.无论读写,通道只能和Buffer交互。也因为 Buffer，通道可以异步地读写。</li>
<li>NIO有选择器,BIO没有.</li>
</ol>
<h3 id="4-3：IO模型"><a href="#4-3：IO模型" class="headerlink" title="4-3：IO模型"></a>4-3：IO模型</h3><h4 id="4-3-1：IO多路复用"><a href="#4-3-1：IO多路复用" class="headerlink" title="4-3-1：IO多路复用"></a>4-3-1：IO多路复用</h4><p>在IO多路复用模型中,会有一个线程不断去轮询多个socket的状态,只有socket真正有读写事件时,才真正调用实际的IO读写操作.<br>因为使用一个线程来管理,不需要创建新的进程或者线程,并且在真正有IO事件时才会占用资源,所以大大减少了资源占用.</p>
<h4 id="4-3-1：IO多路复用实现方式"><a href="#4-3-1：IO多路复用实现方式" class="headerlink" title="4-3-1：IO多路复用实现方式"></a>4-3-1：IO多路复用实现方式</h4><ul>
<li>select</li>
<li>poll</li>
<li>epoll</li>
</ul>
<h5 id="4-3-1-1：三种实现方式区别"><a href="#4-3-1-1：三种实现方式区别" class="headerlink" title="4-3-1-1：三种实现方式区别"></a>4-3-1-1：三种实现方式区别</h5><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">select</th>
<th align="center">poll</th>
<th align="center">epoll</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数据结构</td>
<td align="center">bitmap</td>
<td align="center">数组</td>
<td align="center">红黑树</td>
</tr>
<tr>
<td align="center">最大连接数</td>
<td align="center">1024</td>
<td align="center">无上限</td>
<td align="center">无上限</td>
</tr>
<tr>
<td align="center">fd拷贝</td>
<td align="center">每次调用select拷贝</td>
<td align="center">每次调用poll拷贝</td>
<td align="center">fd首次调用epoll_ct拷贝,每次调用epoll_wait不拷贝</td>
</tr>
<tr>
<td align="center">工作效率</td>
<td align="center">轮询:O(n)</td>
<td align="center">轮询:O(n)</td>
<td align="center">回调:O(1)</td>
</tr>
</tbody></table>
<h5 id="4-3-1-2：三种常用的实现方式优缺点"><a href="#4-3-1-2：三种常用的实现方式优缺点" class="headerlink" title="4-3-1-2：三种常用的实现方式优缺点"></a>4-3-1-2：三种常用的实现方式优缺点</h5><ol>
<li>select<ul>
<li>单个进程所打开的FD是有限制的，通过FD_SETSIZE设置，默认102</li>
<li>每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</li>
<li>对socket扫描时是线性扫描，采用轮询的方法，效率较低（高并发时）</li>
</ul>
</li>
<li>poll<ul>
<li>每次调用poll，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</li>
<li>对socket扫描时是线性扫描，采用轮询的方法，效率较低（高并发时）</li>
</ul>
</li>
<li>epoll<ul>
<li>epoll只能工作在linux下</li>
</ul>
</li>
</ol>
<h2 id="5：反射"><a href="#5：反射" class="headerlink" title="5：反射"></a>5：反射</h2><h3 id="4-1：反射的概念"><a href="#4-1：反射的概念" class="headerlink" title="4-1：反射的概念"></a>4-1：反射的概念</h3><blockquote>
<p>Java 反射（reflection）机制是指在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。这种动态获取程序信息以及动态调用对象的功能称为 Java 语言的反射机制。反射被视为动态语言的关键。</p>
<p>反射主要是指程序可以访问，检测和修改它本身状态或行为的一种能力，并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。</p>
</blockquote>
<p>反射主要提供以下功能：</p>
<ul>
<li>在运行时判断任意一个对象所属的类；</li>
<li>在运行时构造任意一个类的对象；</li>
<li>在运行时判断任意一个类所具有的成员变量和方法；</li>
<li>在运行时调用任意一个对象的方法；</li>
<li>生成动态代理。</li>
</ul>
<h4 id="4-1-1：反射会导致哪些性能问题"><a href="#4-1-1：反射会导致哪些性能问题" class="headerlink" title="4-1-1：反射会导致哪些性能问题"></a>4-1-1：反射会导致哪些性能问题</h4><h5 id="4-1-1-1：如何避免反射导致的性能问题"><a href="#4-1-1-1：如何避免反射导致的性能问题" class="headerlink" title="4-1-1-1：如何避免反射导致的性能问题"></a>4-1-1-1：如何避免反射导致的性能问题</h5><h4 id="4-1-2：哪些类不能反射"><a href="#4-1-2：哪些类不能反射" class="headerlink" title="4-1-2：哪些类不能反射"></a>4-1-2：哪些类不能反射</h4><h4 id="4-1-3：反射优缺点"><a href="#4-1-3：反射优缺点" class="headerlink" title="4-1-3：反射优缺点"></a>4-1-3：反射优缺点</h4><h4 id="4-1-4：反射的应用场景"><a href="#4-1-4：反射的应用场景" class="headerlink" title="4-1-4：反射的应用场景"></a>4-1-4：反射的应用场景</h4><ol>
<li>IDE的代码提示</li>
<li>框架的开发</li>
</ol>
<h3 id="4-2：Class类的作用"><a href="#4-2：Class类的作用" class="headerlink" title="4-2：Class类的作用"></a>4-2：Class类的作用</h3><p>Java的Class类是Java反射机制的基础,通过Class类我们可以获得关于一个类的相关信息</p>
<p>Java.lang.Class是一个比较特殊的类，它用于封装被装入到JVM中的类（包括类和接口）的信息。当一个类或接口被装入的JVM时便会产生一个与之关联的Java.lang.Class对象，可以通过这个Class对象对被装入类的详细信息进行访问。</p>
<p>虚拟机为每种类型管理一个独一无二的Class对象。也就是说，每个类（型）都有一个Class对象。运行程序时，Java虚拟机(JVM)首先检查是否所要加载的类对应的Class对象是否已经加载。如果没有加载，JVM就会根据类名查找.class文件，并将其Class对象载入。</p>
<h4 id="4-2-1：获取Class对象方法"><a href="#4-2-1：获取Class对象方法" class="headerlink" title="4-2-1：获取Class对象方法"></a>4-2-1：获取Class对象方法</h4><ol>
<li><p>通过类型获取</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Class&lt;?&gt;是一个泛型表示，用于获取一个类的类型。</span></span><br><span class="line">Class&lt;?&gt; c = <span class="keyword">boolean</span>.class;  </span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; classInt = Integer.TYPE;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过实例获取</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder str = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">Class&lt;?&gt; klass = str.getClass();</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过Class的forName静态方法</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="4-2-2：Class-forName和classloader-loadClass的区别"><a href="#4-2-2：Class-forName和classloader-loadClass的区别" class="headerlink" title="4-2-2：Class.forName和classloader.loadClass的区别"></a>4-2-2：Class.forName和classloader.loadClass的区别</h4><p>Java中class.forName()和classLoader都可用来对类进行加载。<br>class.forName()前者除了将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块。<br>而classLoader只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</p>
<h4 id="4-2-3：反射调用类的私有方法"><a href="#4-2-3：反射调用类的私有方法" class="headerlink" title="4-2-3：反射调用类的私有方法"></a>4-2-3：反射调用类的私有方法</h4><p>通过设置<code>setAccessible (boolean flag)</code>可以取消Java的权限控制</p>
<h2 id="5：注解"><a href="#5：注解" class="headerlink" title="5：注解"></a>5：注解</h2><h3 id="5-1：元注解以及分类"><a href="#5-1：元注解以及分类" class="headerlink" title="5-1：元注解以及分类"></a>5-1：元注解以及分类</h3><ul>
<li>@Target（表示该注解可以用于什么地方）</li>
<li>@Retention（表示在什么级别保存该注解信息）</li>
<li>@Documented（将此注解包含在Javadoc中）</li>
<li>@Inherited（允许子类继承父类中的注解）</li>
<li>@Repeatable（1.8新增，允许一个注解在一个元素上使用多次）</li>
<li>@Native（1.8新增，修饰成员变量，表示这个变量可以被本地代码引用，常常被代码生成工具使用）。</li>
</ul>
<h3 id="5-2：Java常用注解"><a href="#5-2：Java常用注解" class="headerlink" title="5-2：Java常用注解"></a>5-2：Java常用注解</h3><p>Java中常用：</p>
<ul>
<li>@Override 表示当前方法覆盖了父类的方法</li>
<li>@Deprecated 表示方法已经过时,方法上有横线，使用时会有警告。</li>
<li>@SuppressWarnings 表示关闭一些警告信息(通知Java编译器忽略特定的编译警告)</li>
<li>@SafeVarargs (jdk1.7更新) 表示：专门为抑制“堆污染”警告提供的。</li>
<li>@FunctionalInterface (jdk1.8更新) 表示：用来指定某个接口必须是函数式接口，否则就会编译出错。</li>
</ul>
<p>Spring中常用：</p>
<ul>
<li>@Configuration把一个类作为一个IoC容器，它的某个方法头上如果注册了@Bean，就会作为这个Spring容器中的Bean。</li>
<li>@Scope注解 作用域</li>
<li>@Lazy(true) 表示延迟初始化</li>
<li>@Service用于标注业务层组件</li>
<li>@Controller用于标注控制层组件@Repository用于标注数据访问组件，即DAO组件。</li>
<li>@Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</li>
<li>@Scope用于指定scope作用域的（用在类上）</li>
<li>@PostConstruct用于指定初始化方法（用在方法上）</li>
<li>@PreDestory用于指定销毁方法（用在方法上）</li>
<li>@DependsOn：定义Bean初始化及销毁时的顺序</li>
<li>@Primary：自动装配时当出现多个Bean候选者时，被注解为@Primary的Bean将作为首选者，否则将抛出异常</li>
<li>@Autowired 默认按类型装配，如果我们想使用按名称装配，可以结合@Qualifier注解一起使用。如下： @Autowired @Qualifier(“personDaoBean”) 存在多个实例配合使用</li>
<li>@Resource默认按名称装配，当找不到与名称匹配的bean才会按类型装配。</li>
<li>@PostConstruct 初始化注解</li>
<li>@PreDestroy 摧毁注解 默认 单例 启动就加载</li>
</ul>
<h2 id="6：泛型"><a href="#6：泛型" class="headerlink" title="6：泛型"></a>6：泛型</h2><h3 id="6-1：什么是泛型"><a href="#6-1：什么是泛型" class="headerlink" title="6-1：什么是泛型"></a>6-1：什么是泛型</h3><p>Java泛型（ generics） 是JDK 5中引⼊的⼀个新特性， 允许在定义类和接口的时候使⽤类型参数（ type parameter） 。<br>声明的类型参数在使⽤时⽤具体的类型来替换。 泛型最主要的应⽤是在JDK 5中的新集合类框架中。<br>泛型最⼤的好处是可以提⾼代码的复⽤性。 以List接⼜为例，我们可以将String、 Integer等类型放⼊List中， 如不⽤泛型， 存放String类型要写⼀个List接口， 存放Integer要写另外⼀个List接口， 泛型可以很好的解决这个问题。</p>
<h3 id="6-2：编译器如何处理泛型"><a href="#6-2：编译器如何处理泛型" class="headerlink" title="6-2：编译器如何处理泛型"></a>6-2：编译器如何处理泛型</h3><ol>
<li><code>Code specialization</code>。在实例化一个泛型类或泛型方法时都产生一份新的目标代码（字节码or二进制代码）。例如，针对一个泛型List，可能需要 针对String，Integer，Float产生三份目标代码。</li>
<li><code>Code sharing</code>。对每个泛型类只生成唯一的一份目标代码；该泛型类的所有实例都映射到这份目标代码上，在需要的时候执行类型检查和类型转换。</li>
</ol>
<p>Java中使用<code>Code sharing</code>。对每个泛型类只会生成一份代码</p>
<h4 id="6-2-1：为什么Java要用这种编译器"><a href="#6-2-1：为什么Java要用这种编译器" class="headerlink" title="6-2-1：为什么Java要用这种编译器"></a>6-2-1：为什么Java要用这种编译器</h4><p>C++和C#是使用<code>Code specialization</code>的处理机制，它会导致代码膨胀。另外一个弊端是在引用类型系统中，浪费空间，因为引用类型集合中元素本质上都是一个指针。没必要为每个类型都产生一份执行代码。而这也是Java编译器中采用<code>Code sharing</code>方式处理泛型的主要原因。</p>
<h3 id="6-3-什么是类型擦除"><a href="#6-3-什么是类型擦除" class="headerlink" title="6-3: 什么是类型擦除"></a>6-3: 什么是类型擦除</h3><blockquote>
<p>类型擦除指的是通过类型参数合并，将泛型类型实例关联到同一份字节码上。编译器只为泛型类型生成一份字节码，并将其实例关联到这份字节码上。类型擦除的关键在于从泛型类型中清除类型参数的相关信息，并且在必要的时候添加类型检查和类型转换的方法。 类型擦除可以简单的理解为将泛型Java代码转换为普通Java代码，只不过编译器更直接点，将泛型Java代码直接转换成普通Java字节码。<br>类型擦除的主要过程如下： 1.将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。（这部分内容可以看：Java泛型中extends和super的理解） 2.移除所有的类型参数</p>
</blockquote>
<h4 id="6-3-1：类型擦除过程"><a href="#6-3-1：类型擦除过程" class="headerlink" title="6-3-1：类型擦除过程"></a>6-3-1：类型擦除过程</h4><h3 id="6-4：泛型带来的问题"><a href="#6-4：泛型带来的问题" class="headerlink" title="6-4：泛型带来的问题"></a>6-4：泛型带来的问题</h3><ol>
<li>无法通过泛型重载</li>
<li>泛型异常是同一个异常，无法通过不同泛型重复捕捉</li>
<li>泛型类的静态变量是共享的</li>
</ol>
<h3 id="6-5：泛型应用"><a href="#6-5：泛型应用" class="headerlink" title="6-5：泛型应用"></a>6-5：泛型应用</h3><ol>
<li>类或者接口</li>
<li>方法传参或返回值</li>
<li>容器类型</li>
</ol>
<h4 id="6-5-1：List泛型和原始类型List之间的区别"><a href="#6-5-1：List泛型和原始类型List之间的区别" class="headerlink" title="6-5-1：List泛型和原始类型List之间的区别?"></a>6-5-1：List泛型和原始类型List之间的区别?</h4><ul>
<li><code>List</code> 不会进行类型检查</li>
<li><code>List&lt;Object&gt;</code> 会进行类型检查，可以只能接受Object类型</li>
<li><code>List&lt;?&gt;</code> 会进行类型检查，只能接受一种类型</li>
</ul>
<h4 id="6-5-4：多态时是否会出现类型擦除"><a href="#6-5-4：多态时是否会出现类型擦除" class="headerlink" title="6-5-4：多态时是否会出现类型擦除"></a>6-5-4：多态时是否会出现类型擦除</h4><p>会，会将类型擦除为Objec类型使得我们实际上并没有完成重载，但是jvm会巧妙的通过桥接模式构建一个重载方法调用我们自己写的方法。</p>
<h2 id="7：异常"><a href="#7：异常" class="headerlink" title="7：异常"></a>7：异常</h2><h3 id="7-1：异常的分类"><a href="#7-1：异常的分类" class="headerlink" title="7-1：异常的分类"></a>7-1：异常的分类</h3><p>异常分为两类，<code>Error</code>和<code>Exception</code>，二者皆继承与<code>Throwable</code>类</p>
<ul>
<li>Error 类层级结构描述了 Java 运行时系统的内部错误和资源耗尽错误，应用程序不应该抛出这种类型的对象</li>
<li>Exception 表⽰程序需要捕捉、需要处理的异常，是由于程序设计的不完善⽽出现的问题，是程序必须处理的问题。</li>
</ul>
<h4 id="7-1-1：Error和Exception的区别"><a href="#7-1-1：Error和Exception的区别" class="headerlink" title="7-1-1：Error和Exception的区别"></a>7-1-1：Error和Exception的区别</h4><ol>
<li>Error为系统错误，无法通过程序解决</li>
<li>Exception为程序可以处理的异常</li>
</ol>
<h3 id="7-2：Java中的两种异常类型是什么"><a href="#7-2：Java中的两种异常类型是什么" class="headerlink" title="7-2：Java中的两种异常类型是什么"></a>7-2：Java中的两种异常类型是什么</h3><p>Java中的异常，主要可以分为两⼤类，即受检异常（ checked exception） 和 ⾮受检异常（ unchecked exception）</p>
<ul>
<li>对于⾮受检异常来说，⼀般是运⾏时异常，继承⾃RuntimeException。在编写代码的时候，不需要显⽰的捕获，但是如果不捕获，在运⾏期如果发⽣异常就会中断程序的执⾏。</li>
<li>受检异常：除了RuntimeException以外的异常，都属于受检异常，它们都在Java.lang库内部定义。Java编译器要求程序必须捕获或声明抛出这种异常。</li>
</ul>
<h4 id="7-2-1：他们有什么区别"><a href="#7-2-1：他们有什么区别" class="headerlink" title="7-2-1：他们有什么区别"></a>7-2-1：他们有什么区别</h4><p>受检异常要求一定要处理，而非受检异常应当尽量避免，由开发人员自行处理。</p>
<h4 id="7-2-2：异常链"><a href="#7-2-2：异常链" class="headerlink" title="7-2-2：异常链"></a>7-2-2：异常链</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">  Throwable se = <span class="keyword">new</span> ServletException(<span class="string">&quot;database error&quot;</span>);</span><br><span class="line">  se.initCause(e);</span><br><span class="line">  <span class="keyword">throw</span> se;</span><br><span class="line">  <span class="comment">// 简化方式</span></span><br><span class="line">  <span class="comment">// throw new ServletException(&quot;database error&quot;,e)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这种方式可以抛出子系统的异常，而不丢失原始异常</p>
<h4 id="7-3-3：什么是OOM？常见有哪些OOM"><a href="#7-3-3：什么是OOM？常见有哪些OOM" class="headerlink" title="7-3-3：什么是OOM？常见有哪些OOM"></a>7-3-3：什么是OOM？常见有哪些OOM</h4><p>OOM:OutOfMemory (内存溢出)</p>
<ol>
<li>StackOverFlowError，递归调用过多，栈空间容量不足</li>
<li>Java.lang.OutOfMemoryError: Java heap space</li>
<li>Java.lang.OutOfMemoryError: GC overhead limit exceeded GC回收时间过长，时间过多耗费在GC中，但是回收效果不佳。</li>
<li>Java.lang.OutOfMemoryError: Direct buffer memory 直接内存溢出 ，因为jdk1.8多了元空间直接使用本地内存，而NIO使用的直接内存也是本地内存。</li>
<li>Java.lang.OutOfMemoryError: unable to create new native thread 高并发情况下会出现该异常，该异常与对应的平台有关</li>
</ol>
<h4 id="7-4：try、catch、finally执行顺序"><a href="#7-4：try、catch、finally执行顺序" class="headerlink" title="7-4：try、catch、finally执行顺序"></a>7-4：try、catch、finally执行顺序</h4><p>正常执行try语句，如果try代码块抛出捕捉的错误则执行catch代码块。最后这两个代码块都要执行finally语句。</p>
<h4 id="7-4-1：带return返回顺序"><a href="#7-4-1：带return返回顺序" class="headerlink" title="7-4-1：带return返回顺序"></a>7-4-1：带return返回顺序</h4><p>return前一定会执行finally代码块，并且finally代码块的修改不会影响return的返回值。</p>
<h2 id="8：String"><a href="#8：String" class="headerlink" title="8：String"></a>8：String</h2><h3 id="8-1：string数据结构"><a href="#8-1：string数据结构" class="headerlink" title="8-1：string数据结构"></a>8-1：string数据结构</h3><h4 id="8-1-1：String为什么是final的？"><a href="#8-1-1：String为什么是final的？" class="headerlink" title="8-1-1：String为什么是final的？"></a>8-1-1：String为什么是final的？</h4><ol>
<li>为了实现字符串池</li>
<li>为了线程安全</li>
<li>为了实现HashCode的不变性</li>
</ol>
<h4 id="8-1-2：String的内部属性"><a href="#8-1-2：String的内部属性" class="headerlink" title="8-1-2：String的内部属性"></a>8-1-2：String的内部属性</h4><p>String内部其实就是一个char数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br></pre></td></tr></table></figure>

<h4 id="8-1-3：String的常用方法"><a href="#8-1-3：String的常用方法" class="headerlink" title="8-1-3：String的常用方法"></a>8-1-3：String的常用方法</h4><ol>
<li>charAt()</li>
<li>indexOf()</li>
<li>replace()</li>
<li>substring()</li>
<li>…</li>
</ol>
<h4 id="8-1-4：substring原理"><a href="#8-1-4：substring原理" class="headerlink" title="8-1-4：substring原理"></a>8-1-4：substring原理</h4><p>通过传入的参数构建一个新的String返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> subLen = value.length - beginIndex;</span><br><span class="line">    <span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(subLen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (beginIndex == <span class="number">0</span>) ? <span class="keyword">this</span> : <span class="keyword">new</span> String(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而这个构造方法底部其实就是通过复制创建一个新数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (offset &lt;= value.length) &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = <span class="string">&quot;&quot;</span>.value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span></span><br><span class="line">    <span class="keyword">if</span> (offset &gt; value.length - count) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset + count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-1-5：String长度有限制的"><a href="#8-1-5：String长度有限制的" class="headerlink" title="8-1-5：String长度有限制的"></a>8-1-5：String长度有限制的</h4><ul>
<li>编译期的限制：字符串的UTF8编码值的字节数不能超过65535，字符串的长度不能超过65534；</li>
<li>运行时限制：字符串的长度不能超过2^31-1，占用的内存数不能超过虚拟机能够提供的最大值。</li>
</ul>
<h3 id="8-2：String-str-new-String-“abc”-创建了几个对象"><a href="#8-2：String-str-new-String-“abc”-创建了几个对象" class="headerlink" title="8-2：String str = new String(“abc”);创建了几个对象"></a>8-2：String str = new String(“abc”);创建了几个对象</h3><p>这段代码将创建 1 或 2 个字符串对象。</p>
<ul>
<li>如果池中已存在字符串常量 abc，则只会在堆空间创建一个字符串对象 s1，s1 内部的 char value[] 则指向常量池中的 abc。</li>
<li>如果池中没有字符串常量 abc，那么它将首先在池中创建 abc 对象，然后在堆空间中创建 s1 对象，s1 指向堆中 new 的对象，而 s1 内部的 char value[] 则指向常量池中的 abc。因此将创建总共 2 个字符串对象。<br>所以 s1 指向堆内存，s2 指向常量池，但是 s1 的 value[] 和 s2 的 value[] 指向的是常量池中的同一个对象。所以 s1 == s2 为 false，s1.equals(s2) 为 true。</li>
</ul>
<h4 id="8-2-1：String-str-”abc”-堆和常量池中的情况"><a href="#8-2-1：String-str-”abc”-堆和常量池中的情况" class="headerlink" title="8-2-1：String str=”abc”,堆和常量池中的情况"></a>8-2-1：String str=”abc”,堆和常量池中的情况</h4><p>会在常量池中创建对象，不会创建在堆中</p>
<h3 id="8-3：String的-与equals问题"><a href="#8-3：String的-与equals问题" class="headerlink" title="8-3：String的==与equals问题"></a>8-3：String的==与equals问题</h3><p>== 的作用：</p>
<ul>
<li>基本类型：比较值是否相等</li>
<li>引用类型：比较内存地址值是否相等</li>
</ul>
<p>equals 的作用:</p>
<ul>
<li>引用类型：默认情况下，比较内存地址值是否相等。可以按照需求逻辑，重写对象的 equals 方法。</li>
</ul>
<h4 id="8-3-1：两个st1-“abc”相等问题"><a href="#8-3-1：两个st1-“abc”相等问题" class="headerlink" title="8-3-1：两个st1 = “abc”相等问题"></a>8-3-1：两个st1 = “abc”相等问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(str1==str2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>因为用这种方式创建，这两个字符其实指向的是一个引用</p>
<h4 id="8-3-2：一个创建对象，一个str1-“abc”"><a href="#8-3-2：一个创建对象，一个str1-“abc”" class="headerlink" title="8-3-2：一个创建对象，一个str1=“abc”"></a>8-3-2：一个创建对象，一个str1=“abc”</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(str1==str2); <span class="comment">// false</span></span><br><span class="line">System.out.println(str1.equals(str2)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>因为创建对象，引用指向堆内存中的对象，而使用equals会比较对象内部对字符串的引用</p>
<h4 id="8-3-3：一个a-b-c，一个abc"><a href="#8-3-3：一个a-b-c，一个abc" class="headerlink" title="8-3-3：一个a+b+c，一个abc"></a>8-3-3：一个a+b+c，一个abc</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;a&quot;</span>+<span class="string">&quot;b&quot;</span>+<span class="string">&quot;c&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(str1==str2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>其实str1只会创建一个对象，因为编译器进行了优化。会自动处理为”abc”。</p>
<h4 id="8-3-4：一个str1-c，一个abc"><a href="#8-3-4：一个str1-c，一个abc" class="headerlink" title="8-3-4：一个str1+c，一个abc"></a>8-3-4：一个str1+c，一个abc</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">str1 = str1+<span class="string">&quot;c&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(str1==str2); <span class="comment">// false</span></span><br><span class="line">System.out.println(str1.equals(str2)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>因为String中<code>+</code>的重载其实是转为StringBuilder.append()添加再通过toString()转为String类型。而StringBuilder的toString()方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create a copy, don&#x27;t share the array</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(value, <span class="number">0</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相当于用new方式创建一个String对象，那么这两种比较结果就可以看出来。</p>
<h4 id="8-3-5：两个new-String对象"><a href="#8-3-5：两个new-String对象" class="headerlink" title="8-3-5：两个new String对象"></a>8-3-5：两个new String对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(str1==str2); <span class="comment">// false</span></span><br><span class="line">System.out.println(str1.equals(str2)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>创建两个对象，比较引用肯定是false，但是内部数组指向的都是常量池中的同一数据，所以equals为true。</p>
<h3 id="8-4：拼接方式"><a href="#8-4：拼接方式" class="headerlink" title="8-4：拼接方式"></a>8-4：拼接方式</h3><p><img src= "/img/loading.gif" data-lazy-src="https://image.shiming.online/blog/2021-03-14/20210314121500.png!img" alt="20210314121500"></p>
<h3 id="8-5-String、StringBuffer和StringBuilder区别"><a href="#8-5-String、StringBuffer和StringBuilder区别" class="headerlink" title="8-5: String、StringBuffer和StringBuilder区别"></a>8-5: String、StringBuffer和StringBuilder区别</h3><p>String不可变，StringBuffer和StringBuilder可变。而StringBuffer线程安全，StringBuilder线程不安全。</p>
<h3 id="8-5-1：StringBuffer如何实现线程安全"><a href="#8-5-1：StringBuffer如何实现线程安全" class="headerlink" title="8-5-1：StringBuffer如何实现线程安全"></a>8-5-1：StringBuffer如何实现线程安全</h3><p>StringBuffer的方式使用<code>synchronized</code>修饰</p>
<h4 id="8-5-2：处理数据量较大的字符串用String还是StringBuilder，为什么"><a href="#8-5-2：处理数据量较大的字符串用String还是StringBuilder，为什么" class="headerlink" title="8-5-2：处理数据量较大的字符串用String还是StringBuilder，为什么"></a>8-5-2：处理数据量较大的字符串用String还是StringBuilder，为什么</h4><p>StringBuilder，因为String的各种拼接其实就是转化为StringBuilder来进行。</p>
<h3 id="8-5-3：为什么StringBuffer和StringBuilder比String更快（不变性）"><a href="#8-5-3：为什么StringBuffer和StringBuilder比String更快（不变性）" class="headerlink" title="8-5-3：为什么StringBuffer和StringBuilder比String更快（不变性）"></a>8-5-3：为什么StringBuffer和StringBuilder比String更快（不变性）</h3><ol>
<li>string类设计成final类型，每次有修改操作时，都会赋值给新的对象。</li>
<li>因为赋值给新的对象，原来的对象就不再引用，就会进行回收。</li>
</ol>
<h3 id="8-6：应用"><a href="#8-6：应用" class="headerlink" title="8-6：应用"></a>8-6：应用</h3><h4 id="8-6-1：如何把一段逗号分割的字符串转换成一个数组"><a href="#8-6-1：如何把一段逗号分割的字符串转换成一个数组" class="headerlink" title="8-6-1：如何把一段逗号分割的字符串转换成一个数组?"></a>8-6-1：如何把一段逗号分割的字符串转换成一个数组?</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] arr = s.split(<span class="string">&quot;,&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="8-6-2：String-和-char-数组谁更适合存密码"><a href="#8-6-2：String-和-char-数组谁更适合存密码" class="headerlink" title="8-6-2：String 和 char[] 数组谁更适合存密码"></a>8-6-2：String 和 char[] 数组谁更适合存密码</h4><p>String，因为String不可变，所以不会对密码进行修改。</p>
<h2 id="9：枚举"><a href="#9：枚举" class="headerlink" title="9：枚举"></a>9：枚举</h2><h3 id="9-1：enum线程安全"><a href="#9-1：enum线程安全" class="headerlink" title="9-1：enum线程安全"></a>9-1：enum线程安全</h3><p>因为枚举类的实例都是静态常量，而静态属性都是在类加载之后就初始化。当一个Java类第一次被真正使用到的时候静态资源被初始化、Java类的加载和初始化过程都是线程安全的。所以，创建一个enum类型是线程安全的。</p>
<h3 id="9-2-switch-是否可用于String类型的判断"><a href="#9-2-switch-是否可用于String类型的判断" class="headerlink" title="9-2: switch 是否可用于String类型的判断"></a>9-2: switch 是否可用于String类型的判断</h3><p>可以，实际上会将String转为hashcode，再通过equals判断是否相等。</p>
<h2 id="10：时间类"><a href="#10：时间类" class="headerlink" title="10：时间类"></a>10：时间类</h2><h3 id="10-1：SimpDateFormat是线程不安全的类，如何改为线程安全"><a href="#10-1：SimpDateFormat是线程不安全的类，如何改为线程安全" class="headerlink" title="10-1：SimpDateFormat是线程不安全的类，如何改为线程安全"></a>10-1：SimpDateFormat是线程不安全的类，如何改为线程安全</h3><p>因为SimpDateFormat内部有一个Calendar类的引用，多线程或者设为静态属性会共用这个引用，导致处理时会出现错误。</p>
<ol>
<li>加锁</li>
<li>使用ThreadLocal</li>
<li>DateUtils</li>
<li>使用jdk1.8的DateTimeFormatter代替。</li>
</ol>
<h2 id="11：Object类"><a href="#11：Object类" class="headerlink" title="11：Object类"></a>11：Object类</h2><h3 id="11-1：Object类有哪些方法"><a href="#11-1：Object类有哪些方法" class="headerlink" title="11-1：Object类有哪些方法"></a>11-1：Object类有哪些方法</h3><ol>
<li>getClass()</li>
<li>hashCode()</li>
<li>equals()</li>
<li>clone()</li>
<li>toString()</li>
<li>notify()</li>
<li>notifyAll()</li>
<li>wait()</li>
<li>finalize()</li>
</ol>
<h3 id="11-1-1：XX-toString和String-valueOf"><a href="#11-1-1：XX-toString和String-valueOf" class="headerlink" title="11-1-1：XX.toString和String.valueOf()"></a>11-1-1：XX.toString和String.valueOf()</h3><p>String.valueOf()其实就是调用toString()方法，只是toString()会抛出空指针异常，而String.valueOf()对于空串会返回”null”;</p>
<h3 id="11-1-1：为什么操作线程方法在Object对象中"><a href="#11-1-1：为什么操作线程方法在Object对象中" class="headerlink" title="11-1-1：为什么操作线程方法在Object对象中"></a>11-1-1：为什么操作线程方法在Object对象中</h3><p>因为这些方法在操作同步线程时，都必须要标识它们操作线程的锁，只有同一个锁上的被等待线程，可以被同一个锁上的notify唤醒，不可以对不同锁中的线程进行唤醒。</p>
<h2 id="12：序列化与反序列化"><a href="#12：序列化与反序列化" class="headerlink" title="12：序列化与反序列化"></a>12：序列化与反序列化</h2><h3 id="12-1：Java序列化与反序列化是什么"><a href="#12-1：Java序列化与反序列化是什么" class="headerlink" title="12-1：Java序列化与反序列化是什么"></a>12-1：Java序列化与反序列化是什么</h3><p>序列化是将对象转换为可传输格式的过程。 是一种数据的持久化手段。一般广泛应用于网络传输，RMI和RPC等场景中。</p>
<p>反序列化是序列化的逆操作。</p>
<p>序列化是将对象的状态信息转换为可存储或传输的形式的过程。一般是以字节码或XML格式传输。而字节码或XML编码格式可以还原为完全相等的对象。这个相反的过程称为反序列化。</p>
<h3 id="12-2：为什么需要序列化与反序列化"><a href="#12-2：为什么需要序列化与反序列化" class="headerlink" title="12-2：为什么需要序列化与反序列化"></a>12-2：为什么需要序列化与反序列化</h3><p>在Java中，我们可以通过多种方式来创建对象，并且只要对象没有被回收我们都可以复用该对象。但是，我们创建出来的这些Java对象都是存在于JVM的堆内存中的。只有JVM处于运行状态的时候，这些对象才可能存在。一旦JVM停止运行，这些对象的状态也就随之而丢失了。</p>
<p>但是在真实的应用场景中，我们需要将这些对象持久化下来，并且能够在需要的时候把对象重新读取出来。Java的对象序列化可以帮助我们实现该功能。</p>
<h3 id="12-3：Java对象如何实现序列化与反序列化"><a href="#12-3：Java对象如何实现序列化与反序列化" class="headerlink" title="12-3：Java对象如何实现序列化与反序列化"></a>12-3：Java对象如何实现序列化与反序列化</h3><ul>
<li>实现 <code>Java.io.Serializable</code>接口。</li>
<li>实现<code>Externalizable</code>接口</li>
</ul>
<h4 id="12-3-1：如何实现序列化"><a href="#12-3-1：如何实现序列化" class="headerlink" title="12-3-1：如何实现序列化"></a>12-3-1：如何实现序列化</h4><ol>
<li>在Java中，只要一个类实现了Java.io.Serializable接口，那么它就可以被序列化。</li>
<li>通过ObjectOutputStream和ObjectInputStream对对象进行序列化及反序列化</li>
<li>虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（就是 private static final long serialVersionUID）</li>
<li>序列化并不保存静态变量。</li>
<li>要想将父类对象也序列化，就需要让父类也实现Serializable 接口。</li>
<li>Transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。</li>
<li>服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。</li>
</ol>
<h4 id="12-3-2：Externalizable和Serializable的区别"><a href="#12-3-2：Externalizable和Serializable的区别" class="headerlink" title="12-3-2：Externalizable和Serializable的区别"></a>12-3-2：Externalizable和Serializable的区别</h4><p>Externalizable继承了Serializable， 该接口中定义了两个抽象⽅法：<code>writeExternal()</code>与<code>readExternal()</code>。 当使⽤Externalizable接口来进⾏序列化与反序列化的时候需要开发⼈员重写<code>writeExternal()</code>与<code>readExternal()</code>⽅法。<br>如果没有在这两个⽅法中定义序列化实现细节，那么序列化之后，对象内容为空。</p>
<p>实现Externalizable接口的类反序列化时会通过无参构造函数创建类再填充数据，所以必须要提供⼀个public的⽆参的构造器。</p>
<p><strong>实现Externalizable， 并实现<code>writeExternal()</code>和<code>readExternal()</code>⽅法可以指定序列化哪些属性。</strong></p>
<h4 id="12-3-3-什么是serialVersionUID"><a href="#12-3-3-什么是serialVersionUID" class="headerlink" title="12-3-3: 什么是serialVersionUID"></a>12-3-3: 什么是serialVersionUID</h4><p><code>serialVersionUID</code>是用来验证版本一致性的。用于反序列化时保证数据的版本正确。</p>
<h4 id="12-3-4：序列化协议有哪些"><a href="#12-3-4：序列化协议有哪些" class="headerlink" title="12-3-4：序列化协议有哪些"></a>12-3-4：序列化协议有哪些</h4><ul>
<li>xml</li>
<li>json</li>
<li>…</li>
</ul>
<h4 id="12-3-5：Serializable接口并没有方法和字段，为什么只有实现了该接口的类的对象才能被序列化呢？"><a href="#12-3-5：Serializable接口并没有方法和字段，为什么只有实现了该接口的类的对象才能被序列化呢？" class="headerlink" title="12-3-5：Serializable接口并没有方法和字段，为什么只有实现了该接口的类的对象才能被序列化呢？"></a>12-3-5：Serializable接口并没有方法和字段，为什么只有实现了该接口的类的对象才能被序列化呢？</h4><p>是因为在<code>ObjectOutputStream</code>的<code>writeObject0()</code>中进行了判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    writeString((String) obj, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">    writeArray(obj, desc, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">    writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">    writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(</span><br><span class="line">            cl.getName() + <span class="string">&quot;\n&quot;</span> + debugInfoStack.toString());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(cl.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进行序列化操作时，会判断要被序列化的类是否是Enum、Array和Serializable类型，如果不是则直接抛出NotSerializableException。</p>
<h4 id="12-3-6：Java对象如何实现反序列化"><a href="#12-3-6：Java对象如何实现反序列化" class="headerlink" title="12-3-6：Java对象如何实现反序列化"></a>12-3-6：Java对象如何实现反序列化</h4><p>使用<code>ObjectInputSteam</code></p>
<h4 id="12-3-7：哪些不会被序列化"><a href="#12-3-7：哪些不会被序列化" class="headerlink" title="12-3-7：哪些不会被序列化"></a>12-3-7：哪些不会被序列化</h4><p>使用<code>transient</code>修饰的成员和静态成员属性不会序列化。</p>
<h4 id="12-5-8：如果类中的一个成员未实现可序列化接口，会发生什么情况？"><a href="#12-5-8：如果类中的一个成员未实现可序列化接口，会发生什么情况？" class="headerlink" title="12-5-8：如果类中的一个成员未实现可序列化接口，会发生什么情况？"></a>12-5-8：如果类中的一个成员未实现可序列化接口，会发生什么情况？</h4><p>运行时将引发不可序列化异常<code>NotSerializableException</code></p>
<h4 id="12-5-9：如果类是可序列化的-但其父类不是-则反序列化后从父类类继承的实例变量的状态如何？"><a href="#12-5-9：如果类是可序列化的-但其父类不是-则反序列化后从父类类继承的实例变量的状态如何？" class="headerlink" title="12-5-9：如果类是可序列化的, 但其父类不是, 则反序列化后从父类类继承的实例变量的状态如何？"></a>12-5-9：如果类是可序列化的, 但其父类不是, 则反序列化后从父类类继承的实例变量的状态如何？</h4><p>父类的实例变量将通过构造函数初始化。如果想要保留父类的实例变量，父类也需要实现序列化接口</p>
<h4 id="12-5-10：是否可以自定义序列化过程-或者是否可以覆盖-Java-中的默认序列化过程？"><a href="#12-5-10：是否可以自定义序列化过程-或者是否可以覆盖-Java-中的默认序列化过程？" class="headerlink" title="12-5-10：是否可以自定义序列化过程, 或者是否可以覆盖 Java 中的默认序列化过程？"></a>12-5-10：是否可以自定义序列化过程, 或者是否可以覆盖 Java 中的默认序列化过程？</h4><p>可以，只要重写<code>writeObject()</code>和<code>readObject()</code>方法，就会调用重写的方法。</p>
<h4 id="12-5-11：假设新类的父类实现序列化接口-如何避免新类被序列化？"><a href="#12-5-11：假设新类的父类实现序列化接口-如何避免新类被序列化？" class="headerlink" title="12-5-11：假设新类的父类实现序列化接口, 如何避免新类被序列化？"></a>12-5-11：假设新类的父类实现序列化接口, 如何避免新类被序列化？</h4><p>和上一问相同，重写<code>writeObject()</code>和<code>readObject()</code>方法而方法内部不做实现。</p>
<h3 id="12-4：序列化和反序列化应用场景"><a href="#12-4：序列化和反序列化应用场景" class="headerlink" title="12-4：序列化和反序列化应用场景"></a>12-4：序列化和反序列化应用场景</h3><h2 id="13：并发高频"><a href="#13：并发高频" class="headerlink" title="13：并发高频"></a>13：并发高频</h2><h3 id="13-1-进程"><a href="#13-1-进程" class="headerlink" title="13-1:进程"></a>13-1:进程</h3><h4 id="13-1-1：什么是进程"><a href="#13-1-1：什么是进程" class="headerlink" title="13-1-1：什么是进程"></a>13-1-1：什么是进程</h4><p>进程是程序的一次执行过程，进程是程序运行和资源分配的基本单位。</p>
<h4 id="13-1-2：进程的状态"><a href="#13-1-2：进程的状态" class="headerlink" title="13-1-2：进程的状态"></a>13-1-2：进程的状态</h4><p>多进程和多线程都分为五个阶段</p>
<ol>
<li>创建</li>
<li>就绪</li>
<li>运行</li>
<li>阻塞</li>
<li>死亡</li>
</ol>
<h5 id="13-1-2-1：进程的状态变迁"><a href="#13-1-2-1：进程的状态变迁" class="headerlink" title="13-1-2-1：进程的状态变迁"></a>13-1-2-1：进程的状态变迁</h5><p><img src= "/img/loading.gif" data-lazy-src="https://image.shiming.online/blog/2021-03-15/20210315170532.png!img" alt="20210315170532"></p>
<h4 id="13-1-3：什么是PCB"><a href="#13-1-3：什么是PCB" class="headerlink" title="13-1-3：什么是PCB"></a>13-1-3：什么是PCB</h4><p>存放进程的管理和控制信息的数据结构称为进程控制块。它是进程管理和控制的最重要的数据结构，每一个进程均有一个PCB，在创建进程时，建立PCB，伴随进程运行的全过程，直到进程撤消而撤消。</p>
<h5 id="13-1-3-1：PCB-具体包含什么信息呢？"><a href="#13-1-3-1：PCB-具体包含什么信息呢？" class="headerlink" title="13-1-3-1：PCB 具体包含什么信息呢？"></a>13-1-3-1：PCB 具体包含什么信息呢？</h5><ul>
<li>进程标识符name</li>
<li>进程当前状态 status</li>
<li>进程相应的程序和数据地址</li>
<li>进程资源清单</li>
<li>进程优先级priority</li>
<li>CPU现场保护区 cpustatus</li>
<li>进程同步与通信机制</li>
<li>进程所在队列PCB的连接字</li>
<li>与进程有关的其他信息</li>
</ul>
<h4 id="13-1-3-2：多个-PCB-是如何组织的呢？"><a href="#13-1-3-2：多个-PCB-是如何组织的呢？" class="headerlink" title="13-1-3-2：多个 PCB 是如何组织的呢？"></a>13-1-3-2：多个 PCB 是如何组织的呢？</h4><ol>
<li>线性表方式<br>线性表方式将所有进程控制块的首地址连续存储在一整块内存空间中，操作系统每次查找目标进程时，只需要遍历这张表，就可以找到相应的进程控制块，进而控制目标进程。</li>
<li>索引表方式<br>索引表方式可以看做是线性表方式的“改进版”，它根据当前各个进程不同的执行状态，分别建立就绪索引表、阻塞索引表等</li>
<li>链接表方式<br>链接表方式会将处于相同执行状态的进程控制块通过指针串联成一个链表，从而分别组建成就绪链表、阻塞链表等</li>
</ol>
<h4 id="13-1-4：进程的控制"><a href="#13-1-4：进程的控制" class="headerlink" title="13-1-4：进程的控制"></a>13-1-4：进程的控制</h4><p>对进程在生命周期中各种状态之间的转换进行有效的控制，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。在操作系统中，一般把进程控制用的程序段称为原语，原语的特点是执行期间不允许中断，它是一个不可分割的基本单位。</p>
<ul>
<li>创建原语：一个进程可以使用创建原语创建一个新的进程，前者称为父进程，后者称为子进程，子进程又可以创建新的子进程，构成新的子进程，构成新的父子关系。建立进程控制块PCB：先申请一个空闲的PCB区域，将有关信息填入PCB，置该进程为就绪状态，最后将它插入到就绪状态队列中去。</li>
<li>撤销原语：找到要被撤销的进程PCB，将它从所在队列中消去。</li>
<li>阻塞原语：把进程运行状态转换为阻塞状态。首先应中断CPU执行，把CPU的当前状态保存到PCB的现场信息中，把它插入到该事件的等待队列中去。</li>
<li>唤醒原语：进程因为等待时间的发生而处于等待状态，当等待事件完成后，就用唤醒原语将其转换为就绪状态。具体操作过程：在等待队列中找到该进程，置该进程的当前状态为就绪状态，然后将它从等待队列中撤去并插入到就绪队列中排队，等待调度执行。</li>
</ul>
<h4 id="13-1-5：进程间通信"><a href="#13-1-5：进程间通信" class="headerlink" title="13-1-5：进程间通信"></a>13-1-5：进程间通信</h4><ul>
<li>管道/匿名管道(Pipes) ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。</li>
<li>有名管道(Names Pipes) : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循先进先出(first in first out)。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</li>
<li>信号(Signal) ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</li>
<li>消息队列(Message Queuing) ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。</li>
<li>信号量(Semaphores) ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。</li>
<li>共享内存(Shared memory) ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。</li>
<li>套接字(Sockets) : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</li>
</ul>
<h4 id="13-1-6：进程的内存结构"><a href="#13-1-6：进程的内存结构" class="headerlink" title="13-1-6：进程的内存结构"></a>13-1-6：进程的内存结构</h4><ul>
<li>文本段：包含了进程运行的程序机器语言指令。文本段具有只读属性，以防止进程通过错误指针意外修改自身指令。因为多个进程可同时运行同一程序，所以又将文本段设为可共享，这样，一份程序代码的拷贝可以映射到所有这些进程的虚拟地址空间中。</li>
<li>初始化数据段：包含显示初始化的全局变量和静态变量。当程序加载到内存时，从可执行文件中读取这些变量的值。</li>
<li>未初始化数据段：包含了未进行显示初始化的全局变量和静态变量。程序启动之前，系统将本段内所有内存初始化为0。出于历史原因，此段常被称为BSS段，这源于老版本的汇编语言助记符“block started by symbol”。将经过初始化的全局变量和静态变量与未初始化的全局变量和静态变量分开存放，其主要原因在于程序在磁盘上存储时，没有必要为未经初始化的变量分配存储空间。相反，可执行文件只需记录未初始化数据段的位置及所需大小，直到运行时再由程序加载器来分配空间。</li>
<li>栈（stack）：是一个动态增长和收缩的段，有栈帧（stack frames）组成。系统会为每个当前调用的函数分配一个栈帧。栈帧中存储了函数的局部变量（所谓自动变量）、实参和返回值。</li>
<li>堆（heap）：是可在运行时（为变量）动态进行内存分配的一块区域。堆顶端称为program break。</li>
</ul>
<h3 id="13-2：线程"><a href="#13-2：线程" class="headerlink" title="13-2：线程"></a>13-2：线程</h3><h4 id="13-2-1：线程概念"><a href="#13-2-1：线程概念" class="headerlink" title="13-2-1：线程概念"></a>13-2-1：线程概念</h4><p>多进程中每个进程拥有自己独立的代码和数据空间（进程上下文），而多线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器 (PC)。共享变量使线程之间的通信比进程之间的通信更有效，更容易。此外，在某些操作系统中，线程更” 轻量级”, 创建，撤销一个线程比启动新线程开销更小。</p>
<p>线程是进程的一个实体，是 CPU 调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。</p>
<h5 id="13-2-1-1：为什么使用线程"><a href="#13-2-1-1：为什么使用线程" class="headerlink" title="13-2-1-1：为什么使用线程"></a>13-2-1-1：为什么使用线程</h5><p>线程的创建和切换开销更小，因为线程共享代码段、数据段等内存空间。</p>
<h5 id="13-2-1-2：线程的优缺点"><a href="#13-2-1-2：线程的优缺点" class="headerlink" title="13-2-1-2：线程的优缺点"></a>13-2-1-2：线程的优缺点</h5><p>优点：</p>
<ul>
<li>创建和切换开销更小</li>
<li>线程间方便的通信机制</li>
</ul>
<p>缺点：</p>
<ul>
<li>调度时, 要保存线程状态，频繁调度, 需要占用大量的机时；</li>
<li>程序设计上容易出错（线程同步问题）。</li>
</ul>
<h4 id="13-2-2：三种线程的实现方式"><a href="#13-2-2：三种线程的实现方式" class="headerlink" title="13-2-2：三种线程的实现方式"></a>13-2-2：三种线程的实现方式</h4><ol>
<li>实现Runnable接口</li>
<li>继承Thread接口</li>
<li>实现Callable接口</li>
</ol>
<h4 id="13-2-3：用户线程如何理解？"><a href="#13-2-3：用户线程如何理解？" class="headerlink" title="13-2-3：用户线程如何理解？"></a>13-2-3：用户线程如何理解？</h4><p>不需要内核支持而在用户程序中实现的线程，其不依赖于操作系统核心，应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。<br>不需要用户态/核心态切换，速度快，操作系统内核不知道多线程的存在，因此一个线程阻塞将使得整个进程（包括它的所有线程）阻塞。由于这里的处理器时间片分配是以进程为基本单位，所以每个线程执行的时间相对减少。</p>
<h5 id="13-2-3-1：用户线程存在什么优势和缺陷？"><a href="#13-2-3-1：用户线程存在什么优势和缺陷？" class="headerlink" title="13-2-3-1：用户线程存在什么优势和缺陷？"></a>13-2-3-1：用户线程存在什么优势和缺陷？</h5><p>优点：</p>
<ul>
<li>线程的调度不需要内核直接参与，控制简单。</li>
<li>可以在不支持线程的操作系统中实现。</li>
<li>创建和销毁线程、线程切换代价等线程管理的代价比内核线程少得多。</li>
<li>允许每个进程定制自己的调度算法，线程管理比较灵活。</li>
<li>线程程能够利用的表空间和堆栈空间比内核级线多。</li>
<li>同一进程中只能同时有一个线程在运行，如果有一个线程使用了系统调用而阻塞，那么整个进程都会被挂起。另外，页面失效也会产生同样的问题</li>
</ul>
<p>缺点：</p>
<ul>
<li>资源调度按照进程进行，多个处理机下，同一个进程中的线程只能在同一个处理机下分时复用</li>
</ul>
<h4 id="13-2-4：内核线程如何理解？"><a href="#13-2-4：内核线程如何理解？" class="headerlink" title="13-2-4：内核线程如何理解？"></a>13-2-4：内核线程如何理解？</h4><p>由操作系统内核创建和撤销。内核维护进程及线程的上下文信息以及线程切换。一个内核线程由于I/O操作而阻塞，不会影响其它线程的运行。</p>
<h5 id="13-2-4-1：内核线程存在什么优势和缺陷"><a href="#13-2-4-1：内核线程存在什么优势和缺陷" class="headerlink" title="13-2-4-1：内核线程存在什么优势和缺陷"></a>13-2-4-1：内核线程存在什么优势和缺陷</h5><p>优点：</p>
<ul>
<li>当有多个处理机时，一个进程的多个线程可以同时执行</li>
</ul>
<p>缺点：</p>
<ul>
<li>即使CPU在同一个进程的多个线程之间切换，也需要陷入内核，因此其速度和效率不如用户级线程。</li>
</ul>
<h4 id="13-2-5：用户线程和内核线程的对应关系"><a href="#13-2-5：用户线程和内核线程的对应关系" class="headerlink" title="13-2-5：用户线程和内核线程的对应关系"></a>13-2-5：用户线程和内核线程的对应关系</h4><ul>
<li>内核支持：用户级线程可在一个不支持线程的OS中实现；内核支持线程则需要得到OS内核的支持。亦即内核支持线程是OS内核可感知的，而用户级线程是OS内核不可感知的。</li>
<li>处理器分配：在多处理机环境下，对用户级线程而言主，内核一次只为一个进程分配一个处理器，进程无法享用多处理机带来的好处；在设置有内核支持线程时，内核可调度一个应用中的多个线程同时在多个处理器上并行运行，提高程序的执行速度和效率。</li>
<li>调度和线程执行时间：设置有内核支持线程的系统，其调度方式和算法与进程的调度十分相似，只不过调度单位是线程；对只设置了用户级线程的系统，调度的单位仍为进程。</li>
<li>用户级线程执行系统调用指令时将导致其所属进程被中断，而内核支持线程执行系统调用指令时，只导致该线程被中断。</li>
<li>在只有用户级线程的系统内，CPU调度还是以进程为单位，处于运行状态的进程中的多个线程，由用户程序控制线程的轮换运行；在有内核支持线程的系统内，CPU调度则以线程为单位，由OS的线程调度程序负责线程的调度。</li>
</ul>
<h4 id="13-2-6：轻量级进程如何理解"><a href="#13-2-6：轻量级进程如何理解" class="headerlink" title="13-2-6：轻量级进程如何理解"></a>13-2-6：轻量级进程如何理解</h4><p>轻量级进程(LWP)是建立在内核之上并由内核支持的用户线程，它是内核线程的高度抽象，每一个轻量级进程都与一个特定的内核线程关联。内核线程只能由内核管理并像普通进程一样被调度。</p>
<h5 id="13-2-6-1：-LWP-与用户线程的对应关系"><a href="#13-2-6-1：-LWP-与用户线程的对应关系" class="headerlink" title="13-2-6-1： LWP 与用户线程的对应关系"></a>13-2-6-1： LWP 与用户线程的对应关系</h5><p>LWP与普通进程的区别也在于它只有一个最小的执行上下文和调度程序所需的统计信息，而这也是它之所以被称为轻量级的原因。而和线程相比，LWP可以共享进程空间，像进程一眼调度。</p>
<h4 id="13-2-3：线程同步"><a href="#13-2-3：线程同步" class="headerlink" title="13-2-3：线程同步"></a>13-2-3：线程同步</h4><ul>
<li>锁和同步</li>
<li>等待/通知机制：notify(),wait()</li>
<li>信号量：valatile</li>
<li>管道</li>
<li>其他<ul>
<li>join()</li>
<li>sleep()</li>
<li>ThreadLocal</li>
<li>InheritableThreadLocal</li>
</ul>
</li>
</ul>
<h5 id="13-2-3-1：wait-notify机制"><a href="#13-2-3-1：wait-notify机制" class="headerlink" title="13-2-3-1：wait/notify机制"></a>13-2-3-1：wait/notify机制</h5><ul>
<li>wait()：Object类的静态方法，释放当前线程占有的机锁，进入阻塞状态</li>
<li>notify()/notifyAll()：唤醒一个/全部等待该锁的线程，然后继续执行，执行完成后释放锁。</li>
</ul>
<h5 id="13-2-3-2：管道通信"><a href="#13-2-3-2：管道通信" class="headerlink" title="13-2-3-2：管道通信"></a>13-2-3-2：管道通信</h5><ul>
<li>PipedInputStream和PipedOutputStream</li>
<li>PipedReader和PipedWriter</li>
</ul>
<h3 id="13-3-线程与进程的区别"><a href="#13-3-线程与进程的区别" class="headerlink" title="13-3.线程与进程的区别"></a>13-3.线程与进程的区别</h3><h4 id="13-3-1：进程切换与线程切换的区别"><a href="#13-3-1：进程切换与线程切换的区别" class="headerlink" title="13-3-1：进程切换与线程切换的区别"></a>13-3-1：进程切换与线程切换的区别</h4><p>进程切换与线程切换的一个最主要区别就在于进程切换涉及到虚拟地址空间的切换而线程切换则不会。因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换。</p>
<h4 id="13-3-2：为什么进程花销比线程花销大"><a href="#13-3-2：为什么进程花销比线程花销大" class="headerlink" title="13-3-2：为什么进程花销比线程花销大"></a>13-3-2：为什么进程花销比线程花销大</h4><p>进程都有自己的虚拟地址空间，把虚拟地址转换为物理地址需要查找页表，页表查找是一个很慢的过程，因此通常使用Cache来缓存常用的地址映射，这样可以加速页表查找，这个cache就是TLB，Translation Lookaside Buffer，我们不需要关心这个名字只需要知道TLB本质上就是一个cache，是用来加速页表查找的。<br>由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么当进程切换后页表也要进行切换，页表切换后TLB就失效了，cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致TLB失效，因为线程线程无需切换地址空间，因此我们通常说线程切换要比较进程切换块，原因就在这里。</p>
<ol>
<li>上下文切换<br>4-1：什么是上下⽂切换?<br>4-2：CPU 上下文切换<br>4-3：进程的上下文<br>4-3-1：进程上下文概念<br>4-3-2：进程的上下文切换到底是切换什么呢？<br>4-3-3：发生进程上下文切换有哪些场景？<br>4-4：线程上下文</li>
<li>调度<br>5-1：什么是调度<br>5-2：什么时候会发生调度<br>5-3：调度原则<br>5-4：进程调度算法</li>
<li>互斥与同步<br>6-1：互斥概念<br>6-1-1：临界区<br>6-2：同步概念<br>6-2-1：同步的原理<br>6-2-1：线程同步的方式<br>6-2-2：同步方法和同步代码块的区别是什么<br>6-2-3：在监视器内部，是如何做线程同步的？<br>6-3：同步与互斥的区别<br>6-3-1：互斥与同步实现</li>
<li>生产者与消费者问题（同步问题）<br>7-1：Java中几种解决同步问题的方式</li>
<li>并发级别（并行和并发）<br>8-1：并行与并发概念</li>
<li>并发特性</li>
<li>多线程<br>5-1：为什么要使⽤多线程呢<br>5-1-1：使⽤多线程可能带来什么问题?<br>5-2：多线程公共用一个数据注意什么<br>5-2-1：如何确保 N 个线程可以访问 N 个资源同时又不导致死锁？<br>5-2-2：单cpu上多线程效率和单线程比如何</li>
<li>线程的基本操作<br>6-1：说说 sleep() ⽅法和 wait() ⽅法区别和共同点?<br>6-2：yield join notify notifyAll<br>6-3：为什么我们调⽤ start() ⽅法时会执⾏ run() ⽅法，为什么我们不能直接调⽤run() ⽅法<br>6-4：中断线程方法（36期）<br>6-5：一般线程和守护线程以及两者区别</li>
<li>创建线程<br>12-1：创建线程的方式<br>12-1-1：实现Runnable接⼝和Callable接⼝的区别<br>12-1-2：实现 Runnable 接口比继承 Thread 类所具有的优势<br>12-1-3：run()方法和start()方法的区别<br>12-2：创建线程的对比</li>
<li>线程安全<br>13-1：什么是线程安全<br>13-1-1：举例说明线程不安全<br>13-2：线程安全的方式</li>
<li>synchronized关键字<br>10-1：synchronized关键字<br>10-2：JDK1.6优化有哪些？<br>10-3：底层原理<br>10-3-1：monitor基本原理<br>10-4：synchronized的优势<br>10-5：synchronized锁的膨胀（升级）过程<br>10-6：那如何判断共享数据不会被线程竞争？<br>10-7：synchronized将线程的并行处理转为串行处理，有什么缺点<br>10-8：使用Synchronized关键字需要注意什么<br>10-9：synchronized在内存层面，是如何实现加锁和释放锁的？<br>10-10：synchronized关键字，是怎么保证线程安全的呢？</li>
<li>volatile关键字<br>15-1：基本原理<br>15-1-1：缓存一致性协议<br>15-1-2：内存屏障<br>15-1-2-1：volatile中的内存屏障<br>15-2：为什么要是用volatile关键字<br>15-3：volatile的作用<br>15-4：原子性<br>15-4-1：volatile为什么不保证原子性吗<br>15-4-2：怎么保证输出结果是20000呢<br>15-5-3：volatile都不保证原子性，为啥我们还要用它？<br>15-6：安全性<br>15-7：重排<br>15-7-1：为什么其他线程能感知到变量更新<br>15-7-2：为什么要重排<br>15-7-3： 有哪几种重排<br>15-7-4：举例说一下指令重排<br>15-8：happen-before原则是什么<br>15-9：volatile的典型应用场景</li>
<li>synchronized与其他的区别<br>16-1：谈谈 synchronized和ReentrantLock 的区别<br>16-2：Lock和synchronized的区别<br>16-3：synchronized 关键字和 volatile 关键字的区别</li>
<li>线程池–死锁<br>17-1：使⽤线程池的好处<br>17-2：常规实现线程池方法<br>17-3：线程池增长策略<br>17-3-1：线程池的核心线程数和最大线程数<br>17-4：线程池拒绝策略<br>17-5：线程池参数<br>17-6：线程池处理流程<br>17-7：设计线程池<br>17-7-1：如何设计一个线程池<br>17-8：死亡问题<br>17-8-1：单一线程池中线程死亡该怎么办<br>17-8-2：如何防止线程池线程死掉<br>17-9：线程池的风险<br>17-9-1：死锁<br>17-9-1-1：什么是线程死锁<br>17-9-1-2：产生死锁的条件<br>17-9-1-3：如何解决线程死锁问题<br>17-10：线程池单例问题</li>
<li>锁<br>18-1：锁<br>18-2：乐观锁与悲观锁<br>18-2-1：两种锁的使用场景<br>18-2-2：乐观锁常见的两种实现方式<br>18-2-3：乐观锁的缺点<br>18-3：自旋锁<br>18-3-1：自旋锁的优缺点<br>18-3-2：自旋锁的升级——自适应自旋<br>18-3-3：自旋锁使用场景<br>18-4：可重入锁（递归锁）<br>18-4-1：可重入锁使用场景<br>18-4-2：可重入锁如果加了两把，但是只释放了一把会出现什么问题？<br>18-4-3：如果只加了一把锁，释放两次会出现什么问题？<br>18-5：读写锁<br>18-6：公平锁与非公平锁<br>18-6-1：公平锁与非公平锁优缺点<br>18-6-2：公平锁与非公平锁使用场景<br>18-7：共享锁<br>18-7-1：共享锁使用场景<br>18-8：独占锁<br>18-8-1：独占锁使用场景<br>18-9：重量级锁<br>18-9-1：重量级锁使用场景<br>18-10：轻量级锁<br>18-10-1：轻量级锁优缺点<br>18-11：偏向锁<br>18-11-1：偏向锁优缺点<br>18-12：分段锁<br>18-13：互斥锁<br>18-14：同步锁<br>18-15：死锁<br>18-16：锁粗化<br>18-17：锁消除<br>18-18：提高锁性能的方法</li>
<li>ThreadLocal<br>19-1：什么是ThreadLocal，优势在哪里<br>19-2：ThreadLocal的实现原理<br>19-3：ThreadLocal内存泄露问题<br>19-3-1：ThreadLocal如何防止内存泄漏？</li>
<li>线程变量绑定</li>
<li>无锁-CAS、Atomic<br>21-1：CAS<br>21-1-1：CAS使用时存在的问题以及解决方案<br>21-1-1-1：CAS的ABA问题<br>21-2：CAS原理<br>21-2：原子类原理<br>21-1-1：为什么要使用原子类<br>21-1-2：原子类的作用？<br>21-4：i++自增操作不是原子性的，如何决绝原子性问题<br>21-5：基本数据类型原子类的优势<br>21-6：为什么是unsafe<br>26-2：Unsafe为什么是不安全的？<br>26-3：Unsafe的实例怎么获取？<br>26-4：讲一讲Unsafe中的CAS操作？<br>26-5：unsafe的阻塞/唤醒操作？</li>
<li>AQS（队列同步器）<br>23-1：对AQS原理分析<br>23-2：AQS 对资源的共享⽅式<br>23-3：AQS 组件<br>23-4：AQS应用场景</li>
<li>并发容器<br>24-1：JDK 提供的并发容器总结<br>24-2：CopyOnWriteArrayList 是如何做到的？<br>24-3：BlockingQueue<br>24-3-1：什么是阻塞队列<br>24-3-2：阻塞队列的常用类<br>24-3-3：手写堵塞队列</li>
<li>快速失败与安全失败</li>
</ol>
<h2 id="14：JVM高频"><a href="#14：JVM高频" class="headerlink" title="14：JVM高频"></a>14：JVM高频</h2><p>1.JVM<br>1-1：JVM1.8新特性<br>1-2：JDK1.8默认垃圾回收器<br>2.类加载<br>1-1：类的生命周期<br>1-2：类的加载过程（37期）<br>1-2-1：符号引用于直接饮用<br>1-3：类加载机制<br>1-4：知道哪些类加载器?<br>1-4-1：类加载器之间的关系<br>1-5：创建并使用自定义类加载器<br>1-5：双亲委派模型流程<br>1-5-1：双亲委派模型带来了什么好处呢？<br>1-5-2：如果我们不想⽤双亲委派模型怎么办？<br>1-5-3：自己写一个类能不能被加载？<br>1-5-4：如何破坏双亲委派机制<br>3.垃圾回收<br>3-1：什么是GC<br>3-1-1：垃圾回收的优点<br>3-1-2：什么样的对象需要回收<br>3-1-3：垃圾回收器可以马上回收内存吗？<br>3-1-4：有什么办法主动通知虚拟机进行垃圾回收？<br>3-2：垃圾回收器的基本原理是什么？<br>3-3：如何判断对象已经死亡？<br>3-3-1：可作为GC Roots的对象？<br>3-3-2：不可达的对象是否非死不可<br>3-4：如何判断一个类是无用的类<br>3-5：如何判断一个常量是废弃常量？<br>3-6：如何减少 GC 的次数<br>3-7：垃圾回收算法<br>3-8：垃圾回收器<br>3-8-1：Serial收集器<br>3-8-2：ParNew收集器<br>3-8-3：Parallel Scavenge收集器<br>3-8-4：Serial Old收集器<br>3-8-5：Parallel Old收集器<br>3-8-6：CMS收集器<br>3-8-6-1：产生 concurrent mode failure 真正的原因<br>3-8-6-2：CMS 出现FullGC的原因<br>3-8-6-3：cms怎么解决内存碎片的问题<br>3-8-6-4：CMS GC发生concurrent mode failure时的full GC为什么是单线程的?<br>3-8-7：G1收集器<br>3-8-8：CMS与G1区别<br>3-8-9：吞吐有限和响应有限的垃圾收集器如何选择<br>3-9：为什么要分代回收？分代回收背后的思想？<br>3-9-1：young gc、old gc、full gc、mixed gc区别<br>3-9-1-1：新生代的 GC 如何避免全堆扫描？<br>3-9-1-1：young gc 触发条件是什么？<br>3-9-1-1-1：TLAB你了解多少？<br>3-9-1-1-2：PLAB你了解多少？<br>3-9-1-2：full gc 触发条件有哪些？<br>3-10：为什么有些新老年代的收集器不能组合使用比如 ParNew 和 Parallel Old？<br>3-10：为什么新生代都是复制算法，老年代都是标记整理算法</p>
<p>JVM内存模型（堆栈五大分区）<br>4-1：堆的分区<br>4-1-1：分区的目的<br>4-1-2：Minor GC与Full GC分别什么时候发生？<br>4-1-3：Minor Gc和Full GC 有什么不同呢？<br>4-1-5：年轻代<br>4-1-5-1：为什么会有年轻代<br>4-1-5-2：年轻代中的GC<br>6-5：为什么是8：1：1<br>4-1-6：老年代<br>4-1-7：持久代<br>4-1-8：对象在堆内存移动<br>4-1-8-1：如何判断发生GC时对象在堆内存移动呢？<br>4-1-9：Java中对象并不是都在堆上分配内存的<br>4-2：栈<br>4-1-1：栈的实现<br>4-1-2：栈堆存放什么东西<br>4-1-2：什么是栈<br>4-1-3：栈帧<br>4-1-3-1：栈帧结构<br>4-1-4：虚拟机栈和本地⽅法栈为什么是私有的?<br>4-3：堆与栈的区别<br>4-3-1：<br>4-4：程序计数器<br>4-4-1：为什么要有程序计数器（作用）<br>4-4-2：程序计数器为什么是私有的?<br>4-4：元空间<br>4-4-1：Java 8的metaspace (元空间)<br>4-4-2：为什么要进行元空间代替持久代呢?<br>Java内存结构（JMM）<br>5-1：为什么需要Java内存模型？<br>5-1-1：什么是Java内存模型？<br>5-1-2：Java内存模型的两大内存是啥？<br>5-1-3：内存如何工作<br>5-2：什么是JMM<br>Java对象的创建过程（对象头等概念）<br>6-1：内存分配的两种⽅式选择<br>6-2：虚拟机如何保证线程安全<br>6-3：对象的访问定位有哪两种⽅式?<br>6-3-1：访问定位两种方式的优缺点<br>对象头<br>对象分配规则<br>内存泄露与内存溢出<br>8-1：什么是内存泄漏<br>8-1-1：如何检测内存泄**<em>r&gt;8-2：什么是内存溢出<br>8-2-2：手写出现内存溢出的情形<br>8-3：内存溢出，内存泄漏区别<br>8-4：如何避免内存泄露、溢出<br>8-5：内存结构的溢出与泄**</em>r&gt;8-5-1：溢出<br>8-5-1-1：溢出例子<br>8-5-2：泄露<br>调优工具<br>3-2：强、软、弱、虚引用<br>10-1:虚引用与软引用和弱引用的一个区别<br>JVM进程有哪些线程启动? (拼多多)<br>jvm启动模式之client 与server<br>简述JVM中静态分派和动态分派(引申:重载和重写)</p>
<h2 id="15：计网与操作系统"><a href="#15：计网与操作系统" class="headerlink" title="15：计网与操作系统"></a>15：计网与操作系统</h2><p>1.各层协议<br>1-1：OSI与TCP/IP各层的结构与功能,都有哪些协议?<br>1-2：⽹络层与数据链路层有什么关系呢？<br>1-3：网络层的路由算法<br>1.Get与Post<br>1-1：get与post的区别<br>1-2：后台获取前端数据方法<br>1-3：如何通过GET方式上传压缩包<br>2.报文结构与状态码<br>2-1：状态码<br>2-2：HTTP请求组成<br>3.计算机网络-HTTP-HTTP的1.0-3.0<br>3-1：HTTP-1.0<br>3-1-1：HTTP-1.0优缺点<br>3-1-2：Http为什么是无连接和无状态的<br>3-2：HTTP-1.1<br>3-2-1：HTTP/1.1相对于HTTP1.0改善<br>3-2-2：HTTP1.1缺点<br>3-2-3：HTTP⻓连接,短连接(也是TCP连接,短连接)<br>3-3：HTTP-2<br>3-3-1：HTTP/2 做了什么优化<br>3-3-2：HTTP/2有哪些缺陷<br>3-4：HTTP-3<br>3-4-1：HTTP/3做了哪些优化<br>3-5：http工作流程<br>3-6：一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？<br>4.计算机网络-HTTP与HTTPs前世今生<br>4-1：什么是HTTPS<br>4-2：HTTPS 解决了 HTTP 的哪些问题？（为什么要HTTPS）<br>4-2-1：加密算法<br>4-2-1-1：Https对称加解密的过程<br>4-2-1-2：Https非对称加密过程<br>4-2-1：数字证书认证机构的流程<br>4-3：HTTP与HTTPS建立请求过程<br>4-3-1：HTTP 请求过程<br>4-3-2：HTTPS 请求过程（加密过程）<br>4-3-2-1：SSL/TLS握⼿<br>4-3-3：HTTP与HTTPS区别<br>4-3-4：为何不所有的网站都使用HTTPS<br>5.各种协议的端口号<br>6.拆包粘包<br>6-1：什么是TCP粘包？<br>6-2：粘包的原因<br>6-3：粘包解决方案<br>6-4：UDP会不会产生粘包问题呢？<br>6-5：HTTP拆包粘包<br>7.计算机网络-HTTP-Cookie与Session<br>7-1：Cookie 和 Session 的区别<br>8.计算机网络-HTTP-Cookie<br>8-1：Cookie作用<br>8-2：HTTP是不保存状态的协议,如何保存⽤户状态<br>8-3：Cookie 被禁⽤怎么办<br>8-3-1：cookie被禁用了，session还能用么<br>8-4：cookie如何放置攻击<br>9.计算机网络-HTTP-Session<br>9-1：Session用户登录状态过程<br>9-2：如何保存session<br>9-3：如何实现 Session 跟踪呢？<br>9-4：Session机制（多个session如何识别）<br>10.计算机网络-HTTP-token<br>10-1：token的验证流程<br>10-2：token和cookie实现的区别<br>11.计算机网络-HTTP-url/uri<br>11-1：URI和URL的区别是什么?<br>12.计算机网络-综合应用-输入网址<br>12-1：输入网址过程<br>12-2：为什么域名要分级设计<br>12-3：重定向原因<br>15.TCP的三次握手<br>15-1：TCP三次握手流程<br>15-2：TCP为什么要三次握⼿<br>15-3：TCP为什么SYN<br>15-4：TCP除了SYN，为什么还要 ACK<br>15-5：什么是 SYN 攻击？如何避免 SYN 攻击？<br>15-5：如何对三次握手进行性能优化<br>15-6：如何绕过三次握手发送数据<br>15-7：TCP Fast Open的过程<br>15-8：为什么需要 TCP 协议？<br>15-9：什么是 TCP 连接？<br>15-10：如何唯一确定一个 TCP 连接呢？<br>15-11：有一个 IP 的服务器监听了一个端口，它的 TCP 的最大连接数是多少？<br>15-12：服务端最大并发 TCP 连接数远不能达到理论上限<br>15-15：为什么客户端和服务端的初始序列号 ISN 是不相同的？<br>15-16：什么是Mss<br>15-17：既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？<br>16.TCP的四次挥手<br>16-1：TCP四次挥手流程<br>16-2：TCP为什么要四次挥手<br>16-3：TCP第四次挥手后会理解断开呢？<br>16-3：如何对四次挥手进行优化<br>16-4：为什么TIME_WAIT 等待的时间是 2MSL？<br>16-5：为什么需要TIME_WAIT状态？（已经主动关闭连接了为啥还要保持资源一段时间呢？）<br>16-6：TIME_WAIT 过多有什么危害？<br>16-7：如何优化 TIME_WAIT？<br>16-8：如果已经建⽴了连接，但是客户端突然出现故障了怎么办？<br>17.TCP传输数据优化方案<br>17-1：TCP传输数据优化<br>18.TCP与UDP/IP比较<br>18-1：TCP与UDP区别<br>18-2：TCP 和 UDP 应用场景<br>18-3：TCP与IP的区别<br>19.TCP<br>19-1：TCP<br>19-1-1：为什么TCP面向流<br>19-2：TCP首部<br>19-2：TCP作用<br>19-3：TCP 数据包的大小<br>19-4：TCP 数据包的编号（SEQ）<br>19-5：TCP 数据包的组装<br>19-6：TCP首部组成<br>20.TCP/UDP如何保证可靠传输方式<br>20-1：TCP如何保证稳定传输<br>20-2：UDP如何做可靠传输<br>21.重传机制<br>21-1：常见的重传机制<br>21-2：超时重传<br>21-3：什么时候会发生超时重传<br>21-4：超时重传存在的问题<br>21-5：快速重传<br>21-6：快速重传的问题<br>21-7：SACK方法<br>21-8：D-SACK<br>21-9：D-SACK好处<br>22.滑动窗口与流量控制<br>22-1：引入窗口概念的原因<br>22-2：什么是窗口<br>22-3：窗口大小由哪一方决定？<br>22-4：发送方的窗口<br>22-5：流量控制<br>22-6：流量控制的过程<br>22-9：TCP 是如何解决窗口关闭时，潜在的死锁现象呢？<br>23.拥塞控制<br>23-1：为什么要有拥塞控制呀，不是有流量控制了吗？<br>23-2：什么是拥塞控制<br>23-3：什么是拥塞窗口？和发送窗口有什么关系呢？<br>23-4：那么怎么知道当前网络是否出现了拥塞呢？<br>23-5：拥塞控制算法<br>23-6：那慢启动涨到什么时候是个头呢？<br>23-7：重传机制何时结束<br>24.ARQ协议<br>24-1：什么是ARQ协议<br>24-2：什么是停⽌等待ARQ协议<br>24-3: 什么是连续ARQ协议<br>25.Socket<br>25-1： TCP 应该如何 Socket 编程？</p>
<p>——操作系统——————————————–</p>
<p>1.内存管理-虚拟内存<br>1-1：什么是虚拟地址<br>1-2：操作系统是如何管理虚拟地址与物理地址之间的关系？<br>1-3：什么是虚拟内存<br>1-3-1：虚拟内存的优缺点<br>1-3-2：为什么虚拟内存可以大于物理内存<br>2.内存管理-内存分段<br>2-1：什么是内存分段<br>2-2：分段机制下，虚拟地址和物理地址是如何映射的？<br>2-3：访问某段偏移量xxx的虚拟地址<br>2-4：内存分段缺陷<br>2-5：如何解决内存分段的缺陷</p>
<p>内存管理-内存分页<br>3-1：为什么有内存分页（内存分页定义）<br>3-2：分页是怎么解决分段的内存碎片、内存交换效率低的问题？<br>3-3：分页机制下，虚拟地址和物理地址是如何映射的？<br>3-4：简单的分页有什么缺陷吗？<br>3-5：简单的分页缺陷的解决方案<br>3-6：分了二级表，内存不是变大了呢<br>3-7：为什么不分级的页表就做不到这样节约内存呢？<br>3-8：多级页表的缺陷以及解决方案<br>内存管理-段页式内存管理<br>4-1：什么是段页式内存管理<br>4-2：段页式内存管理实现的方式<br>内存管理-linux内存管理<br>5-1：Linux 操作系统采用了哪种方式来管理内存<br>5-2：Linux 的虚拟地址空间是如何分布的？<br>5-3：内核空间与用户空间的区别<br>5-4：用户空间分布<br>内存管理-页面置换算法<br>6-1：页面置换算法<br>6-2：⻚⾯置换算法的作⽤?<br>6-3：手写LRU缓存<br>磁盘调度算法<br>文件系统组成<br>7-1：什么是文件系统<br>虚拟文件系统<br>文件的使用<br>文件的存储<br>空闲空间管理<br>文件系统的结构<br>目录的存储<br>软链接和硬链接<br>页面置换算法</p>
<h2 id="16：数据库"><a href="#16：数据库" class="headerlink" title="16：数据库"></a>16：数据库</h2><h3 id="16-1：MySQL"><a href="#16-1：MySQL" class="headerlink" title="16-1：MySQL"></a>16-1：MySQL</h3><h4 id="16-1-1：为什么要使用数据库"><a href="#16-1-1：为什么要使用数据库" class="headerlink" title="16-1-1：为什么要使用数据库"></a>16-1-1：为什么要使用数据库</h4><p>为了更高效且条例分明的存储数据，能够更迅速和方便地管理数据。</p>
<ol>
<li>数据库可以结构化存储大量的数据信息，方柏霓用户进行有效的检索和访问。</li>
<li>数据库可以有效地保证数据信息的一致性，完整性，降低数据冗余</li>
<li>数据库可以满足应用的共享和安全方面的要求，把数据放在数据库中在很多情况下也是出于安全的考虑。</li>
<li>数据库技术能够方便智能化地分析，产生新的有用信息。</li>
</ol>
<h4 id="16-1-2-什么是SQL？"><a href="#16-1-2-什么是SQL？" class="headerlink" title="16-1-2: 什么是SQL？"></a>16-1-2: 什么是SQL？</h4><ul>
<li>SQL 指结构化查询语言，全称是 Structured Query Language。</li>
<li>SQL 让您可以访问和处理数据库，包括数据插入、查询、更新和删除。</li>
<li>SQL 在1986年成为 ANSI（American National Standards Institute 美国国家标准化组织）的一项标准，在 1987 年成为国际标准化组织（ISO）标准。</li>
</ul>
<h4 id="16-1-3：什么是MySQL"><a href="#16-1-3：什么是MySQL" class="headerlink" title="16-1-3：什么是MySQL?"></a>16-1-3：什么是MySQL?</h4><p>MySQL是一种关系型数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。</p>
<h3 id="16-2：关系型数据库与非关系型数据库"><a href="#16-2：关系型数据库与非关系型数据库" class="headerlink" title="16-2：关系型数据库与非关系型数据库"></a>16-2：关系型数据库与非关系型数据库</h3><h4 id="16-2-1：非关系型数据库和关系型数据库定义"><a href="#16-2-1：非关系型数据库和关系型数据库定义" class="headerlink" title="16-2-1：非关系型数据库和关系型数据库定义"></a>16-2-1：非关系型数据库和关系型数据库定义</h4><ul>
<li>关系数据库（英语：Relational database），是创建在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。</li>
<li>NoSQL（最初表示Non-SQL，后来有人转解为Not only SQL），是对不同于传统的关系数据库的数据库管理系统的统称。<br>允许部分资料使用SQL系统存储，而其他资料允许使用NOSQL系统存储。其数据存储可以不需要固定的表格模式以及元数据（metadata），也经常会避免使用SQL的JOIN操作，一般有水平可扩展性的特征。</li>
</ul>
<h4 id="16-2-2：关系型数据库优缺点"><a href="#16-2-2：关系型数据库优缺点" class="headerlink" title="16-2-2：关系型数据库优缺点"></a>16-2-2：关系型数据库优缺点</h4><p>优点：</p>
<ul>
<li>通过事务处理保持数据的一致性</li>
<li>数据更新的开销很小</li>
<li>可以进行Join等复杂查询</li>
<li>20多年的技术历程，技术成熟</li>
</ul>
<p>缺点：</p>
<ul>
<li>数据读写必须经过sql解析，大量数据、高并发下读写性能不足</li>
<li>为保证数据一致性，需要加锁，影响并发操作</li>
<li>无法适应非结构化的存储</li>
<li>大量数据集中到一台服务区处理，使服务器不堪重负</li>
<li>“阻抗失谐”，即数据库中存储的对象与实际的对象实体有一定的差别</li>
<li>扩展困难</li>
<li>数据库庞大，价格昂贵</li>
</ul>
<h4 id="16-2-3：非关系型数据库优缺点"><a href="#16-2-3：非关系型数据库优缺点" class="headerlink" title="16-2-3：非关系型数据库优缺点"></a>16-2-3：非关系型数据库优缺点</h4><p>优点：</p>
<ul>
<li>处理高并发、大批量数据的能力强</li>
<li>支持分布式集群，负载均衡，性能高</li>
<li>解决“阻抗失谐”问题</li>
<li>内存级数据库，查询速度快</li>
<li>存储格式多，支持key-value形式、文档形式、图片形式</li>
<li>没有多表连接查询机制的限制，扩展性高</li>
</ul>
<p>缺点：</p>
<ul>
<li>技术起步晚，维护工具以及技术资料有限</li>
<li>不支持sql工业标准</li>
<li>没有join等复杂的连接操作</li>
<li>事务处理能力弱</li>
<li>没有完整性约束，对于复杂业务场景支持较差</li>
</ul>
<h4 id="16-3-4：非关系型数据库和关系型数据库区别"><a href="#16-3-4：非关系型数据库和关系型数据库区别" class="headerlink" title="16-3-4：非关系型数据库和关系型数据库区别"></a>16-3-4：非关系型数据库和关系型数据库区别</h4><table>
<thead>
<tr>
<th align="center">关系型数据库</th>
<th align="center">非关系型数据库</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数据相互关联</td>
<td align="center">数据独立</td>
</tr>
<tr>
<td align="center">一般数据量</td>
<td align="center">海量数据</td>
</tr>
<tr>
<td align="center">行存储</td>
<td align="center">列储存</td>
</tr>
<tr>
<td align="center">保证数据完整性和安全性</td>
<td align="center">不保证数据完整性和安全性存储</td>
</tr>
</tbody></table>
<h3 id="16-3：三大范式"><a href="#16-3：三大范式" class="headerlink" title="16-3：三大范式"></a>16-3：三大范式</h3><h4 id="16-3-1：数据库三大范式是什么"><a href="#16-3-1：数据库三大范式是什么" class="headerlink" title="16-3-1：数据库三大范式是什么"></a>16-3-1：数据库三大范式是什么</h4><ol>
<li>数据库表的每一列都是不可分割的基本数据项</li>
<li>每一行都要有唯一标识存在，这个唯一属性列被称为主关键字或主键、主码。实体的属性完全依赖于主关键字。</li>
<li>属性不依赖于其他非主属性。</li>
</ol>
<h3 id="16-4：数据库的数据类型"><a href="#16-4：数据库的数据类型" class="headerlink" title="16-4：数据库的数据类型"></a>16-4：数据库的数据类型</h3><h4 id="16-4-1：MySQL的数据类型"><a href="#16-4-1：MySQL的数据类型" class="headerlink" title="16-4-1：MySQL的数据类型"></a>16-4-1：MySQL的数据类型</h4><ul>
<li>TINYINT：1个字节，整形</li>
<li>SMALLINT：2个字节，整形</li>
<li>MEDIUMINT：3个字节，整形</li>
<li>INT：4个字节：整形</li>
<li>BITINT：8个字节，整形</li>
<li>FLOAT：4个字节，单精度浮点型</li>
<li>DOUBLE：8个字节，双精度浮点型</li>
<li>DECIMAL：定点型，解决浮点数的精度丢失问题</li>
<li>CHAR：固定长度字符串</li>
<li>VARCHAR：可变长度字符串</li>
<li>DATA：3个字节，yyyy-MM-dd，日期</li>
<li>TIME：3个字节，HH:mm:ss，时间</li>
<li>YEAR：1个字节，yyyy，年</li>
<li>DATETIME：8个字节，yyyy-MM-dd HH:mm:ss 日期+时间</li>
<li>TIMESTAMP：4个字节，yyyy-MM-dd HH:mm:ss 日期+时间，可作时间戳</li>
</ul>
<h4 id="16-4-2：varchar与char的区别"><a href="#16-4-2：varchar与char的区别" class="headerlink" title="16-4-2：varchar与char的区别"></a>16-4-2：varchar与char的区别</h4><p>char是一种固定长度的类型，varchar则是一种可变长度的类型，它们的区别是：</p>
<ul>
<li>char(M)类型的数据列里，每个值都占用M个字节，如果某个长度小于M，MySQL就会在它的右边用空格字符补足．（在检索操作中那些填补出来的空格字符将被去掉）</li>
<li>在varchar(M)类型的数据列里，每个值只占用刚好够用的字节再加上一个用来记录其长度的字节（即总长度为L+1字节）．</li>
</ul>
<h5 id="16-4-2-1：varchar-50-中50的涵义"><a href="#16-4-2-1：varchar-50-中50的涵义" class="headerlink" title="16-4-2-1：varchar(50)中50的涵义"></a>16-4-2-1：varchar(50)中50的涵义</h5><p>archar(50)中50的涵义最多存放50个字符，varchar(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存，<br>因为order by col采用fixed_length计算col长度</p>
<h4 id="16-4-3：int-20-中20的涵义"><a href="#16-4-3：int-20-中20的涵义" class="headerlink" title="16-4-3：int(20)中20的涵义"></a>16-4-3：int(20)中20的涵义</h4><p>显示长度，不足用0补齐</p>
<h4 id="16-4-4：FLOAT和DOUBLE的区别是什么？"><a href="#16-4-4：FLOAT和DOUBLE的区别是什么？" class="headerlink" title="16-4-4：FLOAT和DOUBLE的区别是什么？"></a>16-4-4：FLOAT和DOUBLE的区别是什么？</h4><p>单精度和双精度的区别</p>
<h4 id="16-4-5：MySQL-INT和CHAR隐式类型转换需要注意什么？"><a href="#16-4-5：MySQL-INT和CHAR隐式类型转换需要注意什么？" class="headerlink" title="16-4-5：MySQL INT和CHAR隐式类型转换需要注意什么？"></a>16-4-5：MySQL INT和CHAR隐式类型转换需要注意什么？</h4><ol>
<li>当查询字段是INT类型，如果查询条件为CHAR，将查询条件转换为INT，如果是字符串前导都是数字，将截取前导数字用来比较，如果没有前导数字，则转换为0。</li>
<li>当查询字段是CHAR/VARCHAR类型，如果查询条件为INT，将查询字段为换为INT再进行比较，可能会造成全表扫描。</li>
</ol>
<h3 id="16-5：SQL生命周期"><a href="#16-5：SQL生命周期" class="headerlink" title="16-5：SQL生命周期"></a>16-5：SQL生命周期</h3><ul>
<li>连接器：建立连接</li>
<li>查询缓存：缓冲中存在则返回，否则继续执行（8.0后删除）</li>
<li>分析器：词法分析，判断是否合法</li>
<li>优化器：索引优化</li>
<li>执行器：有索引则按照索引树跳转，否则全表扫描。</li>
</ul>
<h3 id="16-6：MySQL预编译"><a href="#16-6：MySQL预编译" class="headerlink" title="16-6：MySQL预编译"></a>16-6：MySQL预编译</h3><h4 id="16-6-1：预编译的好处"><a href="#16-6-1：预编译的好处" class="headerlink" title="16-6-1：预编译的好处"></a>16-6-1：预编译的好处</h4><p>即时sql每次都会进行分析和优化，而预编译sql将语句参数化，实现一次编译，多次执行。省去了解析优化等过程。此外预编译能防止sql注入。</p>
<h3 id="16-7：SQL注入"><a href="#16-7：SQL注入" class="headerlink" title="16-7：SQL注入"></a>16-7：SQL注入</h3><h4 id="16-7-1：SQL注入简介"><a href="#16-7-1：SQL注入简介" class="headerlink" title="16-7-1：SQL注入简介"></a>16-7-1：SQL注入简介</h4><p>Sql 注入攻击是通过将恶意的 Sql 查询或添加语句插入到应用的输入参数中，再在后台 Sql 服务器上解析执行进行的攻击，它目前黑客对数据库进行攻击的最常用手段之一。</p>
<h4 id="16-7-3：SQL注入解决方案"><a href="#16-7-3：SQL注入解决方案" class="headerlink" title="16-7-3：SQL注入解决方案"></a>16-7-3：SQL注入解决方案</h4><ul>
<li>严格限制 Web 应用的数据库的操作权限，给连接数据库的用户提供满足需要的最低权限，最大限度的减少注入攻击对数据库的危害</li>
<li>校验参数的数据格式是否合法（可以使用正则或特殊字符的判断）</li>
<li>对进入数据库的特殊字符进行转义处理，或编码转换</li>
<li>预编译 SQL（Java 中使用 PreparedStatement），参数化查询方式，避免 SQL 拼接</li>
<li>发布前，利用工具进行 SQL 注入检测</li>
<li>报错信息不要包含 SQL 信息输出到 Web 页面</li>
</ul>
<h3 id="16-8：sql语句"><a href="#16-8：sql语句" class="headerlink" title="16-8：sql语句"></a>16-8：sql语句</h3><h4 id="16-8-1：SQL的分类"><a href="#16-8-1：SQL的分类" class="headerlink" title="16-8-1：SQL的分类"></a>16-8-1：SQL的分类</h4><ul>
<li>数据操作语言(DML)：对数据库中数据的操作</li>
<li>数据定义语言(DDL)：定义SQL模式，基本表，视图和索引的创建和撤销</li>
<li>数据控制语言(DCL)：用于数据库搜全，角色控制等管理工作</li>
<li>事务控制语言(TCL)：用于数据库的事务管理</li>
</ul>
<h4 id="16-8-2：多表查询"><a href="#16-8-2：多表查询" class="headerlink" title="16-8-2：多表查询"></a>16-8-2：多表查询</h4><ul>
<li>合并查询结果（union，union all）</li>
<li>连接查询（交叉连接（cross join）、内连接（inner join）、左连接（left join）、右连接（right JOIN)、全连接）</li>
<li>CASE表达式。</li>
</ul>
<h5 id="16-8-2-1：笛卡尔积问题"><a href="#16-8-2-1：笛卡尔积问题" class="headerlink" title="16-8-2-1：笛卡尔积问题"></a>16-8-2-1：笛卡尔积问题</h5><p>连接查询，如果on条件是非唯一字段，会出现笛卡尔积(局部笛卡尔积)；如果on条件是表的唯一字段，则不会出现笛卡尔积。</p>
<h5 id="16-8-2-2：笛卡尔积的解决方案"><a href="#16-8-2-2：笛卡尔积的解决方案" class="headerlink" title="16-8-2-2：笛卡尔积的解决方案"></a>16-8-2-2：笛卡尔积的解决方案</h5><ul>
<li>使用左连接，右连接，内连接</li>
<li>使用唯一条件作为on筛选条件</li>
</ul>
<h4 id="16-8-3：常见函数"><a href="#16-8-3：常见函数" class="headerlink" title="16-8-3：常见函数"></a>16-8-3：常见函数</h4><ul>
<li>ABS(X):返回X的绝对值</li>
<li>MOD(N,M)或%:返回N被M除的余数</li>
<li>FLOOR(X):返回不大于X的最大整数值</li>
<li>CEILING(X):返回不小于X的最小整数值</li>
<li>ROUND(X) :返回参数X的四舍五入的一个整数</li>
<li>….</li>
</ul>
<h5 id="16-8-3-1：单行函数"><a href="#16-8-3-1：单行函数" class="headerlink" title="16-8-3-1：单行函数"></a>16-8-3-1：单行函数</h5><h5 id="16-8-3-2：聚合函数"><a href="#16-8-3-2：聚合函数" class="headerlink" title="16-8-3-2：聚合函数"></a>16-8-3-2：聚合函数</h5><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AVG([distinct] expr)</td>
<td align="center">求平均值</td>
</tr>
<tr>
<td align="center">COUNT({*</td>
<td align="center">[distinct] } expr)</td>
</tr>
<tr>
<td align="center">MAX([distinct] expr)</td>
<td align="center">求最大值</td>
</tr>
<tr>
<td align="center">MIN([distinct] expr)</td>
<td align="center">求最小值</td>
</tr>
<tr>
<td align="center">SUM([distinct] expr)</td>
<td align="center">求累加和</td>
</tr>
</tbody></table>
<h4 id="16-8-4：关键字-语句"><a href="#16-8-4：关键字-语句" class="headerlink" title="16-8-4：关键字/语句"></a>16-8-4：关键字/语句</h4><h5 id="16-8-4-1：truncate、-delete区别"><a href="#16-8-4-1：truncate、-delete区别" class="headerlink" title="16-8-4-1：truncate、 delete区别"></a>16-8-4-1：truncate、 delete区别</h5><ul>
<li>DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。</li>
<li>TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。</li>
<li>drop语句将表所占用的空间全释放掉。</li>
</ul>
<p>in 是把外表和内表作 hash 连接，而exists是对外表作loop循环，每次loop循环再对内表进行查询。 in 其实与等于相似，比如in(1,2) 就是 = 1 or = 2的一种简单写法，所以一般在元素少的时候使用in，如果多的话就用exists</p>
<h5 id="16-8-4-2：mysql的having用法"><a href="#16-8-4-2：mysql的having用法" class="headerlink" title="16-8-4-2：mysql的having用法"></a>16-8-4-2：mysql的having用法</h5><p>having字句可以让我们筛选成组后的各种数据，where字句在聚合前先筛选记录，也就是说作用在group by和having字句前。而 having子句在聚合后对组记录进行筛选。<br>where和having不可以同时使用</p>
<h5 id="16-8-4-3：mysql中-in-和-exists-区别"><a href="#16-8-4-3：mysql中-in-和-exists-区别" class="headerlink" title="16-8-4-3：mysql中 in 和 exists 区别"></a>16-8-4-3：mysql中 in 和 exists 区别</h5><ul>
<li>IN适合于外表大而内表小的情况</li>
<li>EXISTS适合于外表小而内表大的情况</li>
</ul>
<h5 id="16-8-4-4：WHERE子句和HAVING子句的执行速度"><a href="#16-8-4-4：WHERE子句和HAVING子句的执行速度" class="headerlink" title="16-8-4-4：WHERE子句和HAVING子句的执行速度"></a>16-8-4-4：WHERE子句和HAVING子句的执行速度</h5><p>WHERE 处理速度比 HAVING 处理速度高</p>
<h5 id="16-8-4-5：groupby和having的区别"><a href="#16-8-4-5：groupby和having的区别" class="headerlink" title="16-8-4-5：groupby和having的区别"></a>16-8-4-5：groupby和having的区别</h5><p>groupby是对数据分组，而having是对分组的结果进行筛选，两者相辅相成。</p>
<h5 id="16-8-4-6：UNION与UNION-ALL的区别？"><a href="#16-8-4-6：UNION与UNION-ALL的区别？" class="headerlink" title="16-8-4-6：UNION与UNION ALL的区别？"></a>16-8-4-6：UNION与UNION ALL的区别？</h5><p>union会去重，union all保留所有数据</p>
<h5 id="16-8-4-6：count-、count-1-、count-column-的区别"><a href="#16-8-4-6：count-、count-1-、count-column-的区别" class="headerlink" title="16-8-4-6：count(*)、count(1)、count(column)的区别"></a>16-8-4-6：count(*)、count(1)、count(column)的区别</h5><ol>
<li>count(*)查询所有行</li>
<li>count(1)查询所有行</li>
<li>count(column)统计列字段，会忽略null的情况</li>
</ol>
<p>执行效率上，count(*)=count(1)&gt;count(primary key)&gt;count(column)</p>
<h5 id="16-8-4-7：MySQL，左连接中on和where的区别"><a href="#16-8-4-7：MySQL，左连接中on和where的区别" class="headerlink" title="16-8-4-7：MySQL，左连接中on和where的区别"></a>16-8-4-7：MySQL，左连接中on和where的区别</h5><p>on是两个表之间的筛选条件，最先执行，where是对单表进行筛选。</p>
<h4 id="16-8-5：增删改查（CURD）-日志"><a href="#16-8-5：增删改查（CURD）-日志" class="headerlink" title="16-8-5：增删改查（CURD）+ 日志"></a>16-8-5：增删改查（CURD）+ 日志</h4><h5 id="16-8-5-1：一条sql执行过程"><a href="#16-8-5-1：一条sql执行过程" class="headerlink" title="16-8-5-1：一条sql执行过程"></a>16-8-5-1：一条sql执行过程</h5><ul>
<li>MySQL 主要分为 Server 层和引擎层，Server 层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用,redolog 只有 InnoDB 有。</li>
<li>引擎层是插件式的，目前主要包括，MyISAM,InnoDB,Memory 等。</li>
<li>SQL 等执行过程分为两类，一类对于查询等过程如下：权限校验—&gt;查询缓存（8.0以前）—&gt;分析器（词法分析，语法分析）—&gt;优化器（确定执行方案）—&gt;权限校验—&gt;执行器—&gt;引擎</li>
<li>对于更新等语句执行流程如下：分析器—-&gt;权限校验—-&gt;执行器—&gt;引擎—redo log prepare—》&gt;inlog—&gt;redo log commit</li>
</ul>
<h5 id="16-8-5-2：一条sql更新-删除-增加语句时怎么执行的"><a href="#16-8-5-2：一条sql更新-删除-增加语句时怎么执行的" class="headerlink" title="16-8-5-2：一条sql更新/删除/增加语句时怎么执行的"></a>16-8-5-2：一条sql更新/删除/增加语句时怎么执行的</h5><ul>
<li>先查询数据，如果有缓存，也是会用到缓存。</li>
<li>修改数据，然后调用引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。</li>
<li>执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为提交状态。</li>
<li>更新完成。</li>
</ul>
<h5 id="16-8-5-3：日志"><a href="#16-8-5-3：日志" class="headerlink" title="16-8-5-3：日志"></a>16-8-5-3：日志</h5><p>日志文件中记录着MySQL数据库运行期间发生的变化；也就是说用来记录MySQL数据库的客户端连接状况、SQL语句的执行情况和错误信息等。当数据库遭到意外的损坏时，可以通过日志查看文件出错的原因，并且可以通过日志文件进行数据恢复。</p>
<h5 id="16-8-5-4：什么是binlog"><a href="#16-8-5-4：什么是binlog" class="headerlink" title="16-8-5-4：什么是binlog"></a>16-8-5-4：什么是binlog</h5><p>binlog是MySQl server层维护的一种二进制日志，这个文件记录了MySQL所有的DML操作。通过binlog日志我们可以做数据恢复，增量备份，主主复制和主从复制等等</p>
<h5 id="16-8-5-5：binlog一般用来做什么"><a href="#16-8-5-5：binlog一般用来做什么" class="headerlink" title="16-8-5-5：binlog一般用来做什么"></a>16-8-5-5：binlog一般用来做什么</h5><ul>
<li>复制：MySQL Replication在Master端开启binlog，Master把它的二进制日志传递给slaves并回放来达到master-slave数据一致的目的</li>
<li>数据恢复：通过mysqlbinlog工具恢复数据</li>
<li>增量备份</li>
</ul>
<h5 id="16-8-5-6：MySQL的binlog有几种录入格式"><a href="#16-8-5-6：MySQL的binlog有几种录入格式" class="headerlink" title="16-8-5-6：MySQL的binlog有几种录入格式"></a>16-8-5-6：MySQL的binlog有几种录入格式</h5><ul>
<li>Statement：每一条会修改数据的sql都会记录在binlog中</li>
<li>MiXED：不记录sql语句上下文相关信息，仅保存哪条记录被修改</li>
<li>ROW：是以上两种level的混合使用，一般的语句修改使用statment格式保存binlog，如一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog,MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种.新版本的MySQL中row level模式也被做了优化，并不是所有的修改都会以row level来记录，像遇到表结构变更的时候就会以statement模式来记录。至于update或者delete等修改数据的语句，还是会记录所有行的变更。</li>
</ul>
<h5 id="16-8-5-7：redo-log"><a href="#16-8-5-7：redo-log" class="headerlink" title="16-8-5-7：redo log"></a>16-8-5-7：redo log</h5><p>当我们想要修改DB上某一行数据的时候，InnoDB是把数据从磁盘读取到内存的缓冲池上进行修改。这个时候数据在内存中被修改，与磁盘中相比就存在了差异，我们称这种有差异的数据为脏页。<br>InnoDB对脏页的处理不是每次生成脏页就将脏页刷新回磁盘，这样会产生海量的IO操作，严重影响InnoDB的处理性能。既然脏页与磁盘中的数据存在差异，那么如果在这期间DB出现故障就会造成数据的丢失。为了解决这个问题，redo log就应运而生了。</p>
<p>redo log就是存储了数据被修改后的值。当我们提交一个事务时，InnoDB会先去把要修改的数据写入日志，然后再去修改缓冲池里面的真正数据页。</p>
<h5 id="16-8-5-8：binlog和redo-log比较"><a href="#16-8-5-8：binlog和redo-log比较" class="headerlink" title="16-8-5-8：binlog和redo log比较"></a>16-8-5-8：binlog和redo log比较</h5><ul>
<li>redo log是属于innoDB层面，binlog属于MySQL Server层面的，这样在数据库用别的存储引擎时可以达到一致性的要求。</li>
<li>redo log是物理日志，记录该数据页更新的内容；binlog是逻辑日志，记录的是这个更新语句的原始逻辑</li>
<li>redo log是循环写，日志空间大小固定；binlog是追加写，是指一份写到一定大小的时候会更换下一个文件，不会覆盖。</li>
<li>binlog可以作为恢复数据使用，主从复制搭建，redo log作为异常宕机或者介质故障后的数据恢复使用。</li>
</ul>
<h5 id="16-8-5-9：我写其中的某一个log，失败了，那会怎么办？"><a href="#16-8-5-9：我写其中的某一个log，失败了，那会怎么办？" class="headerlink" title="16-8-5-9：我写其中的某一个log，失败了，那会怎么办？"></a>16-8-5-9：我写其中的某一个log，失败了，那会怎么办？</h5><p>因为redo log和bin log的两阶段提交，所以不会影响数据。</p>
<h5 id="16-8-5-10：两阶段提交意义"><a href="#16-8-5-10：两阶段提交意义" class="headerlink" title="16-8-5-10：两阶段提交意义"></a>16-8-5-10：两阶段提交意义</h5><ol>
<li>如果先写redo log，后写binlog，假如binlog失败，恢复后主库根据redo log重做，但是binlog不存在，复制到从库到出现主从不一致</li>
<li>如果先写binlog，后写redolog，假如redo log失败，恢复后从库根据主库的binlog回放数据，但是主库因为redo log不存在回滚事务。也会出现主从不一致。</li>
</ol>
<p>两阶段先在redo log提交变为prepare状态，修改后提交binlog，再把redo log改为commit状态。保证了数据的一致性。</p>
<h5 id="16-8-5-11：MySQL如何保证redo-log和binlog的数据是一致的"><a href="#16-8-5-11：MySQL如何保证redo-log和binlog的数据是一致的" class="headerlink" title="16-8-5-11：MySQL如何保证redo log和binlog的数据是一致的"></a>16-8-5-11：MySQL如何保证redo log和binlog的数据是一致的</h5><p>通过两阶段提交。</p>
<ol>
<li>如果数据库在记录此事务的binlog之前和过程中发生crash。数据库在恢复后认为此事务并没有成功提交，则会回滚此事务的操作。与此同时，因为在binlog中也没有此事务的记录，所以从库也不会有此事务的数据修改。</li>
<li>如果数据库在记录此事务的binlog之后发生crash。此时，即使是redo log中还没有记录此事务的commit 标签，数据库在恢复后也会认为此事务提交成功（因为在上述两阶段过程中，binlog写入成功就认为事务成功提交了）。它会扫描最后一个binlog文件，并提取其中的事务ID（xid），InnoDB会将那些状态为Prepare的事务（redo log没有记录commit 标签）的xid和Binlog中提取的xid做比较，如果在Binlog中存在，则提交该事务，否则回滚该事务。这也就是说，binlog中记录的事务，在恢复时都会被认为是已提交事务，会在redo log中重新写入commit标志，并完成此事务的重做（主库中有此事务的数据修改）。与此同时，因为在binlog中已经有了此事务的记录，所有从库也会有此事务的数据修改。</li>
</ol>
<h5 id="16-8-5-12：如果整个数据库的数据都被删除了，那我可以用redo-log的记录来恢复吗？"><a href="#16-8-5-12：如果整个数据库的数据都被删除了，那我可以用redo-log的记录来恢复吗？" class="headerlink" title="16-8-5-12：如果整个数据库的数据都被删除了，那我可以用redo log的记录来恢复吗？"></a>16-8-5-12：如果整个数据库的数据都被删除了，那我可以用redo log的记录来恢复吗？</h5><p>不能，因为功能的不同，redo log 存储的是物理数据的变更，如果我们内存的数据已经刷到了磁盘了，那redo log的数据就无效了。所以redo log不会存储着历史所有数据的变更，文件的内容会被覆盖的。</p>
<h5 id="16-8-5-13：MySQL查询字段区不区分大小写？"><a href="#16-8-5-13：MySQL查询字段区不区分大小写？" class="headerlink" title="16-8-5-13：MySQL查询字段区不区分大小写？"></a>16-8-5-13：MySQL查询字段区不区分大小写？</h5><p>MySQL查询是不区分大小写的</p>
<h5 id="16-8-5-14：如何解决需要区分英文大小写的场景"><a href="#16-8-5-14：如何解决需要区分英文大小写的场景" class="headerlink" title="16-8-5-14：如何解决需要区分英文大小写的场景"></a>16-8-5-14：如何解决需要区分英文大小写的场景</h5><ol>
<li>Mysql默认的字符检索策略：utf8_general_ci，表示不区分大小写；utf8_general_cs表示区分大小写，utf8_bin表示二进制比较，同样也区分大小写</li>
<li>直接修改sql语句，在要查询的字段前面加上binary关键字即可</li>
</ol>
<h4 id="16-8-6：常见约束"><a href="#16-8-6：常见约束" class="headerlink" title="16-8-6：常见约束"></a>16-8-6：常见约束</h4><h5 id="16-8-6-1：字段为什么要求定义为not-null"><a href="#16-8-6-1：字段为什么要求定义为not-null" class="headerlink" title="16-8-6-1：字段为什么要求定义为not null?"></a>16-8-6-1：字段为什么要求定义为not null?</h5><ol>
<li>索引性能不好 Mysql难以优化引用可空列查询，它会使索引、索引统计和值更加复杂。可空列需要更多的存储空间，还需要mysql内部进行特殊处理。可空列被索引后，每条记录都需要一个额外的字节，还能导致MYisam 中固定大小的索引变成可变大小的索引。如此看来，不指定not null并没有性能上的优势</li>
<li>查询会出现一些不可预料的结果，因为null列的存在，会出现很多出人意料的结果，从而浪费开发时间去排查Bug；</li>
</ol>
<h5 id="16-8-6-2：超键、候选键、主键、外键分别是什么？"><a href="#16-8-6-2：超键、候选键、主键、外键分别是什么？" class="headerlink" title="16-8-6-2：超键、候选键、主键、外键分别是什么？"></a>16-8-6-2：超键、候选键、主键、外键分别是什么？</h5><ul>
<li>超键(super key):在关系中能唯一标识元组的属性集称为关系模式的超键</li>
<li>候选键(candidate key):不含有多余属性的超键称为候选键</li>
<li>主键(primary key):用户选作元组标识的一个候选键程序主键</li>
<li>外键(foreign key)如果关系模式R1中的某属性集不是R1的主键，而是另一个关系R2的主键则该属性集是关系模式R1的外键。</li>
</ul>
<h5 id="16-8-6-3：为什么用自增列作为主键"><a href="#16-8-6-3：为什么用自增列作为主键" class="headerlink" title="16-8-6-3：为什么用自增列作为主键"></a>16-8-6-3：为什么用自增列作为主键</h5><ul>
<li>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页</li>
<li>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页的中间某个位置，此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</li>
</ul>
<h5 id="16-8-6-4：主键使用自增ID还是UUID"><a href="#16-8-6-4：主键使用自增ID还是UUID" class="headerlink" title="16-8-6-4：主键使用自增ID还是UUID?"></a>16-8-6-4：主键使用自增ID还是UUID?</h5><p>自增id</p>
<h5 id="16-8-6-5：使用自增id的缺点"><a href="#16-8-6-5：使用自增id的缺点" class="headerlink" title="16-8-6-5：使用自增id的缺点"></a>16-8-6-5：使用自增id的缺点</h5><ol>
<li>别人一旦爬取你的数据库,就可以根据数据库的自增id获取到你的业务增长信息，很容易分析出你的经营情况</li>
<li>对于高并发的负载，innodb在按主键进行插入的时候会造成明显的锁争用，主键的上界会成为争抢的热点，因为所有的插入都发生在这里，并发插入会导致间隙锁竞争</li>
<li>Auto_Increment锁机制会造成自增锁的抢夺,有一定的性能损失</li>
</ol>
<h5 id="16-8-6-6：数据库主键自增怎么获取主键值"><a href="#16-8-6-6：数据库主键自增怎么获取主键值" class="headerlink" title="16-8-6-6：数据库主键自增怎么获取主键值"></a>16-8-6-6：数据库主键自增怎么获取主键值</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">”insertUser”</span>  <span class="attr">useGeneratedKeys</span>=<span class="string">”true”</span> <span class="attr">keyProperty</span>=<span class="string">”userId”</span> &gt;</span></span><br><span class="line">insert into user( </span><br><span class="line">user_name, user_password, create_time) </span><br><span class="line">values(#&#123;userName&#125;, #&#123;userPassword&#125; , #&#123;createTime, jdbcType= TIMESTAMP&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="16-8-6-7：为什么要尽量设定一个主键"><a href="#16-8-6-7：为什么要尽量设定一个主键" class="headerlink" title="16-8-6-7：为什么要尽量设定一个主键?"></a>16-8-6-7：为什么要尽量设定一个主键?</h5><p>设定了主键之后,在后续的删改查的时候可能更加快速以及确保操作数据范围安全</p>
<h3 id="16-9：sql实战"><a href="#16-9：sql实战" class="headerlink" title="16-9：sql实战"></a>16-9：sql实战</h3><h4 id="16-9-1：去重重复数据"><a href="#16-9-1：去重重复数据" class="headerlink" title="16-9-1：去重重复数据"></a>16-9-1：去重重复数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> <span class="keyword">id</span> <span class="keyword">from</span> <span class="keyword">table</span></span><br></pre></td></tr></table></figure>

<h4 id="16-9-2：MySQL-如何高效率随机获取N条数据？"><a href="#16-9-2：MySQL-如何高效率随机获取N条数据？" class="headerlink" title="16-9-2：MySQL 如何高效率随机获取N条数据？"></a>16-9-2：MySQL 如何高效率随机获取N条数据？</h4><p>计算id最大值和最小值，从中取随机数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> mm_account </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> &gt;= ((<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(<span class="keyword">id</span>) <span class="keyword">FROM</span> mm_account)-(<span class="keyword">SELECT</span> <span class="keyword">MIN</span>(<span class="keyword">id</span>) <span class="keyword">FROM</span> mm_account)) * <span class="keyword">RAND</span>() + (<span class="keyword">SELECT</span> <span class="keyword">MIN</span>(<span class="keyword">id</span>) <span class="keyword">FROM</span> mm_account)</span><br><span class="line"><span class="keyword">limit</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<h3 id="16-10-事务"><a href="#16-10-事务" class="headerlink" title="16-10:事务"></a>16-10:事务</h3><h4 id="16-10-1：什么是事务"><a href="#16-10-1：什么是事务" class="headerlink" title="16-10-1：什么是事务"></a>16-10-1：什么是事务</h4><p>MySQL 事务主要用于处理操作量大，复杂度高的数据。用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。</p>
<h4 id="16-10-2：数据库事务特性"><a href="#16-10-2：数据库事务特性" class="headerlink" title="16-10-2：数据库事务特性"></a>16-10-2：数据库事务特性</h4><ol>
<li><p><strong>A (Atomicity) 原子性</strong><br>原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。<br>比如银行转账，从A账户转100元至B账户，分为两个步骤：1）从A账户取100元；2）存入100元至B账户。这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100元。</p>
</li>
<li><p><strong>C (Consistency) 一致性</strong><br>一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。<br>例如现有完整性约束a+b=10，如果一个事务改变了a，那么必须得改变b，使得事务结束后依然满足a+b=10，否则事务失败。</p>
</li>
<li><p><strong>I (Isolation) 隔离性</strong><br>所谓的隔离性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。<br>比如现有有个交易是从A账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元的。</p>
</li>
<li><p><strong>D (Durability) 持久性</strong><br>持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。</p>
</li>
</ol>
<h4 id="16-10-3：ACID靠什么保证的-底层原理"><a href="#16-10-3：ACID靠什么保证的-底层原理" class="headerlink" title="16-10-3：ACID靠什么保证的(底层原理)"></a>16-10-3：ACID靠什么保证的(底层原理)</h4><ol>
<li>原子性通过<code>undo log</code>日志实现。回滚日志会记录相应的日志信息，例如delete数据时，记录一条insert语句，回滚时插入。</li>
<li>通过原子性，持久性，隔离性保证了一致性。</li>
<li>通过<code>redo log</code>保证持久性，重做日志会记录处理后的数据。</li>
<li>通过锁保证了隔离性</li>
</ol>
<h5 id="16-10-3-1：什么是undo-log"><a href="#16-10-3-1：什么是undo-log" class="headerlink" title="16-10-3-1：什么是undo log"></a>16-10-3-1：什么是undo log</h5><p>undo log主要有两个作用：回滚和多版本控制(MVCC)</p>
<p>在数据修改的时候，不仅记录了redo log，还记录undo log，如果因为某些原因导致事务失败或回滚了，可以用undo log进行回滚</p>
<h4 id="16-10-4：数据库崩溃时事务的恢复机制"><a href="#16-10-4：数据库崩溃时事务的恢复机制" class="headerlink" title="16-10-4：数据库崩溃时事务的恢复机制"></a>16-10-4：数据库崩溃时事务的恢复机制</h4><p>undo log通过回滚保证事务的原子性，redo log通过恢复保证事务的持久性</p>
<h4 id="16-10-5：在并发环境下-事务会发生哪些问题"><a href="#16-10-5：在并发环境下-事务会发生哪些问题" class="headerlink" title="16-10-5：在并发环境下,事务会发生哪些问题?"></a>16-10-5：在并发环境下,事务会发生哪些问题?</h4><ol>
<li>脏读(dirty read)：如果第二个事务查询到第一个事务还未提交的更新数据，形成脏读。</li>
<li>幻读(phantom read)：一个事务执行两次查询，第二次查询比第一次多出或少一些数据，造成两次结果不一致。只是另一个事务在这两次查询中间插入或者删除了数据造成的。</li>
<li>不可重复读(unrepeated read)：一个事务两次读取同一行数据，结果得到不同状态结果，如中间正好另一个事务更新了该数据，两次结果相异，不可信任。</li>
</ol>
<h5 id="16-10-5-1：不可重复读和幻读的区别"><a href="#16-10-5-1：不可重复读和幻读的区别" class="headerlink" title="16-10-5-1：不可重复读和幻读的区别"></a>16-10-5-1：不可重复读和幻读的区别</h5><p>不可重复读是对同一条数据而言，而幻读是对多条数据的读取结果。</p>
<h5 id="16-10-5-2：如何解决幻读"><a href="#16-10-5-2：如何解决幻读" class="headerlink" title="16-10-5-2：如何解决幻读"></a>16-10-5-2：如何解决幻读</h5><p>使用序列化隔离等级，这个等级会开启表锁。</p>
<h4 id="16-10-6：如何解决事务并发问题"><a href="#16-10-6：如何解决事务并发问题" class="headerlink" title="16-10-6：如何解决事务并发问题"></a>16-10-6：如何解决事务并发问题</h4><p>通过加锁和MVCC机制</p>
<h4 id="16-10-7：四大隔离级别"><a href="#16-10-7：四大隔离级别" class="headerlink" title="16-10-7：四大隔离级别"></a>16-10-7：四大隔离级别</h4><ol>
<li><strong>读未提交：read uncommitted</strong><br>SELECT语句以非锁定方式被执行，所以有可能读到脏数据，隔离级别最低。（读不锁）</li>
<li><strong>读已提交：read committed</strong><br>只能读取到已经提交的数据。即解决了脏读，但未解决不可重复读。（读锁，等写完）</li>
<li><strong>可重复读：repeatable read</strong><br>在同一个事务内的查询都是事务开始时刻一致的，InnoDB的默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻读。(写锁，等读完)</li>
<li><strong>串行化：serializable</strong><br>完全的串行化读，所有SELECT语句都被隐式的转换成SELECT … LOCK IN SHARE MODE，即读取使用表级共享锁，读写相互都会阻塞。隔离级别最高。(以上3个均为行锁/记录锁，当前为表锁)</li>
</ol>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Read uncommitted</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">Read committed</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">Repeatable read</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">Serializable</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<h5 id="16-10-7-1：隔离级别的原理"><a href="#16-10-7-1：隔离级别的原理" class="headerlink" title="16-10-7-1：隔离级别的原理"></a>16-10-7-1：隔离级别的原理</h5><p>在数据库增删改查四种操作中，insert、delete和update都是会加排它锁(Exclusive Locks)的，而select只有显式声明才会加锁:</p>
<ul>
<li><p>select: 即最常用的查询，是不加任何锁的</p>
</li>
<li><p>select … lock in share mode: 会加共享锁(Shared Locks)</p>
</li>
<li><p>select … for update: 会加排它锁</p>
</li>
<li><p>读未提交中写虽然会加排他锁，但是读不加锁所以排他锁不会影响读取数据</p>
</li>
<li><p>读已提交中写加排他锁，读的时候不加写锁而是获取MVCC机制，获取最新快照。因为快照是每次select生成，如果多次select间有事务提交更改数据，就出现了不可重复读问题。</p>
</li>
<li><p>可重复读中写加排他锁，不同的是MVCC版本的生成时机：一次事务只在第一次select时生成快照。后续读取都是基于一个版本，实现了可重复读。</p>
</li>
<li><p>串行化会在读时加共享锁，写时加排他锁。</p>
</li>
</ul>
<h5 id="16-10-7-2：MySQL-中RC（读已提交）和RR（可重复读）隔离级别的区别"><a href="#16-10-7-2：MySQL-中RC（读已提交）和RR（可重复读）隔离级别的区别" class="headerlink" title="16-10-7-2：MySQL 中RC（读已提交）和RR（可重复读）隔离级别的区别"></a>16-10-7-2：MySQL 中RC（读已提交）和RR（可重复读）隔离级别的区别</h5><p>在于MVCC版本的加载时机，读已提交是每次select都会读取快照，可重复读是事务第一次读取生成快照，后续基于这个版本查询。</p>
<h4 id="16-10-8：如何手动处理事务"><a href="#16-10-8：如何手动处理事务" class="headerlink" title="16-10-8：如何手动处理事务"></a>16-10-8：如何手动处理事务</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span></span><br><span class="line">....</span><br><span class="line"><span class="keyword">commit</span></span><br></pre></td></tr></table></figure>

<p>语句内的一系列语句都处于一个事务周期内，否则每一个sql语句都是一个独立事务。</p>
<h3 id="16-11：引擎"><a href="#16-11：引擎" class="headerlink" title="16-11：引擎"></a>16-11：引擎</h3><h4 id="16-11-1：MySQL存储引擎MyISAM与InnoDB区别"><a href="#16-11-1：MySQL存储引擎MyISAM与InnoDB区别" class="headerlink" title="16-11-1：MySQL存储引擎MyISAM与InnoDB区别"></a>16-11-1：MySQL存储引擎MyISAM与InnoDB区别</h4><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">MyIASM</th>
<th align="center">InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td align="center">事务支持</td>
<td align="center">不支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">外键约束</td>
<td align="center">不支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">索引结构</td>
<td align="center">非聚集索引</td>
<td align="center">聚集索引</td>
</tr>
<tr>
<td align="center">保存行数</td>
<td align="center">保存</td>
<td align="center">不保存</td>
</tr>
<tr>
<td align="center">全文索引</td>
<td align="center">支持</td>
<td align="center">不支持</td>
</tr>
<tr>
<td align="center">粒度</td>
<td align="center">表锁</td>
<td align="center">行锁</td>
</tr>
<tr>
<td align="center">主键</td>
<td align="center">不必需</td>
<td align="center">必需</td>
</tr>
<tr>
<td align="center">存储文件</td>
<td align="center">frm</td>
<td align="center">frm,MYD,MYI</td>
</tr>
<tr>
<td align="center">存储空间</td>
<td align="center">可压缩</td>
<td align="center">不可压缩</td>
</tr>
</tbody></table>
<h4 id="16-11-2：InnoDB引擎的4大特性"><a href="#16-11-2：InnoDB引擎的4大特性" class="headerlink" title="16-11-2：InnoDB引擎的4大特性"></a>16-11-2：InnoDB引擎的4大特性</h4><ol>
<li>写缓冲：对于不在缓冲池的非唯一普通索引页，不会立即将磁盘页刷入缓冲池中，而是记录缓冲变更，等未来数据读取时，在将数据合并到缓冲池。写缓冲的目的是降低写操作的磁盘IO，提升数据库性能。</li>
<li>二次写：避免脏页刷盘时崩溃导致数据丢失的问题，将脏页先拷贝到内存中的doublewrite buffer中，再从两次写缓冲区分两次写入磁盘共享表空间。最后从两次写缓冲区写入实际表空间。保证了系统崩溃时脏页数据不会丢失。</li>
<li>自适应hash：会监控对表上二级索引的查找，如果发现某二级索引被频繁访问，此索引成为热数据，建立hash索引以提升查询速度，此建立是自动建立哈希索引，故称为自适应哈希索引。</li>
<li>预读：磁盘读写，并不是按需读取，而是按页读取，一次至少读一页数据。如果未来要读取的数据就在页中，就能够省去后续的磁盘IO，提高效率。将预读的页放入缓冲池中，从而提高读取效率</li>
</ol>
<h3 id="16-12：MySQl锁"><a href="#16-12：MySQl锁" class="headerlink" title="16-12：MySQl锁"></a>16-12：MySQl锁</h3><h4 id="16-12-1：MyISAM和InnoDB存储引擎使用的锁"><a href="#16-12-1：MyISAM和InnoDB存储引擎使用的锁" class="headerlink" title="16-12-1：MyISAM和InnoDB存储引擎使用的锁"></a>16-12-1：MyISAM和InnoDB存储引擎使用的锁</h4><p>MyISAM使用表锁，而InnoDB使用行锁+表锁。</p>
<h4 id="16-12-2：InnoDB存储引擎的锁的算法"><a href="#16-12-2：InnoDB存储引擎的锁的算法" class="headerlink" title="16-12-2：InnoDB存储引擎的锁的算法"></a>16-12-2：InnoDB存储引擎的锁的算法</h4><ul>
<li>Record Lock：单个行记录上的范围</li>
<li>Gap Lock：间隙锁，锁定一个范围，但不包含记录本身</li>
<li>Next-Key Lock：Gap Lock + Record Lock，锁定一个范围，并且锁定记录本身</li>
</ul>
<h4 id="16-12-3：MySQL锁的种类"><a href="#16-12-3：MySQL锁的种类" class="headerlink" title="16-12-3：MySQL锁的种类"></a>16-12-3：MySQL锁的种类</h4><ol>
<li>共享/排它锁(Shared and Exclusive Locks)</li>
<li>意向锁(Intention Locks)</li>
<li>记录锁(Record Locks)</li>
<li>间隙锁(Gap Locks)</li>
<li>临键锁(Next-key Locks)</li>
<li>插入意向锁(Insert Intention Locks)</li>
<li>自增锁(Auto-inc Locks)</li>
</ol>
<h5 id="16-12-3-1：共享-排它锁-Shared-and-Exclusive-Locks"><a href="#16-12-3-1：共享-排它锁-Shared-and-Exclusive-Locks" class="headerlink" title="16-12-3-1：共享/排它锁(Shared and Exclusive Locks)"></a>16-12-3-1：共享/排它锁(Shared and Exclusive Locks)</h5><p>即读锁和写锁，读锁时其他线程也可以读，但是不能写，写锁其他线程不能读也不能写。</p>
<h5 id="16-12-3-2：意向锁-Intention-Locks"><a href="#16-12-3-2：意向锁-Intention-Locks" class="headerlink" title="16-12-3-2：意向锁(Intention Locks)"></a>16-12-3-2：意向锁(Intention Locks)</h5><p>意向锁是一种不与行锁冲突的表级锁。</p>
<ul>
<li><p>意向共享锁（IS）：事务有意向对表中某些行加共享锁</p>
</li>
<li><p>意向排他锁（IX）：事务有意向对表中某些行加排他锁</p>
</li>
<li><p>InnoDB 支持多粒度锁，特定场景下，行级锁可以与表级锁共存。</p>
</li>
<li><p>意向锁之间互不排斥，但除了 IS（意向共享锁） 与 S（共享锁） 兼容外，意向锁会与 共享锁 / 排他锁 互斥</p>
</li>
<li><p>IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。</p>
</li>
<li><p>意向锁在保证并发性的前提下，实现了行锁和表锁共存且满足事务隔离性的要求。</p>
</li>
</ul>
<h5 id="16-12-3-4：记录锁-Record-Locks"><a href="#16-12-3-4：记录锁-Record-Locks" class="headerlink" title="16-12-3-4：记录锁(Record Locks)"></a>16-12-3-4：记录锁(Record Locks)</h5><p>为某行记录加锁，它封锁该行的索引记录，行锁，排他锁。存在于包括主键索引在内的唯一索引中，锁定单条索引记录。</p>
<h5 id="16-12-3-5：间隙锁-Gap-Locks"><a href="#16-12-3-5：间隙锁-Gap-Locks" class="headerlink" title="16-12-3-5：间隙锁(Gap Locks)"></a>16-12-3-5：间隙锁(Gap Locks)</h5><p>间隙锁基于非唯一索引，它锁定一段范围内的索引记录。间隙锁基于Next-Key Locking 算法，请务必牢记：使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的一条数据。</p>
<h5 id="16-12-3-6：临键锁-Next-key-Locks"><a href="#16-12-3-6：临键锁-Next-key-Locks" class="headerlink" title="16-12-3-6：临键锁(Next-key Locks)"></a>16-12-3-6：临键锁(Next-key Locks)</h5><p>Next-Key 可以理解为一种特殊的间隙锁，也可以理解为一种特殊的算法。通过临建锁可以解决幻读的问题。 每个数据行上的非唯一索引列上都会存在一把临键锁，当某个事务持有该数据行的临键锁时，会锁住一段左开右闭区间的数据。需要强调的一点是，InnoDB 中行级锁是基于索引实现的，临键锁只与非唯一索引列有关，在唯一索引列（包括主键列）上不存在临键锁。</p>
<h5 id="16-12-3-7：自增锁-Auto-inc-Locks"><a href="#16-12-3-7：自增锁-Auto-inc-Locks" class="headerlink" title="16-12-3-7：自增锁(Auto-inc Locks)"></a>16-12-3-7：自增锁(Auto-inc Locks)</h5><p>自增锁是一种特殊的表级别锁（table-level lock），专门针对事务插入AUTO_INCREMENT类型的列。最简单的情况，如果一个事务正在往表中插入记录，所有其他事务的插入必须等待，以便第一个事务插入的行，是连续的主键值。</p>
<h4 id="16-12-4：数据库死锁的预防与解除"><a href="#16-12-4：数据库死锁的预防与解除" class="headerlink" title="16-12-4：数据库死锁的预防与解除"></a>16-12-4：数据库死锁的预防与解除</h4><ol>
<li>尽量避免并发地执行涉及到修改数据的语句</li>
<li>要求每个事务一次就将所有要使用的数据全部加锁，否则就不予执行</li>
<li>预先规定一个封锁顺序，所有的事务都必须按这个顺序对数据执行封锁。如不同的过程在事务内部对对象的更新执行顺序应尽量保持一致。</li>
<li>每个事务的执行时间不可太长，在业务允许的情况下可以考虑将事务分割成为几个小事务来执行。【比如说把复杂的多表查询分散成多次单表查询】</li>
<li>数据存储空间离散法。数据存储空间离散法是指采取各种手段，将逻辑上在一个表中的数据分散到若干离散的空间上去，以便改善对表的访问性能。主要通过将大表按行或列分解为若干小表，或者按不同的用户群分解两种方法实现。这种方法类似分散“数据热点”，但是确实，如果数据不是太经常被访问，那么死锁就不会太经常发生。</li>
<li>类似1，比如有一个修改上百条记录的update语句，我们可以修改成每10条一个update语句，或者干脆就每条记录一个update语句。</li>
<li>将经常更新的数据库和查询数据库分开</li>
</ol>
<h4 id="16-12-5：多版本并发控制MVCC"><a href="#16-12-5：多版本并发控制MVCC" class="headerlink" title="16-12-5：多版本并发控制MVCC"></a>16-12-5：多版本并发控制MVCC</h4><p>多版本并发控制（MVCC） 是通过保存数据在某个时间点的快照来实现并发控制的。也就是说，不管事务执行多长时间，事务内部看到的数据是不受其它事务影响的，根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。</p>
<p>简单来说，多版本并发控制 的思想就是保存数据的历史版本，通过对数据行的多个版本管理来实现数据库的并发控制。这样我们就可以通过比较版本号决定数据是否显示出来，读取数据的时候不需要加锁也可以保证事务的隔离效果。</p>
<h4 id="16-12-6：哪些读操作是快照读？哪些操作又是当前读呢？"><a href="#16-12-6：哪些读操作是快照读？哪些操作又是当前读呢？" class="headerlink" title="16-12-6：哪些读操作是快照读？哪些操作又是当前读呢？"></a>16-12-6：哪些读操作是快照读？哪些操作又是当前读呢？</h4><p>读未提交和序列化的情况下select是当前读，读已提交和可重复读的情况下select是快照读。<br>而update，insert，remove都是当前读。</p>
<h4 id="16-12-7：为什么将-插入-更新-删除-操作，都归为当前读"><a href="#16-12-7：为什么将-插入-更新-删除-操作，都归为当前读" class="headerlink" title="16-12-7：为什么将 插入/更新/删除 操作，都归为当前读"></a>16-12-7：为什么将 插入/更新/删除 操作，都归为当前读</h4><p>因为对数据的更新必须基于数据的最新情况。</p>
<h3 id="16-13：索引"><a href="#16-13：索引" class="headerlink" title="16-13：索引"></a>16-13：索引</h3><h4 id="16-13-1：主键与索引的区别"><a href="#16-13-1：主键与索引的区别" class="headerlink" title="16-13-1：主键与索引的区别"></a>16-13-1：主键与索引的区别</h4><ol>
<li>主键一定是唯一性索引，唯一性索引并不一定就是主键。</li>
<li>一个表中可以有多个唯一性索引，但只能有一个主键。</li>
<li>主键列不允许空值，而唯一性索引列允许空值。</li>
<li>索引可以提高查询的速度。</li>
</ol>
<h4 id="16-13-2：索引的分类"><a href="#16-13-2：索引的分类" class="headerlink" title="16-13-2：索引的分类"></a>16-13-2：索引的分类</h4><ul>
<li>普通索引：无限制条件，最基本的索引</li>
<li>唯一索引：索引列的值必须唯一，但允许有控制，如果是联合索引，列值的组合必须唯一</li>
<li>主键索引：特殊的唯一索引，一个表只能有一个主键，不能为null，建表时会自动创建</li>
<li>联合索引：多个字段上创建的索引，遵循最左前缀匹配</li>
<li>全文索引：查找文本关键字</li>
</ul>
<h5 id="16-13-2-1：联合索引失效的条件"><a href="#16-13-2-1：联合索引失效的条件" class="headerlink" title="16-13-2-1：联合索引失效的条件"></a>16-13-2-1：联合索引失效的条件</h5><ul>
<li>不符合最左前缀匹配</li>
<li>不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描</li>
<li>存储引擎不能使用索引范围条件右边的列（&lt; ,&gt; between and）</li>
<li>mysql在使用不等于（!=或者&lt;&gt;）的时候无法使用索引会导致全表扫描</li>
<li>is not null也无法使用索引</li>
<li>like以通配符开头（’%abc…’）mysql索引失效会变成全表扫描的操作。</li>
<li>mysql中，如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)。要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引</li>
</ul>
<h5 id="16-13-2-2：单列索引和联合索引区别"><a href="#16-13-2-2：单列索引和联合索引区别" class="headerlink" title="16-13-2-2：单列索引和联合索引区别"></a>16-13-2-2：单列索引和联合索引区别</h5><p>多个单列索引在多条件查询时优化器会选择最优索引策略，可能只用一个索引，也可能将多个索引全用上(or)！<br>但多个单列索引底层会建立多个B+索引树，比较占用空间，也会浪费一定搜索效率，故如果只有多条件联合查询时最好建联合索引！<br>同时存在联合索引和单列索引时，会根据优化器的判断选择最优索引执行。</p>
<h4 id="16-13-3：主键索引和普通索引的工作原理"><a href="#16-13-3：主键索引和普通索引的工作原理" class="headerlink" title="16-13-3：主键索引和普通索引的工作原理"></a>16-13-3：主键索引和普通索引的工作原理</h4><p>主键索引也叫做聚簇索引，其余都称呼为非主键索引也叫二级索引。聚簇索引中的叶子节点存储了整行数据，而二级索引（非聚簇索引）存储了索引和主键id，查找是先在普通索引树上找到主键id，再通过id查询主键索引树。</p>
<p>在流程中从非主键索引树搜索回到主键索引树搜索的过程称为：回表。</p>
<h4 id="16-13-4：覆盖索引"><a href="#16-13-4：覆盖索引" class="headerlink" title="16-13-4：覆盖索引"></a>16-13-4：覆盖索引</h4><p>覆盖索引（covering index ，或称为索引覆盖）即从非主键索引中就能查到的记录，而不需要查询主键索引中的记录，避免了回表的产生减少了树的搜索次数，显著提升性能。</p>
<h4 id="16-13-5：mysql索引的结构"><a href="#16-13-5：mysql索引的结构" class="headerlink" title="16-13-5：mysql索引的结构"></a>16-13-5：mysql索引的结构</h4><p>b+树 – 多路平衡查找树</p>
<h5 id="16-13-5-1：B-树比B树的优势"><a href="#16-13-5-1：B-树比B树的优势" class="headerlink" title="16-13-5-1：B+树比B树的优势"></a>16-13-5-1：B+树比B树的优势</h5><ol>
<li>单一节点存储更多的元素，使得查询的IO次数更少；</li>
<li>所有查询都要查找到叶子节点，查询性能稳定；</li>
<li>所有叶子节点形成有序链表，便于范围查询。</li>
</ol>
<h5 id="16-13-5-2：B-树与红黑树比较"><a href="#16-13-5-2：B-树与红黑树比较" class="headerlink" title="16-13-5-2：B+树与红黑树比较"></a>16-13-5-2：B+树与红黑树比较</h5><p>在大规模数据存储的时候，红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁，进而导致效率低下的情况。为什么会出现这样的情况，我们知道要获取磁盘上数据，必须先通过磁盘移动臂移动到数据所在的柱面，然后找到指定盘面，接着旋转盘面找到数据所在的磁道，最后对数据进行读写。磁盘IO代价主要花费在查找所需的柱面上，树的深度过大会造成磁盘IO频繁读写。根据磁盘查找存取的次数往往由树的高度所决定，所以，只要我们通过某种较好的树结构减少树的结构尽量减少树的高度，B树可以有多个子女，从几十到上千，可以降低树的高度。</p>
<h5 id="16-13-5-3：B-树与hash索引比较"><a href="#16-13-5-3：B-树与hash索引比较" class="headerlink" title="16-13-5-3：B+树与hash索引比较"></a>16-13-5-3：B+树与hash索引比较</h5><p>Hash优势：</p>
<ol>
<li>等值查询。哈希索引具有绝对优势（前提是：没有大量重复键值，如果大量重复键值时，哈希索引的效率很低，因为存在所谓的哈希碰撞问题。）</li>
</ol>
<p>哈希索引不适用的场景：</p>
<ol>
<li>不支持范围查询</li>
<li>不支持索引完成排序</li>
<li>不支持联合索引的最左前缀匹配规则</li>
</ol>
<h4 id="16-13-6：聚簇索引与非聚簇索引概念"><a href="#16-13-6：聚簇索引与非聚簇索引概念" class="headerlink" title="16-13-6：聚簇索引与非聚簇索引概念"></a>16-13-6：聚簇索引与非聚簇索引概念</h4><ul>
<li>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据</li>
<li>非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因</li>
</ul>
<h5 id="16-13-6-1：聚簇索引的优缺点"><a href="#16-13-6-1：聚簇索引的优缺点" class="headerlink" title="16-13-6-1：聚簇索引的优缺点"></a>16-13-6-1：聚簇索引的优缺点</h5><p>聚簇索引的优点：</p>
<ol>
<li>当你需要取出一定范围内的数据时，用聚簇索引也比用非聚簇索引好</li>
<li>当通过聚簇索引查找目标数据时理论上比非聚簇索引要快，因为非聚簇索引定位到对应主键时还要多一次目标记录寻址,即多一次I/</li>
<li>使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</li>
</ol>
<p>聚簇索引的缺点：</p>
<ol>
<li>插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键。</li>
<li>更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。</li>
<li>二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。二级索引的叶节点存储的是主键值，而不是行指针（非聚簇索引存储的是指针或者说是地址），这是为了减少当出现行移动或数据页分裂时二级索引的维护工作，但会让二级索引占用更多的空间。</li>
<li>采用聚簇索引插入新值比采用非聚簇索引插入新值的速度要慢很多，因为插入要保证主键不能重复，判断主键不能重复，采用的方式在不同的索引下面会有很大的性能差距，聚簇索引遍历所有的叶子节点，非聚簇索引也判断所有的叶子节点，但是聚簇索引的叶子节点除了带有主键还有记录值，记录的大小往往比主键要大的多。这样就会导致聚簇索引在判定新记录携带的主键是否重复时进行昂贵的I/O代价。</li>
</ol>
<h4 id="16-13-7：为什么要用索引（优点）"><a href="#16-13-7：为什么要用索引（优点）" class="headerlink" title="16-13-7：为什么要用索引（优点）"></a>16-13-7：为什么要用索引（优点）</h4><ul>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
<li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li>
<li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li>
<li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</li>
<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能</li>
</ul>
<h4 id="16-13-8：索引这么多优点，为什么不对表中的每一个列创建一个索引呢？（缺点）"><a href="#16-13-8：索引这么多优点，为什么不对表中的每一个列创建一个索引呢？（缺点）" class="headerlink" title="16-13-8：索引这么多优点，为什么不对表中的每一个列创建一个索引呢？（缺点）"></a>16-13-8：索引这么多优点，为什么不对表中的每一个列创建一个索引呢？（缺点）</h4><p>优化器只会选择一个最佳索引使用。</p>
<ul>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li>
<li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li>
<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li>
</ul>
<h4 id="16-13-9：创建索引原则（使用场景）"><a href="#16-13-9：创建索引原则（使用场景）" class="headerlink" title="16-13-9：创建索引原则（使用场景）"></a>16-13-9：创建索引原则（使用场景）</h4><ol>
<li>最左前缀匹配原则</li>
<li>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</li>
<li>尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录</li>
<li>索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);</li>
<li>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可</li>
<li>Where 子句中经常使用的字段应该创建索引，分组字段或者排序字段应该创建索引，两个表的连接字段应该创建索引。</li>
<li>like 模糊查询中，右模糊查询（321%）会使用索引，而%321 和%321%会放弃索引而使用全局扫描</li>
</ol>
<h4 id="16-13-10：最左前缀原则内部原理"><a href="#16-13-10：最左前缀原则内部原理" class="headerlink" title="16-13-10：最左前缀原则内部原理"></a>16-13-10：最左前缀原则内部原理</h4><p>因为索引是有序的，所以会在第一列排序的基础上对第二列排序，第二列排序的基础上对第三列排序，导致了最左前缀原则</p>
<h4 id="16-13-11：创建索引的三种方式"><a href="#16-13-11：创建索引的三种方式" class="headerlink" title="16-13-11：创建索引的三种方式"></a>16-13-11：创建索引的三种方式</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> indexName <span class="keyword">on</span> tableName(fieldName);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_301(</span><br><span class="line">            tid <span class="built_in">int</span>,</span><br><span class="line">            tname <span class="built_in">varchar</span>(<span class="number">20</span>),</span><br><span class="line">            gender <span class="built_in">varchar</span>(<span class="number">1</span>),</span><br><span class="line">            <span class="keyword">index</span> [indexName] (fieldName)</span><br><span class="line">         );</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tableName <span class="keyword">add</span> <span class="keyword">unique</span> <span class="keyword">index</span> indexName (fieldName);</span><br></pre></td></tr></table></figure>

<h4 id="16-13-12：索引叶子节点为什么不直接保存的记录地址而要存主键键值"><a href="#16-13-12：索引叶子节点为什么不直接保存的记录地址而要存主键键值" class="headerlink" title="16-13-12：索引叶子节点为什么不直接保存的记录地址而要存主键键值"></a>16-13-12：索引叶子节点为什么不直接保存的记录地址而要存主键键值</h4><h3 id="16-14-优化方案"><a href="#16-14-优化方案" class="headerlink" title="16-14.优化方案"></a>16-14.优化方案</h3><h4 id="16-14-1：explain（优化）"><a href="#16-14-1：explain（优化）" class="headerlink" title="16-14-1：explain（优化）"></a>16-14-1：explain（优化）</h4><p>explain用于获取查询执行计划（即MySQL是如何执行一个查询的）</p>
<h4 id="16-14-2：explain主要包含的信息"><a href="#16-14-2：explain主要包含的信息" class="headerlink" title="16-14-2：explain主要包含的信息"></a>16-14-2：explain主要包含的信息</h4><table>
<thead>
<tr>
<th align="center">Column</th>
<th align="center">JSON Name</th>
<th align="center">Meaning</th>
</tr>
</thead>
<tbody><tr>
<td align="center">id</td>
<td align="center">select_id</td>
<td align="center">The SELECT identifier - 优先级</td>
</tr>
<tr>
<td align="center">select_type</td>
<td align="center">None</td>
<td align="center">The SELECT type - 查询类型</td>
</tr>
<tr>
<td align="center">table</td>
<td align="center">table_name</td>
<td align="center">The table for the output row - 涉及的表或衍生表</td>
</tr>
<tr>
<td align="center">partitions</td>
<td align="center">partitions</td>
<td align="center">The matching partitions - 判断查询是否高效的依据</td>
</tr>
<tr>
<td align="center">type</td>
<td align="center">access_type</td>
<td align="center">The join type - 连接可能</td>
</tr>
<tr>
<td align="center">possible_keys</td>
<td align="center">possible_keys</td>
<td align="center">The possible indexes to choose - 能够使用的索引</td>
</tr>
<tr>
<td align="center">key</td>
<td align="center">key</td>
<td align="center">The index actually chosen - 实际使用的索引</td>
</tr>
<tr>
<td align="center">key_len</td>
<td align="center">key_length</td>
<td align="center">The length of the chosen key - 索引的字节数</td>
</tr>
<tr>
<td align="center">ref</td>
<td align="center">ref</td>
<td align="center">The columns compared to the index - 哪个字段/常数和索引一起使用</td>
</tr>
<tr>
<td align="center">rows</td>
<td align="center">rows</td>
<td align="center">Estimate of rows to be examined - 统计信息</td>
</tr>
<tr>
<td align="center">filtered</td>
<td align="center">filtered</td>
<td align="center">Percentage of rows filtered by table condition - 过滤的百分比</td>
</tr>
<tr>
<td align="center">Extra</td>
<td align="center">None</td>
<td align="center">Additional information - 额外信息</td>
</tr>
</tbody></table>
<h5 id="16-14-2-1：id"><a href="#16-14-2-1：id" class="headerlink" title="16-14-2-1：id"></a>16-14-2-1：id</h5><p>sql语句执行优先级，id越大越先执行，同一等级从上到下执行</p>
<h5 id="16-14-2-2：select-type"><a href="#16-14-2-2：select-type" class="headerlink" title="16-14-2-2：select_type"></a>16-14-2-2：select_type</h5><ol>
<li>simple：简单查询（不包含子查询和union查询）</li>
<li>primary：复杂查询的最外围查询</li>
<li>subquery：包含在select中的子查询（不在from字句中）</li>
<li>derived：包含在from子句中的子查询，结果会存放在临时表中</li>
<li>union：union中的第二个和随后的select</li>
</ol>
<h5 id="16-14-2-3：type"><a href="#16-14-2-3：type" class="headerlink" title="16-14-2-3：type"></a>16-14-2-3：type</h5><ol>
<li>null：不用访问表或者索引，直接就能得到结果（例如索引列中取得最大值）</li>
<li>system：查询的表只有一行的情况，system是const类型的特例</li>
<li>const：针对主键或唯一索引的等值查询扫描，最多只返回一行数据。const查询速度非常快, 因为它仅仅读取一次即可。</li>
<li>eq_ref：此类型通常出现在多表的join查询，表示对于前表的每一个结果，都只能匹配到后表的一行结果，并且查询的比较操作通常是=，查询效率较高。</li>
<li>ref：相比eq_ref，不使用唯一索引，而是使用普通索引或者唯一性索引的最左前缀，可能会找到多个符合条件的行。</li>
<li>range：扫描部分索引(范围扫描)，对索引的扫描开始于某一点，返回匹配值域的行，常见于between、&lt;、&gt;、in等查询</li>
<li>index：表示全索引扫描(full index scan), 和ALL类型类似, 只不过ALL类型是全表扫描, 而index类型则仅仅扫描所有的索引, 而不扫描数据.</li>
<li>all：全表扫描</li>
</ol>
<h4 id="16-14-3：为什么要优化"><a href="#16-14-3：为什么要优化" class="headerlink" title="16-14-3：为什么要优化"></a>16-14-3：为什么要优化</h4><ul>
<li>查询性能低</li>
<li>执行时间过长</li>
<li>等待时间过长</li>
<li>SQL写的太差(尤其体现在多表查询上)</li>
<li>索引失效</li>
<li>服务器参数(缓存,线程数)设置不合理</li>
<li>项目需求不合理</li>
<li>…</li>
</ul>
<h5 id="16-14-3-1：数据库的优化（如果mysql数据过多，如何进行处理）"><a href="#16-14-3-1：数据库的优化（如果mysql数据过多，如何进行处理）" class="headerlink" title="16-14-3-1：数据库的优化（如果mysql数据过多，如何进行处理）"></a>16-14-3-1：数据库的优化（如果mysql数据过多，如何进行处理）</h5><ol>
<li>根据三大范式设计数据库</li>
<li>优化sql和索引</li>
<li>缓存</li>
<li>主从复制/主主复制</li>
<li>分区表</li>
<li>垂直拆分</li>
<li>水平拆分</li>
</ol>
<h5 id="16-14-3-2：创建时优化"><a href="#16-14-3-2：创建时优化" class="headerlink" title="16-14-3-2：创建时优化"></a>16-14-3-2：创建时优化</h5><ol>
<li>尽可能使用not null</li>
<li>使用紧凑的数据类型</li>
<li>为每张表设置id</li>
<li>选择合适的引擎</li>
<li>根据三大范式设计</li>
</ol>
<h5 id="16-14-3-3：索引优化"><a href="#16-14-3-3：索引优化" class="headerlink" title="16-14-3-3：索引优化"></a>16-14-3-3：索引优化</h5><ol>
<li>优化索引字段</li>
<li>组合索引字段顺序</li>
<li>索引合并</li>
</ol>
<h5 id="16-14-3-4：查询优化"><a href="#16-14-3-4：查询优化" class="headerlink" title="16-14-3-4：查询优化"></a>16-14-3-4：查询优化</h5><ol>
<li>避免select *</li>
<li>只需要一行数据时使用limit 1</li>
<li>join时使用相同类型的列并建立索引</li>
<li>不要order by rand()</li>
<li>使用预编译</li>
<li>拆分大的delete和insert语句</li>
</ol>
<h5 id="16-14-3-5：一条SQL语句执行得很慢的原因有哪些"><a href="#16-14-3-5：一条SQL语句执行得很慢的原因有哪些" class="headerlink" title="16-14-3-5：一条SQL语句执行得很慢的原因有哪些"></a>16-14-3-5：一条SQL语句执行得很慢的原因有哪些</h5><ul>
<li>硬件问题</li>
<li>没有索引或者索引失效</li>
<li>数据过多</li>
<li>服务器各个参数限制</li>
</ul>
<h5 id="16-14-3-6：分页查询优化"><a href="#16-14-3-6：分页查询优化" class="headerlink" title="16-14-3-6：分页查询优化"></a>16-14-3-6：分页查询优化</h5><p>分页查询中随着n逐渐变大，就需要扫描更多的数据来定位，耗费大量的IO成本和时间成本</p>
<ol>
<li>limit offset,size（含子查询）</li>
<li>id &lt; max and limit size</li>
<li>覆盖索引 + join</li>
<li>id &lt; max and limit size（不含子查询）</li>
<li>min&lt;=id&lt;=max</li>
</ol>
<h4 id="16-14-4：为什么数据库会选错了索引"><a href="#16-14-4：为什么数据库会选错了索引" class="headerlink" title="16-14-4：为什么数据库会选错了索引"></a>16-14-4：为什么数据库会选错了索引</h4><p>在一些不断删除历史数据和新增数据的场景下，MySQL会出现选错索引的情况</p>
<p>MySQL在采样统计的时候，会默认选择N个数据页，然后统计这个数据页上的不同值的个数，然后取平均值，再乘以这个索引的总数据页数量，就得到了索引的基数，这个基数是个估计值，不准确。</p>
<p>频繁进行插入和删除的表中，统计信息可能不准确，使得优化器选错索引。</p>
<p>解决方案：</p>
<ol>
<li>可以使用analyze table t的方法来对表的索引信息做重新统计，提高索引统计信息的准确性，该过程没有修改表的数据，只是对表加了MDL读锁。</li>
<li>optimize table t，该方法会重建表并且重新统计表的索引信息。</li>
</ol>
<p>如果还是不能解决问题，那么可以考虑采用下面3种方法：</p>
<ol>
<li>使用force index的方法来强制SQL使用某个索引来执行。</li>
<li>考虑修改语句，引导MySQL使用我们期望的索引。</li>
<li>删除指定索引，重建其他更合适的索引来进行替代</li>
</ol>
<h3 id="16-16：主从复制"><a href="#16-16：主从复制" class="headerlink" title="16-16：主从复制"></a>16-16：主从复制</h3><h4 id="16-16-1：什么是主从复制"><a href="#16-16-1：什么是主从复制" class="headerlink" title="16-16-1：什么是主从复制"></a>16-16-1：什么是主从复制</h4><p>主从复制是指一台服务器充当主数据库服务器，另一台或多台服务器充当从数据库服务器，主服务器中的数据自动复制到从服务器之中。对于多级复制，数据库服务器即可充当主机，也可充当从机。MySQL主从复制的基础是主服务器对数据库修改记录二进制日志，从服务器通过主服务器的二进制日志自动执行更新。</p>
<h4 id="16-16-2：主从复制的作用（好处，或者说为什么要做主从）"><a href="#16-16-2：主从复制的作用（好处，或者说为什么要做主从）" class="headerlink" title="16-16-2：主从复制的作用（好处，或者说为什么要做主从）"></a>16-16-2：主从复制的作用（好处，或者说为什么要做主从）</h4><ul>
<li>高可用</li>
<li>负载均衡</li>
<li>读写分离</li>
</ul>
<h4 id="16-16-3：主从复制的原理（重中之重，面试必问）"><a href="#16-16-3：主从复制的原理（重中之重，面试必问）" class="headerlink" title="16-16-3：主从复制的原理（重中之重，面试必问）"></a>16-16-3：主从复制的原理（重中之重，面试必问）</h4><ol>
<li>主库使用binlog记录数据变动</li>
<li>从库复制binlog并读取到relay log中</li>
<li>从库根据relay log逐一执行</li>
</ol>
<p>binlog有三种方式记录：</p>
<ol>
<li>基于sql语句的记录（statement）：记录执行的sql语句</li>
<li>基于行的复制（row）：记录行修改的数据</li>
<li>混合模式复制（mixed）：一般情况使用statement模式，对于statement无法复制的情况使用row复制</li>
</ol>
<h4 id="16-16-4：主从复制的几种方式"><a href="#16-16-4：主从复制的几种方式" class="headerlink" title="16-16-4：主从复制的几种方式"></a>16-16-4：主从复制的几种方式</h4><ol>
<li>异步模式：主节点不会主动推送数据到从节点，库在执行完客户端提交的事务后会立即将结果返给给客户端，并不关心从库是否已经接收并处理。</li>
<li>主库在执行完客户端提交的事务后不是立刻返回给客户端，而是等待至少一个从库接收到并写到 relay log 中才返回成功信息给客户端（只能保证主库的 Binlog 至少传输到了一个从节点上），否则需要等待直到超时时间然后切换成异步模式再提交。</li>
<li>指当主库执行完一个事务，然后所有的从库都复制了该事务并成功执行完才返回成功信息给客户端。因为需要等待所有从库执行完该事务才能返回成功信息，所以全同步复制的性能必然会收到严重的影响。</li>
</ol>
<p>GTID：以前的主从复制通过偏移量读取binlog，而GITD模式会生成全局事务id，从库复制后比较事务是否执行。</p>
<h3 id="16-17：数据库池与JDBC"><a href="#16-17：数据库池与JDBC" class="headerlink" title="16-17：数据库池与JDBC"></a>16-17：数据库池与JDBC</h3><h4 id="16-17-1：什么是数据库连接池？"><a href="#16-17-1：什么是数据库连接池？" class="headerlink" title="16-17-1：什么是数据库连接池？"></a>16-17-1：什么是数据库连接池？</h4><p>数据库连接池（Connection pooling）是程序启动时建立足够的数据库连接，并将这些连接组成一个连接池，由程序动态地对池中的连接进行申请，使用，释放。</p>
<h4 id="16-17-2：数据库连接池种类"><a href="#16-17-2：数据库连接池种类" class="headerlink" title="16-17-2：数据库连接池种类"></a>16-17-2：数据库连接池种类</h4><ul>
<li>DBCP （Database Connection Pool）</li>
<li>C3P0</li>
<li>Proxool</li>
<li>BoneCP</li>
<li>Druid</li>
</ul>
<h4 id="16-17-3：传统的连接机制与数据库连接池的运行机制区别"><a href="#16-17-3：传统的连接机制与数据库连接池的运行机制区别" class="headerlink" title="16-17-3：传统的连接机制与数据库连接池的运行机制区别"></a>16-17-3：传统的连接机制与数据库连接池的运行机制区别</h4><p>传统连接:</p>
<ol>
<li>装载数据库驱动程序</li>
<li>通过JDBC建立数据库连接</li>
<li>访问数据库，执行SQL语句</li>
<li>断开数据库连接。</li>
</ol>
<p>使用了数据库连接池的机制：</p>
<ol>
<li>程序初始化时创建连接池</li>
<li>使用时向连接池申请可用连接</li>
<li>使用完毕，将连接返还给连接池</li>
<li>程序退出时，断开所有连接，并释放资源</li>
</ol>
<h4 id="16-17-4：说说数据库连接池工作原理"><a href="#16-17-4：说说数据库连接池工作原理" class="headerlink" title="16-17-4：说说数据库连接池工作原理"></a>16-17-4：说说数据库连接池工作原理</h4><ol>
<li><p><strong>连接池的建立</strong>:一般在系统初始化时，连接池会根据系统配置建立，并在池中创建了几个连接对象，以便使用时能从连接池中获取。连接池中的连接不能随意创建和关闭，这样避免了连接随意建立和关闭造成的系统开销。Java中提供了很多容器类可以方便的构建连接池，例如Vector、Stack等。</p>
</li>
<li><p><strong>连接池的管理</strong>:连接池管理策略是连接池机制的核心，连接池内连接的分配和释放对系统的性能有很大的影响。其管理策略是：</p>
<ul>
<li>当客户请求数据库连接时，首先查看连接池中是否有空闲连接，如果存在空闲连接，则将连接分配给客户使用；如果没有空闲连接，则查看当前所开的连接数是否已经达到最大连接数，如果没达到就重新创建一个连接给请求的客户；如果达到就按设定的最大等待时间进行等待，如果超出最大等待时间，则抛出异常给客户。</li>
<li>当客户释放数据库连接时，先判断该连接的引用次数是否超过了规定值，如果超过就从连接池中删除该连接，否则保留为其他客户服务。<br>该策略保证了数据库连接的有效复用，避免频繁的建立、释放连接所带来的系统资源开销。</li>
</ul>
</li>
<li><p><strong>连接池的关闭</strong>。当应用程序退出时，关闭连接池中所有的连接，释放连接池相关的资源，该过程正好与创建相反。</p>
</li>
</ol>
<h3 id="16-18：分库分表"><a href="#16-18：分库分表" class="headerlink" title="16-18：分库分表"></a>16-18：分库分表</h3><h4 id="16-18-1：为什么要分库分表？"><a href="#16-18-1：为什么要分库分表？" class="headerlink" title="16-18-1：为什么要分库分表？"></a>16-18-1：为什么要分库分表？</h4><p>目的就是为了缓解数据库的压力，最大限度提高数据操作的效率。</p>
<h4 id="16-18-2：数据分表"><a href="#16-18-2：数据分表" class="headerlink" title="16-18-2：数据分表"></a>16-18-2：数据分表</h4><ul>
<li>垂直分表：因为字段太多导致数据太多，可以切分字段到不同的表中</li>
<li>水平分表：针对数据量巨大的单张表（比如订单表），按照某种规则（RANGE,HASH取模等），切分到多张表里面去。但是这些表还是在同一个库中，所以库级别的数据库操作还是有IO瓶颈。</li>
</ul>
<h4 id="16-18-3：数据分库"><a href="#16-18-3：数据分库" class="headerlink" title="16-18-3：数据分库"></a>16-18-3：数据分库</h4><ul>
<li>垂直分库：将一个系统中的不同业务拆分，放到不同的库，不同的服务器中</li>
<li>水平分库：将单张表的数据切分到多个服务器上去，每个服务器具有相应的库与表，只是表中数据集合不同。 水平分库分表能够有效的缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源等的瓶颈。</li>
</ul>
<h4 id="16-18-4：分库分表带来的问题"><a href="#16-18-4：分库分表带来的问题" class="headerlink" title="16-18-4：分库分表带来的问题"></a>16-18-4：分库分表带来的问题</h4><ol>
<li>分布式事务</li>
<li>多库结果集合并</li>
<li>跨库join</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">失铭</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://shiming.best/blog/a7ef9c4d/">https://shiming.best/blog/a7ef9c4d/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://shiming.best" target="_blank">失铭的日记</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="https://image.shiming.online/guidao/pic-88.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/blog/a2a7cca8/"><img class="prev-cover" data-lazy-src="https://image.shiming.online/guidao/pic-88.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">HashMap源码解析</div></div></a></div><div class="next-post pull-right"><a href="/blog/81f10c79/"><img class="next-cover" data-lazy-src="https://image.shiming.online/guidao/pic-88.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">常量池</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/blog/1491d7b8/" title="Java208道面试题"><img class="cover" data-lazy-src="https://image.shiming.online/guidao/pic-88.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-18</div><div class="title">Java208道面试题</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" data-lazy-src="https://image.shiming.online/background/info.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">失铭</div><div class="author-info__description">El Psy Congroo</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">101</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">51</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">36</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/XShiMing"><i class="fab fa-github"></i><span>Follow Me</span></a></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎阅读我的笔记。笔记中可能存在遗漏或简单的错误，请见谅。</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#toString-%E5%92%8C-String-valueOf-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.</span> <span class="toc-text">toString 和 String.valueOf()的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.</span> <span class="toc-text">重载和重写的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Comparator%E4%B8%8EComparable%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">Comparator与Comparable有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#int%E5%92%8CInteger-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8C%E8%BF%98%E6%9C%89Integer%E7%BC%93%E5%AD%98%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.</span> <span class="toc-text">int和Integer 有什么区别，还有Integer缓存的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9F%E5%BA%95%E5%B1%82%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E5%88%B0%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%EF%BC%9F%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E6%98%AF%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">数组的特点？底层如何定位到数组中的元素？数组的内存空间是连续的吗？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring"><span class="toc-number"></span> <span class="toc-text">Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E5%92%8CSpringBoot%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.</span> <span class="toc-text">Spring和SpringBoot的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringBoot%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">SpringBoot的自动装配原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%AF%94%E8%BE%83%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">对象比较有几种方式？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL"><span class="toc-number"></span> <span class="toc-text">MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E5%BC%95%E6%93%8E%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.</span> <span class="toc-text">两种引擎的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis"><span class="toc-number"></span> <span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">为什么需要分布式锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redlock%E7%AE%97%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">Redlock算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-number"></span> <span class="toc-text">计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">1.</span> <span class="toc-text">TCP四次挥手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%AD%89%E5%BE%852MSL"><span class="toc-number">2.</span> <span class="toc-text">为什么需要等待2MSL</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%9B%E5%AE%A2%E9%9D%A2%E7%BB%8F"><span class="toc-number"></span> <span class="toc-text">牛客面经</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1%EF%BC%9AJava%E7%89%B9%E6%80%A7"><span class="toc-number"></span> <span class="toc-text">1：Java特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%EF%BC%9AJava%E7%89%B9%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">1-1：Java特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2%EF%BC%9AJVM-JRE-JDK-JIT"><span class="toc-number">2.</span> <span class="toc-text">1-2：JVM\JRE\JDK\JIT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3%EF%BC%9A%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="toc-number">3.</span> <span class="toc-text">1-3：变量的初始化顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4%EF%BC%9A%E2%BE%AF%E5%90%91%E8%BF%87%E7%A8%8B%E6%80%A7%E8%83%BD%E2%BD%90%E2%BE%AF%E5%90%91%E5%AF%B9%E8%B1%A1%E2%BE%BC"><span class="toc-number">4.</span> <span class="toc-text">1-4：⾯向过程性能⽐⾯向对象⾼</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5%EF%BC%9A%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E8%B1%A1%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-number">5.</span> <span class="toc-text">1-5：持久化对象三种状态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%EF%BC%9AJava%E5%9F%BA%E7%A1%80-%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1-OOP"><span class="toc-number"></span> <span class="toc-text">2：Java基础-面对对象(OOP)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-number">1.</span> <span class="toc-text">2-1：面向对象的原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%EF%BC%9AJava%E7%B1%BB%E4%BB%A5%E5%8F%8A%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98"><span class="toc-number">2.</span> <span class="toc-text">2-2：Java类以及类的成员</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1%EF%BC%9A%E5%B1%9E%E6%80%A7"><span class="toc-number">2.1.</span> <span class="toc-text">2-2-1：属性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-1-1%EF%BC%9A%E5%B1%9E%E6%80%A7%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E7%9B%B8%E5%90%8C%E7%82%B9%E3%80%81%E4%B8%8D%E5%90%8C%E7%82%B9"><span class="toc-number">2.1.1.</span> <span class="toc-text">2-2-1-1：属性与局部变量的相同点、不同点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2%EF%BC%9AJava%E5%9F%BA%E7%A1%80-%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">2.2.</span> <span class="toc-text">2-2-2：Java基础-构造器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-1%EF%BC%9A%E2%BC%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E2%BD%85%E6%B3%95%E7%9A%84%E4%BD%9C%E2%BD%A4%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.3.</span> <span class="toc-text">2-2-2-1：⼀个类的构造⽅法的作⽤是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-2%EF%BC%9A%E6%9E%84%E9%80%A0%E2%BD%85%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">2.4.</span> <span class="toc-text">2-2-2-2：构造⽅法有哪些特性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-3%EF%BC%9A%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E8%A2%AB%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD"><span class="toc-number">2.5.</span> <span class="toc-text">2-2-2-3：构造方法可不可以被重写和重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-4%EF%BC%9A%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%83%BD%E7%94%A8private%E4%BF%AE%E9%A5%B0%E5%90%97"><span class="toc-number">2.6.</span> <span class="toc-text">2-2-2-4：构造函数能用private修饰吗</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%EF%BC%9A%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">3.</span> <span class="toc-text">2-3：面对对象三大特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1%EF%BC%9A%E5%B0%81%E8%A3%85"><span class="toc-number">3.1.</span> <span class="toc-text">2-3-1：封装</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-1-1%EF%BC%9A%E5%B0%81%E8%A3%85%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.1.1.</span> <span class="toc-text">2-3-1-1：封装的应用场景</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2%EF%BC%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">3.2.</span> <span class="toc-text">2-3-2：继承</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-2-1%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%A7%E6%89%BF"><span class="toc-number">3.2.1.</span> <span class="toc-text">2-3-2-1：什么是继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-2-2%EF%BC%9A%E7%BB%A7%E6%89%BF%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.2.2.</span> <span class="toc-text">2-3-2-2：继承的应用场景</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3%EF%BC%9A%E5%A4%9A%E6%80%81"><span class="toc-number">3.3.</span> <span class="toc-text">2-3-3：多态</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-3-1%EF%BC%9A%E5%A4%9A%E6%80%81%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6%EF%BC%88%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E3%80%81%E6%9C%BA%E5%88%B6%EF%BC%89"><span class="toc-number">3.3.1.</span> <span class="toc-text">2-3-3-1：多态的必要条件（实现方式、机制）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-3-2%EF%BC%9A%E5%A4%9A%E6%80%81%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">3.3.2.</span> <span class="toc-text">2-3-3-2：多态的好处</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-3-3%EF%BC%9A%E5%A4%9A%E6%80%81%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">3.3.3.</span> <span class="toc-text">2-3-3-3：多态的例子</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4%EF%BC%9A%E6%8A%BD%E8%B1%A1"><span class="toc-number">4.</span> <span class="toc-text">2-4：抽象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1%EF%BC%9AJava-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%8F%AF%E4%BB%A5%E6%9C%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%9F%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">4.1.</span> <span class="toc-text">2-4-1：Java 抽象类可以有构造函数吗？作用是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2%EF%BC%9AJava-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E5%90%97%EF%BC%9F-%E5%AE%83%E4%BB%AC%E9%9C%80%E8%A6%81%E5%AE%9E%E7%8E%B0%E6%89%80%E6%9C%89%E7%9A%84%E6%96%B9%E6%B3%95%E5%90%97"><span class="toc-number">4.2.</span> <span class="toc-text">2-4-2：Java 抽象类可以实现接口吗？ 它们需要实现所有的方法吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3%EF%BC%9AJava-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%8F%AF%E4%BB%A5%E6%98%AF-final-%E7%9A%84%E5%90%97"><span class="toc-number">4.3.</span> <span class="toc-text">2-4-3：Java 抽象类可以是 final 的吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-4%EF%BC%9AJava-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%8F%AF%E4%BB%A5%E6%9C%89-static-%E6%96%B9%E6%B3%95%E5%90%97"><span class="toc-number">4.4.</span> <span class="toc-text">2-4-4：Java 抽象类可以有 static 方法吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-5%EF%BC%9A%E5%8F%AF%E4%BB%A5%E5%88%9B%E5%BB%BA%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%90%97%EF%BC%88new-%E7%B1%BB%EF%BC%89"><span class="toc-number">4.5.</span> <span class="toc-text">2-4-5：可以创建抽象类的实例吗（new 类）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-6%EF%BC%9A%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%BF%85%E9%A1%BB%E6%9C%89%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%90%97"><span class="toc-number">4.6.</span> <span class="toc-text">2-4-6：抽象类必须有抽象方法吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-7%EF%BC%9A%E4%BD%95%E6%97%B6%E9%80%89%E7%94%A8%E6%8A%BD%E8%B1%A1%E7%B1%BB%E8%80%8C%E4%B8%8D%E6%98%AF%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.7.</span> <span class="toc-text">2-4-7：何时选用抽象类而不是接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-8%EF%BC%9AJava%E4%B8%AD%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">4.8.</span> <span class="toc-text">2-4-8：Java中的抽象方法是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-9%EF%BC%9AJava%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%AD%E5%8F%AF%E4%BB%A5%E5%8C%85%E5%90%ABmain%E6%96%B9%E6%B3%95%E5%90%97"><span class="toc-number">4.9.</span> <span class="toc-text">2-4-9：Java抽象类中可以包含main方法吗</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5%EF%BC%9A%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E5%8C%BA%E5%88%AB"><span class="toc-number">5.</span> <span class="toc-text">2-5：面对对象区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-1%EF%BC%9A%E6%8E%A5%E2%BC%9D%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.1.</span> <span class="toc-text">2-5-1：接⼝和抽象类的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-2%EF%BC%9A%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%8C%BA%E5%88%AB"><span class="toc-number">5.2.</span> <span class="toc-text">2-5-2：继承和实现区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-3%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E8%BF%98%E6%9C%89%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">5.3.</span> <span class="toc-text">2-5-3：为什么要设计接口、抽象类还有实现类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-Java%E5%9F%BA%E7%A1%80-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">6.</span> <span class="toc-text">2-6.Java基础-关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-1-%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%AE%BF%E9%97%AEprivate%E6%88%90%E5%91%98%E5%92%8C%E6%96%B9%E6%B3%95%EF%BC%8C%E6%97%A2%E7%84%B6%E8%83%BD%E8%AE%BF%E9%97%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81private%EF%BC%9F"><span class="toc-number">6.1.</span> <span class="toc-text">2-6-1: 通过反射访问private成员和方法，既然能访问为什么要private？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-2%EF%BC%9Astatic%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">6.2.</span> <span class="toc-text">2-6-2：static关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-2-1%EF%BC%9Astatic%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">6.2.1.</span> <span class="toc-text">2-6-2-1：static使用场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-2-2%EF%BC%9A%E9%9D%99%E6%80%81%E2%BD%85%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E2%BD%85%E6%B3%95%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C"><span class="toc-number">6.2.2.</span> <span class="toc-text">2-6-2-2：静态⽅法和实例⽅法有何不同</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-2-3%EF%BC%9A%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">6.2.3.</span> <span class="toc-text">2-6-2-3：静态变量和实例变量的区别？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-2-4%EF%BC%9Astatic%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%E9%9D%9Estatic%E6%96%B9%E6%B3%95%E6%88%96%E5%8F%98%E9%87%8F%E5%90%97"><span class="toc-number">6.2.4.</span> <span class="toc-text">2-6-2-4：static方法可以访问非static方法或变量吗?</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-3%EF%BC%9Afinal%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">6.3.</span> <span class="toc-text">2-6-3：final关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-3-1%EF%BC%9Afinal%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">6.3.1.</span> <span class="toc-text">2-6-3-1：final关键字使用场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-3-2%EF%BC%9Afinal-finally-finalize-%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82"><span class="toc-number">6.3.2.</span> <span class="toc-text">2-6-3-2：final, finally, finalize 的区别。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-3-3%EF%BC%9A%E4%BD%BF%E7%94%A8final%E5%85%B3%E9%94%AE%E5%AD%97%E4%BF%AE%E9%A5%B0%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E6%97%B6%EF%BC%8C%E6%98%AF%E5%BC%95%E7%94%A8%E4%B8%8D%E8%83%BD%E5%8F%98%EF%BC%8C%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%B8%8D%E8%83%BD%E5%8F%98%EF%BC%9F"><span class="toc-number">6.3.3.</span> <span class="toc-text">2-6-3-3：使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-4%EF%BC%9Athis%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8Csuper%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">6.4.</span> <span class="toc-text">2-6-4：this关键字和super关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-5%EF%BC%9Atransient%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">6.5.</span> <span class="toc-text">2-6-5：transient关键字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-Java%E5%9F%BA%E7%A1%80-%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99"><span class="toc-number">7.</span> <span class="toc-text">2-7.Java基础-重载与重写</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-1%EF%BC%9A%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99"><span class="toc-number">7.1.</span> <span class="toc-text">2-7-1：重载与重写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-2%EF%BC%9AJava-%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A6%86%E7%9B%96-override-%E4%B8%80%E4%B8%AA-private-%E6%88%96%E8%80%85%E6%98%AF-static-%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">7.2.</span> <span class="toc-text">2-7-2：Java 中是否可以覆盖(override)一个 private 或者是 static 的方法？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-Java%E5%9F%BA%E7%A1%80-%E5%80%BC%E4%BC%A0%E9%80%92%E4%B8%8E%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="toc-number">8.</span> <span class="toc-text">2-8.Java基础-值传递与引用传递</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-1%EF%BC%9A%E5%80%BC%E4%BC%A0%E9%80%92%E4%B8%8E%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">8.1.</span> <span class="toc-text">2-8-1：值传递与引用传递的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-2%EF%BC%9A%E5%80%BC%E4%BC%A0%E9%80%92%E4%B8%8E%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E7%9A%84%E5%AE%9E%E4%BE%8B%E4%B8%BE%E8%AF%81"><span class="toc-number">8.2.</span> <span class="toc-text">2-8-2：值传递与引用传递的实例举证</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-Java%E5%9F%BA%E7%A1%80-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">9.</span> <span class="toc-text">2-9.Java基础-深拷贝与浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-9-1%EF%BC%9A%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">9.1.</span> <span class="toc-text">2-9-1：深拷贝与浅拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-9-2%EF%BC%9A%E6%B5%85%E6%8B%B7%E8%B4%9D%E6%96%B9%E6%B3%95"><span class="toc-number">9.2.</span> <span class="toc-text">2-9-2：浅拷贝方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-9-3%EF%BC%9A%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%96%B9%E6%B3%95"><span class="toc-number">9.3.</span> <span class="toc-text">2-9-3：深拷贝方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-9-4%EF%BC%9A%E8%B5%8B%E5%80%BC%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.4.</span> <span class="toc-text">2-9-4：赋值和浅拷贝的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-10-equals%E4%B8%8Ehashcode"><span class="toc-number">10.</span> <span class="toc-text">2-10 equals与hashcode</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-10-1%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%87%8D%E5%86%99hashcode%E4%B8%8Eequals"><span class="toc-number">10.1.</span> <span class="toc-text">2-10-1：为什么要重写hashcode与equals</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-10-2%EF%BC%9A%E9%87%8D%E5%86%99equals%E4%B8%8D%E9%87%8D%E5%86%99hashcode%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">10.2.</span> <span class="toc-text">2-10-2：重写equals不重写hashcode会出现什么问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-10-3%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84hashcode%E5%80%BC%EF%BC%8C%E5%AE%83%E4%BB%AC%E4%B9%9F%E4%B8%8D%E4%B8%80%E5%AE%9A%E6%98%AF%E7%9B%B8%E7%AD%89%E7%9A%84%EF%BC%9F"><span class="toc-number">10.3.</span> <span class="toc-text">2-10-3：为什么两个对象有相同的hashcode值，它们也不一定是相等的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-10-4%EF%BC%9A%E9%98%BF%E9%87%8C%E5%85%B3%E4%BA%8Ehashcode%E5%92%8Cequals%E7%9A%84%E5%A4%84%E7%90%86%E8%A7%84%E5%88%99"><span class="toc-number">10.4.</span> <span class="toc-text">2-10-4：阿里关于hashcode和equals的处理规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-10-5%EF%BC%9Ahashcode%E5%92%8Cequals%E6%BA%90%E7%A0%81%E5%86%99%E4%B8%80%E4%B8%8B"><span class="toc-number">10.5.</span> <span class="toc-text">2-10-5：hashcode和equals源码写一下</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-11-i-%E4%B8%8E-i%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">11.</span> <span class="toc-text">2-11 i++与++i的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-11-1%EF%BC%9Ai-%E5%92%8C-i%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%8F%8A%E5%85%B6%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">11.1.</span> <span class="toc-text">2-11-1：i++和++i的区别，及其线程安全问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-11-2%EF%BC%9Ai-%E5%92%8C-i%E6%98%AF%E5%90%A6%E4%B8%BA%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">11.2.</span> <span class="toc-text">2-11-2：i++和++i是否为原子操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-11-3%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0i-%E5%92%8C-i%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E5%91%A2%EF%BC%9F"><span class="toc-number">11.3.</span> <span class="toc-text">2-11-3：如何实现i++和++i的原子性呢？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-12-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.</span> <span class="toc-text">2-12 数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-12-1%EF%BC%9A%E5%85%AB%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">12.1.</span> <span class="toc-text">2-12-1：八种数据类型是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-12-1-1%EF%BC%9AJava%E4%B8%BA%E4%BB%80%E4%B9%88%E9%99%A4%E4%BA%86%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BF%98%E8%A6%81%E6%9C%89%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.1.1.</span> <span class="toc-text">2-12-1-1：Java为什么除了基本数据类型还要有引用数据类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-12-1-2%EF%BC%9AString%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.1.2.</span> <span class="toc-text">2-12-1-2：String为什么不是基本数据类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-12-1-2%EF%BC%9A%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D"><span class="toc-number">12.1.3.</span> <span class="toc-text">2-12-1-2：引用类型有哪几种</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-12-2%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%8C%83%E5%9B%B4"><span class="toc-number">12.1.4.</span> <span class="toc-text">2-12-2：数据类型的范围</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-12-2-1%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88byte%E7%B1%BB%E5%9E%8B%E6%98%AF-128-127"><span class="toc-number">12.1.5.</span> <span class="toc-text">2-12-2-1：为什么byte类型是-128~+127</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-12-3%EF%BC%9A%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1"><span class="toc-number">12.2.</span> <span class="toc-text">2-12-3：自动拆装箱</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-12-3-1%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1"><span class="toc-number">12.2.1.</span> <span class="toc-text">2-12-3-1：为什么要有自动拆装箱</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-12-3-2%EF%BC%9A%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">12.2.2.</span> <span class="toc-text">2-12-3-2：自动拆装箱的原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-12-3-3%EF%BC%9A%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">12.2.3.</span> <span class="toc-text">2-12-3-3：自动拆装箱使用场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-12-3-4%EF%BC%9A%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">12.2.4.</span> <span class="toc-text">2-12-3-4：自动拆装箱带来的问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-12-4%EF%BC%9AInteger%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-number">12.3.</span> <span class="toc-text">2-12-4：Integer缓存机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-12-4-1%EF%BC%9Aint%E4%B8%8EInteger%E5%8C%BA%E5%88%AB"><span class="toc-number">12.3.1.</span> <span class="toc-text">2-12-4-1：int与Integer区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-12-5%EF%BC%9AString%E8%BD%AC%E5%87%BAint%E5%9E%8B%EF%BC%8C-%E5%88%A4%E6%96%AD%E8%83%BD%E4%B8%8D%E8%83%BD%E8%BD%AC%EF%BC%9F-%E5%A6%82%E4%BD%95%E8%BD%AC%EF%BC%9F"><span class="toc-number">12.4.</span> <span class="toc-text">2-12-5：String转出int型， 判断能不能转？ 如何转？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-12-6%EF%BC%9Ashort-s1-1-s1-s1-1-%E6%9C%89%E4%BB%80%E4%B9%88%E9%94%99-short-s1-1-s1-1-%E6%9C%89%E4%BB%80%E4%B9%88%E9%94%99"><span class="toc-number">12.5.</span> <span class="toc-text">2-12-6：short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有什么错? short s1 &#x3D; 1; s1+&#x3D;1;有什么错?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%EF%BC%9A%E5%90%84%E7%A7%8D%E9%9B%86%E5%90%88%E5%AE%B6%E6%97%8F"><span class="toc-number"></span> <span class="toc-text">3：各种集合家族</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%EF%BC%9ACollection%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="toc-number">1.</span> <span class="toc-text">3-1：Collection集合框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2%EF%BC%9A%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="toc-number">1.1.</span> <span class="toc-text">3-1-2：并发集合框架</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Hashmap"><span class="toc-number">2.</span> <span class="toc-text">3-2.Hashmap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1%EF%BC%9Ahashmap%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">3-2-1：hashmap的数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1%EF%BC%9A%E6%89%A9%E5%AE%B9%E6%AD%BB%E5%BE%AA%E7%8E%AF%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.</span> <span class="toc-text">3-2-1：扩容死循环问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2%EF%BC%9A%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">3-2-2：链表插入法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-2-1%EF%BC%9A%E5%A4%B4%E6%8F%92%E6%B3%95"><span class="toc-number">2.3.1.</span> <span class="toc-text">3-2-2-1：头插法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-2-2%EF%BC%9A%E5%B0%BE%E6%8F%92%E6%B3%95"><span class="toc-number">2.3.2.</span> <span class="toc-text">3-2-2-2：尾插法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3%EF%BC%9A%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%BC%95%E5%85%A5"><span class="toc-number">2.4.</span> <span class="toc-text">3-2-3：红黑树的引入</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-3-1%EF%BC%9AHashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%A0%91%E5%8C%96"><span class="toc-number">2.4.1.</span> <span class="toc-text">3-2-3-1：HashMap为什么要树化?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-3-2%EF%BC%9Ahashmap%E6%A0%91%E5%8C%96%E9%97%A8%E6%A7%9B%E5%8F%8A%E4%BD%9C%E7%94%A8"><span class="toc-number">2.4.2.</span> <span class="toc-text">3-2-3-2：hashmap树化门槛及作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-3-3%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8A%8A%E9%93%BE%E8%A1%A8%E5%85%A8%E9%83%A8%E6%8D%A2%E4%B8%BA%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">2.4.3.</span> <span class="toc-text">3-2-3-3：为什么不把链表全部换为红黑树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-3-4%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E8%80%8C%E4%B8%8D%E6%98%AFAVL%E6%A0%91%EF%BC%9F"><span class="toc-number">2.4.4.</span> <span class="toc-text">3-2-3-4：为什么是使用红黑树而不是AVL树？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-3-5%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E4%BB%A3%E6%9B%BF%EF%BC%8C%E8%80%8C%E9%80%89%E6%8B%A9%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">2.4.5.</span> <span class="toc-text">3-2-3-5：为什么不用二叉查找树代替，而选择红黑树</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4%EF%BC%9AHashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E6%8F%92%E5%85%A5%E7%A9%BA%E5%80%BC"><span class="toc-number">2.5.</span> <span class="toc-text">3-2-4：HashMap为什么可以插入空值?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-5%EF%BC%9AJDK8%E4%B8%ADhashmap%E7%9A%84%E6%94%B9%E5%8F%98"><span class="toc-number">2.6.</span> <span class="toc-text">3-2-5：JDK8中hashmap的改变</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2%EF%BC%9Aput%E6%93%8D%E4%BD%9C"><span class="toc-number">2.7.</span> <span class="toc-text">3-3-2：put操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3%EF%BC%9AHashMap%E7%9A%84get%E6%93%8D%E4%BD%9C"><span class="toc-number">2.8.</span> <span class="toc-text">3-3-3：HashMap的get操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-3-1%EF%BC%9A%E6%89%8B%E5%86%99get%E6%96%B9%E6%B3%95"><span class="toc-number">2.8.1.</span> <span class="toc-text">3-3-3-1：手写get方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-3-2%EF%BC%9Ahashmap%E7%9A%84get%E5%92%8Cput%E6%93%8D%E4%BD%9C%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.8.2.</span> <span class="toc-text">3-3-3-2：hashmap的get和put操作的时间复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-4%EF%BC%9Ahashmap%E7%9A%84String%E7%B1%BB%E5%9E%8B%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97hashcode%E7%9A%84"><span class="toc-number">2.9.</span> <span class="toc-text">3-3-4：hashmap的String类型如何计算hashcode的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-5%EF%BC%9Ahashmap%E5%AE%B9%E9%87%8F"><span class="toc-number">2.10.</span> <span class="toc-text">3-3-5：hashmap容量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-5-1%EF%BC%9AHashMap%E4%B8%AD-tab-length-1-amp-hash%E4%BD%9C%E7%94%A8"><span class="toc-number">2.10.1.</span> <span class="toc-text">3-3-5-1：HashMap中(tab.length - 1) &amp; hash作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-5-2%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E9%BB%98%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A1%B6%E6%95%B0%E7%BB%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">2.10.2.</span> <span class="toc-text">3-3-5-2：为什么默认初始化桶数组大小</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-5-3%EF%BC%9Ahashmap%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF2%E7%9A%84%E6%AC%A1%E5%B9%82"><span class="toc-number">2.10.3.</span> <span class="toc-text">3-3-5-3：hashmap为什么是2的次幂</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-5-4%EF%BC%9A%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%89%A9%E5%AE%B9"><span class="toc-number">2.10.4.</span> <span class="toc-text">3-3-5-4：什么时候扩容</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-5-6%EF%BC%9AreHash%EF%BC%88%E9%87%8D%E6%95%A3%E5%88%97%EF%BC%89%E8%BF%87%E7%A8%8B"><span class="toc-number">2.10.5.</span> <span class="toc-text">3-3-5-6：reHash（重散列）过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-5-7%EF%BC%9A%E8%AF%A5%E5%AE%B9%E9%87%8F%E5%A6%82%E4%BD%95%E5%8F%98%E5%8C%96"><span class="toc-number">2.10.6.</span> <span class="toc-text">3-3-5-7：该容量如何变化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-5-8%EF%BC%9A%E8%BF%99%E7%A7%8D%E5%8F%98%E5%8C%96%E4%BC%9A%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">2.10.7.</span> <span class="toc-text">3-3-5-8：这种变化会带来什么问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-5-9%EF%BC%9A%E6%89%A9%E5%AE%B9%E7%9A%84%E5%87%A0%E4%B8%AA%E5%8F%82%E6%95%B0"><span class="toc-number">2.10.8.</span> <span class="toc-text">3-3-5-9：扩容的几个参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-5-10%EF%BC%9AHashMap-%E7%9A%84-table-%E7%9A%84%E5%AE%B9%E9%87%8F%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A"><span class="toc-number">2.10.9.</span> <span class="toc-text">3-3-5-10：HashMap 的 table 的容量如何确定</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-5-11%EF%BC%9AloadFactor-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.10.10.</span> <span class="toc-text">3-3-5-11：loadFactor 是什么</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-5-12%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8JDK1-7%E7%9A%84%E6%97%B6%E5%80%99%E6%98%AF%E5%85%88%E8%BF%9B%E8%A1%8C%E6%89%A9%E5%AE%B9%E5%90%8E%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%EF%BC%8C%E8%80%8C%E5%9C%A8JDK1-8%E7%9A%84%E6%97%B6%E5%80%99%E5%88%99%E6%98%AF%E5%85%88%E6%8F%92%E5%85%A5%E5%90%8E%E8%BF%9B%E8%A1%8C%E6%89%A9%E5%AE%B9%E7%9A%84%E5%91%A2"><span class="toc-number">2.10.11.</span> <span class="toc-text">3-3-5-12：为什么在JDK1.7的时候是先进行扩容后进行插入，而在JDK1.8的时候则是先插入后进行扩容的呢</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-5-13%EF%BC%9AJDK1-8%E9%93%BE%E8%A1%A8%E8%BD%AC%E5%8C%96%E4%B8%BA%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E9%98%88%E5%80%BC%E6%98%AF8-%E8%80%8C%E4%B8%8D%E6%98%AF7%E6%88%96%E8%80%85%E4%B8%8D%E6%98%AF20%E5%91%A2"><span class="toc-number">2.10.12.</span> <span class="toc-text">3-3-5-13：JDK1.8链表转化为红黑树的阈值是8,而不是7或者不是20呢</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-5-14%EF%BC%9A%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%87%E4%B8%AA%E5%85%83%E7%B4%A0%E4%B9%8B%E5%90%8E%E4%BC%9A%E4%B8%8D%E4%BC%9A%E6%89%A9%E5%AE%B9%EF%BC%8C%E6%89%A9%E5%AE%B9%E6%89%A9%E5%A4%9A%E5%B0%91"><span class="toc-number">2.10.13.</span> <span class="toc-text">3-3-5-14：插入一万个元素之后会不会扩容，扩容扩多少</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-6%EF%BC%9Ahash%E5%87%BD%E6%95%B0"><span class="toc-number">2.11.</span> <span class="toc-text">3-3-6：hash函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-6-1%EF%BC%9Ahash-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.11.1.</span> <span class="toc-text">3-3-6-1：hash 的实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-6-2%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%9F"><span class="toc-number">2.11.2.</span> <span class="toc-text">3-3-6-2：为什么要用异或运算符？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-6-3%EF%BC%9A%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">2.11.3.</span> <span class="toc-text">3-3-6-3：哈希冲突的解决方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-6-4%EF%BC%9A%E4%B8%80%E8%87%B4%E6%80%A7hash%E5%92%8C%E6%99%AE%E9%80%9Ahash%E5%8C%BA%E5%88%AB"><span class="toc-number">2.11.4.</span> <span class="toc-text">3-3-6-4：一致性hash和普通hash区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-6-5%EF%BC%9A%E6%89%B0%E5%8A%A8%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E4%BD%9C%E7%94%A8"><span class="toc-number">2.11.5.</span> <span class="toc-text">3-3-6-5：扰动函数以及作用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-7%EF%BC%9Ahashmap%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98"><span class="toc-number">2.12.</span> <span class="toc-text">3-3-7：hashmap线程问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-7-1%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84Map"><span class="toc-number">2.12.1.</span> <span class="toc-text">3-3-7-1：线程安全的Map</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-8%EF%BC%9AHashMap%E5%BC%95%E7%94%A8"><span class="toc-number">2.13.</span> <span class="toc-text">3-3-8：HashMap引用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-8-1%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88hashmap%E4%B8%ADString%E3%80%81integer%E5%8C%85%E8%A3%85%E7%B1%BB%E9%80%82%E5%90%88%E4%BD%9C%E4%B8%BAkey"><span class="toc-number">2.13.1.</span> <span class="toc-text">3-3-8-1：为什么hashmap中String、integer包装类适合作为key</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-8-2%EF%BC%9A%E5%A6%82%E6%9E%9C%E6%83%B3%E8%A6%81%E4%B8%80%E4%B8%AAkey%E5%AF%B9%E5%BA%94%E5%A4%9A%E4%B8%AAValue%E7%9A%84%E8%AF%9D%EF%BC%8C%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1Map"><span class="toc-number">2.13.2.</span> <span class="toc-text">3-3-8-2：如果想要一个key对应多个Value的话，怎么设计Map</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-8-3%EF%BC%9A%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1HashMap-lt-Integer-Integer-gt-map-new-HashMap-lt-gt-%E5%85%88put-10-1-%E7%84%B6%E5%90%8Eget-new-Long-10-%E7%BB%93%E6%9E%9C%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">2.13.3.</span> <span class="toc-text">3-3-8-3：创建一个对象HashMap&lt;Integer,Integer&gt; map&#x3D;new HashMap&lt;&gt;先put(10,1),然后get(new Long(10))结果是多少？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-8-4%EF%BC%9A%E4%BD%BF%E7%94%A8final-static%E4%BF%AE%E9%A5%B0%E9%9B%86%E5%90%88Hashmap%E4%BC%9A%E4%BA%A7%E7%94%9F%E4%BB%80%E4%B9%88%E5%BD%B1%E5%93%8D"><span class="toc-number">2.13.4.</span> <span class="toc-text">3-3-8-4：使用final static修饰集合Hashmap会产生什么影响</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-8-5%EF%BC%9AJDK%E7%9A%84Hashmap%E4%B8%8ERedis%E7%9A%84Hashmap%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.13.5.</span> <span class="toc-text">3-3-8-5：JDK的Hashmap与Redis的Hashmap的区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-9%EF%BC%9AConcurrentHashMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.14.</span> <span class="toc-text">3-3-9：ConcurrentHashMap数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-9-1%EF%BC%9AConcurrentHashMap%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.14.1.</span> <span class="toc-text">3-3-9-1：ConcurrentHashMap的底层实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-9-2%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88ConcurrentHashMap%EF%BC%88Hashtable%EF%BC%89%E4%B8%BA%E4%BD%95%E4%B8%8D%E6%94%AF%E6%8C%81null%E9%94%AE%E5%92%8Cnull%E5%80%BC"><span class="toc-number">2.14.2.</span> <span class="toc-text">3-3-9-2：为什么ConcurrentHashMap（Hashtable）为何不支持null键和null值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-9-3%EF%BC%9A%E5%88%86%E6%AE%B5%E9%94%81%E5%8E%9F%E7%90%86"><span class="toc-number">2.14.3.</span> <span class="toc-text">3-3-9-3：分段锁原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-9-4%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%86%85%E7%BD%AE%E9%94%81synchronized%E6%9D%A5%E4%BB%A3%E6%9B%BF%E9%87%8D%E5%85%A5%E9%94%81-ReentrantLock%EF%BC%9F"><span class="toc-number">2.14.4.</span> <span class="toc-text">3-3-9-4：为什么要使用内置锁synchronized来代替重入锁 ReentrantLock？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-9-5%EF%BC%9AHashmap%E4%B8%8EConcurrentHashMap%E4%B8%ADput%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.14.5.</span> <span class="toc-text">3-3-9-5：Hashmap与ConcurrentHashMap中put的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-9-6%EF%BC%9A%E6%89%8B%E5%86%99ConcurrentHashMap%E7%9A%84get%E6%93%8D%E4%BD%9C"><span class="toc-number">2.14.6.</span> <span class="toc-text">3-3-9-6：手写ConcurrentHashMap的get操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-9-7%EF%BC%9A%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%8F%91%E7%94%9F%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">2.14.7.</span> <span class="toc-text">3-3-9-7：什么时候会发生扩容机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-9-8%EF%BC%9Ahashmap%E4%B8%8EConcurrentHashMap%E4%B8%AD%E6%89%A9%E5%AE%B9%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.14.8.</span> <span class="toc-text">3-3-9-8：hashmap与ConcurrentHashMap中扩容的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-9-10%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88-ConcurrentHashMap-%E6%AF%94-Hashtable-%E6%95%88%E7%8E%87%E8%A6%81%E9%AB%98%EF%BC%9F"><span class="toc-number">2.14.9.</span> <span class="toc-text">3-3-9-10：为什么 ConcurrentHashMap 比 Hashtable 效率要高？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-9-11%EF%BC%9AConcurrentHashMap-%E7%9A%84%E5%B9%B6%E5%8F%91%E5%BA%A6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.14.10.</span> <span class="toc-text">3-3-9-11：ConcurrentHashMap 的并发度是什么？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4%EF%BC%9ATreeMap"><span class="toc-number">3.</span> <span class="toc-text">3-4：TreeMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-1%EF%BC%9ATreeMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">3-4-1：TreeMap数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-2%EF%BC%9ATreeMap%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.2.</span> <span class="toc-text">3-4-2：TreeMap使用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-LinkedHashMap"><span class="toc-number">4.</span> <span class="toc-text">3-5.LinkedHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-1%EF%BC%9ALinkedHashMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.</span> <span class="toc-text">3-5-1：LinkedHashMap数据结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-Hashtable"><span class="toc-number">5.</span> <span class="toc-text">3-7.Hashtable</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-1%EF%BC%9AHashtable%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">5.1.</span> <span class="toc-text">3-7-1：Hashtable数据结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8%EF%BC%9AArrayLlist"><span class="toc-number">6.</span> <span class="toc-text">3-8：ArrayLlist</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-1%EF%BC%9AArrayList%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">6.1.</span> <span class="toc-text">3-8-1：ArrayList数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-2%EF%BC%9A%E6%95%B0%E7%BB%84-Array-%E5%92%8C%E5%88%97%E8%A1%A8-ArrayList-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">6.2.</span> <span class="toc-text">3-8-2：数组(Array)和列表(ArrayList)有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-3%EF%BC%9AArrayList%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">6.3.</span> <span class="toc-text">3-8-3：ArrayList扩容机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-4%EF%BC%9AArrayList%E7%9A%84add%E6%93%8D%E4%BD%9C"><span class="toc-number">6.4.</span> <span class="toc-text">3-8-4：ArrayList的add操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-5%EF%BC%9AArraylist%E5%88%9D%E5%A7%8B%E5%A4%A7%E5%B0%8F%E4%BB%A5%E5%8F%8A%E6%89%A9%E5%AE%B9%E5%A4%A7%E5%B0%8F"><span class="toc-number">6.5.</span> <span class="toc-text">3-8-5：Arraylist初始大小以及扩容大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-6%EF%BC%9A%E9%82%A3%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3ArrayList%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E5%91%A2%EF%BC%9F"><span class="toc-number">6.6.</span> <span class="toc-text">3-8-6：那如何解决ArrayList线程不安全问题呢？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9%EF%BC%9Avector"><span class="toc-number">7.</span> <span class="toc-text">3-9：vector</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-9-1%EF%BC%9Avector%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">7.1.</span> <span class="toc-text">3-9-1：vector数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-9-2%EF%BC%9A%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">7.2.</span> <span class="toc-text">3-9-2：扩容机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-10%EF%BC%9ALinkedlist"><span class="toc-number">8.</span> <span class="toc-text">3-10：Linkedlist</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-10-1%EF%BC%9ALinkedlist%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">8.1.</span> <span class="toc-text">3-10-1：Linkedlist数据结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-11%EF%BC%9AHashSet"><span class="toc-number">9.</span> <span class="toc-text">3-11：HashSet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-11-1%EF%BC%9AHashSet%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">9.1.</span> <span class="toc-text">3-11-1：HashSet数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-11-2%EF%BC%9AHashSet%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">9.2.</span> <span class="toc-text">3-11-2：HashSet的内存泄漏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-11-3%EF%BC%9AHashSet%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">9.3.</span> <span class="toc-text">3-11-3：HashSet如何保证线程安全</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-12%EF%BC%9ATreeSet"><span class="toc-number">10.</span> <span class="toc-text">3-12：TreeSet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-12-1%EF%BC%9ATreeSet%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">10.1.</span> <span class="toc-text">3-12-1：TreeSet数据结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-13%EF%BC%9ALinkedHashSet"><span class="toc-number">11.</span> <span class="toc-text">3-13：LinkedHashSet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-13-1%EF%BC%9ALinkedHashSet%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">11.1.</span> <span class="toc-text">3-13-1：LinkedHashSet数据结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-14-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-%E9%9D%9E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88"><span class="toc-number">12.</span> <span class="toc-text">3-14.线程安全&#x2F;非线程安全的集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-15%EF%BC%9AJava%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88-%E9%9B%86%E5%90%88%E5%A4%A7%E6%AF%94%E8%BE%83"><span class="toc-number">13.</span> <span class="toc-text">3-15：Java基础-集合-集合大比较</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-15-1%EF%BC%9Aset%E5%92%8Clist%E3%80%81map%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">13.1.</span> <span class="toc-text">3-15-1：set和list、map的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-15-2%EF%BC%9AArraylist%E3%80%81Linkedlist%E5%8C%BA%E5%88%AB%E5%92%8C%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">13.2.</span> <span class="toc-text">3-15-2：Arraylist、Linkedlist区别和适用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-15-3%EF%BC%9AHashMap%E3%80%81Treemap%E3%80%81LinkedHashMap%E5%8C%BA%E5%88%AB%E5%92%8C%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">13.3.</span> <span class="toc-text">3-15-3：HashMap、Treemap、LinkedHashMap区别和适用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-16%EF%BC%9ACollections"><span class="toc-number">14.</span> <span class="toc-text">3-16：Collections</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-16-1%EF%BC%9ACollection%E4%B8%8ECollections%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">14.1.</span> <span class="toc-text">3-16-1：Collection与Collections的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%EF%BC%9AIO"><span class="toc-number"></span> <span class="toc-text">4：IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1%EF%BC%9AIO%E6%B5%81"><span class="toc-number">1.</span> <span class="toc-text">4-1：IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1%EF%BC%9A%E4%B8%BA%E4%BD%95%E8%BF%98%E8%A6%81%E6%9C%89%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-number">1.1.</span> <span class="toc-text">4-1-1：为何还要有字符流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2%EF%BC%9A%E5%AD%97%E8%8A%82%E6%B5%81%E5%92%8C%E5%AD%97%E7%AC%A6%E6%B5%81%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.</span> <span class="toc-text">4-1-2：字节流和字符流区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2%EF%BC%9ABIO-NIO-AIO"><span class="toc-number">2.</span> <span class="toc-text">4-2：BIO\NIO\AIO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1%EF%BC%9ABIO-NIO-AIO%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.</span> <span class="toc-text">4-2-1：BIO\NIO\AIO定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2%EF%BC%9ABIO%E4%B8%8ENIO%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.</span> <span class="toc-text">4-2-2：BIO与NIO的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3%EF%BC%9AIO%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">4-3：IO模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1%EF%BC%9AIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">3.1.</span> <span class="toc-text">4-3-1：IO多路复用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1%EF%BC%9AIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">3.2.</span> <span class="toc-text">4-3-1：IO多路复用实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-1-1%EF%BC%9A%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%8C%BA%E5%88%AB"><span class="toc-number">3.2.1.</span> <span class="toc-text">4-3-1-1：三种实现方式区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-1-2%EF%BC%9A%E4%B8%89%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">3.2.2.</span> <span class="toc-text">4-3-1-2：三种常用的实现方式优缺点</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%EF%BC%9A%E5%8F%8D%E5%B0%84"><span class="toc-number"></span> <span class="toc-text">5：反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1%EF%BC%9A%E5%8F%8D%E5%B0%84%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">4-1：反射的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1%EF%BC%9A%E5%8F%8D%E5%B0%84%E4%BC%9A%E5%AF%BC%E8%87%B4%E5%93%AA%E4%BA%9B%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.</span> <span class="toc-text">4-1-1：反射会导致哪些性能问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-1-1%EF%BC%9A%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%8F%8D%E5%B0%84%E5%AF%BC%E8%87%B4%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.1.</span> <span class="toc-text">4-1-1-1：如何避免反射导致的性能问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2%EF%BC%9A%E5%93%AA%E4%BA%9B%E7%B1%BB%E4%B8%8D%E8%83%BD%E5%8F%8D%E5%B0%84"><span class="toc-number">1.2.</span> <span class="toc-text">4-1-2：哪些类不能反射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3%EF%BC%9A%E5%8F%8D%E5%B0%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.3.</span> <span class="toc-text">4-1-3：反射优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-4%EF%BC%9A%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.4.</span> <span class="toc-text">4-1-4：反射的应用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2%EF%BC%9AClass%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">4-2：Class类的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1%EF%BC%9A%E8%8E%B7%E5%8F%96Class%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">4-2-1：获取Class对象方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2%EF%BC%9AClass-forName%E5%92%8Cclassloader-loadClass%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.</span> <span class="toc-text">4-2-2：Class.forName和classloader.loadClass的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3%EF%BC%9A%E5%8F%8D%E5%B0%84%E8%B0%83%E7%94%A8%E7%B1%BB%E7%9A%84%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">4-2-3：反射调用类的私有方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%EF%BC%9A%E6%B3%A8%E8%A7%A3"><span class="toc-number"></span> <span class="toc-text">5：注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1%EF%BC%9A%E5%85%83%E6%B3%A8%E8%A7%A3%E4%BB%A5%E5%8F%8A%E5%88%86%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">5-1：元注解以及分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2%EF%BC%9AJava%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.</span> <span class="toc-text">5-2：Java常用注解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%EF%BC%9A%E6%B3%9B%E5%9E%8B"><span class="toc-number"></span> <span class="toc-text">6：泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">6-1：什么是泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2%EF%BC%9A%E7%BC%96%E8%AF%91%E5%99%A8%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E6%B3%9B%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">6-2：编译器如何处理泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-1%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88Java%E8%A6%81%E7%94%A8%E8%BF%99%E7%A7%8D%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-number">2.1.</span> <span class="toc-text">6-2-1：为什么Java要用这种编译器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="toc-number">3.</span> <span class="toc-text">6-3: 什么是类型擦除</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-1%EF%BC%9A%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%E8%BF%87%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">6-3-1：类型擦除过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4%EF%BC%9A%E6%B3%9B%E5%9E%8B%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text">6-4：泛型带来的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5%EF%BC%9A%E6%B3%9B%E5%9E%8B%E5%BA%94%E7%94%A8"><span class="toc-number">5.</span> <span class="toc-text">6-5：泛型应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-1%EF%BC%9AList%E6%B3%9B%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8BList%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.1.</span> <span class="toc-text">6-5-1：List泛型和原始类型List之间的区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-4%EF%BC%9A%E5%A4%9A%E6%80%81%E6%97%B6%E6%98%AF%E5%90%A6%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="toc-number">5.2.</span> <span class="toc-text">6-5-4：多态时是否会出现类型擦除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%EF%BC%9A%E5%BC%82%E5%B8%B8"><span class="toc-number"></span> <span class="toc-text">7：异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1%EF%BC%9A%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">7-1：异常的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-1%EF%BC%9AError%E5%92%8CException%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.</span> <span class="toc-text">7-1-1：Error和Exception的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2%EF%BC%9AJava%E4%B8%AD%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.</span> <span class="toc-text">7-2：Java中的两种异常类型是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-1%EF%BC%9A%E4%BB%96%E4%BB%AC%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.</span> <span class="toc-text">7-2-1：他们有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-2%EF%BC%9A%E5%BC%82%E5%B8%B8%E9%93%BE"><span class="toc-number">2.2.</span> <span class="toc-text">7-2-2：异常链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-3%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AFOOM%EF%BC%9F%E5%B8%B8%E8%A7%81%E6%9C%89%E5%93%AA%E4%BA%9BOOM"><span class="toc-number">2.3.</span> <span class="toc-text">7-3-3：什么是OOM？常见有哪些OOM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4%EF%BC%9Atry%E3%80%81catch%E3%80%81finally%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">2.4.</span> <span class="toc-text">7-4：try、catch、finally执行顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-1%EF%BC%9A%E5%B8%A6return%E8%BF%94%E5%9B%9E%E9%A1%BA%E5%BA%8F"><span class="toc-number">2.5.</span> <span class="toc-text">7-4-1：带return返回顺序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%EF%BC%9AString"><span class="toc-number"></span> <span class="toc-text">8：String</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1%EF%BC%9Astring%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">8-1：string数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-1%EF%BC%9AString%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFfinal%E7%9A%84%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">8-1-1：String为什么是final的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-2%EF%BC%9AString%E7%9A%84%E5%86%85%E9%83%A8%E5%B1%9E%E6%80%A7"><span class="toc-number">1.2.</span> <span class="toc-text">8-1-2：String的内部属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-3%EF%BC%9AString%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">8-1-3：String的常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-4%EF%BC%9Asubstring%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.</span> <span class="toc-text">8-1-4：substring原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-5%EF%BC%9AString%E9%95%BF%E5%BA%A6%E6%9C%89%E9%99%90%E5%88%B6%E7%9A%84"><span class="toc-number">1.5.</span> <span class="toc-text">8-1-5：String长度有限制的</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2%EF%BC%9AString-str-new-String-%E2%80%9Cabc%E2%80%9D-%E5%88%9B%E5%BB%BA%E4%BA%86%E5%87%A0%E4%B8%AA%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.</span> <span class="toc-text">8-2：String str &#x3D; new String(“abc”);创建了几个对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1%EF%BC%9AString-str-%E2%80%9Dabc%E2%80%9D-%E5%A0%86%E5%92%8C%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%B8%AD%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">2.1.</span> <span class="toc-text">8-2-1：String str&#x3D;”abc”,堆和常量池中的情况</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3%EF%BC%9AString%E7%9A%84-%E4%B8%8Eequals%E9%97%AE%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">8-3：String的&#x3D;&#x3D;与equals问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-1%EF%BC%9A%E4%B8%A4%E4%B8%AAst1-%E2%80%9Cabc%E2%80%9D%E7%9B%B8%E7%AD%89%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.</span> <span class="toc-text">8-3-1：两个st1 &#x3D; “abc”相等问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-2%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%EF%BC%8C%E4%B8%80%E4%B8%AAstr1-%E2%80%9Cabc%E2%80%9D"><span class="toc-number">3.2.</span> <span class="toc-text">8-3-2：一个创建对象，一个str1&#x3D;“abc”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-3%EF%BC%9A%E4%B8%80%E4%B8%AAa-b-c%EF%BC%8C%E4%B8%80%E4%B8%AAabc"><span class="toc-number">3.3.</span> <span class="toc-text">8-3-3：一个a+b+c，一个abc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-4%EF%BC%9A%E4%B8%80%E4%B8%AAstr1-c%EF%BC%8C%E4%B8%80%E4%B8%AAabc"><span class="toc-number">3.4.</span> <span class="toc-text">8-3-4：一个str1+c，一个abc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-5%EF%BC%9A%E4%B8%A4%E4%B8%AAnew-String%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.5.</span> <span class="toc-text">8-3-5：两个new String对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4%EF%BC%9A%E6%8B%BC%E6%8E%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">8-4：拼接方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-String%E3%80%81StringBuffer%E5%92%8CStringBuilder%E5%8C%BA%E5%88%AB"><span class="toc-number">5.</span> <span class="toc-text">8-5: String、StringBuffer和StringBuilder区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-1%EF%BC%9AStringBuffer%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">6.</span> <span class="toc-text">8-5-1：StringBuffer如何实现线程安全</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-2%EF%BC%9A%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E9%87%8F%E8%BE%83%E5%A4%A7%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%94%A8String%E8%BF%98%E6%98%AFStringBuilder%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-number">6.1.</span> <span class="toc-text">8-5-2：处理数据量较大的字符串用String还是StringBuilder，为什么</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-3%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88StringBuffer%E5%92%8CStringBuilder%E6%AF%94String%E6%9B%B4%E5%BF%AB%EF%BC%88%E4%B8%8D%E5%8F%98%E6%80%A7%EF%BC%89"><span class="toc-number">7.</span> <span class="toc-text">8-5-3：为什么StringBuffer和StringBuilder比String更快（不变性）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6%EF%BC%9A%E5%BA%94%E7%94%A8"><span class="toc-number">8.</span> <span class="toc-text">8-6：应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6-1%EF%BC%9A%E5%A6%82%E4%BD%95%E6%8A%8A%E4%B8%80%E6%AE%B5%E9%80%97%E5%8F%B7%E5%88%86%E5%89%B2%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84"><span class="toc-number">8.1.</span> <span class="toc-text">8-6-1：如何把一段逗号分割的字符串转换成一个数组?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6-2%EF%BC%9AString-%E5%92%8C-char-%E6%95%B0%E7%BB%84%E8%B0%81%E6%9B%B4%E9%80%82%E5%90%88%E5%AD%98%E5%AF%86%E7%A0%81"><span class="toc-number">8.2.</span> <span class="toc-text">8-6-2：String 和 char[] 数组谁更适合存密码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%EF%BC%9A%E6%9E%9A%E4%B8%BE"><span class="toc-number"></span> <span class="toc-text">9：枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1%EF%BC%9Aenum%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">1.</span> <span class="toc-text">9-1：enum线程安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-switch-%E6%98%AF%E5%90%A6%E5%8F%AF%E7%94%A8%E4%BA%8EString%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%A4%E6%96%AD"><span class="toc-number">2.</span> <span class="toc-text">9-2: switch 是否可用于String类型的判断</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%EF%BC%9A%E6%97%B6%E9%97%B4%E7%B1%BB"><span class="toc-number"></span> <span class="toc-text">10：时间类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1%EF%BC%9ASimpDateFormat%E6%98%AF%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E7%B1%BB%EF%BC%8C%E5%A6%82%E4%BD%95%E6%94%B9%E4%B8%BA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">1.</span> <span class="toc-text">10-1：SimpDateFormat是线程不安全的类，如何改为线程安全</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%EF%BC%9AObject%E7%B1%BB"><span class="toc-number"></span> <span class="toc-text">11：Object类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1%EF%BC%9AObject%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">11-1：Object类有哪些方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-1%EF%BC%9AXX-toString%E5%92%8CString-valueOf"><span class="toc-number">2.</span> <span class="toc-text">11-1-1：XX.toString和String.valueOf()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-1%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E6%93%8D%E4%BD%9C%E7%BA%BF%E7%A8%8B%E6%96%B9%E6%B3%95%E5%9C%A8Object%E5%AF%B9%E8%B1%A1%E4%B8%AD"><span class="toc-number">3.</span> <span class="toc-text">11-1-1：为什么操作线程方法在Object对象中</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%EF%BC%9A%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number"></span> <span class="toc-text">12：序列化与反序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1%EF%BC%9AJava%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.</span> <span class="toc-text">12-1：Java序列化与反序列化是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">2.</span> <span class="toc-text">12-2：为什么需要序列化与反序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3%EF%BC%9AJava%E5%AF%B9%E8%B1%A1%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">3.</span> <span class="toc-text">12-3：Java对象如何实现序列化与反序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-1%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">3.1.</span> <span class="toc-text">12-3-1：如何实现序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-2%EF%BC%9AExternalizable%E5%92%8CSerializable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.2.</span> <span class="toc-text">12-3-2：Externalizable和Serializable的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-3-%E4%BB%80%E4%B9%88%E6%98%AFserialVersionUID"><span class="toc-number">3.3.</span> <span class="toc-text">12-3-3: 什么是serialVersionUID</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-4%EF%BC%9A%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AE%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">3.4.</span> <span class="toc-text">12-3-4：序列化协议有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-5%EF%BC%9ASerializable%E6%8E%A5%E5%8F%A3%E5%B9%B6%E6%B2%A1%E6%9C%89%E6%96%B9%E6%B3%95%E5%92%8C%E5%AD%97%E6%AE%B5%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AA%E6%9C%89%E5%AE%9E%E7%8E%B0%E4%BA%86%E8%AF%A5%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%89%8D%E8%83%BD%E8%A2%AB%E5%BA%8F%E5%88%97%E5%8C%96%E5%91%A2%EF%BC%9F"><span class="toc-number">3.5.</span> <span class="toc-text">12-3-5：Serializable接口并没有方法和字段，为什么只有实现了该接口的类的对象才能被序列化呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-6%EF%BC%9AJava%E5%AF%B9%E8%B1%A1%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">3.6.</span> <span class="toc-text">12-3-6：Java对象如何实现反序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-7%EF%BC%9A%E5%93%AA%E4%BA%9B%E4%B8%8D%E4%BC%9A%E8%A2%AB%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">3.7.</span> <span class="toc-text">12-3-7：哪些不会被序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-5-8%EF%BC%9A%E5%A6%82%E6%9E%9C%E7%B1%BB%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E6%88%90%E5%91%98%E6%9C%AA%E5%AE%9E%E7%8E%B0%E5%8F%AF%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A5%E5%8F%A3%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%EF%BC%9F"><span class="toc-number">3.8.</span> <span class="toc-text">12-5-8：如果类中的一个成员未实现可序列化接口，会发生什么情况？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-5-9%EF%BC%9A%E5%A6%82%E6%9E%9C%E7%B1%BB%E6%98%AF%E5%8F%AF%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84-%E4%BD%86%E5%85%B6%E7%88%B6%E7%B1%BB%E4%B8%8D%E6%98%AF-%E5%88%99%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%90%8E%E4%BB%8E%E7%88%B6%E7%B1%BB%E7%B1%BB%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E7%9A%84%E7%8A%B6%E6%80%81%E5%A6%82%E4%BD%95%EF%BC%9F"><span class="toc-number">3.9.</span> <span class="toc-text">12-5-9：如果类是可序列化的, 但其父类不是, 则反序列化后从父类类继承的实例变量的状态如何？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-5-10%EF%BC%9A%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%87%E7%A8%8B-%E6%88%96%E8%80%85%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A6%86%E7%9B%96-Java-%E4%B8%AD%E7%9A%84%E9%BB%98%E8%AE%A4%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">3.10.</span> <span class="toc-text">12-5-10：是否可以自定义序列化过程, 或者是否可以覆盖 Java 中的默认序列化过程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-5-11%EF%BC%9A%E5%81%87%E8%AE%BE%E6%96%B0%E7%B1%BB%E7%9A%84%E7%88%B6%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A5%E5%8F%A3-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%96%B0%E7%B1%BB%E8%A2%AB%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F"><span class="toc-number">3.11.</span> <span class="toc-text">12-5-11：假设新类的父类实现序列化接口, 如何避免新类被序列化？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4%EF%BC%9A%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.</span> <span class="toc-text">12-4：序列化和反序列化应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%EF%BC%9A%E5%B9%B6%E5%8F%91%E9%AB%98%E9%A2%91"><span class="toc-number"></span> <span class="toc-text">13：并发高频</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">13-1:进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-1%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">13-1-1：什么是进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-2%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">1.2.</span> <span class="toc-text">13-1-2：进程的状态</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#13-1-2-1%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81"><span class="toc-number">1.2.1.</span> <span class="toc-text">13-1-2-1：进程的状态变迁</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-3%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AFPCB"><span class="toc-number">1.3.</span> <span class="toc-text">13-1-3：什么是PCB</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#13-1-3-1%EF%BC%9APCB-%E5%85%B7%E4%BD%93%E5%8C%85%E5%90%AB%E4%BB%80%E4%B9%88%E4%BF%A1%E6%81%AF%E5%91%A2%EF%BC%9F"><span class="toc-number">1.3.1.</span> <span class="toc-text">13-1-3-1：PCB 具体包含什么信息呢？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-3-2%EF%BC%9A%E5%A4%9A%E4%B8%AA-PCB-%E6%98%AF%E5%A6%82%E4%BD%95%E7%BB%84%E7%BB%87%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">13-1-3-2：多个 PCB 是如何组织的呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-4%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8E%A7%E5%88%B6"><span class="toc-number">1.5.</span> <span class="toc-text">13-1-4：进程的控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-5%EF%BC%9A%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">1.6.</span> <span class="toc-text">13-1-5：进程间通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-6%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.</span> <span class="toc-text">13-1-6：进程的内存结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2%EF%BC%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">13-2：线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-1%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">13-2-1：线程概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#13-2-1-1%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.1.1.</span> <span class="toc-text">13-2-1-1：为什么使用线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13-2-1-2%EF%BC%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.1.2.</span> <span class="toc-text">13-2-1-2：线程的优缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-2%EF%BC%9A%E4%B8%89%E7%A7%8D%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">13-2-2：三种线程的实现方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-3%EF%BC%9A%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">13-2-3：用户线程如何理解？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#13-2-3-1%EF%BC%9A%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E5%AD%98%E5%9C%A8%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF%E5%92%8C%E7%BC%BA%E9%99%B7%EF%BC%9F"><span class="toc-number">2.3.1.</span> <span class="toc-text">13-2-3-1：用户线程存在什么优势和缺陷？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-4%EF%BC%9A%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">2.4.</span> <span class="toc-text">13-2-4：内核线程如何理解？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#13-2-4-1%EF%BC%9A%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E5%AD%98%E5%9C%A8%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF%E5%92%8C%E7%BC%BA%E9%99%B7"><span class="toc-number">2.4.1.</span> <span class="toc-text">13-2-4-1：内核线程存在什么优势和缺陷</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-5%EF%BC%9A%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB"><span class="toc-number">2.5.</span> <span class="toc-text">13-2-5：用户线程和内核线程的对应关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-6%EF%BC%9A%E8%BD%BB%E9%87%8F%E7%BA%A7%E8%BF%9B%E7%A8%8B%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3"><span class="toc-number">2.6.</span> <span class="toc-text">13-2-6：轻量级进程如何理解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#13-2-6-1%EF%BC%9A-LWP-%E4%B8%8E%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB"><span class="toc-number">2.6.1.</span> <span class="toc-text">13-2-6-1： LWP 与用户线程的对应关系</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-3%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">2.7.</span> <span class="toc-text">13-2-3：线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#13-2-3-1%EF%BC%9Await-notify%E6%9C%BA%E5%88%B6"><span class="toc-number">2.7.1.</span> <span class="toc-text">13-2-3-1：wait&#x2F;notify机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13-2-3-2%EF%BC%9A%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1"><span class="toc-number">2.7.2.</span> <span class="toc-text">13-2-3-2：管道通信</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.</span> <span class="toc-text">13-3.线程与进程的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-3-1%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.</span> <span class="toc-text">13-3-1：进程切换与线程切换的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-3-2%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%9B%E7%A8%8B%E8%8A%B1%E9%94%80%E6%AF%94%E7%BA%BF%E7%A8%8B%E8%8A%B1%E9%94%80%E5%A4%A7"><span class="toc-number">3.2.</span> <span class="toc-text">13-3-2：为什么进程花销比线程花销大</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%EF%BC%9AJVM%E9%AB%98%E9%A2%91"><span class="toc-number"></span> <span class="toc-text">14：JVM高频</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%EF%BC%9A%E8%AE%A1%E7%BD%91%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number"></span> <span class="toc-text">15：计网与操作系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number"></span> <span class="toc-text">16：数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1%EF%BC%9AMySQL"><span class="toc-number">1.</span> <span class="toc-text">16-1：MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#16-1-1%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.1.</span> <span class="toc-text">16-1-1：为什么要使用数据库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-1-2-%E4%BB%80%E4%B9%88%E6%98%AFSQL%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">16-1-2: 什么是SQL？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-1-3%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AFMySQL"><span class="toc-number">1.3.</span> <span class="toc-text">16-1-3：什么是MySQL?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-2%EF%BC%9A%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">2.</span> <span class="toc-text">16-2：关系型数据库与非关系型数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#16-2-1%EF%BC%9A%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.</span> <span class="toc-text">16-2-1：非关系型数据库和关系型数据库定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-2-2%EF%BC%9A%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.2.</span> <span class="toc-text">16-2-2：关系型数据库优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-2-3%EF%BC%9A%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.3.</span> <span class="toc-text">16-2-3：非关系型数据库优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-3-4%EF%BC%9A%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8C%BA%E5%88%AB"><span class="toc-number">2.4.</span> <span class="toc-text">16-3-4：非关系型数据库和关系型数据库区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-3%EF%BC%9A%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">16-3：三大范式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#16-3-1%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.1.</span> <span class="toc-text">16-3-1：数据库三大范式是什么</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-4%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">16-4：数据库的数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#16-4-1%EF%BC%9AMySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.</span> <span class="toc-text">16-4-1：MySQL的数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-4-2%EF%BC%9Avarchar%E4%B8%8Echar%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.2.</span> <span class="toc-text">16-4-2：varchar与char的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#16-4-2-1%EF%BC%9Avarchar-50-%E4%B8%AD50%E7%9A%84%E6%B6%B5%E4%B9%89"><span class="toc-number">4.2.1.</span> <span class="toc-text">16-4-2-1：varchar(50)中50的涵义</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-4-3%EF%BC%9Aint-20-%E4%B8%AD20%E7%9A%84%E6%B6%B5%E4%B9%89"><span class="toc-number">4.3.</span> <span class="toc-text">16-4-3：int(20)中20的涵义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-4-4%EF%BC%9AFLOAT%E5%92%8CDOUBLE%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.4.</span> <span class="toc-text">16-4-4：FLOAT和DOUBLE的区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-4-5%EF%BC%9AMySQL-INT%E5%92%8CCHAR%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.5.</span> <span class="toc-text">16-4-5：MySQL INT和CHAR隐式类型转换需要注意什么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-5%EF%BC%9ASQL%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">5.</span> <span class="toc-text">16-5：SQL生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-6%EF%BC%9AMySQL%E9%A2%84%E7%BC%96%E8%AF%91"><span class="toc-number">6.</span> <span class="toc-text">16-6：MySQL预编译</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#16-6-1%EF%BC%9A%E9%A2%84%E7%BC%96%E8%AF%91%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">6.1.</span> <span class="toc-text">16-6-1：预编译的好处</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-7%EF%BC%9ASQL%E6%B3%A8%E5%85%A5"><span class="toc-number">7.</span> <span class="toc-text">16-7：SQL注入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#16-7-1%EF%BC%9ASQL%E6%B3%A8%E5%85%A5%E7%AE%80%E4%BB%8B"><span class="toc-number">7.1.</span> <span class="toc-text">16-7-1：SQL注入简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-7-3%EF%BC%9ASQL%E6%B3%A8%E5%85%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">7.2.</span> <span class="toc-text">16-7-3：SQL注入解决方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-8%EF%BC%9Asql%E8%AF%AD%E5%8F%A5"><span class="toc-number">8.</span> <span class="toc-text">16-8：sql语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#16-8-1%EF%BC%9ASQL%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">8.1.</span> <span class="toc-text">16-8-1：SQL的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-8-2%EF%BC%9A%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-number">8.2.</span> <span class="toc-text">16-8-2：多表查询</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#16-8-2-1%EF%BC%9A%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF%E9%97%AE%E9%A2%98"><span class="toc-number">8.2.1.</span> <span class="toc-text">16-8-2-1：笛卡尔积问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-8-2-2%EF%BC%9A%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">8.2.2.</span> <span class="toc-text">16-8-2-2：笛卡尔积的解决方案</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-8-3%EF%BC%9A%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0"><span class="toc-number">8.3.</span> <span class="toc-text">16-8-3：常见函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#16-8-3-1%EF%BC%9A%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0"><span class="toc-number">8.3.1.</span> <span class="toc-text">16-8-3-1：单行函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-8-3-2%EF%BC%9A%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0"><span class="toc-number">8.3.2.</span> <span class="toc-text">16-8-3-2：聚合函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-8-4%EF%BC%9A%E5%85%B3%E9%94%AE%E5%AD%97-%E8%AF%AD%E5%8F%A5"><span class="toc-number">8.4.</span> <span class="toc-text">16-8-4：关键字&#x2F;语句</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#16-8-4-1%EF%BC%9Atruncate%E3%80%81-delete%E5%8C%BA%E5%88%AB"><span class="toc-number">8.4.1.</span> <span class="toc-text">16-8-4-1：truncate、 delete区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-8-4-2%EF%BC%9Amysql%E7%9A%84having%E7%94%A8%E6%B3%95"><span class="toc-number">8.4.2.</span> <span class="toc-text">16-8-4-2：mysql的having用法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-8-4-3%EF%BC%9Amysql%E4%B8%AD-in-%E5%92%8C-exists-%E5%8C%BA%E5%88%AB"><span class="toc-number">8.4.3.</span> <span class="toc-text">16-8-4-3：mysql中 in 和 exists 区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-8-4-4%EF%BC%9AWHERE%E5%AD%90%E5%8F%A5%E5%92%8CHAVING%E5%AD%90%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E9%80%9F%E5%BA%A6"><span class="toc-number">8.4.4.</span> <span class="toc-text">16-8-4-4：WHERE子句和HAVING子句的执行速度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-8-4-5%EF%BC%9Agroupby%E5%92%8Chaving%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.4.5.</span> <span class="toc-text">16-8-4-5：groupby和having的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-8-4-6%EF%BC%9AUNION%E4%B8%8EUNION-ALL%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">8.4.6.</span> <span class="toc-text">16-8-4-6：UNION与UNION ALL的区别？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-8-4-6%EF%BC%9Acount-%E3%80%81count-1-%E3%80%81count-column-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.4.7.</span> <span class="toc-text">16-8-4-6：count(*)、count(1)、count(column)的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-8-4-7%EF%BC%9AMySQL%EF%BC%8C%E5%B7%A6%E8%BF%9E%E6%8E%A5%E4%B8%ADon%E5%92%8Cwhere%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.4.8.</span> <span class="toc-text">16-8-4-7：MySQL，左连接中on和where的区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-8-5%EF%BC%9A%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%EF%BC%88CURD%EF%BC%89-%E6%97%A5%E5%BF%97"><span class="toc-number">8.5.</span> <span class="toc-text">16-8-5：增删改查（CURD）+ 日志</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#16-8-5-1%EF%BC%9A%E4%B8%80%E6%9D%A1sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">8.5.1.</span> <span class="toc-text">16-8-5-1：一条sql执行过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-8-5-2%EF%BC%9A%E4%B8%80%E6%9D%A1sql%E6%9B%B4%E6%96%B0-%E5%88%A0%E9%99%A4-%E5%A2%9E%E5%8A%A0%E8%AF%AD%E5%8F%A5%E6%97%B6%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E7%9A%84"><span class="toc-number">8.5.2.</span> <span class="toc-text">16-8-5-2：一条sql更新&#x2F;删除&#x2F;增加语句时怎么执行的</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-8-5-3%EF%BC%9A%E6%97%A5%E5%BF%97"><span class="toc-number">8.5.3.</span> <span class="toc-text">16-8-5-3：日志</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-8-5-4%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AFbinlog"><span class="toc-number">8.5.4.</span> <span class="toc-text">16-8-5-4：什么是binlog</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-8-5-5%EF%BC%9Abinlog%E4%B8%80%E8%88%AC%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88"><span class="toc-number">8.5.5.</span> <span class="toc-text">16-8-5-5：binlog一般用来做什么</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-8-5-6%EF%BC%9AMySQL%E7%9A%84binlog%E6%9C%89%E5%87%A0%E7%A7%8D%E5%BD%95%E5%85%A5%E6%A0%BC%E5%BC%8F"><span class="toc-number">8.5.6.</span> <span class="toc-text">16-8-5-6：MySQL的binlog有几种录入格式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-8-5-7%EF%BC%9Aredo-log"><span class="toc-number">8.5.7.</span> <span class="toc-text">16-8-5-7：redo log</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-8-5-8%EF%BC%9Abinlog%E5%92%8Credo-log%E6%AF%94%E8%BE%83"><span class="toc-number">8.5.8.</span> <span class="toc-text">16-8-5-8：binlog和redo log比较</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-8-5-9%EF%BC%9A%E6%88%91%E5%86%99%E5%85%B6%E4%B8%AD%E7%9A%84%E6%9F%90%E4%B8%80%E4%B8%AAlog%EF%BC%8C%E5%A4%B1%E8%B4%A5%E4%BA%86%EF%BC%8C%E9%82%A3%E4%BC%9A%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">8.5.9.</span> <span class="toc-text">16-8-5-9：我写其中的某一个log，失败了，那会怎么办？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-8-5-10%EF%BC%9A%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E6%84%8F%E4%B9%89"><span class="toc-number">8.5.10.</span> <span class="toc-text">16-8-5-10：两阶段提交意义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-8-5-11%EF%BC%9AMySQL%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81redo-log%E5%92%8Cbinlog%E7%9A%84%E6%95%B0%E6%8D%AE%E6%98%AF%E4%B8%80%E8%87%B4%E7%9A%84"><span class="toc-number">8.5.11.</span> <span class="toc-text">16-8-5-11：MySQL如何保证redo log和binlog的数据是一致的</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-8-5-12%EF%BC%9A%E5%A6%82%E6%9E%9C%E6%95%B4%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%95%B0%E6%8D%AE%E9%83%BD%E8%A2%AB%E5%88%A0%E9%99%A4%E4%BA%86%EF%BC%8C%E9%82%A3%E6%88%91%E5%8F%AF%E4%BB%A5%E7%94%A8redo-log%E7%9A%84%E8%AE%B0%E5%BD%95%E6%9D%A5%E6%81%A2%E5%A4%8D%E5%90%97%EF%BC%9F"><span class="toc-number">8.5.12.</span> <span class="toc-text">16-8-5-12：如果整个数据库的数据都被删除了，那我可以用redo log的记录来恢复吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-8-5-13%EF%BC%9AMySQL%E6%9F%A5%E8%AF%A2%E5%AD%97%E6%AE%B5%E5%8C%BA%E4%B8%8D%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99%EF%BC%9F"><span class="toc-number">8.5.13.</span> <span class="toc-text">16-8-5-13：MySQL查询字段区不区分大小写？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-8-5-14%EF%BC%9A%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%9C%80%E8%A6%81%E5%8C%BA%E5%88%86%E8%8B%B1%E6%96%87%E5%A4%A7%E5%B0%8F%E5%86%99%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">8.5.14.</span> <span class="toc-text">16-8-5-14：如何解决需要区分英文大小写的场景</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-8-6%EF%BC%9A%E5%B8%B8%E8%A7%81%E7%BA%A6%E6%9D%9F"><span class="toc-number">8.6.</span> <span class="toc-text">16-8-6：常见约束</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#16-8-6-1%EF%BC%9A%E5%AD%97%E6%AE%B5%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%B1%82%E5%AE%9A%E4%B9%89%E4%B8%BAnot-null"><span class="toc-number">8.6.1.</span> <span class="toc-text">16-8-6-1：字段为什么要求定义为not null?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-8-6-2%EF%BC%9A%E8%B6%85%E9%94%AE%E3%80%81%E5%80%99%E9%80%89%E9%94%AE%E3%80%81%E4%B8%BB%E9%94%AE%E3%80%81%E5%A4%96%E9%94%AE%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">8.6.2.</span> <span class="toc-text">16-8-6-2：超键、候选键、主键、外键分别是什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-8-6-3%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E8%87%AA%E5%A2%9E%E5%88%97%E4%BD%9C%E4%B8%BA%E4%B8%BB%E9%94%AE"><span class="toc-number">8.6.3.</span> <span class="toc-text">16-8-6-3：为什么用自增列作为主键</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-8-6-4%EF%BC%9A%E4%B8%BB%E9%94%AE%E4%BD%BF%E7%94%A8%E8%87%AA%E5%A2%9EID%E8%BF%98%E6%98%AFUUID"><span class="toc-number">8.6.4.</span> <span class="toc-text">16-8-6-4：主键使用自增ID还是UUID?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-8-6-5%EF%BC%9A%E4%BD%BF%E7%94%A8%E8%87%AA%E5%A2%9Eid%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">8.6.5.</span> <span class="toc-text">16-8-6-5：使用自增id的缺点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-8-6-6%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BB%E9%94%AE%E8%87%AA%E5%A2%9E%E6%80%8E%E4%B9%88%E8%8E%B7%E5%8F%96%E4%B8%BB%E9%94%AE%E5%80%BC"><span class="toc-number">8.6.6.</span> <span class="toc-text">16-8-6-6：数据库主键自增怎么获取主键值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-8-6-7%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%B0%BD%E9%87%8F%E8%AE%BE%E5%AE%9A%E4%B8%80%E4%B8%AA%E4%B8%BB%E9%94%AE"><span class="toc-number">8.6.7.</span> <span class="toc-text">16-8-6-7：为什么要尽量设定一个主键?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-9%EF%BC%9Asql%E5%AE%9E%E6%88%98"><span class="toc-number">9.</span> <span class="toc-text">16-9：sql实战</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#16-9-1%EF%BC%9A%E5%8E%BB%E9%87%8D%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE"><span class="toc-number">9.1.</span> <span class="toc-text">16-9-1：去重重复数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-9-2%EF%BC%9AMySQL-%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E7%8E%87%E9%9A%8F%E6%9C%BA%E8%8E%B7%E5%8F%96N%E6%9D%A1%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="toc-number">9.2.</span> <span class="toc-text">16-9-2：MySQL 如何高效率随机获取N条数据？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-10-%E4%BA%8B%E5%8A%A1"><span class="toc-number">10.</span> <span class="toc-text">16-10:事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#16-10-1%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1"><span class="toc-number">10.1.</span> <span class="toc-text">16-10-1：什么是事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-10-2%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7"><span class="toc-number">10.2.</span> <span class="toc-text">16-10-2：数据库事务特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-10-3%EF%BC%9AACID%E9%9D%A0%E4%BB%80%E4%B9%88%E4%BF%9D%E8%AF%81%E7%9A%84-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">10.3.</span> <span class="toc-text">16-10-3：ACID靠什么保证的(底层原理)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#16-10-3-1%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AFundo-log"><span class="toc-number">10.3.1.</span> <span class="toc-text">16-10-3-1：什么是undo log</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-10-4%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B4%A9%E6%BA%83%E6%97%B6%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%81%A2%E5%A4%8D%E6%9C%BA%E5%88%B6"><span class="toc-number">10.4.</span> <span class="toc-text">16-10-4：数据库崩溃时事务的恢复机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-10-5%EF%BC%9A%E5%9C%A8%E5%B9%B6%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8B-%E4%BA%8B%E5%8A%A1%E4%BC%9A%E5%8F%91%E7%94%9F%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="toc-number">10.5.</span> <span class="toc-text">16-10-5：在并发环境下,事务会发生哪些问题?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#16-10-5-1%EF%BC%9A%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%92%8C%E5%B9%BB%E8%AF%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.5.1.</span> <span class="toc-text">16-10-5-1：不可重复读和幻读的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-10-5-2%EF%BC%9A%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB"><span class="toc-number">10.5.2.</span> <span class="toc-text">16-10-5-2：如何解决幻读</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-10-6%EF%BC%9A%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="toc-number">10.6.</span> <span class="toc-text">16-10-6：如何解决事务并发问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-10-7%EF%BC%9A%E5%9B%9B%E5%A4%A7%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">10.7.</span> <span class="toc-text">16-10-7：四大隔离级别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#16-10-7-1%EF%BC%9A%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">10.7.1.</span> <span class="toc-text">16-10-7-1：隔离级别的原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-10-7-2%EF%BC%9AMySQL-%E4%B8%ADRC%EF%BC%88%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4%EF%BC%89%E5%92%8CRR%EF%BC%88%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%EF%BC%89%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.7.2.</span> <span class="toc-text">16-10-7-2：MySQL 中RC（读已提交）和RR（可重复读）隔离级别的区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-10-8%EF%BC%9A%E5%A6%82%E4%BD%95%E6%89%8B%E5%8A%A8%E5%A4%84%E7%90%86%E4%BA%8B%E5%8A%A1"><span class="toc-number">10.8.</span> <span class="toc-text">16-10-8：如何手动处理事务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-11%EF%BC%9A%E5%BC%95%E6%93%8E"><span class="toc-number">11.</span> <span class="toc-text">16-11：引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#16-11-1%EF%BC%9AMySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8EMyISAM%E4%B8%8EInnoDB%E5%8C%BA%E5%88%AB"><span class="toc-number">11.1.</span> <span class="toc-text">16-11-1：MySQL存储引擎MyISAM与InnoDB区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-11-2%EF%BC%9AInnoDB%E5%BC%95%E6%93%8E%E7%9A%844%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">11.2.</span> <span class="toc-text">16-11-2：InnoDB引擎的4大特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-12%EF%BC%9AMySQl%E9%94%81"><span class="toc-number">12.</span> <span class="toc-text">16-12：MySQl锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#16-12-1%EF%BC%9AMyISAM%E5%92%8CInnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%BD%BF%E7%94%A8%E7%9A%84%E9%94%81"><span class="toc-number">12.1.</span> <span class="toc-text">16-12-1：MyISAM和InnoDB存储引擎使用的锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-12-2%EF%BC%9AInnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9A%84%E9%94%81%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-number">12.2.</span> <span class="toc-text">16-12-2：InnoDB存储引擎的锁的算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-12-3%EF%BC%9AMySQL%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">12.3.</span> <span class="toc-text">16-12-3：MySQL锁的种类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#16-12-3-1%EF%BC%9A%E5%85%B1%E4%BA%AB-%E6%8E%92%E5%AE%83%E9%94%81-Shared-and-Exclusive-Locks"><span class="toc-number">12.3.1.</span> <span class="toc-text">16-12-3-1：共享&#x2F;排它锁(Shared and Exclusive Locks)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-12-3-2%EF%BC%9A%E6%84%8F%E5%90%91%E9%94%81-Intention-Locks"><span class="toc-number">12.3.2.</span> <span class="toc-text">16-12-3-2：意向锁(Intention Locks)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-12-3-4%EF%BC%9A%E8%AE%B0%E5%BD%95%E9%94%81-Record-Locks"><span class="toc-number">12.3.3.</span> <span class="toc-text">16-12-3-4：记录锁(Record Locks)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-12-3-5%EF%BC%9A%E9%97%B4%E9%9A%99%E9%94%81-Gap-Locks"><span class="toc-number">12.3.4.</span> <span class="toc-text">16-12-3-5：间隙锁(Gap Locks)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-12-3-6%EF%BC%9A%E4%B8%B4%E9%94%AE%E9%94%81-Next-key-Locks"><span class="toc-number">12.3.5.</span> <span class="toc-text">16-12-3-6：临键锁(Next-key Locks)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-12-3-7%EF%BC%9A%E8%87%AA%E5%A2%9E%E9%94%81-Auto-inc-Locks"><span class="toc-number">12.3.6.</span> <span class="toc-text">16-12-3-7：自增锁(Auto-inc Locks)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-12-4%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E6%AD%BB%E9%94%81%E7%9A%84%E9%A2%84%E9%98%B2%E4%B8%8E%E8%A7%A3%E9%99%A4"><span class="toc-number">12.4.</span> <span class="toc-text">16-12-4：数据库死锁的预防与解除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-12-5%EF%BC%9A%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6MVCC"><span class="toc-number">12.5.</span> <span class="toc-text">16-12-5：多版本并发控制MVCC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-12-6%EF%BC%9A%E5%93%AA%E4%BA%9B%E8%AF%BB%E6%93%8D%E4%BD%9C%E6%98%AF%E5%BF%AB%E7%85%A7%E8%AF%BB%EF%BC%9F%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%E5%8F%88%E6%98%AF%E5%BD%93%E5%89%8D%E8%AF%BB%E5%91%A2%EF%BC%9F"><span class="toc-number">12.6.</span> <span class="toc-text">16-12-6：哪些读操作是快照读？哪些操作又是当前读呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-12-7%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B0%86-%E6%8F%92%E5%85%A5-%E6%9B%B4%E6%96%B0-%E5%88%A0%E9%99%A4-%E6%93%8D%E4%BD%9C%EF%BC%8C%E9%83%BD%E5%BD%92%E4%B8%BA%E5%BD%93%E5%89%8D%E8%AF%BB"><span class="toc-number">12.7.</span> <span class="toc-text">16-12-7：为什么将 插入&#x2F;更新&#x2F;删除 操作，都归为当前读</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-13%EF%BC%9A%E7%B4%A2%E5%BC%95"><span class="toc-number">13.</span> <span class="toc-text">16-13：索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#16-13-1%EF%BC%9A%E4%B8%BB%E9%94%AE%E4%B8%8E%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">13.1.</span> <span class="toc-text">16-13-1：主键与索引的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-13-2%EF%BC%9A%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">13.2.</span> <span class="toc-text">16-13-2：索引的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#16-13-2-1%EF%BC%9A%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="toc-number">13.2.1.</span> <span class="toc-text">16-13-2-1：联合索引失效的条件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-13-2-2%EF%BC%9A%E5%8D%95%E5%88%97%E7%B4%A2%E5%BC%95%E5%92%8C%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%8C%BA%E5%88%AB"><span class="toc-number">13.2.2.</span> <span class="toc-text">16-13-2-2：单列索引和联合索引区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-13-3%EF%BC%9A%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E5%92%8C%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">13.3.</span> <span class="toc-text">16-13-3：主键索引和普通索引的工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-13-4%EF%BC%9A%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">13.4.</span> <span class="toc-text">16-13-4：覆盖索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-13-5%EF%BC%9Amysql%E7%B4%A2%E5%BC%95%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">13.5.</span> <span class="toc-text">16-13-5：mysql索引的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#16-13-5-1%EF%BC%9AB-%E6%A0%91%E6%AF%94B%E6%A0%91%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">13.5.1.</span> <span class="toc-text">16-13-5-1：B+树比B树的优势</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-13-5-2%EF%BC%9AB-%E6%A0%91%E4%B8%8E%E7%BA%A2%E9%BB%91%E6%A0%91%E6%AF%94%E8%BE%83"><span class="toc-number">13.5.2.</span> <span class="toc-text">16-13-5-2：B+树与红黑树比较</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-13-5-3%EF%BC%9AB-%E6%A0%91%E4%B8%8Ehash%E7%B4%A2%E5%BC%95%E6%AF%94%E8%BE%83"><span class="toc-number">13.5.3.</span> <span class="toc-text">16-13-5-3：B+树与hash索引比较</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-13-6%EF%BC%9A%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E4%B8%8E%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E6%A6%82%E5%BF%B5"><span class="toc-number">13.6.</span> <span class="toc-text">16-13-6：聚簇索引与非聚簇索引概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#16-13-6-1%EF%BC%9A%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">13.6.1.</span> <span class="toc-text">16-13-6-1：聚簇索引的优缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-13-7%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%B4%A2%E5%BC%95%EF%BC%88%E4%BC%98%E7%82%B9%EF%BC%89"><span class="toc-number">13.7.</span> <span class="toc-text">16-13-7：为什么要用索引（优点）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-13-8%EF%BC%9A%E7%B4%A2%E5%BC%95%E8%BF%99%E4%B9%88%E5%A4%9A%E4%BC%98%E7%82%B9%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%AF%B9%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%AF%8F%E4%B8%80%E4%B8%AA%E5%88%97%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%B4%A2%E5%BC%95%E5%91%A2%EF%BC%9F%EF%BC%88%E7%BC%BA%E7%82%B9%EF%BC%89"><span class="toc-number">13.8.</span> <span class="toc-text">16-13-8：索引这么多优点，为什么不对表中的每一个列创建一个索引呢？（缺点）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-13-9%EF%BC%9A%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E5%8E%9F%E5%88%99%EF%BC%88%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%89"><span class="toc-number">13.9.</span> <span class="toc-text">16-13-9：创建索引原则（使用场景）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-13-10%EF%BC%9A%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86"><span class="toc-number">13.10.</span> <span class="toc-text">16-13-10：最左前缀原则内部原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-13-11%EF%BC%9A%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">13.11.</span> <span class="toc-text">16-13-11：创建索引的三种方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-13-12%EF%BC%9A%E7%B4%A2%E5%BC%95%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%9B%B4%E6%8E%A5%E4%BF%9D%E5%AD%98%E7%9A%84%E8%AE%B0%E5%BD%95%E5%9C%B0%E5%9D%80%E8%80%8C%E8%A6%81%E5%AD%98%E4%B8%BB%E9%94%AE%E9%94%AE%E5%80%BC"><span class="toc-number">13.12.</span> <span class="toc-text">16-13-12：索引叶子节点为什么不直接保存的记录地址而要存主键键值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-14-%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88"><span class="toc-number">14.</span> <span class="toc-text">16-14.优化方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#16-14-1%EF%BC%9Aexplain%EF%BC%88%E4%BC%98%E5%8C%96%EF%BC%89"><span class="toc-number">14.1.</span> <span class="toc-text">16-14-1：explain（优化）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-14-2%EF%BC%9Aexplain%E4%B8%BB%E8%A6%81%E5%8C%85%E5%90%AB%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-number">14.2.</span> <span class="toc-text">16-14-2：explain主要包含的信息</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#16-14-2-1%EF%BC%9Aid"><span class="toc-number">14.2.1.</span> <span class="toc-text">16-14-2-1：id</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-14-2-2%EF%BC%9Aselect-type"><span class="toc-number">14.2.2.</span> <span class="toc-text">16-14-2-2：select_type</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-14-2-3%EF%BC%9Atype"><span class="toc-number">14.2.3.</span> <span class="toc-text">16-14-2-3：type</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-14-3%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BC%98%E5%8C%96"><span class="toc-number">14.3.</span> <span class="toc-text">16-14-3：为什么要优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#16-14-3-1%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BC%98%E5%8C%96%EF%BC%88%E5%A6%82%E6%9E%9Cmysql%E6%95%B0%E6%8D%AE%E8%BF%87%E5%A4%9A%EF%BC%8C%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86%EF%BC%89"><span class="toc-number">14.3.1.</span> <span class="toc-text">16-14-3-1：数据库的优化（如果mysql数据过多，如何进行处理）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-14-3-2%EF%BC%9A%E5%88%9B%E5%BB%BA%E6%97%B6%E4%BC%98%E5%8C%96"><span class="toc-number">14.3.2.</span> <span class="toc-text">16-14-3-2：创建时优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-14-3-3%EF%BC%9A%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96"><span class="toc-number">14.3.3.</span> <span class="toc-text">16-14-3-3：索引优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-14-3-4%EF%BC%9A%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">14.3.4.</span> <span class="toc-text">16-14-3-4：查询优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-14-3-5%EF%BC%9A%E4%B8%80%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%BE%97%E5%BE%88%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">14.3.5.</span> <span class="toc-text">16-14-3-5：一条SQL语句执行得很慢的原因有哪些</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-14-3-6%EF%BC%9A%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">14.3.6.</span> <span class="toc-text">16-14-3-6：分页查询优化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-14-4%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%9A%E9%80%89%E9%94%99%E4%BA%86%E7%B4%A2%E5%BC%95"><span class="toc-number">14.4.</span> <span class="toc-text">16-14-4：为什么数据库会选错了索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-16%EF%BC%9A%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">15.</span> <span class="toc-text">16-16：主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#16-16-1%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">15.1.</span> <span class="toc-text">16-16-1：什么是主从复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-16-2%EF%BC%9A%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%88%E5%A5%BD%E5%A4%84%EF%BC%8C%E6%88%96%E8%80%85%E8%AF%B4%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%81%9A%E4%B8%BB%E4%BB%8E%EF%BC%89"><span class="toc-number">15.2.</span> <span class="toc-text">16-16-2：主从复制的作用（好处，或者说为什么要做主从）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-16-3%EF%BC%9A%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%88%E9%87%8D%E4%B8%AD%E4%B9%8B%E9%87%8D%EF%BC%8C%E9%9D%A2%E8%AF%95%E5%BF%85%E9%97%AE%EF%BC%89"><span class="toc-number">15.3.</span> <span class="toc-text">16-16-3：主从复制的原理（重中之重，面试必问）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-16-4%EF%BC%9A%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">15.4.</span> <span class="toc-text">16-16-4：主从复制的几种方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-17%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B1%A0%E4%B8%8EJDBC"><span class="toc-number">16.</span> <span class="toc-text">16-17：数据库池与JDBC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#16-17-1%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%EF%BC%9F"><span class="toc-number">16.1.</span> <span class="toc-text">16-17-1：什么是数据库连接池？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-17-2%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%A7%8D%E7%B1%BB"><span class="toc-number">16.2.</span> <span class="toc-text">16-17-2：数据库连接池种类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-17-3%EF%BC%9A%E4%BC%A0%E7%BB%9F%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%9C%BA%E5%88%B6%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%8C%BA%E5%88%AB"><span class="toc-number">16.3.</span> <span class="toc-text">16-17-3：传统的连接机制与数据库连接池的运行机制区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-17-4%EF%BC%9A%E8%AF%B4%E8%AF%B4%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">16.4.</span> <span class="toc-text">16-17-4：说说数据库连接池工作原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-18%EF%BC%9A%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-number">17.</span> <span class="toc-text">16-18：分库分表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#16-18-1%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%EF%BC%9F"><span class="toc-number">17.1.</span> <span class="toc-text">16-18-1：为什么要分库分表？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-18-2%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%88%86%E8%A1%A8"><span class="toc-number">17.2.</span> <span class="toc-text">16-18-2：数据分表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-18-3%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%88%86%E5%BA%93"><span class="toc-number">17.3.</span> <span class="toc-text">16-18-3：数据分库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-18-4%EF%BC%9A%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">17.4.</span> <span class="toc-text">16-18-4：分库分表带来的问题</span></a></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/3cd8af52/" title="Integer源码解析">Integer源码解析</a><time datetime="2021-03-17T05:37:08.000Z" title="发表于 2021-03-17 13:37:08">2021-03-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/abb154f4/" title="ArrayList源码解析">ArrayList源码解析</a><time datetime="2021-03-12T05:36:21.000Z" title="发表于 2021-03-12 13:36:21">2021-03-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/a2a7cca8/" title="HashMap源码解析">HashMap源码解析</a><time datetime="2021-03-10T09:21:46.000Z" title="发表于 2021-03-10 17:21:46">2021-03-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/a7ef9c4d/" title="Java面试题">Java面试题</a><time datetime="2021-02-26T05:37:39.000Z" title="发表于 2021-02-26 13:37:39">2021-02-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/81f10c79/" title="常量池">常量池</a><time datetime="2021-02-25T05:43:24.000Z" title="发表于 2021-02-25 13:43:24">2021-02-25</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 失铭</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="icp"><a target="_blank" rel="noopener" href="http://beian.miit.gov.cn/"><img class="icp-icon" src="/img/icp.png" alt="ICP"/><span>渝ICP备2020010262号</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.spacingElementById('content-inner')
  else {
    $.getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js', () => {
      pangu.spacingElementById('content-inner')
    })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguFn)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    let initData = {
      el: '#vcomment',
      appId: '8AI4XAeM1WByt61C1hTs3U7f-MdYXbMMI',
      appKey: 'TxTEH6NbG1UeKnrlAFuRIcDH',
      placeholder: '给我的文章加点评论吧~',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    }

    if (true) { 
      initData.requiredFields= ('nick'.split(','))
    }
    
    if (false) {
      const otherData = false
      initData = Object.assign({}, initData, otherData)
    }
    
    const valine = new Valine(initData)
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script></div></body></html>