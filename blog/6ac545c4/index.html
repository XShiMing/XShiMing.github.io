<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>面试题-Java基础 | 失铭的日记</title><meta name="keywords" content="Java基础"><meta name="author" content="失铭"><meta name="copyright" content="失铭"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="1：Java 特性1-1：Java 特点 简单性 面向对象 分布式 健壮性 安全性 体系结构中立 可移植性 解释型 高性能 多线程 动态性  1-2：JVM\JRE\JDK\JIT JDK：Java Development Kit 的简称，Java 开发工具包，提供了 Java 的开发环境和运行环境。 JRE：Java Runtime Environment 的简称，Java 运行环境，为 Jav">
<meta property="og:type" content="article">
<meta property="og:title" content="面试题-Java基础">
<meta property="og:url" content="https://shiming.best/blog/6ac545c4/index.html">
<meta property="og:site_name" content="失铭的日记">
<meta property="og:description" content="1：Java 特性1-1：Java 特点 简单性 面向对象 分布式 健壮性 安全性 体系结构中立 可移植性 解释型 高性能 多线程 动态性  1-2：JVM\JRE\JDK\JIT JDK：Java Development Kit 的简称，Java 开发工具包，提供了 Java 的开发环境和运行环境。 JRE：Java Runtime Environment 的简称，Java 运行环境，为 Jav">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://image.shiming.online/guidao/pic-88.jpg">
<meta property="article:published_time" content="2021-04-28T08:36:58.000Z">
<meta property="article:modified_time" content="2021-04-28T08:36:58.000Z">
<meta property="article:author" content="失铭">
<meta property="article:tag" content="Java基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://image.shiming.online/guidao/pic-88.jpg"><link rel="shortcut icon" href="https://image.shiming.online/background/favicon.ico"><link rel="canonical" href="https://shiming.best/blog/6ac545c4/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-04-28 16:36:58'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><link rel="stylesheet" href="/css/background.css"><link rel="stylesheet" href="/css/gdt.css"><link rel="stylesheet" href="/css/foot.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1995009_6m1bfgtzjiv.css"><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="失铭的日记" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="https://image.shiming.online/background/info.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">116</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">61</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">33</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/Java/%E6%BA%90%E7%A0%81/"><i class="fa-fw iconfont icon-CodeApplicationDevelopmentProgrammingSoftware"></i><span> 源码</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-32shejimoshi"></i><span> 设计模式</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/blog/41682/"><i class="fa-fw iconfont icon-dashujukeshihuaico--copy"></i><span> 设计模式</span></a></li><li><a class="site-page" href="/blog/8f9f2030/"><i class="fa-fw iconfont icon-chuangjian"></i><span> 创建型模式</span></a></li><li><a class="site-page" href="/blog/620ff0b5/"><i class="fa-fw iconfont icon-jiegou"></i><span> 结构型模式</span></a></li><li><a class="site-page" href="/blog/e55dcfb0/"><i class="fa-fw iconfont icon-hangwei"></i><span> 行为型模式</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-lianjie"></i><span> 链接库</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-shoucang"></i><span> 收藏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-qita1"></i><span> 其他</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw iconfont icon-GoogleMaterialicmusicnotepx"></i><span> 音乐</span></a></li><li><a class="site-page" href="/2020/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></li></ul></div></div></div></div><div id="body-wrap"><header class="no-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">失铭的日记</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/Java/%E6%BA%90%E7%A0%81/"><i class="fa-fw iconfont icon-CodeApplicationDevelopmentProgrammingSoftware"></i><span> 源码</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-32shejimoshi"></i><span> 设计模式</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/blog/41682/"><i class="fa-fw iconfont icon-dashujukeshihuaico--copy"></i><span> 设计模式</span></a></li><li><a class="site-page" href="/blog/8f9f2030/"><i class="fa-fw iconfont icon-chuangjian"></i><span> 创建型模式</span></a></li><li><a class="site-page" href="/blog/620ff0b5/"><i class="fa-fw iconfont icon-jiegou"></i><span> 结构型模式</span></a></li><li><a class="site-page" href="/blog/e55dcfb0/"><i class="fa-fw iconfont icon-hangwei"></i><span> 行为型模式</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-lianjie"></i><span> 链接库</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-shoucang"></i><span> 收藏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-qita1"></i><span> 其他</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw iconfont icon-GoogleMaterialicmusicnotepx"></i><span> 音乐</span></a></li><li><a class="site-page" href="/2020/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></li></ul></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">面试题-Java基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-04-28T08:36:58.000Z" title="发表于 2021-04-28 16:36:58">2021-04-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-04-28T08:36:58.000Z" title="更新于 2021-04-28 16:36:58">2021-04-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%85%B6%E4%BB%96/">其他</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%85%B6%E4%BB%96/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>18分钟</span></span></div></div></div><article class="post-content" id="article-container"><h2 id="1：Java-特性"><a href="#1：Java-特性" class="headerlink" title="1：Java 特性"></a>1：Java 特性</h2><h3 id="1-1：Java-特点"><a href="#1-1：Java-特点" class="headerlink" title="1-1：Java 特点"></a>1-1：Java 特点</h3><ol>
<li>简单性</li>
<li>面向对象</li>
<li>分布式</li>
<li>健壮性</li>
<li>安全性</li>
<li>体系结构中立</li>
<li>可移植性</li>
<li>解释型</li>
<li>高性能</li>
<li>多线程</li>
<li>动态性</li>
</ol>
<h3 id="1-2：JVM-JRE-JDK-JIT"><a href="#1-2：JVM-JRE-JDK-JIT" class="headerlink" title="1-2：JVM\JRE\JDK\JIT"></a>1-2：JVM\JRE\JDK\JIT</h3><ul>
<li>JDK：<code>Java Development Kit</code> 的简称，Java 开发工具包，提供了 Java 的开发环境和运行环境。</li>
<li>JRE：<code>Java Runtime Environment</code> 的简称，Java 运行环境，为 Java 的运行提供了所需环境。</li>
<li>JVM：<code>Java Virtual Machine</code>，Java 虚拟机。</li>
<li>JIT：<code>Just-In-Time Compiler</code>，即时编译器。</li>
</ul>
<p>JDK 包含 JRE 和编译器 Javac，还包含很多 Java 程序调试和分析的工具。JRE（Java 运行时环境）包含虚拟机但是不包含编译器。<br>简单来说：如果需要运行 Java 程序，只需安装 JRE ，如果需要编写 Java 程序，则需要安装 JDK。</p>
<h3 id="1-3：变量的初始化顺序"><a href="#1-3：变量的初始化顺序" class="headerlink" title="1-3：变量的初始化顺序"></a>1-3：变量的初始化顺序</h3><ol>
<li>父类静态代码块</li>
<li>子类静态代码块</li>
<li>父类成员代码块</li>
<li>父类构造函数</li>
<li>子类成员代码块</li>
<li>子类构造函数</li>
</ol>
<p>静态代码块和非静态代码块按顺序加载。</p>
<h3 id="1-4：⾯向过程性能⽐⾯向对象⾼"><a href="#1-4：⾯向过程性能⽐⾯向对象⾼" class="headerlink" title="1-4：⾯向过程性能⽐⾯向对象⾼"></a>1-4：⾯向过程性能⽐⾯向对象⾼</h3><p>因为类加载过程需要实例化，比较消耗资源，但是面向对象的特征又使得程序易维护，易复用，易扩展。</p>
<p>但是面向过程也需要分配内存，计算内存偏移量，Java 性能差的主要原因并不是因为它是面向对象语言，而是 Java 是半编译语言，最终的执行代码并不是可以直接被 CPU 执行的二进制机械码。而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定比 Java 好。</p>
<h3 id="1-5：持久化对象三种状态"><a href="#1-5：持久化对象三种状态" class="headerlink" title="1-5：持久化对象三种状态"></a>1-5：持久化对象三种状态</h3><p>瞬态，持久化，托管。</p>
<h2 id="2：Java-基础-面对对象-OOP"><a href="#2：Java-基础-面对对象-OOP" class="headerlink" title="2：Java 基础-面对对象(OOP)"></a>2：Java 基础-面对对象(OOP)</h2><h3 id="2-1：面向对象的原则"><a href="#2-1：面向对象的原则" class="headerlink" title="2-1：面向对象的原则"></a>2-1：面向对象的原则</h3><ol>
<li>单一职责原则（Single Responsibility Principle）<br>每一个类应该专注于做一件事情。</li>
<li>里氏替换原则（Liskov Substitution Principle）<br>超类存在的地方，子类是可以替换的。</li>
<li>依赖倒置原则（Dependence Inversion Principle）<br>实现尽量依赖抽象，不依赖具体实现。</li>
<li>接口隔离原则（Interface Segregation Principle）<br>应当为客户端提供尽可能小的单独的接口，而不是提供大的总的接口。</li>
<li>迪米特法则（Law Of Demeter）<br>又叫最少知识原则，一个软件实体应当尽可能少的与其他实体发生相互作用。</li>
<li>开闭原则（Open Close Principle）<br>面向扩展开放，面向修改关闭。</li>
<li>组合/聚合复用原则（Composite/Aggregate Reuse Principle CARP）<br>尽量使用合成/聚合达到复用，尽量少用继承。原则： 一个类中有另一个类的对象。</li>
</ol>
<h3 id="2-2：Java-类以及类的成员"><a href="#2-2：Java-类以及类的成员" class="headerlink" title="2-2：Java 类以及类的成员"></a>2-2：Java 类以及类的成员</h3><h4 id="2-2-1：属性"><a href="#2-2-1：属性" class="headerlink" title="2-2-1：属性"></a>2-2-1：属性</h4><h5 id="2-2-1-1：属性与局部变量的相同点、不同点"><a href="#2-2-1-1：属性与局部变量的相同点、不同点" class="headerlink" title="2-2-1-1：属性与局部变量的相同点、不同点"></a>2-2-1-1：属性与局部变量的相同点、不同点</h5><ol>
<li>属性直接声明在类里边，方法外边的变量为属性变量，直接声明在方法里边的变量为局部变量。</li>
<li>属性变量有默认值，在使用之前不要求一定赋值，局部变量没有默认值，在使用之前一定要被赋值。</li>
<li>属性变量可以有权限修饰符修饰，局部变量不能用权限修饰符修饰。</li>
<li>属性变量的作用范围在整个类中，局部变量的作用范围在所属代码段中。</li>
<li>属性变量可以由 static 修饰，局部变量不能由 static 修饰。</li>
</ol>
<h4 id="2-2-2：Java-基础-构造器"><a href="#2-2-2：Java-基础-构造器" class="headerlink" title="2-2-2：Java 基础-构造器"></a>2-2-2：Java 基础-构造器</h4><h4 id="2-2-2-1：⼀个类的构造⽅法的作⽤是什么"><a href="#2-2-2-1：⼀个类的构造⽅法的作⽤是什么" class="headerlink" title="2-2-2-1：⼀个类的构造⽅法的作⽤是什么"></a>2-2-2-1：⼀个类的构造⽅法的作⽤是什么</h4><p>完成对象的初始化。</p>
<h4 id="2-2-2-2：构造⽅法有哪些特性？"><a href="#2-2-2-2：构造⽅法有哪些特性？" class="headerlink" title="2-2-2-2：构造⽅法有哪些特性？"></a>2-2-2-2：构造⽅法有哪些特性？</h4><p>无返回值，不可重写，不可以用<code>static</code>，<code>synchronized</code>，<code>abstart</code>，<code>final</code>修饰。方法名和类名相同。</p>
<h4 id="2-2-2-3：构造方法可不可以被重写和重载"><a href="#2-2-2-3：构造方法可不可以被重写和重载" class="headerlink" title="2-2-2-3：构造方法可不可以被重写和重载"></a>2-2-2-3：构造方法可不可以被重写和重载</h4><p>构造方法可以重载，不可以重写。</p>
<h4 id="2-2-2-4：构造函数能用-private-修饰吗"><a href="#2-2-2-4：构造函数能用-private-修饰吗" class="headerlink" title="2-2-2-4：构造函数能用 private 修饰吗"></a>2-2-2-4：构造函数能用 private 修饰吗</h4><p>构造方法可以用 private 修饰，保证只有内部方法可以通过这个构造。</p>
<h3 id="2-3：面对对象三大特性"><a href="#2-3：面对对象三大特性" class="headerlink" title="2-3：面对对象三大特性"></a>2-3：面对对象三大特性</h3><blockquote>
<p>来自维基百科：面向对象程序设计（英语：Object-oriented programming，缩写：OOP）是种具有对象概念的编程典范，同时也是一种程序开发的抽象方针。它可能包含数据、属性、代码与方法。对象则指的是类（class）的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性，对象里的程序可以访问及经常修改对象相关联的数据。在面向对象程序编程里，计算机程序会被设计成彼此相关的对象。</p>
</blockquote>
<h4 id="2-3-1：封装"><a href="#2-3-1：封装" class="headerlink" title="2-3-1：封装"></a>2-3-1：封装</h4><p>封装（数据安全）：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。</p>
<h5 id="2-3-1-1：封装的应用场景"><a href="#2-3-1-1：封装的应用场景" class="headerlink" title="2-3-1-1：封装的应用场景"></a>2-3-1-1：封装的应用场景</h5><ol>
<li>控制访问范围</li>
<li>代码复用</li>
<li>隐藏实现细节</li>
</ol>
<h4 id="2-3-2：继承"><a href="#2-3-2：继承" class="headerlink" title="2-3-2：继承"></a>2-3-2：继承</h4><h5 id="2-3-2-1：什么是继承"><a href="#2-3-2-1：什么是继承" class="headerlink" title="2-3-2-1：什么是继承"></a>2-3-2-1：什么是继承</h5><p>继承（代码复用）：在已存在的类的基础上扩展新类，提高代码的复用，程序的可维护性，节省大量创建新类的时间，提高效率。</p>
<h5 id="2-3-2-2：继承的应用场景"><a href="#2-3-2-2：继承的应用场景" class="headerlink" title="2-3-2-2：继承的应用场景"></a>2-3-2-2：继承的应用场景</h5><p>对现存场景修改，维护</p>
<h4 id="2-3-3：多态"><a href="#2-3-3：多态" class="headerlink" title="2-3-3：多态"></a>2-3-3：多态</h4><p>多态（动态绑定）：多态是同一个行为具有多个不同表现形式或形态的能力。</p>
<h5 id="2-3-3-1：多态的必要条件（实现方式、机制）"><a href="#2-3-3-1：多态的必要条件（实现方式、机制）" class="headerlink" title="2-3-3-1：多态的必要条件（实现方式、机制）"></a>2-3-3-1：多态的必要条件（实现方式、机制）</h5><ol>
<li>继承（实现）</li>
<li>重写</li>
<li>父类引用指向子类实例</li>
</ol>
<h5 id="2-3-3-2：多态的好处"><a href="#2-3-3-2：多态的好处" class="headerlink" title="2-3-3-2：多态的好处"></a>2-3-3-2：多态的好处</h5><p>在不同情形可以更方便的调用不同方法，设计模式就经常使用多态来实现。通过实现同一接口的不同具体实现，来调用方法名相同但是具体效果不同的方法。</p>
<h5 id="2-3-3-3：多态的例子"><a href="#2-3-3-3：多态的例子" class="headerlink" title="2-3-3-3：多态的例子"></a>2-3-3-3：多态的例子</h5><p>策略模式，状态模式，设计模式基本都有多态。</p>
<h3 id="2-4：抽象"><a href="#2-4：抽象" class="headerlink" title="2-4：抽象"></a>2-4：抽象</h3><h4 id="2-4-1：Java-抽象类可以有构造函数吗？作用是什么"><a href="#2-4-1：Java-抽象类可以有构造函数吗？作用是什么" class="headerlink" title="2-4-1：Java 抽象类可以有构造函数吗？作用是什么"></a>2-4-1：Java 抽象类可以有构造函数吗？作用是什么</h4><p>抽象类可以有构造函数，虽然抽象类不能实例化，但是子类可以通过父类构造函数初始化父类属性。</p>
<h4 id="2-4-2：Java-抽象类可以实现接口吗？-它们需要实现所有的方法吗"><a href="#2-4-2：Java-抽象类可以实现接口吗？-它们需要实现所有的方法吗" class="headerlink" title="2-4-2：Java 抽象类可以实现接口吗？ 它们需要实现所有的方法吗"></a>2-4-2：Java 抽象类可以实现接口吗？ 它们需要实现所有的方法吗</h4><p>抽象类可以实现接口，不需要实现所有，因为抽象类自身也有抽象方法。</p>
<h4 id="2-4-3：Java-抽象类可以是-final-的吗"><a href="#2-4-3：Java-抽象类可以是-final-的吗" class="headerlink" title="2-4-3：Java 抽象类可以是 final 的吗"></a>2-4-3：Java 抽象类可以是 final 的吗</h4><p>不可以，因为抽象类就是用来继承的。</p>
<h4 id="2-4-4：Java-抽象类可以有-static-方法吗"><a href="#2-4-4：Java-抽象类可以有-static-方法吗" class="headerlink" title="2-4-4：Java 抽象类可以有 static 方法吗"></a>2-4-4：Java 抽象类可以有 static 方法吗</h4><p>可以</p>
<h4 id="2-4-5：可以创建抽象类的实例吗（new-类）"><a href="#2-4-5：可以创建抽象类的实例吗（new-类）" class="headerlink" title="2-4-5：可以创建抽象类的实例吗（new 类）"></a>2-4-5：可以创建抽象类的实例吗（new 类）</h4><p>不可以</p>
<h4 id="2-4-6：抽象类必须有抽象方法吗"><a href="#2-4-6：抽象类必须有抽象方法吗" class="headerlink" title="2-4-6：抽象类必须有抽象方法吗"></a>2-4-6：抽象类必须有抽象方法吗</h4><p>不一定，只是无论有没有抽象方法抽象类都不能实例化。</p>
<h4 id="2-4-7：何时选用抽象类而不是接口"><a href="#2-4-7：何时选用抽象类而不是接口" class="headerlink" title="2-4-7：何时选用抽象类而不是接口"></a>2-4-7：何时选用抽象类而不是接口</h4><p>接口被用于常用的功能，便于日后维护和添加删除，而抽象类更倾向于充当公共类的角色，不适用于日后重新对立面的代码修改。功能需要累积时用抽象类，不需要累积时用接口。</p>
<h4 id="2-4-8：Java-中的抽象方法是什么"><a href="#2-4-8：Java-中的抽象方法是什么" class="headerlink" title="2-4-8：Java 中的抽象方法是什么"></a>2-4-8：Java 中的抽象方法是什么</h4><p>用<code>abstract</code>修饰的没有方法体的方法。</p>
<h4 id="2-4-9：Java-抽象类中可以包含-main-方法吗"><a href="#2-4-9：Java-抽象类中可以包含-main-方法吗" class="headerlink" title="2-4-9：Java 抽象类中可以包含 main 方法吗"></a>2-4-9：Java 抽象类中可以包含 main 方法吗</h4><p>可以</p>
<h3 id="2-5：面对对象区别"><a href="#2-5：面对对象区别" class="headerlink" title="2-5：面对对象区别"></a>2-5：面对对象区别</h3><h4 id="2-5-1：接⼝和抽象类的区别"><a href="#2-5-1：接⼝和抽象类的区别" class="headerlink" title="2-5-1：接⼝和抽象类的区别"></a>2-5-1：接⼝和抽象类的区别</h4><p>相同点：</p>
<ol>
<li>都不能被实例化。</li>
<li>接口的实现类或抽象类的子类都只有实现了接口或抽象类中的抽象方法后才能实例化。</li>
</ol>
<p>不同点：</p>
<ol>
<li>接口只有定义，不能有方法的实现，Java 1.8 中可以定义 default 方法体，而抽象类可以有定义与实现，方法可在抽象类中实现。</li>
<li>实现接口的关键字为 implements，继承抽象类的关键字为 extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。</li>
<li>接口强调特定功能的实现，而抽象类强调所属关系。</li>
<li>接口成员变量默认为 public static final，必须赋初值，不能被修改；其所有的成员方法都是 public、abstract 的。抽象类中成员变量默认 default，可在子类中被重新定义，也可被重新赋值；抽象方法被 abstract 修饰，不能被 private、static、synchronized 和 native 等修饰，必须以分号结尾，不带花括号。</li>
<li>接口被用于常用的功能，便于日后维护和添加删除，而抽象类更倾向于充当公共类的角色，不适用于日后重新对立面的代码修改。功能需要累积时用抽象类，不需要累积时用接口。</li>
</ol>
<h4 id="2-5-2：继承和实现区别"><a href="#2-5-2：继承和实现区别" class="headerlink" title="2-5-2：继承和实现区别"></a>2-5-2：继承和实现区别</h4><p>一个类只能继承一个类，但是能实现多个接口。</p>
<h4 id="2-5-3：为什么要设计接口、抽象类还有实现类"><a href="#2-5-3：为什么要设计接口、抽象类还有实现类" class="headerlink" title="2-5-3：为什么要设计接口、抽象类还有实现类"></a>2-5-3：为什么要设计接口、抽象类还有实现类</h4><p>设计模式中的桥接模式其实就是将一个类的复杂属性用抽象类和接口拆分。例如红球，篮球，红色正方体，蓝色正方体，将球和正方体拆分为抽象类形状，颜色拆分为接口。通过这种方式使代码易维护，易扩展，易复用。</p>
<h3 id="2-6-Java-基础-关键字"><a href="#2-6-Java-基础-关键字" class="headerlink" title="2-6.Java 基础-关键字"></a>2-6.Java 基础-关键字</h3><h4 id="2-6-1-通过反射访问-private-成员和方法，既然能访问为什么要-private？"><a href="#2-6-1-通过反射访问-private-成员和方法，既然能访问为什么要-private？" class="headerlink" title="2-6-1: 通过反射访问 private 成员和方法，既然能访问为什么要 private？"></a>2-6-1: 通过反射访问 private 成员和方法，既然能访问为什么要 private？</h4><p>private 并不是严格的代码安全，只是提供一般情况下的封装，做到不暴露细节。</p>
<h4 id="2-6-2：static-关键字"><a href="#2-6-2：static-关键字" class="headerlink" title="2-6-2：static 关键字"></a>2-6-2：static 关键字</h4><h5 id="2-6-2-1：static-使用场景"><a href="#2-6-2-1：static-使用场景" class="headerlink" title="2-6-2-1：static 使用场景"></a>2-6-2-1：static 使用场景</h5><ol>
<li>修饰成员变量和成员方法</li>
<li>静态代码块</li>
<li>修饰类(只能修饰内部类)</li>
<li>静态导包(用来导入类中的静态资源，1.5 之后的新特性)</li>
</ol>
<h5 id="2-6-2-2：静态⽅法和实例⽅法有何不同"><a href="#2-6-2-2：静态⽅法和实例⽅法有何不同" class="headerlink" title="2-6-2-2：静态⽅法和实例⽅法有何不同"></a>2-6-2-2：静态⽅法和实例⽅法有何不同</h5><ol>
<li>外部调用方法时，可以直接通过类型调用静态方法，而实例方法必须用对象调用。</li>
<li>静态方法内部不能调用实例变量和实例方法。而实例方法都可以。</li>
</ol>
<h5 id="2-6-2-3：静态变量和实例变量的区别？"><a href="#2-6-2-3：静态变量和实例变量的区别？" class="headerlink" title="2-6-2-3：静态变量和实例变量的区别？"></a>2-6-2-3：静态变量和实例变量的区别？</h5><p>静态变量属于类，实例变量属于对象。</p>
<h5 id="2-6-2-4：static-方法可以访问非-static-方法或变量吗"><a href="#2-6-2-4：static-方法可以访问非-static-方法或变量吗" class="headerlink" title="2-6-2-4：static 方法可以访问非 static 方法或变量吗?"></a>2-6-2-4：static 方法可以访问非 static 方法或变量吗?</h5><p>不可以</p>
<h4 id="2-6-3：final-关键字"><a href="#2-6-3：final-关键字" class="headerlink" title="2-6-3：final 关键字"></a>2-6-3：final 关键字</h4><h5 id="2-6-3-1：final-关键字使用场景"><a href="#2-6-3-1：final-关键字使用场景" class="headerlink" title="2-6-3-1：final 关键字使用场景"></a>2-6-3-1：final 关键字使用场景</h5><ol>
<li>final 修饰类，表示类不可继承。</li>
<li>final 修饰方法，表示方法不可重写。</li>
<li>final 修饰常量，表示常亮不可更改，必须显式初始化。但是常亮如果式引用类型，只是引用不能改变，对象属性可以改变。</li>
</ol>
<h5 id="2-6-3-2：final-finally-finalize-的区别"><a href="#2-6-3-2：final-finally-finalize-的区别" class="headerlink" title="2-6-3-2：final, finally, finalize 的区别"></a>2-6-3-2：final, finally, finalize 的区别</h5><ol>
<li>final 是修饰符，用来修饰类，方法，常量。</li>
<li>finally 是代码块，用于执行 try-catch 的收尾。</li>
<li>finalize 是垃圾回收方法，用于进行垃圾回收。</li>
</ol>
<h5 id="2-6-3-3：使用-final-关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？"><a href="#2-6-3-3：使用-final-关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？" class="headerlink" title="2-6-3-3：使用 final 关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？"></a>2-6-3-3：使用 final 关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？</h5><p>引用不能变，对象属性可以改变。</p>
<h4 id="2-6-4：this-关键字和-super-关键字"><a href="#2-6-4：this-关键字和-super-关键字" class="headerlink" title="2-6-4：this 关键字和 super 关键字"></a>2-6-4：this 关键字和 super 关键字</h4><p>this 关键字调用本对象，super 调用父类。</p>
<h4 id="2-6-5：transient-关键字"><a href="#2-6-5：transient-关键字" class="headerlink" title="2-6-5：transient 关键字"></a>2-6-5：transient 关键字</h4><p>transient 关键字用于不参与序列化。</p>
<h3 id="2-7-Java-基础-重载与重写"><a href="#2-7-Java-基础-重载与重写" class="headerlink" title="2-7.Java 基础-重载与重写"></a>2-7.Java 基础-重载与重写</h3><h4 id="2-7-1：重载与重写"><a href="#2-7-1：重载与重写" class="headerlink" title="2-7-1：重载与重写"></a>2-7-1：重载与重写</h4><ul>
<li>重载发生在一个类中，同一个方法根据传入数据的不同，做出不同的处理。</li>
<li>重写发生在父类和子类中，传入数据相同，返回值相同。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">区别点</th>
<th align="center">重载</th>
<th align="center">重写</th>
</tr>
</thead>
<tbody><tr>
<td align="center">发生范围</td>
<td align="center">同一个类</td>
<td align="center">子类</td>
</tr>
<tr>
<td align="center">参数列表</td>
<td align="center">必须修改</td>
<td align="center">不能修改</td>
</tr>
<tr>
<td align="center">返回类型</td>
<td align="center">可修改</td>
<td align="center">子类更小或相等</td>
</tr>
<tr>
<td align="center">异常</td>
<td align="center">可修改</td>
<td align="center">更小或相等</td>
</tr>
<tr>
<td align="center">访问修饰符</td>
<td align="center">可修改</td>
<td align="center">子类访问范围更大或相等</td>
</tr>
<tr>
<td align="center">发生阶段</td>
<td align="center">编译器</td>
<td align="center">运行期</td>
</tr>
</tbody></table>
<blockquote>
<p>返回类型为 void 或基础类型不可修改，引用类型可以使用子类</p>
</blockquote>
<p><strong>override（重写）：</strong></p>
<ul>
<li>方法名、参数、返回值相同。</li>
<li>子类方法不能缩小父类方法的访问权限。</li>
<li>子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。</li>
<li>存在于父类和子类之间。</li>
<li>方法被定义为 final 不能被重写。</li>
</ul>
<p><strong>overload（重载）：</strong></p>
<ul>
<li>参数类型、个数、顺序至少有一个不相同。</li>
<li>不能重载只有返回值不同的方法名。</li>
<li>存在于父类和子类、同类中。</li>
</ul>
<h4 id="2-7-2：Java-中是否可以覆盖-override-一个-private-或者是-static-的方法？"><a href="#2-7-2：Java-中是否可以覆盖-override-一个-private-或者是-static-的方法？" class="headerlink" title="2-7-2：Java 中是否可以覆盖(override)一个 private 或者是 static 的方法？"></a>2-7-2：Java 中是否可以覆盖(override)一个 private 或者是 static 的方法？</h4><p>不可以</p>
<ul>
<li>private 方法只有父类能访问，子类不能访问。所以不能重写。</li>
<li>static 方法是编译时绑定，重写是运行时绑定，形式上可以重写，但是实际上不起作用。</li>
</ul>
<h3 id="2-8-Java-基础-值传递与引用传递"><a href="#2-8-Java-基础-值传递与引用传递" class="headerlink" title="2-8.Java 基础-值传递与引用传递"></a>2-8.Java 基础-值传递与引用传递</h3><h4 id="2-8-1：值传递与引用传递的概念"><a href="#2-8-1：值传递与引用传递的概念" class="headerlink" title="2-8-1：值传递与引用传递的概念"></a>2-8-1：值传递与引用传递的概念</h4><ol>
<li>值传递（pass by value）是指在调用函数时将实际参数<strong>复制</strong>一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</li>
<li>引用传递（pass by reference）是指在调用函数时将实际参数的地址<strong>直接</strong>传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</li>
</ol>
<h4 id="2-8-2：值传递与引用传递的实例举证"><a href="#2-8-2：值传递与引用传递的实例举证" class="headerlink" title="2-8-2：值传递与引用传递的实例举证"></a>2-8-2：值传递与引用传递的实例举证</h4><p>基础类型就是值传递，引用类型例如数组，字符串也是值传递，是将引用复制一份传递个方法。</p>
<h3 id="2-9-Java-基础-深拷贝与浅拷贝"><a href="#2-9-Java-基础-深拷贝与浅拷贝" class="headerlink" title="2-9.Java 基础-深拷贝与浅拷贝"></a>2-9.Java 基础-深拷贝与浅拷贝</h3><h4 id="2-9-1：深拷贝与浅拷贝"><a href="#2-9-1：深拷贝与浅拷贝" class="headerlink" title="2-9-1：深拷贝与浅拷贝"></a>2-9-1：深拷贝与浅拷贝</h4><ul>
<li>如果类中属性有自定义引用类型，浅拷贝只拷贝引用，不拷贝引用指向的对象。浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝。</li>
<li>深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝（例：JSON.parse()和 JSON.stringify()，但是此方法无法复制函数类型）。</li>
</ul>
<h4 id="2-9-2：浅拷贝方法"><a href="#2-9-2：浅拷贝方法" class="headerlink" title="2-9-2：浅拷贝方法"></a>2-9-2：浅拷贝方法</h4><p>实现 Cloneable 接口，重写 clone 方法。</p>
<h4 id="2-9-3：深拷贝方法"><a href="#2-9-3：深拷贝方法" class="headerlink" title="2-9-3：深拷贝方法"></a>2-9-3：深拷贝方法</h4><p>实现 Cloneable 接口，重写 clone 方法法将属性对象也调用 clone 方法。或者实现 Serializable 接口。</p>
<h4 id="2-9-4：赋值和浅拷贝的区别"><a href="#2-9-4：赋值和浅拷贝的区别" class="headerlink" title="2-9-4：赋值和浅拷贝的区别"></a>2-9-4：赋值和浅拷贝的区别</h4><p>赋值时直接将引用引向堆内存，浅拷贝的问题是只是复制一个引用。</p>
<h3 id="2-10-equals-与-hashcode"><a href="#2-10-equals-与-hashcode" class="headerlink" title="2-10 equals 与 hashcode"></a>2-10 equals 与 hashcode</h3><h4 id="2-10-1：为什么要重写-hashcode-与-equals"><a href="#2-10-1：为什么要重写-hashcode-与-equals" class="headerlink" title="2-10-1：为什么要重写 hashcode 与 equals"></a>2-10-1：为什么要重写 hashcode 与 equals</h4><p>因为 hashcode 和 equals 方法是 Object 类的方法，如果不重写 equals()，则会直接比较引用。源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> public boolean equals(Object obj) &#123;</span><br><span class="line">    return (this &#x3D;&#x3D; obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如上，如果不充写 equals()方法则二者不可能相等。而 hashcode 和 equals 的关系是：</p>
<ol>
<li>hashcode 不等，equals()一定不等</li>
<li>hashcode 相等，equasl()也不一定相等</li>
<li>equasl()相等，hashcode 一定相等</li>
<li>equasl()不等，hashcode 也一定不等</li>
</ol>
<p>这四条定义是为了保证 HashMap 这一类使用 hash 的类计算不出错。虽然重写 equals()方法不重写 hashCode()方法也不会报错。<br>但是在 HashMap 的比较中，是根据 hashcode 先比较，在使用 equals()进行比较。如果不重写 hashCode()方法有极大概率永远也不会相等。那么 HashMap 就废掉了。</p>
<h4 id="2-10-2：重写-equals-不重写-hashcode-会出现什么问题"><a href="#2-10-2：重写-equals-不重写-hashcode-会出现什么问题" class="headerlink" title="2-10-2：重写 equals 不重写 hashcode 会出现什么问题"></a>2-10-2：重写 equals 不重写 hashcode 会出现什么问题</h4><p>HashMap 无法比较，无法 get。</p>
<h4 id="2-10-3：为什么两个对象有相同的-hashcode-值，它们也不一定是相等的？"><a href="#2-10-3：为什么两个对象有相同的-hashcode-值，它们也不一定是相等的？" class="headerlink" title="2-10-3：为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？"></a>2-10-3：为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？</h4><p>不重写的时候，hashcode 是根据 jvm 内存地址经过运算而来，所以一般是不相等的。而重写后根据重写后的规则才可能相同。</p>
<h4 id="2-10-4：阿里关于-hashcode-和-equals-的处理规则"><a href="#2-10-4：阿里关于-hashcode-和-equals-的处理规则" class="headerlink" title="2-10-4：阿里关于 hashcode 和 equals 的处理规则"></a>2-10-4：阿里关于 hashcode 和 equals 的处理规则</h4><p>关于 hashCode 和 equals 的处理，遵循如下规则：</p>
<ol>
<li>只要覆写 equals，就必须覆写 hashCode。</li>
<li>因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须覆写这两种方法。</li>
<li>如果自定义对象作为 Map 的键，那么必须覆写 hashCode 和 equals。</li>
</ol>
<h4 id="2-10-5：hashcode-和-equals-源码写一下"><a href="#2-10-5：hashcode-和-equals-源码写一下" class="headerlink" title="2-10-5：hashcode 和 equals 源码写一下"></a>2-10-5：hashcode 和 equals 源码写一下</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>hashcode 是个 native 方法</p>
<h3 id="2-11-i-与-i-的问题"><a href="#2-11-i-与-i-的问题" class="headerlink" title="2-11 i++与++i 的问题"></a>2-11 i++与++i 的问题</h3><h4 id="2-11-1：i-和-i-的区别，及其线程安全问题"><a href="#2-11-1：i-和-i-的区别，及其线程安全问题" class="headerlink" title="2-11-1：i++和++i 的区别，及其线程安全问题"></a>2-11-1：i++和++i 的区别，及其线程安全问题</h4><p>i++是调用 i 的值，再+1，++i 是先+1，让调用 i 的值。这两个都是线程不安全的。</p>
<p><code>i++</code>其实是取值，运算，赋值三步操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> temp = i</span><br><span class="line">temp+<span class="number">1</span></span><br><span class="line">i = temp</span><br></pre></td></tr></table></figure>

<p>如果 a,b 两个线程同时进行 i++，a 先读取 i 的值为 100，随后切换线程 b 读取 i 的值也为 100。然后 a 进行 100+1 并赋值，b 也进行 100+1 并赋值。最后的结果为 i=101，实际运算结果为 i=102。</p>
<h4 id="2-11-2：i-和-i-是否为原子操作"><a href="#2-11-2：i-和-i-是否为原子操作" class="headerlink" title="2-11-2：i++和++i 是否为原子操作"></a>2-11-2：i++和++i 是否为原子操作</h4><p>不是</p>
<h4 id="2-11-3：如何实现-i-和-i-的原子性呢？"><a href="#2-11-3：如何实现-i-和-i-的原子性呢？" class="headerlink" title="2-11-3：如何实现 i++和++i 的原子性呢？"></a>2-11-3：如何实现 i++和++i 的原子性呢？</h4><p>atomic 包</p>
<h3 id="2-12-数据类型"><a href="#2-12-数据类型" class="headerlink" title="2-12 数据类型"></a>2-12 数据类型</h3><h4 id="2-12-1：八种数据类型是什么？"><a href="#2-12-1：八种数据类型是什么？" class="headerlink" title="2-12-1：八种数据类型是什么？"></a>2-12-1：八种数据类型是什么？</h4><p>byte，short，int，long，float，double，char，boolean</p>
<h5 id="2-12-1-1：Java-为什么除了基本数据类型还要有引用数据类型"><a href="#2-12-1-1：Java-为什么除了基本数据类型还要有引用数据类型" class="headerlink" title="2-12-1-1：Java 为什么除了基本数据类型还要有引用数据类型"></a>2-12-1-1：Java 为什么除了基本数据类型还要有引用数据类型</h5><p>Java 是面向对象语言，准确来说是只有引用类型的，而基础数据类型是为了减少资源消耗，加快运行速度推出的。</p>
<h5 id="2-12-1-2：String-为什么不是基本数据类型"><a href="#2-12-1-2：String-为什么不是基本数据类型" class="headerlink" title="2-12-1-2：String 为什么不是基本数据类型"></a>2-12-1-2：String 为什么不是基本数据类型</h5><p>String 内部其实是个 char[]数组，所以是引用类型</p>
<h5 id="2-12-1-2：引用类型有哪几种"><a href="#2-12-1-2：引用类型有哪几种" class="headerlink" title="2-12-1-2：引用类型有哪几种"></a>2-12-1-2：引用类型有哪几种</h5><p>除了基础类型都是引用类型</p>
<h5 id="2-12-2：数据类型的范围"><a href="#2-12-2：数据类型的范围" class="headerlink" title="2-12-2：数据类型的范围"></a>2-12-2：数据类型的范围</h5><ul>
<li>byte：一个字节，<code>-2^7-1~2^7</code>，-128~127</li>
<li>short：两个字节，<code>-2^15-1~2^15</code>，-32768~32767</li>
<li>int：四个字节，<code>-2^31-1~2^31</code>，-2147483648~2147483647</li>
<li>long：八个字节，<code>-2^63-1~2^63</code>，-9223372036854774808~9223372036854774807</li>
<li>float：四个字节，3.402823e+38 ~ 1.401298e-45</li>
<li>double：八个字节，1.797693e+308~ 4.9000000e-324</li>
<li>char：两个字节</li>
<li>boolean：四个字节</li>
</ul>
<h5 id="2-12-2-1：为什么-byte-类型是-128-127"><a href="#2-12-2-1：为什么-byte-类型是-128-127" class="headerlink" title="2-12-2-1：为什么 byte 类型是-128~+127"></a>2-12-2-1：为什么 byte 类型是-128~+127</h5><ol>
<li>计算机中负数是用补码的形式保存、并用它参与加减法运算的，减法会被转换为加法，计算机中没有减法运算。</li>
<li>反码是为了解决减法运算，补码是为了解决反码产生的 ±0 的问题。参考(<a target="_blank" rel="noopener" href="https://blog.csdn.net/boatalways/article/details/17027573">https://blog.csdn.net/boatalways/article/details/17027573</a>)</li>
<li>对人而言二进制所代表的值一定是从原码求出的，开头如果是 1 的二进制，一定要说明其是原码、反码还是补码。</li>
<li>在原码、反码、补码相互转换以及求对应的十进制求值时，符号位是绝不参与的，但是在加减过程中，是参与位运算的。</li>
<li>计算机中规定了+0 对应的二进制就是 0，那么-0 就没有意义了，必须找一个数和它对应。</li>
<li>byte 的最小值-128、short 的最小值-32768、int 的最小值-2147483648 都是用对应的-0 的原码来进行表示，这是人为规定的、人为规定的、人为规定的。但是这么规定又很巧妙，妙在上述 10 中的三点。</li>
</ol>
<h4 id="2-12-3：自动拆装箱"><a href="#2-12-3：自动拆装箱" class="headerlink" title="2-12-3：自动拆装箱"></a>2-12-3：自动拆装箱</h4><h5 id="2-12-3-1：为什么要有自动拆装箱"><a href="#2-12-3-1：为什么要有自动拆装箱" class="headerlink" title="2-12-3-1：为什么要有自动拆装箱"></a>2-12-3-1：为什么要有自动拆装箱</h5><p>基础类型是为了使运算更快，而包装类型是为了使基础类型具有类的特性。有了这两样东西有时候就需要进行转换，所以就有了自动拆装箱。</p>
<h5 id="2-12-3-2：自动拆装箱的原理"><a href="#2-12-3-2：自动拆装箱的原理" class="headerlink" title="2-12-3-2：自动拆装箱的原理"></a>2-12-3-2：自动拆装箱的原理</h5><p>自动装箱都是通过包装类的 <code>valueOf()</code> 方法来实现的.自动拆箱都是通过包装类对象的 <code>xxxValue()</code> 来实现的。</p>
<h5 id="2-12-3-3：自动拆装箱使用场景"><a href="#2-12-3-3：自动拆装箱使用场景" class="headerlink" title="2-12-3-3：自动拆装箱使用场景"></a>2-12-3-3：自动拆装箱使用场景</h5><ol>
<li>将基础类型放入集合 - 自动装箱</li>
<li>包装类型和基本类型的大小比较 - 自动拆箱</li>
<li>包装类型的运算 - 自动拆箱</li>
<li>三目运算符的使用 - 自动拆箱</li>
<li>函数参数与返回值</li>
</ol>
<h5 id="2-12-3-4：自动拆装箱带来的问题"><a href="#2-12-3-4：自动拆装箱带来的问题" class="headerlink" title="2-12-3-4：自动拆装箱带来的问题"></a>2-12-3-4：自动拆装箱带来的问题</h5><ol>
<li>因为包装类型是对象，缓存范围(-128-127)之外的比较需要使用 equals</li>
<li>有些场景会自动拆装箱，如果包装类型为 null，自动拆箱可能会抛出 NPE 错误</li>
<li>循环中大量拆装箱，浪费资源</li>
</ol>
<h4 id="2-12-4：Integer-缓存机制"><a href="#2-12-4：Integer-缓存机制" class="headerlink" title="2-12-4：Integer 缓存机制"></a>2-12-4：Integer 缓存机制</h4><h5 id="2-12-4-1：int-与-Integer-区别"><a href="#2-12-4-1：int-与-Integer-区别" class="headerlink" title="2-12-4-1：int 与 Integer 区别"></a>2-12-4-1：int 与 Integer 区别</h5><ol>
<li>一个是基础类型，一个是包装类型</li>
<li>Integer 变量必须实例化后才能使用；int 变量不需要；</li>
<li>Integer 实际是对象的引用，指向此 new 的 Integer 对象；int 是直接存储数据值</li>
<li>Integer 的默认值是 null；int 的默认值是 0。</li>
<li>int 可以用<code>==</code>比较，而 Integer 在缓存池范围内可以用<code>==</code>，范围外必须用 equals()</li>
</ol>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/guodongdidi/p/6953217.html">int 和 Integer 的区别</a></p>
</blockquote>
<h4 id="2-12-5：String-转出-int-型，-判断能不能转？-如何转？"><a href="#2-12-5：String-转出-int-型，-判断能不能转？-如何转？" class="headerlink" title="2-12-5：String 转出 int 型， 判断能不能转？ 如何转？"></a>2-12-5：String 转出 int 型， 判断能不能转？ 如何转？</h4><p>Integer.parseInt();<br>Integer.valueOf();</p>
<h4 id="2-12-6：short-s1-1-s1-s1-1-有什么错-short-s1-1-s1-1-有什么错"><a href="#2-12-6：short-s1-1-s1-s1-1-有什么错-short-s1-1-s1-1-有什么错" class="headerlink" title="2-12-6：short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1+=1;有什么错?"></a>2-12-6：short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1+=1;有什么错?</h4><p>因为<code>s1+1</code>会自动进行类型转换，变为 int 型，而<code>+=</code>是 Java 规定的运算符，所以不会报错。</p>
<h3 id="2-13：对象比较有几种方式？"><a href="#2-13：对象比较有几种方式？" class="headerlink" title="2-13：对象比较有几种方式？"></a>2-13：对象比较有几种方式？</h3><ol>
<li>重写 Object 类的 equals（）方法；</li>
<li>实现 Comparable 接口，并实现 compareTo（）方法；</li>
<li>定义一个单独的对象比较器，继承自 Comparator 接口，实现 compare（）方法。</li>
</ol>
<h4 id="2-13-1：Comparator-与-Comparable-有什么区别？"><a href="#2-13-1：Comparator-与-Comparable-有什么区别？" class="headerlink" title="2-13-1：Comparator 与 Comparable 有什么区别？"></a>2-13-1：Comparator 与 Comparable 有什么区别？</h4><ul>
<li>Comparable 是排序接口；若一个类实现了 Comparable 接口，就意味着“该类支持排序”。</li>
<li>而 Comparator 是比较器；我们若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。</li>
<li>Comparable 相当于“内部比较器”，而 Comparator 相当于“外部比较器”。</li>
</ul>
<h3 id="2-14：数组的特点？底层如何定位到数组中的元素？数组的内存空间是连续的吗？"><a href="#2-14：数组的特点？底层如何定位到数组中的元素？数组的内存空间是连续的吗？" class="headerlink" title="2-14：数组的特点？底层如何定位到数组中的元素？数组的内存空间是连续的吗？"></a>2-14：数组的特点？底层如何定位到数组中的元素？数组的内存空间是连续的吗？</h3><p>数组查询快，增删慢。数组底层是一块连续的内存空间，访问地址时根据内存块的首地址根据公式确定访问下标对应地址。</p>
<ul>
<li>Java 中数组的引用放于栈内存中，而实际数据放于堆内存中。</li>
<li>如果数组是引用类型数组，则堆内存中对应地址则指向对应对象。</li>
<li>多维数组其实也是一维数组，每一格都指向下一层数组。例如二维数组存放行的一维数组，每一格指向列的一维数组。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">失铭</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://shiming.best/blog/6ac545c4/">https://shiming.best/blog/6ac545c4/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://shiming.best" target="_blank">失铭的日记</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E5%9F%BA%E7%A1%80/">Java基础</a></div><div class="post_share"><div class="social-share" data-image="https://image.shiming.online/guidao/pic-88.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/blog/12201e3/"><img class="prev-cover" data-lazy-src="https://image.shiming.online/guidao/pic-88.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">面试题-集合</div></div></a></div><div class="next-post pull-right"><a href="/blog/3cd8af52/"><img class="next-cover" data-lazy-src="https://image.shiming.online/guidao/pic-88.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Integer源码解析</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" data-lazy-src="https://image.shiming.online/background/info.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">失铭</div><div class="author-info__description">El Psy Congroo</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">116</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">61</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">33</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/XShiMing"><i class="fab fa-github"></i><span>Follow Me</span></a></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎阅读我的笔记。笔记中可能存在遗漏或简单的错误，请见谅。</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%EF%BC%9AJava-%E7%89%B9%E6%80%A7"><span class="toc-number">1.</span> <span class="toc-text">1：Java 特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%EF%BC%9AJava-%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.</span> <span class="toc-text">1-1：Java 特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2%EF%BC%9AJVM-JRE-JDK-JIT"><span class="toc-number">1.2.</span> <span class="toc-text">1-2：JVM\JRE\JDK\JIT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3%EF%BC%9A%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.3.</span> <span class="toc-text">1-3：变量的初始化顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4%EF%BC%9A%E2%BE%AF%E5%90%91%E8%BF%87%E7%A8%8B%E6%80%A7%E8%83%BD%E2%BD%90%E2%BE%AF%E5%90%91%E5%AF%B9%E8%B1%A1%E2%BE%BC"><span class="toc-number">1.4.</span> <span class="toc-text">1-4：⾯向过程性能⽐⾯向对象⾼</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5%EF%BC%9A%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E8%B1%A1%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-number">1.5.</span> <span class="toc-text">1-5：持久化对象三种状态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%EF%BC%9AJava-%E5%9F%BA%E7%A1%80-%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1-OOP"><span class="toc-number">2.</span> <span class="toc-text">2：Java 基础-面对对象(OOP)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-number">2.1.</span> <span class="toc-text">2-1：面向对象的原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%EF%BC%9AJava-%E7%B1%BB%E4%BB%A5%E5%8F%8A%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98"><span class="toc-number">2.2.</span> <span class="toc-text">2-2：Java 类以及类的成员</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1%EF%BC%9A%E5%B1%9E%E6%80%A7"><span class="toc-number">2.2.1.</span> <span class="toc-text">2-2-1：属性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-1-1%EF%BC%9A%E5%B1%9E%E6%80%A7%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E7%9B%B8%E5%90%8C%E7%82%B9%E3%80%81%E4%B8%8D%E5%90%8C%E7%82%B9"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">2-2-1-1：属性与局部变量的相同点、不同点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2%EF%BC%9AJava-%E5%9F%BA%E7%A1%80-%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">2.2.2.</span> <span class="toc-text">2-2-2：Java 基础-构造器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-1%EF%BC%9A%E2%BC%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E2%BD%85%E6%B3%95%E7%9A%84%E4%BD%9C%E2%BD%A4%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.2.3.</span> <span class="toc-text">2-2-2-1：⼀个类的构造⽅法的作⽤是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-2%EF%BC%9A%E6%9E%84%E9%80%A0%E2%BD%85%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">2.2.4.</span> <span class="toc-text">2-2-2-2：构造⽅法有哪些特性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-3%EF%BC%9A%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E8%A2%AB%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD"><span class="toc-number">2.2.5.</span> <span class="toc-text">2-2-2-3：构造方法可不可以被重写和重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-4%EF%BC%9A%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%83%BD%E7%94%A8-private-%E4%BF%AE%E9%A5%B0%E5%90%97"><span class="toc-number">2.2.6.</span> <span class="toc-text">2-2-2-4：构造函数能用 private 修饰吗</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%EF%BC%9A%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">2.3.</span> <span class="toc-text">2-3：面对对象三大特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1%EF%BC%9A%E5%B0%81%E8%A3%85"><span class="toc-number">2.3.1.</span> <span class="toc-text">2-3-1：封装</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-1-1%EF%BC%9A%E5%B0%81%E8%A3%85%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">2-3-1-1：封装的应用场景</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2%EF%BC%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">2.3.2.</span> <span class="toc-text">2-3-2：继承</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-2-1%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%A7%E6%89%BF"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">2-3-2-1：什么是继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-2-2%EF%BC%9A%E7%BB%A7%E6%89%BF%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">2-3-2-2：继承的应用场景</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3%EF%BC%9A%E5%A4%9A%E6%80%81"><span class="toc-number">2.3.3.</span> <span class="toc-text">2-3-3：多态</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-3-1%EF%BC%9A%E5%A4%9A%E6%80%81%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6%EF%BC%88%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E3%80%81%E6%9C%BA%E5%88%B6%EF%BC%89"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">2-3-3-1：多态的必要条件（实现方式、机制）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-3-2%EF%BC%9A%E5%A4%9A%E6%80%81%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">2.3.3.2.</span> <span class="toc-text">2-3-3-2：多态的好处</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-3-3%EF%BC%9A%E5%A4%9A%E6%80%81%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">2.3.3.3.</span> <span class="toc-text">2-3-3-3：多态的例子</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4%EF%BC%9A%E6%8A%BD%E8%B1%A1"><span class="toc-number">2.4.</span> <span class="toc-text">2-4：抽象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1%EF%BC%9AJava-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%8F%AF%E4%BB%A5%E6%9C%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%9F%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.4.1.</span> <span class="toc-text">2-4-1：Java 抽象类可以有构造函数吗？作用是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2%EF%BC%9AJava-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E5%90%97%EF%BC%9F-%E5%AE%83%E4%BB%AC%E9%9C%80%E8%A6%81%E5%AE%9E%E7%8E%B0%E6%89%80%E6%9C%89%E7%9A%84%E6%96%B9%E6%B3%95%E5%90%97"><span class="toc-number">2.4.2.</span> <span class="toc-text">2-4-2：Java 抽象类可以实现接口吗？ 它们需要实现所有的方法吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3%EF%BC%9AJava-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%8F%AF%E4%BB%A5%E6%98%AF-final-%E7%9A%84%E5%90%97"><span class="toc-number">2.4.3.</span> <span class="toc-text">2-4-3：Java 抽象类可以是 final 的吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-4%EF%BC%9AJava-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%8F%AF%E4%BB%A5%E6%9C%89-static-%E6%96%B9%E6%B3%95%E5%90%97"><span class="toc-number">2.4.4.</span> <span class="toc-text">2-4-4：Java 抽象类可以有 static 方法吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-5%EF%BC%9A%E5%8F%AF%E4%BB%A5%E5%88%9B%E5%BB%BA%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%90%97%EF%BC%88new-%E7%B1%BB%EF%BC%89"><span class="toc-number">2.4.5.</span> <span class="toc-text">2-4-5：可以创建抽象类的实例吗（new 类）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-6%EF%BC%9A%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%BF%85%E9%A1%BB%E6%9C%89%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%90%97"><span class="toc-number">2.4.6.</span> <span class="toc-text">2-4-6：抽象类必须有抽象方法吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-7%EF%BC%9A%E4%BD%95%E6%97%B6%E9%80%89%E7%94%A8%E6%8A%BD%E8%B1%A1%E7%B1%BB%E8%80%8C%E4%B8%8D%E6%98%AF%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.4.7.</span> <span class="toc-text">2-4-7：何时选用抽象类而不是接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-8%EF%BC%9AJava-%E4%B8%AD%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.4.8.</span> <span class="toc-text">2-4-8：Java 中的抽象方法是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-9%EF%BC%9AJava-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%AD%E5%8F%AF%E4%BB%A5%E5%8C%85%E5%90%AB-main-%E6%96%B9%E6%B3%95%E5%90%97"><span class="toc-number">2.4.9.</span> <span class="toc-text">2-4-9：Java 抽象类中可以包含 main 方法吗</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5%EF%BC%9A%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E5%8C%BA%E5%88%AB"><span class="toc-number">2.5.</span> <span class="toc-text">2-5：面对对象区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-1%EF%BC%9A%E6%8E%A5%E2%BC%9D%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.5.1.</span> <span class="toc-text">2-5-1：接⼝和抽象类的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-2%EF%BC%9A%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%8C%BA%E5%88%AB"><span class="toc-number">2.5.2.</span> <span class="toc-text">2-5-2：继承和实现区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-3%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E8%BF%98%E6%9C%89%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">2.5.3.</span> <span class="toc-text">2-5-3：为什么要设计接口、抽象类还有实现类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-Java-%E5%9F%BA%E7%A1%80-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.6.</span> <span class="toc-text">2-6.Java 基础-关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-1-%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%AE%BF%E9%97%AE-private-%E6%88%90%E5%91%98%E5%92%8C%E6%96%B9%E6%B3%95%EF%BC%8C%E6%97%A2%E7%84%B6%E8%83%BD%E8%AE%BF%E9%97%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81-private%EF%BC%9F"><span class="toc-number">2.6.1.</span> <span class="toc-text">2-6-1: 通过反射访问 private 成员和方法，既然能访问为什么要 private？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-2%EF%BC%9Astatic-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.6.2.</span> <span class="toc-text">2-6-2：static 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-2-1%EF%BC%9Astatic-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.6.2.1.</span> <span class="toc-text">2-6-2-1：static 使用场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-2-2%EF%BC%9A%E9%9D%99%E6%80%81%E2%BD%85%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E2%BD%85%E6%B3%95%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C"><span class="toc-number">2.6.2.2.</span> <span class="toc-text">2-6-2-2：静态⽅法和实例⽅法有何不同</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-2-3%EF%BC%9A%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.6.2.3.</span> <span class="toc-text">2-6-2-3：静态变量和实例变量的区别？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-2-4%EF%BC%9Astatic-%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%E9%9D%9E-static-%E6%96%B9%E6%B3%95%E6%88%96%E5%8F%98%E9%87%8F%E5%90%97"><span class="toc-number">2.6.2.4.</span> <span class="toc-text">2-6-2-4：static 方法可以访问非 static 方法或变量吗?</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-3%EF%BC%9Afinal-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.6.3.</span> <span class="toc-text">2-6-3：final 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-3-1%EF%BC%9Afinal-%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.6.3.1.</span> <span class="toc-text">2-6-3-1：final 关键字使用场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-3-2%EF%BC%9Afinal-finally-finalize-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.6.3.2.</span> <span class="toc-text">2-6-3-2：final, finally, finalize 的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-3-3%EF%BC%9A%E4%BD%BF%E7%94%A8-final-%E5%85%B3%E9%94%AE%E5%AD%97%E4%BF%AE%E9%A5%B0%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E6%97%B6%EF%BC%8C%E6%98%AF%E5%BC%95%E7%94%A8%E4%B8%8D%E8%83%BD%E5%8F%98%EF%BC%8C%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%B8%8D%E8%83%BD%E5%8F%98%EF%BC%9F"><span class="toc-number">2.6.3.3.</span> <span class="toc-text">2-6-3-3：使用 final 关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-4%EF%BC%9Athis-%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C-super-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.6.4.</span> <span class="toc-text">2-6-4：this 关键字和 super 关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-5%EF%BC%9Atransient-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.6.5.</span> <span class="toc-text">2-6-5：transient 关键字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-Java-%E5%9F%BA%E7%A1%80-%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99"><span class="toc-number">2.7.</span> <span class="toc-text">2-7.Java 基础-重载与重写</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-1%EF%BC%9A%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99"><span class="toc-number">2.7.1.</span> <span class="toc-text">2-7-1：重载与重写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-2%EF%BC%9AJava-%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A6%86%E7%9B%96-override-%E4%B8%80%E4%B8%AA-private-%E6%88%96%E8%80%85%E6%98%AF-static-%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">2.7.2.</span> <span class="toc-text">2-7-2：Java 中是否可以覆盖(override)一个 private 或者是 static 的方法？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-Java-%E5%9F%BA%E7%A1%80-%E5%80%BC%E4%BC%A0%E9%80%92%E4%B8%8E%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="toc-number">2.8.</span> <span class="toc-text">2-8.Java 基础-值传递与引用传递</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-1%EF%BC%9A%E5%80%BC%E4%BC%A0%E9%80%92%E4%B8%8E%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">2.8.1.</span> <span class="toc-text">2-8-1：值传递与引用传递的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-2%EF%BC%9A%E5%80%BC%E4%BC%A0%E9%80%92%E4%B8%8E%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E7%9A%84%E5%AE%9E%E4%BE%8B%E4%B8%BE%E8%AF%81"><span class="toc-number">2.8.2.</span> <span class="toc-text">2-8-2：值传递与引用传递的实例举证</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-Java-%E5%9F%BA%E7%A1%80-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.9.</span> <span class="toc-text">2-9.Java 基础-深拷贝与浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-9-1%EF%BC%9A%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.9.1.</span> <span class="toc-text">2-9-1：深拷贝与浅拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-9-2%EF%BC%9A%E6%B5%85%E6%8B%B7%E8%B4%9D%E6%96%B9%E6%B3%95"><span class="toc-number">2.9.2.</span> <span class="toc-text">2-9-2：浅拷贝方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-9-3%EF%BC%9A%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%96%B9%E6%B3%95"><span class="toc-number">2.9.3.</span> <span class="toc-text">2-9-3：深拷贝方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-9-4%EF%BC%9A%E8%B5%8B%E5%80%BC%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.9.4.</span> <span class="toc-text">2-9-4：赋值和浅拷贝的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-10-equals-%E4%B8%8E-hashcode"><span class="toc-number">2.10.</span> <span class="toc-text">2-10 equals 与 hashcode</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-10-1%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%87%8D%E5%86%99-hashcode-%E4%B8%8E-equals"><span class="toc-number">2.10.1.</span> <span class="toc-text">2-10-1：为什么要重写 hashcode 与 equals</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-10-2%EF%BC%9A%E9%87%8D%E5%86%99-equals-%E4%B8%8D%E9%87%8D%E5%86%99-hashcode-%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">2.10.2.</span> <span class="toc-text">2-10-2：重写 equals 不重写 hashcode 会出现什么问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-10-3%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84-hashcode-%E5%80%BC%EF%BC%8C%E5%AE%83%E4%BB%AC%E4%B9%9F%E4%B8%8D%E4%B8%80%E5%AE%9A%E6%98%AF%E7%9B%B8%E7%AD%89%E7%9A%84%EF%BC%9F"><span class="toc-number">2.10.3.</span> <span class="toc-text">2-10-3：为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-10-4%EF%BC%9A%E9%98%BF%E9%87%8C%E5%85%B3%E4%BA%8E-hashcode-%E5%92%8C-equals-%E7%9A%84%E5%A4%84%E7%90%86%E8%A7%84%E5%88%99"><span class="toc-number">2.10.4.</span> <span class="toc-text">2-10-4：阿里关于 hashcode 和 equals 的处理规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-10-5%EF%BC%9Ahashcode-%E5%92%8C-equals-%E6%BA%90%E7%A0%81%E5%86%99%E4%B8%80%E4%B8%8B"><span class="toc-number">2.10.5.</span> <span class="toc-text">2-10-5：hashcode 和 equals 源码写一下</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-11-i-%E4%B8%8E-i-%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.11.</span> <span class="toc-text">2-11 i++与++i 的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-11-1%EF%BC%9Ai-%E5%92%8C-i-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%8F%8A%E5%85%B6%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">2.11.1.</span> <span class="toc-text">2-11-1：i++和++i 的区别，及其线程安全问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-11-2%EF%BC%9Ai-%E5%92%8C-i-%E6%98%AF%E5%90%A6%E4%B8%BA%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">2.11.2.</span> <span class="toc-text">2-11-2：i++和++i 是否为原子操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-11-3%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-i-%E5%92%8C-i-%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E5%91%A2%EF%BC%9F"><span class="toc-number">2.11.3.</span> <span class="toc-text">2-11-3：如何实现 i++和++i 的原子性呢？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-12-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.12.</span> <span class="toc-text">2-12 数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-12-1%EF%BC%9A%E5%85%AB%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.12.1.</span> <span class="toc-text">2-12-1：八种数据类型是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-12-1-1%EF%BC%9AJava-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%99%A4%E4%BA%86%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BF%98%E8%A6%81%E6%9C%89%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.12.1.1.</span> <span class="toc-text">2-12-1-1：Java 为什么除了基本数据类型还要有引用数据类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-12-1-2%EF%BC%9AString-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.12.1.2.</span> <span class="toc-text">2-12-1-2：String 为什么不是基本数据类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-12-1-2%EF%BC%9A%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D"><span class="toc-number">2.12.1.3.</span> <span class="toc-text">2-12-1-2：引用类型有哪几种</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-12-2%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%8C%83%E5%9B%B4"><span class="toc-number">2.12.1.4.</span> <span class="toc-text">2-12-2：数据类型的范围</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-12-2-1%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88-byte-%E7%B1%BB%E5%9E%8B%E6%98%AF-128-127"><span class="toc-number">2.12.1.5.</span> <span class="toc-text">2-12-2-1：为什么 byte 类型是-128~+127</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-12-3%EF%BC%9A%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1"><span class="toc-number">2.12.2.</span> <span class="toc-text">2-12-3：自动拆装箱</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-12-3-1%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1"><span class="toc-number">2.12.2.1.</span> <span class="toc-text">2-12-3-1：为什么要有自动拆装箱</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-12-3-2%EF%BC%9A%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">2.12.2.2.</span> <span class="toc-text">2-12-3-2：自动拆装箱的原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-12-3-3%EF%BC%9A%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.12.2.3.</span> <span class="toc-text">2-12-3-3：自动拆装箱使用场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-12-3-4%EF%BC%9A%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.12.2.4.</span> <span class="toc-text">2-12-3-4：自动拆装箱带来的问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-12-4%EF%BC%9AInteger-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-number">2.12.3.</span> <span class="toc-text">2-12-4：Integer 缓存机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-12-4-1%EF%BC%9Aint-%E4%B8%8E-Integer-%E5%8C%BA%E5%88%AB"><span class="toc-number">2.12.3.1.</span> <span class="toc-text">2-12-4-1：int 与 Integer 区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-12-5%EF%BC%9AString-%E8%BD%AC%E5%87%BA-int-%E5%9E%8B%EF%BC%8C-%E5%88%A4%E6%96%AD%E8%83%BD%E4%B8%8D%E8%83%BD%E8%BD%AC%EF%BC%9F-%E5%A6%82%E4%BD%95%E8%BD%AC%EF%BC%9F"><span class="toc-number">2.12.4.</span> <span class="toc-text">2-12-5：String 转出 int 型， 判断能不能转？ 如何转？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-12-6%EF%BC%9Ashort-s1-1-s1-s1-1-%E6%9C%89%E4%BB%80%E4%B9%88%E9%94%99-short-s1-1-s1-1-%E6%9C%89%E4%BB%80%E4%B9%88%E9%94%99"><span class="toc-number">2.12.5.</span> <span class="toc-text">2-12-6：short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有什么错? short s1 &#x3D; 1; s1+&#x3D;1;有什么错?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-13%EF%BC%9A%E5%AF%B9%E8%B1%A1%E6%AF%94%E8%BE%83%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">2.13.</span> <span class="toc-text">2-13：对象比较有几种方式？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-13-1%EF%BC%9AComparator-%E4%B8%8E-Comparable-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.13.1.</span> <span class="toc-text">2-13-1：Comparator 与 Comparable 有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-14%EF%BC%9A%E6%95%B0%E7%BB%84%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9F%E5%BA%95%E5%B1%82%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E5%88%B0%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%EF%BC%9F%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E6%98%AF%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">2.14.</span> <span class="toc-text">2-14：数组的特点？底层如何定位到数组中的元素？数组的内存空间是连续的吗？</span></a></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/ec09f6b3/" title="面试题-Redis">面试题-Redis</a><time datetime="2021-04-28T09:04:16.000Z" title="发表于 2021-04-28 17:04:16">2021-04-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/828907ec/" title="面试题-Spring">面试题-Spring</a><time datetime="2021-04-28T09:03:37.000Z" title="发表于 2021-04-28 17:03:37">2021-04-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/63929c6f/" title="面试题-数据库">面试题-数据库</a><time datetime="2021-04-28T09:01:41.000Z" title="发表于 2021-04-28 17:01:41">2021-04-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/15163a62/" title="面试题-计网和操作系统">面试题-计网和操作系统</a><time datetime="2021-04-28T09:00:52.000Z" title="发表于 2021-04-28 17:00:52">2021-04-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/8efca904/" title="面试题-JVM">面试题-JVM</a><time datetime="2021-04-28T09:00:08.000Z" title="发表于 2021-04-28 17:00:08">2021-04-28</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 失铭</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="icp"><a target="_blank" rel="noopener" href="http://beian.miit.gov.cn/"><img class="icp-icon" src="/img/icp.png" alt="ICP"/><span>渝ICP备2020010262号</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.spacingElementById('content-inner')
  else {
    $.getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js', () => {
      pangu.spacingElementById('content-inner')
    })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguFn)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    let initData = {
      el: '#vcomment',
      appId: '8AI4XAeM1WByt61C1hTs3U7f-MdYXbMMI',
      appKey: 'TxTEH6NbG1UeKnrlAFuRIcDH',
      placeholder: '给我的文章加点评论吧~',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    }

    if (true) { 
      initData.requiredFields= ('nick'.split(','))
    }
    
    if (false) {
      const otherData = false
      initData = Object.assign({}, initData, otherData)
    }
    
    const valine = new Valine(initData)
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script></div></body></html>