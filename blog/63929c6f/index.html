<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>面试题-数据库 | 失铭的笔记</title><meta name="keywords" content="数据库"><meta name="author" content="失铭"><meta name="copyright" content="失铭"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="1：MySQL1-1：为什么要使用数据库为了更高效且条例分明的存储数据，能够更迅速和方便地管理数据。  数据库可以结构化存储大量的数据信息，方便用户进行有效的检索和访问。 数据库可以有效地保证数据信息的一致性，完整性，降低数据冗余 数据库可以满足应用的共享和安全方面的要求，把数据放在数据库中在很多情况下也是出于安全的考虑。 数据库技术能够方便智能化地分析，产生新的有用信息。  1-2: 什么是 S">
<meta property="og:type" content="article">
<meta property="og:title" content="面试题-数据库">
<meta property="og:url" content="https://shiming.best/blog/63929c6f/index.html">
<meta property="og:site_name" content="失铭的笔记">
<meta property="og:description" content="1：MySQL1-1：为什么要使用数据库为了更高效且条例分明的存储数据，能够更迅速和方便地管理数据。  数据库可以结构化存储大量的数据信息，方便用户进行有效的检索和访问。 数据库可以有效地保证数据信息的一致性，完整性，降低数据冗余 数据库可以满足应用的共享和安全方面的要求，把数据放在数据库中在很多情况下也是出于安全的考虑。 数据库技术能够方便智能化地分析，产生新的有用信息。  1-2: 什么是 S">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://image.shiming.online/guidao/pic-88.jpg">
<meta property="article:published_time" content="2021-04-28T09:01:41.000Z">
<meta property="article:modified_time" content="2021-04-28T09:01:41.000Z">
<meta property="article:author" content="失铭">
<meta property="article:tag" content="数据库">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://image.shiming.online/guidao/pic-88.jpg"><link rel="shortcut icon" href="https://image.shiming.online/background/favicon.ico"><link rel="canonical" href="https://shiming.best/blog/63929c6f/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-04-28 17:01:41'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><link rel="stylesheet" href="/css/background.css"><link rel="stylesheet" href="/css/gdt.css"><link rel="stylesheet" href="/css/foot.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1995009_6m1bfgtzjiv.css"><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="失铭的笔记" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="https://image.shiming.online/background/info.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">118</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">60</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/Java/%E6%BA%90%E7%A0%81/"><i class="fa-fw iconfont icon-CodeApplicationDevelopmentProgrammingSoftware"></i><span> 源码</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-32shejimoshi"></i><span> 设计模式</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/blog/41682/"><i class="fa-fw iconfont icon-dashujukeshihuaico--copy"></i><span> 设计模式</span></a></li><li><a class="site-page" href="/blog/8f9f2030/"><i class="fa-fw iconfont icon-chuangjian"></i><span> 创建型模式</span></a></li><li><a class="site-page" href="/blog/620ff0b5/"><i class="fa-fw iconfont icon-jiegou"></i><span> 结构型模式</span></a></li><li><a class="site-page" href="/blog/e55dcfb0/"><i class="fa-fw iconfont icon-hangwei"></i><span> 行为型模式</span></a></li></ul></div></div></div></div><div id="body-wrap"><header class="no-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">失铭的笔记</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/Java/%E6%BA%90%E7%A0%81/"><i class="fa-fw iconfont icon-CodeApplicationDevelopmentProgrammingSoftware"></i><span> 源码</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-32shejimoshi"></i><span> 设计模式</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/blog/41682/"><i class="fa-fw iconfont icon-dashujukeshihuaico--copy"></i><span> 设计模式</span></a></li><li><a class="site-page" href="/blog/8f9f2030/"><i class="fa-fw iconfont icon-chuangjian"></i><span> 创建型模式</span></a></li><li><a class="site-page" href="/blog/620ff0b5/"><i class="fa-fw iconfont icon-jiegou"></i><span> 结构型模式</span></a></li><li><a class="site-page" href="/blog/e55dcfb0/"><i class="fa-fw iconfont icon-hangwei"></i><span> 行为型模式</span></a></li></ul></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">面试题-数据库</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-04-28T09:01:41.000Z" title="发表于 2021-04-28 17:01:41">2021-04-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-04-28T09:01:41.000Z" title="更新于 2021-04-28 17:01:41">2021-04-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%85%B6%E4%BB%96/">其他</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%85%B6%E4%BB%96/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>47分钟</span></span></div></div></div><article class="post-content" id="article-container"><h2 id="1：MySQL"><a href="#1：MySQL" class="headerlink" title="1：MySQL"></a>1：MySQL</h2><h3 id="1-1：为什么要使用数据库"><a href="#1-1：为什么要使用数据库" class="headerlink" title="1-1：为什么要使用数据库"></a>1-1：为什么要使用数据库</h3><p>为了更高效且条例分明的存储数据，能够更迅速和方便地管理数据。</p>
<ol>
<li>数据库可以结构化存储大量的数据信息，方便用户进行有效的检索和访问。</li>
<li>数据库可以有效地保证数据信息的一致性，完整性，降低数据冗余</li>
<li>数据库可以满足应用的共享和安全方面的要求，把数据放在数据库中在很多情况下也是出于安全的考虑。</li>
<li>数据库技术能够方便智能化地分析，产生新的有用信息。</li>
</ol>
<h3 id="1-2-什么是-SQL？"><a href="#1-2-什么是-SQL？" class="headerlink" title="1-2: 什么是 SQL？"></a>1-2: 什么是 SQL？</h3><ul>
<li>SQL 指结构化查询语言，全称是 Structured Query Language。</li>
<li>SQL 让您可以访问和处理数据库，包括数据插入、查询、更新和删除。</li>
<li>SQL 在 1986 年成为 ANSI（American National Standards Institute 美国国家标准化组织）的一项标准，在 1987 年成为国际标准化组织（ISO）标准。</li>
</ul>
<h3 id="1-3：什么是-MySQL"><a href="#1-3：什么是-MySQL" class="headerlink" title="1-3：什么是 MySQL?"></a>1-3：什么是 MySQL?</h3><p>MySQL 是一种关系型数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。</p>
<h2 id="2：关系型数据库与非关系型数据库"><a href="#2：关系型数据库与非关系型数据库" class="headerlink" title="2：关系型数据库与非关系型数据库"></a>2：关系型数据库与非关系型数据库</h2><h3 id="2-1：非关系型数据库和关系型数据库定义"><a href="#2-1：非关系型数据库和关系型数据库定义" class="headerlink" title="2-1：非关系型数据库和关系型数据库定义"></a>2-1：非关系型数据库和关系型数据库定义</h3><ul>
<li>关系数据库（英语：Relational database），是创建在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。</li>
<li>NoSQL（最初表示 Non-SQL，后来有人转解为 Not only SQL），是对不同于传统的关系数据库的数据库管理系统的统称。<br>允许部分资料使用 SQL 系统存储，而其他资料允许使用 NOSQL 系统存储。其数据存储可以不需要固定的表格模式以及元数据（metadata），也经常会避免使用 SQL 的 JOIN 操作，一般有水平可扩展性的特征。</li>
</ul>
<h3 id="2-2：关系型数据库优缺点"><a href="#2-2：关系型数据库优缺点" class="headerlink" title="2-2：关系型数据库优缺点"></a>2-2：关系型数据库优缺点</h3><p>优点：</p>
<ul>
<li>通过事务处理保持数据的一致性</li>
<li>数据更新的开销很小</li>
<li>可以进行 Join 等复杂查询</li>
<li>20 多年的技术历程，技术成熟</li>
</ul>
<p>缺点：</p>
<ul>
<li>数据读写必须经过 sql 解析，大量数据、高并发下读写性能不足</li>
<li>为保证数据一致性，需要加锁，影响并发操作</li>
<li>无法适应非结构化的存储</li>
<li>大量数据集中到一台服务区处理，使服务器不堪重负</li>
<li>“阻抗失谐”，即数据库中存储的对象与实际的对象实体有一定的差别</li>
<li>扩展困难</li>
<li>数据库庞大，价格昂贵</li>
</ul>
<h3 id="2-3：非关系型数据库优缺点"><a href="#2-3：非关系型数据库优缺点" class="headerlink" title="2-3：非关系型数据库优缺点"></a>2-3：非关系型数据库优缺点</h3><p>优点：</p>
<ul>
<li>处理高并发、大批量数据的能力强</li>
<li>支持分布式集群，负载均衡，性能高</li>
<li>解决“阻抗失谐”问题</li>
<li>内存级数据库，查询速度快</li>
<li>存储格式多，支持 key-value 形式、文档形式、图片形式</li>
<li>没有多表连接查询机制的限制，扩展性高</li>
</ul>
<p>缺点：</p>
<ul>
<li>技术起步晚，维护工具以及技术资料有限</li>
<li>不支持 sql 工业标准</li>
<li>没有 join 等复杂的连接操作</li>
<li>事务处理能力弱</li>
<li>没有完整性约束，对于复杂业务场景支持较差</li>
</ul>
<h3 id="2-4：非关系型数据库和关系型数据库区别"><a href="#2-4：非关系型数据库和关系型数据库区别" class="headerlink" title="2-4：非关系型数据库和关系型数据库区别"></a>2-4：非关系型数据库和关系型数据库区别</h3><table>
<thead>
<tr>
<th align="center">关系型数据库</th>
<th align="center">非关系型数据库</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数据相互关联</td>
<td align="center">数据独立</td>
</tr>
<tr>
<td align="center">一般数据量</td>
<td align="center">海量数据</td>
</tr>
<tr>
<td align="center">行存储</td>
<td align="center">列储存</td>
</tr>
<tr>
<td align="center">保证数据完整性和安全性</td>
<td align="center">不保证数据完整性和安全性存储</td>
</tr>
</tbody></table>
<h2 id="3：三大范式"><a href="#3：三大范式" class="headerlink" title="3：三大范式"></a>3：三大范式</h2><h3 id="3-1：数据库三大范式是什么"><a href="#3-1：数据库三大范式是什么" class="headerlink" title="3-1：数据库三大范式是什么"></a>3-1：数据库三大范式是什么</h3><ol>
<li>数据库表的每一列都是不可分割的基本数据项</li>
<li>每一行都要有唯一标识存在，这个唯一属性列被称为主关键字或主键、主码。实体的属性完全依赖于主关键字。</li>
<li>属性不依赖于其他非主属性。</li>
</ol>
<h2 id="4：数据库的数据类型"><a href="#4：数据库的数据类型" class="headerlink" title="4：数据库的数据类型"></a>4：数据库的数据类型</h2><h3 id="4-1：MySQL-的数据类型"><a href="#4-1：MySQL-的数据类型" class="headerlink" title="4-1：MySQL 的数据类型"></a>4-1：MySQL 的数据类型</h3><ul>
<li>TINYINT：1 个字节，整形</li>
<li>SMALLINT：2 个字节，整形</li>
<li>MEDIUMINT：3 个字节，整形</li>
<li>INT：4 个字节：整形</li>
<li>BITINT：8 个字节，整形</li>
<li>FLOAT：4 个字节，单精度浮点型</li>
<li>DOUBLE：8 个字节，双精度浮点型</li>
<li>DECIMAL：定点型，解决浮点数的精度丢失问题</li>
<li>CHAR：固定长度字符串</li>
<li>VARCHAR：可变长度字符串</li>
<li>DATA：3 个字节，yyyy-MM-dd，日期</li>
<li>TIME：3 个字节，HH:mm:ss，时间</li>
<li>YEAR：1 个字节，yyyy，年</li>
<li>DATETIME：8 个字节，yyyy-MM-dd HH:mm:ss 日期+时间</li>
<li>TIMESTAMP：4 个字节，yyyy-MM-dd HH:mm:ss 日期+时间，可作时间戳</li>
</ul>
<h3 id="4-2：varchar-与-char-的区别"><a href="#4-2：varchar-与-char-的区别" class="headerlink" title="4-2：varchar 与 char 的区别"></a>4-2：varchar 与 char 的区别</h3><p>char 是一种固定长度的类型，varchar 则是一种可变长度的类型，它们的区别是：</p>
<ul>
<li>char(M)类型的数据列里，每个值都占用 M 个字节，如果某个长度小于 M，MySQL 就会在它的右边用空格字符补足．（在检索操作中那些填补出来的空格字符将被去掉）</li>
<li>在 varchar(M)类型的数据列里，每个值只占用刚好够用的字节再加上一个用来记录其长度的字节（即总长度为 L+1 字节）．</li>
</ul>
<h4 id="4-2-1：varchar-50-中-50-的涵义"><a href="#4-2-1：varchar-50-中-50-的涵义" class="headerlink" title="4-2-1：varchar(50)中 50 的涵义"></a>4-2-1：varchar(50)中 50 的涵义</h4><p>varchar(50)中 50 的涵义最多存放 50 个字符，varchar(50)和(200)存储 hello 所占空间一样，但后者在排序时会消耗更多内存，<br>因为 order by col 采用 fixed_length 计算 col 长度</p>
<h3 id="4-3：int-20-中-20-的涵义"><a href="#4-3：int-20-中-20-的涵义" class="headerlink" title="4-3：int(20)中 20 的涵义"></a>4-3：int(20)中 20 的涵义</h3><p>显示长度，不足用 0 补齐</p>
<h3 id="4-4：FLOAT-和-DOUBLE-的区别是什么？"><a href="#4-4：FLOAT-和-DOUBLE-的区别是什么？" class="headerlink" title="4-4：FLOAT 和 DOUBLE 的区别是什么？"></a>4-4：FLOAT 和 DOUBLE 的区别是什么？</h3><p>单精度和双精度的区别</p>
<h3 id="4-5：MySQL-INT-和-CHAR-隐式类型转换需要注意什么？"><a href="#4-5：MySQL-INT-和-CHAR-隐式类型转换需要注意什么？" class="headerlink" title="4-5：MySQL INT 和 CHAR 隐式类型转换需要注意什么？"></a>4-5：MySQL INT 和 CHAR 隐式类型转换需要注意什么？</h3><ol>
<li>当查询字段是 INT 类型，如果查询条件为 CHAR，将查询条件转换为 INT，如果是字符串前导都是数字，将截取前导数字用来比较，如果没有前导数字，则转换为 0。</li>
<li>当查询字段是 CHAR/VARCHAR 类型，如果查询条件为 INT，将查询字段为换为 INT 再进行比较，可能会造成全表扫描。</li>
</ol>
<h2 id="5：SQL-生命周期"><a href="#5：SQL-生命周期" class="headerlink" title="5：SQL 生命周期"></a>5：SQL 生命周期</h2><ul>
<li>连接器：建立连接</li>
<li>查询缓存：缓冲中存在则返回，否则继续执行（8.0 后删除）</li>
<li>分析器：词法分析，判断是否合法</li>
<li>优化器：索引优化</li>
<li>执行器：有索引则按照索引树跳转，否则全表扫描。</li>
</ul>
<h2 id="6：MySQL-预编译"><a href="#6：MySQL-预编译" class="headerlink" title="6：MySQL 预编译"></a>6：MySQL 预编译</h2><h3 id="6-1：预编译的好处"><a href="#6-1：预编译的好处" class="headerlink" title="6-1：预编译的好处"></a>6-1：预编译的好处</h3><p>即时 sql 每次都会进行分析和优化，而预编译 sql 将语句参数化，实现一次编译，多次执行。省去了解析优化等过程。此外预编译能防止 sql 注入。</p>
<h2 id="7：SQL-注入"><a href="#7：SQL-注入" class="headerlink" title="7：SQL 注入"></a>7：SQL 注入</h2><h3 id="7-1：SQL-注入简介"><a href="#7-1：SQL-注入简介" class="headerlink" title="7-1：SQL 注入简介"></a>7-1：SQL 注入简介</h3><p>Sql 注入攻击是通过将恶意的 Sql 查询或添加语句插入到应用的输入参数中，再在后台 Sql 服务器上解析执行进行的攻击，它目前黑客对数据库进行攻击的最常用手段之一。</p>
<h3 id="7-2：SQL-注入解决方案"><a href="#7-2：SQL-注入解决方案" class="headerlink" title="7-2：SQL 注入解决方案"></a>7-2：SQL 注入解决方案</h3><ul>
<li>严格限制 Web 应用的数据库的操作权限，给连接数据库的用户提供满足需要的最低权限，最大限度的减少注入攻击对数据库的危害</li>
<li>校验参数的数据格式是否合法（可以使用正则或特殊字符的判断）</li>
<li>对进入数据库的特殊字符进行转义处理，或编码转换</li>
<li>预编译 SQL（Java 中使用 PreparedStatement），参数化查询方式，避免 SQL 拼接</li>
<li>发布前，利用工具进行 SQL 注入检测</li>
<li>报错信息不要包含 SQL 信息输出到 Web 页面</li>
</ul>
<h2 id="8：sql-语句"><a href="#8：sql-语句" class="headerlink" title="8：sql 语句"></a>8：sql 语句</h2><h3 id="8-1：SQL-的分类"><a href="#8-1：SQL-的分类" class="headerlink" title="8-1：SQL 的分类"></a>8-1：SQL 的分类</h3><ul>
<li>数据操作语言(DML)：对数据库中数据的操作</li>
<li>数据定义语言(DDL)：定义 SQL 模式，基本表，视图和索引的创建和撤销</li>
<li>数据控制语言(DCL)：用于数据库搜全，角色控制等管理工作</li>
<li>事务控制语言(TCL)：用于数据库的事务管理</li>
</ul>
<h3 id="8-2：多表查询"><a href="#8-2：多表查询" class="headerlink" title="8-2：多表查询"></a>8-2：多表查询</h3><ul>
<li>合并查询结果（union，union all）</li>
<li>连接查询（交叉连接（cross join）、内连接（inner join）、左连接（left join）、右连接（right join)、全连接）</li>
<li>CASE 表达式。</li>
</ul>
<h4 id="8-2-1：笛卡尔积问题"><a href="#8-2-1：笛卡尔积问题" class="headerlink" title="8-2-1：笛卡尔积问题"></a>8-2-1：笛卡尔积问题</h4><p>连接查询，如果 on 条件是非唯一字段，会出现笛卡尔积(局部笛卡尔积)；如果 on 条件是表的唯一字段，则不会出现笛卡尔积。</p>
<h4 id="8-2-2：笛卡尔积的解决方案"><a href="#8-2-2：笛卡尔积的解决方案" class="headerlink" title="8-2-2：笛卡尔积的解决方案"></a>8-2-2：笛卡尔积的解决方案</h4><ul>
<li>使用左连接，右连接，内连接</li>
<li>使用唯一条件作为 on 筛选条件</li>
</ul>
<h3 id="8-3：常见函数"><a href="#8-3：常见函数" class="headerlink" title="8-3：常见函数"></a>8-3：常见函数</h3><ul>
<li>ABS(X):返回 X 的绝对值</li>
<li>MOD(N,M)或%:返回 N 被 M 除的余数</li>
<li>FLOOR(X):返回不大于 X 的最大整数值</li>
<li>CEILING(X):返回不小于 X 的最小整数值</li>
<li>ROUND(X) :返回参数 X 的四舍五入的一个整数</li>
<li>….</li>
</ul>
<h4 id="8-3-1：单行函数"><a href="#8-3-1：单行函数" class="headerlink" title="8-3-1：单行函数"></a>8-3-1：单行函数</h4><h4 id="8-3-2：聚合函数"><a href="#8-3-2：聚合函数" class="headerlink" title="8-3-2：聚合函数"></a>8-3-2：聚合函数</h4><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">备注</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">AVG([distinct] expr)</td>
<td align="center">求平均值</td>
<td></td>
</tr>
<tr>
<td align="center">COUNT({*</td>
<td align="center">[distinct] } expr)</td>
<td>统计行的数量</td>
</tr>
<tr>
<td align="center">MAX([distinct] expr)</td>
<td align="center">求最大值</td>
<td></td>
</tr>
<tr>
<td align="center">MIN([distinct] expr)</td>
<td align="center">求最小值</td>
<td></td>
</tr>
<tr>
<td align="center">SUM([distinct] expr)</td>
<td align="center">求累加和</td>
<td></td>
</tr>
</tbody></table>
<h3 id="8-4：关键字-语句"><a href="#8-4：关键字-语句" class="headerlink" title="8-4：关键字/语句"></a>8-4：关键字/语句</h3><h4 id="8-4-1：truncate、-delete-区别"><a href="#8-4-1：truncate、-delete-区别" class="headerlink" title="8-4-1：truncate、 delete 区别"></a>8-4-1：truncate、 delete 区别</h4><ul>
<li>DELETE 语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。</li>
<li>TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。</li>
<li>drop 语句将表所占用的空间全释放掉。</li>
</ul>
<p>in 是把外表和内表作 hash 连接，而 exists 是对外表作 loop 循环，每次 loop 循环再对内表进行查询。 in 其实与等于相似，比如 in(1,2) 就是 = 1 or = 2 的一种简单写法，所以一般在元素少的时候使用 in，如果多的话就用 exists</p>
<h4 id="8-4-2：mysql-的-having-用法"><a href="#8-4-2：mysql-的-having-用法" class="headerlink" title="8-4-2：mysql 的 having 用法"></a>8-4-2：mysql 的 having 用法</h4><p>having 字句可以让我们筛选成组后的各种数据，where 字句在聚合前先筛选记录，也就是说作用在 group by 和 having 字句前。而 having 子句在聚合后对组记录进行筛选。<br>where 和 having 不可以同时使用</p>
<h4 id="8-4-3：mysql-中-in-和-exists-区别"><a href="#8-4-3：mysql-中-in-和-exists-区别" class="headerlink" title="8-4-3：mysql 中 in 和 exists 区别"></a>8-4-3：mysql 中 in 和 exists 区别</h4><ul>
<li>IN 适合于外表大而内表小的情况</li>
<li>EXISTS 适合于外表小而内表大的情况</li>
</ul>
<h4 id="8-4-4：WHERE-子句和-HAVING-子句的执行速度"><a href="#8-4-4：WHERE-子句和-HAVING-子句的执行速度" class="headerlink" title="8-4-4：WHERE 子句和 HAVING 子句的执行速度"></a>8-4-4：WHERE 子句和 HAVING 子句的执行速度</h4><p>WHERE 处理速度比 HAVING 处理速度高</p>
<h4 id="8-4-5：groupby-和-having-的区别"><a href="#8-4-5：groupby-和-having-的区别" class="headerlink" title="8-4-5：groupby 和 having 的区别"></a>8-4-5：groupby 和 having 的区别</h4><p>groupby 是对数据分组，而 having 是对分组的结果进行筛选，两者相辅相成。</p>
<h4 id="8-4-6：UNION-与-UNION-ALL-的区别？"><a href="#8-4-6：UNION-与-UNION-ALL-的区别？" class="headerlink" title="8-4-6：UNION 与 UNION ALL 的区别？"></a>8-4-6：UNION 与 UNION ALL 的区别？</h4><p>union 会去重，union all 保留所有数据</p>
<h4 id="8-4-7：count-、count-1-、count-column-的区别"><a href="#8-4-7：count-、count-1-、count-column-的区别" class="headerlink" title="8-4-7：count(*)、count(1)、count(column)的区别"></a>8-4-7：count(*)、count(1)、count(column)的区别</h4><ol>
<li>count(*)查询所有行</li>
<li>count(1)查询所有行</li>
<li>count(column)统计列字段，会忽略 null 的情况</li>
</ol>
<p>执行效率上，count(*)=count(1)&gt;count(primary key)&gt;count(column)</p>
<h4 id="8-4-8：MySQL，左连接中-on-和-where-的区别"><a href="#8-4-8：MySQL，左连接中-on-和-where-的区别" class="headerlink" title="8-4-8：MySQL，左连接中 on 和 where 的区别"></a>8-4-8：MySQL，左连接中 on 和 where 的区别</h4><p>on 是两个表之间的筛选条件，最先执行，where 是对单表进行筛选。</p>
<h3 id="8-5：增删改查（CURD）-日志"><a href="#8-5：增删改查（CURD）-日志" class="headerlink" title="8-5：增删改查（CURD）+ 日志"></a>8-5：增删改查（CURD）+ 日志</h3><h4 id="8-5-1：一条-sql-执行过程"><a href="#8-5-1：一条-sql-执行过程" class="headerlink" title="8-5-1：一条 sql 执行过程"></a>8-5-1：一条 sql 执行过程</h4><ul>
<li>MySQL 主要分为 Server 层和引擎层，Server 层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用,redolog 只有 InnoDB 有。</li>
<li>引擎层是插件式的，目前主要包括，MyISAM,InnoDB,Memory 等。</li>
<li>SQL 等执行过程分为两类，一类对于查询等过程如下：权限校验—&gt;查询缓存（8.0 以前）—&gt;分析器（词法分析，语法分析）—&gt;优化器（确定执行方案）—&gt;权限校验—&gt;执行器—&gt;引擎</li>
<li>对于更新等语句执行流程如下：分析器—-&gt;权限校验—-&gt;执行器—&gt;引擎—redo log prepare—&gt;binlog—&gt;redo log commit</li>
</ul>
<h4 id="8-5-2：一条-sql-更新-删除-增加语句时怎么执行的"><a href="#8-5-2：一条-sql-更新-删除-增加语句时怎么执行的" class="headerlink" title="8-5-2：一条 sql 更新/删除/增加语句时怎么执行的"></a>8-5-2：一条 sql 更新/删除/增加语句时怎么执行的</h4><ul>
<li>先查询数据，如果有缓存，也是会用到缓存。</li>
<li>修改数据，然后调用引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。</li>
<li>执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为提交状态。</li>
<li>更新完成。</li>
</ul>
<h4 id="8-5-3：日志"><a href="#8-5-3：日志" class="headerlink" title="8-5-3：日志"></a>8-5-3：日志</h4><p>日志文件中记录着 MySQL 数据库运行期间发生的变化；也就是说用来记录 MySQL 数据库的客户端连接状况、SQL 语句的执行情况和错误信息等。当数据库遭到意外的损坏时，可以通过日志查看文件出错的原因，并且可以通过日志文件进行数据恢复。</p>
<h4 id="8-5-4：什么是-binlog"><a href="#8-5-4：什么是-binlog" class="headerlink" title="8-5-4：什么是 binlog"></a>8-5-4：什么是 binlog</h4><p>binlog 是 MySQl server 层维护的一种二进制日志，这个文件记录了 MySQL 所有的 DML 操作。通过 binlog 日志我们可以做数据恢复，增量备份，主主复制和主从复制等等</p>
<h4 id="8-5-5：binlog-一般用来做什么"><a href="#8-5-5：binlog-一般用来做什么" class="headerlink" title="8-5-5：binlog 一般用来做什么"></a>8-5-5：binlog 一般用来做什么</h4><ul>
<li>复制：MySQL Replication 在 Master 端开启 binlog，Master 把它的二进制日志传递给 slaves 并回放来达到 master-slave 数据一致的目的</li>
<li>数据恢复：通过 mysqlbinlog 工具恢复数据</li>
<li>增量备份</li>
</ul>
<h4 id="8-5-6：MySQL-的-binlog-有几种录入格式"><a href="#8-5-6：MySQL-的-binlog-有几种录入格式" class="headerlink" title="8-5-6：MySQL 的 binlog 有几种录入格式"></a>8-5-6：MySQL 的 binlog 有几种录入格式</h4><ul>
<li>Statement：每一条会修改数据的 sql 都会记录在 binlog 中</li>
<li>MiXED：不记录 sql 语句上下文相关信息，仅保存哪条记录被修改</li>
<li>ROW：是以上两种 level 的混合使用，一般的语句修改使用 statment 格式保存 binlog，如一些函数，statement 无法完成主从复制的操作，则采用 row 格式保存 binlog,MySQL 会根据执行的每一条具体的 sql 语句来区分对待记录的日志形式，也就是在 Statement 和 Row 之间选择一种.新版本的 MySQL 中 row level 模式也被做了优化，并不是所有的修改都会以 row level 来记录，像遇到表结构变更的时候就会以 statement 模式来记录。至于 update 或者 delete 等修改数据的语句，还是会记录所有行的变更。</li>
</ul>
<h4 id="8-5-7：redo-log"><a href="#8-5-7：redo-log" class="headerlink" title="8-5-7：redo log"></a>8-5-7：redo log</h4><p>当我们想要修改 DB 上某一行数据的时候，InnoDB 是把数据从磁盘读取到内存的缓冲池上进行修改。这个时候数据在内存中被修改，与磁盘中相比就存在了差异，我们称这种有差异的数据为脏页。<br>InnoDB 对脏页的处理不是每次生成脏页就将脏页刷新回磁盘，这样会产生海量的 IO 操作，严重影响 InnoDB 的处理性能。既然脏页与磁盘中的数据存在差异，那么如果在这期间 DB 出现故障就会造成数据的丢失。为了解决这个问题，redo log 就应运而生了。</p>
<p>redo log 就是存储了数据被修改后的值。当我们提交一个事务时，InnoDB 会先去把要修改的数据写入日志，然后再去修改缓冲池里面的真正数据页。</p>
<h4 id="8-5-8：binlog-和-redo-log-比较"><a href="#8-5-8：binlog-和-redo-log-比较" class="headerlink" title="8-5-8：binlog 和 redo log 比较"></a>8-5-8：binlog 和 redo log 比较</h4><ul>
<li>redo log 是属于 innoDB 层面，binlog 属于 MySQL Server 层面的，这样在数据库用别的存储引擎时可以达到一致性的要求。</li>
<li>redo log 是物理日志，记录该数据页更新的内容；binlog 是逻辑日志，记录的是这个更新语句的原始逻辑</li>
<li>redo log 是循环写，日志空间大小固定；binlog 是追加写，是指一份写到一定大小的时候会更换下一个文件，不会覆盖。</li>
<li>binlog 可以作为恢复数据使用，主从复制搭建，redo log 作为异常宕机或者介质故障后的数据恢复使用。</li>
</ul>
<h4 id="8-5-9：我写其中的某一个-log，失败了，那会怎么办？"><a href="#8-5-9：我写其中的某一个-log，失败了，那会怎么办？" class="headerlink" title="8-5-9：我写其中的某一个 log，失败了，那会怎么办？"></a>8-5-9：我写其中的某一个 log，失败了，那会怎么办？</h4><p>因为 redo log 和 bin log 的两阶段提交，所以不会影响数据。</p>
<h4 id="8-5-10：两阶段提交意义"><a href="#8-5-10：两阶段提交意义" class="headerlink" title="8-5-10：两阶段提交意义"></a>8-5-10：两阶段提交意义</h4><ol>
<li>如果先写 redo log，后写 binlog，假如 binlog 失败，恢复后主库根据 redo log 重做，但是 binlog 不存在，复制到从库到出现主从不一致</li>
<li>如果先写 binlog，后写 redolog，假如 redo log 失败，恢复后从库根据主库的 binlog 回放数据，但是主库因为 redo log 不存在回滚事务。也会出现主从不一致。</li>
</ol>
<p>两阶段先在 redo log 提交变为 prepare 状态，修改后提交 binlog，再把 redo log 改为 commit 状态。保证了数据的一致性。</p>
<h4 id="8-5-11：MySQL-如何保证-redo-log-和-binlog-的数据是一致的"><a href="#8-5-11：MySQL-如何保证-redo-log-和-binlog-的数据是一致的" class="headerlink" title="8-5-11：MySQL 如何保证 redo log 和 binlog 的数据是一致的"></a>8-5-11：MySQL 如何保证 redo log 和 binlog 的数据是一致的</h4><p>通过两阶段提交。</p>
<ol>
<li>如果数据库在记录此事务的 binlog 之前和过程中发生 crash。数据库在恢复后认为此事务并没有成功提交，则会回滚此事务的操作。与此同时，因为在 binlog 中也没有此事务的记录，所以从库也不会有此事务的数据修改。</li>
<li>如果数据库在记录此事务的 binlog 之后发生 crash。此时，即使是 redo log 中还没有记录此事务的 commit 标签，数据库在恢复后也会认为此事务提交成功（因为在上述两阶段过程中，binlog 写入成功就认为事务成功提交了）。它会扫描最后一个 binlog 文件，并提取其中的事务 ID（xid），InnoDB 会将那些状态为 Prepare 的事务（redo log 没有记录 commit 标签）的 xid 和 Binlog 中提取的 xid 做比较，如果在 Binlog 中存在，则提交该事务，否则回滚该事务。这也就是说，binlog 中记录的事务，在恢复时都会被认为是已提交事务，会在 redo log 中重新写入 commit 标志，并完成此事务的重做（主库中有此事务的数据修改）。与此同时，因为在 binlog 中已经有了此事务的记录，所有从库也会有此事务的数据修改。</li>
</ol>
<h4 id="8-5-12：如果整个数据库的数据都被删除了，那我可以用-redo-log-的记录来恢复吗？"><a href="#8-5-12：如果整个数据库的数据都被删除了，那我可以用-redo-log-的记录来恢复吗？" class="headerlink" title="8-5-12：如果整个数据库的数据都被删除了，那我可以用 redo log 的记录来恢复吗？"></a>8-5-12：如果整个数据库的数据都被删除了，那我可以用 redo log 的记录来恢复吗？</h4><p>不能，因为功能的不同，redo log 存储的是物理数据的变更，如果我们内存的数据已经刷到了磁盘了，那 redo log 的数据就无效了。所以 redo log 不会存储着历史所有数据的变更，文件的内容会被覆盖的。</p>
<h4 id="8-5-13：MySQL-查询字段区不区分大小写？"><a href="#8-5-13：MySQL-查询字段区不区分大小写？" class="headerlink" title="8-5-13：MySQL 查询字段区不区分大小写？"></a>8-5-13：MySQL 查询字段区不区分大小写？</h4><p>MySQL 查询是不区分大小写的。</p>
<h4 id="8-5-14：如何解决需要区分英文大小写的场景"><a href="#8-5-14：如何解决需要区分英文大小写的场景" class="headerlink" title="8-5-14：如何解决需要区分英文大小写的场景"></a>8-5-14：如何解决需要区分英文大小写的场景</h4><ol>
<li>Mysql 默认的字符检索策略：utf8_general_ci，表示不区分大小写；utf8_general_cs 表示区分大小写，utf8_bin 表示二进制比较，同样也区分大小写</li>
<li>直接修改 sql 语句，在要查询的字段前面加上 binary 关键字即可。</li>
</ol>
<h3 id="8-6：常见约束"><a href="#8-6：常见约束" class="headerlink" title="8-6：常见约束"></a>8-6：常见约束</h3><h4 id="8-6-1：字段为什么要求定义为-not-null"><a href="#8-6-1：字段为什么要求定义为-not-null" class="headerlink" title="8-6-1：字段为什么要求定义为 not null?"></a>8-6-1：字段为什么要求定义为 not null?</h4><ol>
<li>索引性能不好 Mysql 难以优化引用可空列查询，它会使索引、索引统计和值更加复杂。可空列需要更多的存储空间，还需要 mysql 内部进行特殊处理。可空列被索引后，每条记录都需要一个额外的字节，还能导致 MYisam 中固定大小的索引变成可变大小的索引。如此看来，不指定 not null 并没有性能上的优势。</li>
<li>查询会出现一些不可预料的结果，因为 null 列的存在，会出现很多出人意料的结果，从而浪费开发时间去排查 Bug。</li>
</ol>
<h4 id="8-6-2：超键、候选键、主键、外键分别是什么？"><a href="#8-6-2：超键、候选键、主键、外键分别是什么？" class="headerlink" title="8-6-2：超键、候选键、主键、外键分别是什么？"></a>8-6-2：超键、候选键、主键、外键分别是什么？</h4><ul>
<li>超键(super key):在关系中能唯一标识元组的属性集称为关系模式的超键。</li>
<li>候选键(candidate key):不含有多余属性的超键称为候选键。</li>
<li>主键(primary key):用户选作元组标识的一个候选键程序主键。</li>
<li>外键(foreign key)如果关系模式 R1 中的某属性集不是 R1 的主键，而是另一个关系 R2 的主键则该属性集是关系模式 R1 的外键。</li>
</ul>
<h4 id="8-6-3：为什么用自增列作为主键"><a href="#8-6-3：为什么用自增列作为主键" class="headerlink" title="8-6-3：为什么用自增列作为主键"></a>8-6-3：为什么用自增列作为主键</h4><ul>
<li>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。</li>
<li>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页的中间某个位置，此时 MySQL 不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过 OPTIMIZE TABLE 来重建表并优化填充页面。</li>
</ul>
<h4 id="8-6-4：主键使用自增-ID-还是-UUID"><a href="#8-6-4：主键使用自增-ID-还是-UUID" class="headerlink" title="8-6-4：主键使用自增 ID 还是 UUID?"></a>8-6-4：主键使用自增 ID 还是 UUID?</h4><p>自增 id</p>
<h4 id="8-6-5：使用自增-id-的缺点"><a href="#8-6-5：使用自增-id-的缺点" class="headerlink" title="8-6-5：使用自增 id 的缺点"></a>8-6-5：使用自增 id 的缺点</h4><ol>
<li>别人一旦爬取你的数据库,就可以根据数据库的自增 id 获取到你的业务增长信息，很容易分析出你的经营情况</li>
<li>对于高并发的负载，innodb 在按主键进行插入的时候会造成明显的锁争用，主键的上界会成为争抢的热点，因为所有的插入都发生在这里，并发插入会导致间隙锁竞争</li>
<li>Auto_Increment 锁机制会造成自增锁的抢夺,有一定的性能损失</li>
</ol>
<h4 id="8-6-6：数据库主键自增怎么获取主键值"><a href="#8-6-6：数据库主键自增怎么获取主键值" class="headerlink" title="8-6-6：数据库主键自增怎么获取主键值"></a>8-6-6：数据库主键自增怎么获取主键值</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">”insertUser”</span>  <span class="attr">useGeneratedKeys</span>=<span class="string">”true”</span> <span class="attr">keyProperty</span>=<span class="string">”userId”</span> &gt;</span></span><br><span class="line">insert into user(</span><br><span class="line">user_name, user_password, create_time)</span><br><span class="line">values(#&#123;userName&#125;, #&#123;userPassword&#125; , #&#123;createTime, jdbcType= TIMESTAMP&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="8-6-7：为什么要尽量设定一个主键"><a href="#8-6-7：为什么要尽量设定一个主键" class="headerlink" title="8-6-7：为什么要尽量设定一个主键?"></a>8-6-7：为什么要尽量设定一个主键?</h4><p>设定了主键之后,在后续的删改查的时候可能更加快速以及确保操作数据范围安全</p>
<h2 id="9：sql-实战"><a href="#9：sql-实战" class="headerlink" title="9：sql 实战"></a>9：sql 实战</h2><h3 id="9-1：去重重复数据"><a href="#9-1：去重重复数据" class="headerlink" title="9-1：去重重复数据"></a>9-1：去重重复数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> <span class="keyword">id</span> <span class="keyword">from</span> <span class="keyword">table</span></span><br></pre></td></tr></table></figure>

<h3 id="9-2：MySQL-如何高效率随机获取-N-条数据？"><a href="#9-2：MySQL-如何高效率随机获取-N-条数据？" class="headerlink" title="9-2：MySQL 如何高效率随机获取 N 条数据？"></a>9-2：MySQL 如何高效率随机获取 N 条数据？</h3><p>计算 id 最大值和最小值，从中取随机数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> mm_account</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> &gt;= ((<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(<span class="keyword">id</span>) <span class="keyword">FROM</span> mm_account)-(<span class="keyword">SELECT</span> <span class="keyword">MIN</span>(<span class="keyword">id</span>) <span class="keyword">FROM</span> mm_account)) * <span class="keyword">RAND</span>() + (<span class="keyword">SELECT</span> <span class="keyword">MIN</span>(<span class="keyword">id</span>) <span class="keyword">FROM</span> mm_account)</span><br><span class="line"><span class="keyword">limit</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<h2 id="10：事务"><a href="#10：事务" class="headerlink" title="10：事务"></a>10：事务</h2><h3 id="10-1：什么是事务"><a href="#10-1：什么是事务" class="headerlink" title="10-1：什么是事务"></a>10-1：什么是事务</h3><p>MySQL 事务主要用于处理操作量大，复杂度高的数据。用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。</p>
<h3 id="10-2：数据库事务特性"><a href="#10-2：数据库事务特性" class="headerlink" title="10-2：数据库事务特性"></a>10-2：数据库事务特性</h3><ol>
<li><strong>A (Atomicity) 原子性</strong><br>原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。<br>比如银行转账，从 A 账户转 100 元至 B 账户，分为两个步骤：1）从 A 账户取 100 元；2）存入 100 元至 B 账户。这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了 100 元。</li>
<li><strong>C (Consistency) 一致性</strong><br>一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。<br>例如现有完整性约束 a+b=10，如果一个事务改变了 a，那么必须得改变 b，使得事务结束后依然满足 a+b=10，否则事务失败。</li>
<li><strong>I (Isolation) 隔离性</strong><br>所谓的隔离性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。<br>比如现有有个交易是从 A 账户转 100 元至 B 账户，在这个交易还未完成的情况下，如果此时 B 查询自己的账户，是看不到新增加的 100 元的。</li>
<li><strong>D (Durability) 持久性</strong><br>持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。</li>
</ol>
<h3 id="10-3：ACID-靠什么保证的-底层原理"><a href="#10-3：ACID-靠什么保证的-底层原理" class="headerlink" title="10-3：ACID 靠什么保证的(底层原理)"></a>10-3：ACID 靠什么保证的(底层原理)</h3><ol>
<li>原子性通过<code>undo log</code>日志实现。回滚日志会记录相应的日志信息，例如 delete 数据时，记录一条 insert 语句，回滚时插入。</li>
<li>通过原子性，持久性，隔离性保证了一致性。</li>
<li>通过<code>redo log</code>保证持久性，重做日志会记录处理后的数据。</li>
<li>通过锁保证了隔离性</li>
</ol>
<h4 id="10-3-1：什么是-undo-log"><a href="#10-3-1：什么是-undo-log" class="headerlink" title="10-3-1：什么是 undo log"></a>10-3-1：什么是 undo log</h4><p>undo log 主要有两个作用：回滚和多版本控制(MVCC)</p>
<p>在数据修改的时候，不仅记录了 redo log，还记录 undo log，如果因为某些原因导致事务失败或回滚了，可以用 undo log 进行回滚</p>
<h3 id="10-4：数据库崩溃时事务的恢复机制"><a href="#10-4：数据库崩溃时事务的恢复机制" class="headerlink" title="10-4：数据库崩溃时事务的恢复机制"></a>10-4：数据库崩溃时事务的恢复机制</h3><p>undo log 通过回滚保证事务的原子性，redo log 通过恢复保证事务的持久性</p>
<h3 id="10-5：在并发环境下-事务会发生哪些问题"><a href="#10-5：在并发环境下-事务会发生哪些问题" class="headerlink" title="10-5：在并发环境下,事务会发生哪些问题?"></a>10-5：在并发环境下,事务会发生哪些问题?</h3><ol>
<li>脏读(dirty read)：如果第二个事务查询到第一个事务还未提交的更新数据，形成脏读。</li>
<li>幻读(phantom read)：一个事务执行两次查询，第二次查询比第一次多出或少一些数据，造成两次结果不一致。只是另一个事务在这两次查询中间插入或者删除了数据造成的。</li>
<li>不可重复读(unrepeated read)：一个事务两次读取同一行数据，结果得到不同状态结果，如中间正好另一个事务更新了该数据，两次结果相异，不可信任。</li>
</ol>
<h4 id="10-5-1：不可重复读和幻读的区别"><a href="#10-5-1：不可重复读和幻读的区别" class="headerlink" title="10-5-1：不可重复读和幻读的区别"></a>10-5-1：不可重复读和幻读的区别</h4><p>不可重复读是对同一条数据而言，而幻读是对多条数据的读取结果。</p>
<h4 id="10-5-2：如何解决幻读"><a href="#10-5-2：如何解决幻读" class="headerlink" title="10-5-2：如何解决幻读"></a>10-5-2：如何解决幻读</h4><p>使用序列化隔离等级，这个等级会开启表锁。</p>
<h3 id="10-6：如何解决事务并发问题"><a href="#10-6：如何解决事务并发问题" class="headerlink" title="10-6：如何解决事务并发问题"></a>10-6：如何解决事务并发问题</h3><p>通过加锁和 MVCC 机制</p>
<h3 id="10-7：四大隔离级别"><a href="#10-7：四大隔离级别" class="headerlink" title="10-7：四大隔离级别"></a>10-7：四大隔离级别</h3><ol>
<li><strong>读未提交：read uncommitted</strong><br>SELECT 语句以非锁定方式被执行，所以有可能读到脏数据，隔离级别最低。（读不锁）</li>
<li><strong>读已提交：read committed</strong><br>只能读取到已经提交的数据。即解决了脏读，但未解决不可重复读。（读锁，等写完）</li>
<li><strong>可重复读：repeatable read</strong><br>在同一个事务内的查询都是事务开始时刻一致的，InnoDB 的默认级别。在 SQL 标准中，该隔离级别消除了不可重复读，但是还存在幻读。(写锁，等读完)</li>
<li><strong>串行化：serializable</strong><br>完全的串行化读，所有 SELECT 语句都被隐式的转换成 SELECT … LOCK IN SHARE MODE，即读取使用表级共享锁，读写相互都会阻塞。隔离级别最高。(以上 3 个均为行锁/记录锁，当前为表锁)</li>
</ol>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Read uncommitted</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">Read committed</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">Repeatable read</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">Serializable</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<h4 id="10-7-1：隔离级别的原理"><a href="#10-7-1：隔离级别的原理" class="headerlink" title="10-7-1：隔离级别的原理"></a>10-7-1：隔离级别的原理</h4><p>在数据库增删改查四种操作中，insert、delete 和 update 都是会加排它锁(Exclusive Locks)的，而 select 只有显式声明才会加锁:</p>
<ul>
<li>select: 即最常用的查询，是不加任何锁的</li>
<li>select … lock in share mode: 会加共享锁(Shared Locks)</li>
<li>select … for update: 会加排它锁</li>
<li>读未提交中写虽然会加排他锁，但是读不加锁所以排他锁不会影响读取数据</li>
<li>读已提交中写加排他锁，读的时候不加写锁而是获取 MVCC 机制，获取最新快照。因为快照是每次 select 生成，如果多次 select 间有事务提交更改数据，就出现了不可重复读问题。</li>
<li>可重复读中写加排他锁，不同的是 MVCC 版本的生成时机：一次事务只在第一次 select 时生成快照。后续读取都是基于一个版本，实现了可重复读。</li>
<li>串行化会在读时加共享锁，写时加排他锁。</li>
</ul>
<h4 id="10-7-2：MySQL-中-RC（读已提交）和-RR（可重复读）隔离级别的区别"><a href="#10-7-2：MySQL-中-RC（读已提交）和-RR（可重复读）隔离级别的区别" class="headerlink" title="10-7-2：MySQL 中 RC（读已提交）和 RR（可重复读）隔离级别的区别"></a>10-7-2：MySQL 中 RC（读已提交）和 RR（可重复读）隔离级别的区别</h4><p>在于 MVCC 版本的加载时机，读已提交是每次 select 都会读取快照，可重复读是事务第一次读取生成快照，后续基于这个版本查询。</p>
<h3 id="10-8：如何手动处理事务"><a href="#10-8：如何手动处理事务" class="headerlink" title="10-8：如何手动处理事务"></a>10-8：如何手动处理事务</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span></span><br><span class="line">....</span><br><span class="line"><span class="keyword">commit</span></span><br></pre></td></tr></table></figure>

<p>语句内的一系列语句都处于一个事务周期内，否则每一个 sql 语句都是一个独立事务。</p>
<h2 id="11：引擎"><a href="#11：引擎" class="headerlink" title="11：引擎"></a>11：引擎</h2><h3 id="11-1：MySQL-存储引擎-MyISAM-与-InnoDB-区别"><a href="#11-1：MySQL-存储引擎-MyISAM-与-InnoDB-区别" class="headerlink" title="11-1：MySQL 存储引擎 MyISAM 与 InnoDB 区别"></a>11-1：MySQL 存储引擎 MyISAM 与 InnoDB 区别</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">MyIASM</th>
<th align="center">InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td align="center">事务支持</td>
<td align="center">不支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">外键约束</td>
<td align="center">不支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">索引结构</td>
<td align="center">非聚集索引</td>
<td align="center">聚集索引</td>
</tr>
<tr>
<td align="center">保存行数</td>
<td align="center">保存</td>
<td align="center">不保存</td>
</tr>
<tr>
<td align="center">全文索引</td>
<td align="center">支持</td>
<td align="center">不支持</td>
</tr>
<tr>
<td align="center">粒度</td>
<td align="center">表锁</td>
<td align="center">行锁</td>
</tr>
<tr>
<td align="center">主键</td>
<td align="center">不必需</td>
<td align="center">必需</td>
</tr>
<tr>
<td align="center">存储文件</td>
<td align="center">frm</td>
<td align="center">frm,MYD,MYI</td>
</tr>
<tr>
<td align="center">存储空间</td>
<td align="center">可压缩</td>
<td align="center">不可压缩</td>
</tr>
</tbody></table>
<h3 id="11-2：InnoDB-引擎的-4-大特性"><a href="#11-2：InnoDB-引擎的-4-大特性" class="headerlink" title="11-2：InnoDB 引擎的 4 大特性"></a>11-2：InnoDB 引擎的 4 大特性</h3><ol>
<li>写缓冲：对于不在缓冲池的非唯一普通索引页，不会立即将磁盘页刷入缓冲池中，而是记录缓冲变更，等未来数据读取时，在将数据合并到缓冲池。写缓冲的目的是降低写操作的磁盘 IO，提升数据库性能。</li>
<li>二次写：避免脏页刷盘时崩溃导致数据丢失的问题，将脏页先拷贝到内存中的 doublewrite buffer 中，再从两次写缓冲区分两次写入磁盘共享表空间。最后从两次写缓冲区写入实际表空间。保证了系统崩溃时脏页数据不会丢失。</li>
<li>自适应 hash：会监控对表上二级索引的查找，如果发现某二级索引被频繁访问，此索引成为热数据，建立 hash 索引以提升查询速度，此建立是自动建立哈希索引，故称为自适应哈希索引。</li>
<li>预读：磁盘读写，并不是按需读取，而是按页读取，一次至少读一页数据。如果未来要读取的数据就在页中，就能够省去后续的磁盘 IO，提高效率。将预读的页放入缓冲池中，从而提高读取效率</li>
</ol>
<h2 id="12：MySQl-锁"><a href="#12：MySQl-锁" class="headerlink" title="12：MySQl 锁"></a>12：MySQl 锁</h2><h3 id="12-1：MyISAM-和-InnoDB-存储引擎使用的锁"><a href="#12-1：MyISAM-和-InnoDB-存储引擎使用的锁" class="headerlink" title="12-1：MyISAM 和 InnoDB 存储引擎使用的锁"></a>12-1：MyISAM 和 InnoDB 存储引擎使用的锁</h3><p>MyISAM 使用表锁，而 InnoDB 使用行锁+表锁。</p>
<h3 id="12-2：InnoDB-存储引擎的锁的算法"><a href="#12-2：InnoDB-存储引擎的锁的算法" class="headerlink" title="12-2：InnoDB 存储引擎的锁的算法"></a>12-2：InnoDB 存储引擎的锁的算法</h3><ul>
<li>Record Lock：单个行记录上的范围</li>
<li>Gap Lock：间隙锁，锁定一个范围，但不包含记录本身</li>
<li>Next-Key Lock：Gap Lock + Record Lock，锁定一个范围，并且锁定记录本身</li>
</ul>
<h3 id="12-3：MySQL-锁的种类"><a href="#12-3：MySQL-锁的种类" class="headerlink" title="12-3：MySQL 锁的种类"></a>12-3：MySQL 锁的种类</h3><ol>
<li>共享/排它锁(Shared and Exclusive Locks)</li>
<li>意向锁(Intention Locks)</li>
<li>记录锁(Record Locks)</li>
<li>间隙锁(Gap Locks)</li>
<li>临键锁(Next-key Locks)</li>
<li>插入意向锁(Insert Intention Locks)</li>
<li>自增锁(Auto-inc Locks)</li>
</ol>
<h4 id="12-3-1：共享-排它锁-Shared-and-Exclusive-Locks"><a href="#12-3-1：共享-排它锁-Shared-and-Exclusive-Locks" class="headerlink" title="12-3-1：共享/排它锁(Shared and Exclusive Locks)"></a>12-3-1：共享/排它锁(Shared and Exclusive Locks)</h4><p>即读锁和写锁，读锁时其他线程也可以读，但是不能写，写锁其他线程不能读也不能写。</p>
<h4 id="12-3-2：意向锁-Intention-Locks"><a href="#12-3-2：意向锁-Intention-Locks" class="headerlink" title="12-3-2：意向锁(Intention Locks)"></a>12-3-2：意向锁(Intention Locks)</h4><p>意向锁是一种不与行锁冲突的表级锁。</p>
<ul>
<li>意向共享锁（IS）：事务有意向对表中某些行加共享锁</li>
<li>意向排他锁（IX）：事务有意向对表中某些行加排他锁</li>
<li>InnoDB 支持多粒度锁，特定场景下，行级锁可以与表级锁共存。</li>
<li>意向锁之间互不排斥，但除了 IS（意向共享锁） 与 S（共享锁） 兼容外，意向锁会与 共享锁 / 排他锁 互斥</li>
<li>IX，IS 是表级锁，不会和行级的 X，S 锁发生冲突。只会和表级的 X，S 发生冲突。</li>
<li>意向锁在保证并发性的前提下，实现了行锁和表锁共存且满足事务隔离性的要求。</li>
</ul>
<h4 id="12-3-4：记录锁-Record-Locks"><a href="#12-3-4：记录锁-Record-Locks" class="headerlink" title="12-3-4：记录锁(Record Locks)"></a>12-3-4：记录锁(Record Locks)</h4><p>为某行记录加锁，它封锁该行的索引记录，行锁，排他锁。存在于包括主键索引在内的唯一索引中，锁定单条索引记录。</p>
<h4 id="12-3-5：间隙锁-Gap-Locks"><a href="#12-3-5：间隙锁-Gap-Locks" class="headerlink" title="12-3-5：间隙锁(Gap Locks)"></a>12-3-5：间隙锁(Gap Locks)</h4><p>间隙锁基于非唯一索引，它锁定一段范围内的索引记录。间隙锁基于 Next-Key Locking 算法，请务必牢记：使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的一条数据。</p>
<h4 id="12-3-6：临键锁-Next-key-Locks"><a href="#12-3-6：临键锁-Next-key-Locks" class="headerlink" title="12-3-6：临键锁(Next-key Locks)"></a>12-3-6：临键锁(Next-key Locks)</h4><p>Next-Key 可以理解为一种特殊的间隙锁，也可以理解为一种特殊的算法。通过临建锁可以解决幻读的问题。 每个数据行上的非唯一索引列上都会存在一把临键锁，当某个事务持有该数据行的临键锁时，会锁住一段左开右闭区间的数据。需要强调的一点是，InnoDB 中行级锁是基于索引实现的，临键锁只与非唯一索引列有关，在唯一索引列（包括主键列）上不存在临键锁。</p>
<h4 id="12-3-7：自增锁-Auto-inc-Locks"><a href="#12-3-7：自增锁-Auto-inc-Locks" class="headerlink" title="12-3-7：自增锁(Auto-inc Locks)"></a>12-3-7：自增锁(Auto-inc Locks)</h4><p>自增锁是一种特殊的表级别锁（table-level lock），专门针对事务插入 AUTO_INCREMENT 类型的列。最简单的情况，如果一个事务正在往表中插入记录，所有其他事务的插入必须等待，以便第一个事务插入的行，是连续的主键值。</p>
<h3 id="12-4：数据库死锁的预防与解除"><a href="#12-4：数据库死锁的预防与解除" class="headerlink" title="12-4：数据库死锁的预防与解除"></a>12-4：数据库死锁的预防与解除</h3><ol>
<li>尽量避免并发地执行涉及到修改数据的语句</li>
<li>要求每个事务一次就将所有要使用的数据全部加锁，否则就不予执行</li>
<li>预先规定一个封锁顺序，所有的事务都必须按这个顺序对数据执行封锁。如不同的过程在事务内部对对象的更新执行顺序应尽量保持一致。</li>
<li>每个事务的执行时间不可太长，在业务允许的情况下可以考虑将事务分割成为几个小事务来执行。【比如说把复杂的多表查询分散成多次单表查询】</li>
<li>数据存储空间离散法。数据存储空间离散法是指采取各种手段，将逻辑上在一个表中的数据分散到若干离散的空间上去，以便改善对表的访问性能。主要通过将大表按行或列分解为若干小表，或者按不同的用户群分解两种方法实现。这种方法类似分散“数据热点”，但是确实，如果数据不是太经常被访问，那么死锁就不会太经常发生。</li>
<li>类似 1，比如有一个修改上百条记录的 update 语句，我们可以修改成每 10 条一个 update 语句，或者干脆就每条记录一个 update 语句。</li>
<li>将经常更新的数据库和查询数据库分开</li>
</ol>
<h3 id="12-5：多版本并发控制-MVCC"><a href="#12-5：多版本并发控制-MVCC" class="headerlink" title="12-5：多版本并发控制 MVCC"></a>12-5：多版本并发控制 MVCC</h3><p>多版本并发控制（MVCC） 是通过保存数据在某个时间点的快照来实现并发控制的。也就是说，不管事务执行多长时间，事务内部看到的数据是不受其它事务影响的，根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。</p>
<p>简单来说，多版本并发控制 的思想就是保存数据的历史版本，通过对数据行的多个版本管理来实现数据库的并发控制。这样我们就可以通过比较版本号决定数据是否显示出来，读取数据的时候不需要加锁也可以保证事务的隔离效果。</p>
<h3 id="12-6：哪些读操作是快照读？哪些操作又是当前读呢？"><a href="#12-6：哪些读操作是快照读？哪些操作又是当前读呢？" class="headerlink" title="12-6：哪些读操作是快照读？哪些操作又是当前读呢？"></a>12-6：哪些读操作是快照读？哪些操作又是当前读呢？</h3><p>读未提交和序列化的情况下 select 是当前读，读已提交和可重复读的情况下 select 是快照读。<br>而 update，insert，remove 都是当前读。</p>
<h3 id="12-7：为什么将-插入-更新-删除-操作，都归为当前读"><a href="#12-7：为什么将-插入-更新-删除-操作，都归为当前读" class="headerlink" title="12-7：为什么将 插入/更新/删除 操作，都归为当前读"></a>12-7：为什么将 插入/更新/删除 操作，都归为当前读</h3><p>因为对数据的更新必须基于数据的最新情况。</p>
<h2 id="13：索引"><a href="#13：索引" class="headerlink" title="13：索引"></a>13：索引</h2><h3 id="13-1：主键与索引的区别"><a href="#13-1：主键与索引的区别" class="headerlink" title="13-1：主键与索引的区别"></a>13-1：主键与索引的区别</h3><ol>
<li>主键一定是唯一性索引，唯一性索引并不一定就是主键。</li>
<li>一个表中可以有多个唯一性索引，但只能有一个主键。</li>
<li>主键列不允许空值，而唯一性索引列允许空值。</li>
<li>索引可以提高查询的速度。</li>
</ol>
<h3 id="13-2：索引的分类"><a href="#13-2：索引的分类" class="headerlink" title="13-2：索引的分类"></a>13-2：索引的分类</h3><ul>
<li>普通索引：无限制条件，最基本的索引</li>
<li>唯一索引：索引列的值必须唯一，但允许有控制，如果是联合索引，列值的组合必须唯一</li>
<li>主键索引：特殊的唯一索引，一个表只能有一个主键，不能为 null，建表时会自动创建</li>
<li>联合索引：多个字段上创建的索引，遵循最左前缀匹配</li>
<li>全文索引：查找文本关键字</li>
</ul>
<h4 id="13-2-1：联合索引失效的条件"><a href="#13-2-1：联合索引失效的条件" class="headerlink" title="13-2-1：联合索引失效的条件"></a>13-2-1：联合索引失效的条件</h4><ul>
<li>不符合最左前缀匹配</li>
<li>不在索引列上做任何操作（计算、函数、（自动 or 手动）类型转换），会导致索引失效而转向全表扫描</li>
<li>存储引擎不能使用索引范围条件右边的列（&lt; ,&gt; between and）</li>
<li>mysql 在使用不等于（!=或者&lt;&gt;）的时候无法使用索引会导致全表扫描</li>
<li>is not null 也无法使用索引</li>
<li>like 以通配符开头（’%abc…’）mysql 索引失效会变成全表扫描的操作。</li>
<li>mysql 中，如果条件中有 or，即使其中有条件带索引也不会使用(这也是为什么尽量少用 or 的原因)。要想使用 or，又想让索引生效，只能将 or 条件中的每个列都加上索引</li>
</ul>
<h4 id="13-2-2：单列索引和联合索引区别"><a href="#13-2-2：单列索引和联合索引区别" class="headerlink" title="13-2-2：单列索引和联合索引区别"></a>13-2-2：单列索引和联合索引区别</h4><p>多个单列索引在多条件查询时优化器会选择最优索引策略，可能只用一个索引，也可能将多个索引全用上(or)！<br>但多个单列索引底层会建立多个 B+索引树，比较占用空间，也会浪费一定搜索效率，故如果只有多条件联合查询时最好建联合索引！<br>同时存在联合索引和单列索引时，会根据优化器的判断选择最优索引执行。</p>
<h3 id="13-3：主键索引和普通索引的工作原理"><a href="#13-3：主键索引和普通索引的工作原理" class="headerlink" title="13-3：主键索引和普通索引的工作原理"></a>13-3：主键索引和普通索引的工作原理</h3><p>主键索引也叫做聚簇索引，其余都称呼为非主键索引也叫二级索引。聚簇索引中的叶子节点存储了整行数据，而二级索引（非聚簇索引）存储了索引和主键 id，查找是先在普通索引树上找到主键 id，再通过 id 查询主键索引树。</p>
<p>在流程中从非主键索引树搜索回到主键索引树搜索的过程称为：回表。</p>
<h3 id="13-4：覆盖索引"><a href="#13-4：覆盖索引" class="headerlink" title="13-4：覆盖索引"></a>13-4：覆盖索引</h3><p>覆盖索引（covering index ，或称为索引覆盖）即从非主键索引中就能查到的记录，而不需要查询主键索引中的记录，避免了回表的产生减少了树的搜索次数，显著提升性能。</p>
<h3 id="13-5：mysql-索引的结构"><a href="#13-5：mysql-索引的结构" class="headerlink" title="13-5：mysql 索引的结构"></a>13-5：mysql 索引的结构</h3><p>b+树 – 多路平衡查找树</p>
<h4 id="13-5-1：B-树比-B-树的优势"><a href="#13-5-1：B-树比-B-树的优势" class="headerlink" title="13-5-1：B+树比 B 树的优势"></a>13-5-1：B+树比 B 树的优势</h4><ol>
<li>单一节点存储更多的元素，使得查询的 IO 次数更少；</li>
<li>所有查询都要查找到叶子节点，查询性能稳定；</li>
<li>所有叶子节点形成有序链表，便于范围查询。</li>
</ol>
<h4 id="13-5-2：B-树与红黑树比较"><a href="#13-5-2：B-树与红黑树比较" class="headerlink" title="13-5-2：B+树与红黑树比较"></a>13-5-2：B+树与红黑树比较</h4><p>在大规模数据存储的时候，红黑树往往出现由于树的深度过大而造成磁盘 IO 读写过于频繁，进而导致效率低下的情况。为什么会出现这样的情况，我们知道要获取磁盘上数据，必须先通过磁盘移动臂移动到数据所在的柱面，然后找到指定盘面，接着旋转盘面找到数据所在的磁道，最后对数据进行读写。磁盘 IO 代价主要花费在查找所需的柱面上，树的深度过大会造成磁盘 IO 频繁读写。根据磁盘查找存取的次数往往由树的高度所决定，所以，只要我们通过某种较好的树结构减少树的结构尽量减少树的高度，B 树可以有多个子女，从几十到上千，可以降低树的高度。</p>
<h4 id="13-5-3：B-树与-hash-索引比较"><a href="#13-5-3：B-树与-hash-索引比较" class="headerlink" title="13-5-3：B+树与 hash 索引比较"></a>13-5-3：B+树与 hash 索引比较</h4><p>Hash 优势：</p>
<ol>
<li>等值查询。哈希索引具有绝对优势（前提是：没有大量重复键值，如果大量重复键值时，哈希索引的效率很低，因为存在所谓的哈希碰撞问题。）</li>
</ol>
<p>哈希索引不适用的场景：</p>
<ol>
<li>不支持范围查询</li>
<li>不支持索引完成排序</li>
<li>不支持联合索引的最左前缀匹配规则</li>
</ol>
<h3 id="13-6：聚簇索引与非聚簇索引概念"><a href="#13-6：聚簇索引与非聚簇索引概念" class="headerlink" title="13-6：聚簇索引与非聚簇索引概念"></a>13-6：聚簇索引与非聚簇索引概念</h3><ul>
<li>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据</li>
<li>非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam 通过 key_buffer 把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在 key buffer 命中时，速度慢的原因</li>
</ul>
<h4 id="13-6-1：聚簇索引的优缺点"><a href="#13-6-1：聚簇索引的优缺点" class="headerlink" title="13-6-1：聚簇索引的优缺点"></a>13-6-1：聚簇索引的优缺点</h4><p>聚簇索引的优点：</p>
<ol>
<li>当你需要取出一定范围内的数据时，用聚簇索引也比用非聚簇索引好</li>
<li>当通过聚簇索引查找目标数据时理论上比非聚簇索引要快，因为非聚簇索引定位到对应主键时还要多一次目标记录寻址,即多一次 I/</li>
<li>使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</li>
</ol>
<p>聚簇索引的缺点：</p>
<ol>
<li>插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于 InnoDB 表，我们一般都会定义一个自增的 ID 列为主键。</li>
<li>更新主键的代价很高，因为将会导致被更新的行移动。因此，对于 InnoDB 表，我们一般定义主键为不可更新。</li>
<li>二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。二级索引的叶节点存储的是主键值，而不是行指针（非聚簇索引存储的是指针或者说是地址），这是为了减少当出现行移动或数据页分裂时二级索引的维护工作，但会让二级索引占用更多的空间。</li>
<li>采用聚簇索引插入新值比采用非聚簇索引插入新值的速度要慢很多，因为插入要保证主键不能重复，判断主键不能重复，采用的方式在不同的索引下面会有很大的性能差距，聚簇索引遍历所有的叶子节点，非聚簇索引也判断所有的叶子节点，但是聚簇索引的叶子节点除了带有主键还有记录值，记录的大小往往比主键要大的多。这样就会导致聚簇索引在判定新记录携带的主键是否重复时进行昂贵的 I/O 代价。</li>
</ol>
<h3 id="13-7：为什么要用索引（优点）"><a href="#13-7：为什么要用索引（优点）" class="headerlink" title="13-7：为什么要用索引（优点）"></a>13-7：为什么要用索引（优点）</h3><ul>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
<li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li>
<li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li>
<li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</li>
<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能</li>
</ul>
<h3 id="13-8：索引这么多优点，为什么不对表中的每一个列创建一个索引呢？（缺点）"><a href="#13-8：索引这么多优点，为什么不对表中的每一个列创建一个索引呢？（缺点）" class="headerlink" title="13-8：索引这么多优点，为什么不对表中的每一个列创建一个索引呢？（缺点）"></a>13-8：索引这么多优点，为什么不对表中的每一个列创建一个索引呢？（缺点）</h3><p>优化器只会选择一个最佳索引使用。</p>
<ul>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li>
<li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li>
<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li>
</ul>
<h3 id="13-9：创建索引原则（使用场景）"><a href="#13-9：创建索引原则（使用场景）" class="headerlink" title="13-9：创建索引原则（使用场景）"></a>13-9：创建索引原则（使用场景）</h3><ol>
<li>最左前缀匹配原则</li>
<li>=和 in 可以乱序，比如 a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql 的查询优化器会帮你优化成索引可以识别的形式</li>
<li>尽量选择区分度高的列作为索引,区分度的公式是 count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是 1，而一些状态、性别字段可能在大数据面前区分度就是 0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要 join 的字段我们都要求是 0.1 以上，即平均 1 条扫描 10 条记录</li>
<li>索引列不能参与计算，保持列“干净”，比如 from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成 create_time = unix_timestamp(’2014-05-29’);</li>
<li>尽量的扩展索引，不要新建索引。比如表中已经有 a 的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可</li>
<li>Where 子句中经常使用的字段应该创建索引，分组字段或者排序字段应该创建索引，两个表的连接字段应该创建索引。</li>
<li>like 模糊查询中，右模糊查询（321%）会使用索引，而%321 和%321%会放弃索引而使用全局扫描</li>
</ol>
<h3 id="13-10：最左前缀原则内部原理"><a href="#13-10：最左前缀原则内部原理" class="headerlink" title="13-10：最左前缀原则内部原理"></a>13-10：最左前缀原则内部原理</h3><p>因为索引是有序的，所以会在第一列排序的基础上对第二列排序，第二列排序的基础上对第三列排序，导致了最左前缀原则</p>
<h3 id="13-11：创建索引的三种方式"><a href="#13-11：创建索引的三种方式" class="headerlink" title="13-11：创建索引的三种方式"></a>13-11：创建索引的三种方式</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> indexName <span class="keyword">on</span> tableName(fieldName);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_301(</span><br><span class="line">            tid <span class="built_in">int</span>,</span><br><span class="line">            tname <span class="built_in">varchar</span>(<span class="number">20</span>),</span><br><span class="line">            gender <span class="built_in">varchar</span>(<span class="number">1</span>),</span><br><span class="line">            <span class="keyword">index</span> [indexName] (fieldName)</span><br><span class="line">         );</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tableName <span class="keyword">add</span> <span class="keyword">unique</span> <span class="keyword">index</span> indexName (fieldName);</span><br></pre></td></tr></table></figure>

<h3 id="13-12：索引叶子节点为什么不直接保存的记录地址而要存主键键值"><a href="#13-12：索引叶子节点为什么不直接保存的记录地址而要存主键键值" class="headerlink" title="13-12：索引叶子节点为什么不直接保存的记录地址而要存主键键值"></a>13-12：索引叶子节点为什么不直接保存的记录地址而要存主键键值</h3><h2 id="14：优化方案"><a href="#14：优化方案" class="headerlink" title="14：优化方案"></a>14：优化方案</h2><h3 id="14-1：explain（优化）"><a href="#14-1：explain（优化）" class="headerlink" title="14-1：explain（优化）"></a>14-1：explain（优化）</h3><p>explain 用于获取查询执行计划（即 MySQL 是如何执行一个查询的）</p>
<h3 id="14-2：explain-主要包含的信息"><a href="#14-2：explain-主要包含的信息" class="headerlink" title="14-2：explain 主要包含的信息"></a>14-2：explain 主要包含的信息</h3><table>
<thead>
<tr>
<th align="center">Column</th>
<th align="center">JSON Name</th>
<th align="center">Meaning</th>
</tr>
</thead>
<tbody><tr>
<td align="center">id</td>
<td align="center">select_id</td>
<td align="center">The SELECT identifier - 优先级</td>
</tr>
<tr>
<td align="center">select_type</td>
<td align="center">None</td>
<td align="center">The SELECT type - 查询类型</td>
</tr>
<tr>
<td align="center">table</td>
<td align="center">table_name</td>
<td align="center">The table for the output row - 涉及的表或衍生表</td>
</tr>
<tr>
<td align="center">partitions</td>
<td align="center">partitions</td>
<td align="center">The matching partitions - 判断查询是否高效的依据</td>
</tr>
<tr>
<td align="center">type</td>
<td align="center">access_type</td>
<td align="center">The join type - 连接可能</td>
</tr>
<tr>
<td align="center">possible_keys</td>
<td align="center">possible_keys</td>
<td align="center">The possible indexes to choose - 能够使用的索引</td>
</tr>
<tr>
<td align="center">key</td>
<td align="center">key</td>
<td align="center">The index actually chosen - 实际使用的索引</td>
</tr>
<tr>
<td align="center">key_len</td>
<td align="center">key_length</td>
<td align="center">The length of the chosen key - 索引的字节数</td>
</tr>
<tr>
<td align="center">ref</td>
<td align="center">ref</td>
<td align="center">The columns compared to the index - 哪个字段/常数和索引一起使用</td>
</tr>
<tr>
<td align="center">rows</td>
<td align="center">rows</td>
<td align="center">Estimate of rows to be examined - 统计信息</td>
</tr>
<tr>
<td align="center">filtered</td>
<td align="center">filtered</td>
<td align="center">Percentage of rows filtered by table condition - 过滤的百分比</td>
</tr>
<tr>
<td align="center">Extra</td>
<td align="center">None</td>
<td align="center">Additional information - 额外信息</td>
</tr>
</tbody></table>
<h4 id="14-2-1：id"><a href="#14-2-1：id" class="headerlink" title="14-2-1：id"></a>14-2-1：id</h4><p>sql 语句执行优先级，id 越大越先执行，同一等级从上到下执行</p>
<h4 id="14-2-2：select-type"><a href="#14-2-2：select-type" class="headerlink" title="14-2-2：select_type"></a>14-2-2：select_type</h4><ol>
<li>simple：简单查询（不包含子查询和 union 查询）</li>
<li>primary：复杂查询的最外围查询</li>
<li>subquery：包含在 select 中的子查询（不在 from 字句中）</li>
<li>derived：包含在 from 子句中的子查询，结果会存放在临时表中</li>
<li>union：union 中的第二个和随后的 select</li>
</ol>
<h4 id="14-2-3：type"><a href="#14-2-3：type" class="headerlink" title="14-2-3：type"></a>14-2-3：type</h4><ol>
<li>null：不用访问表或者索引，直接就能得到结果（例如索引列中取得最大值）</li>
<li>system：查询的表只有一行的情况，system 是 const 类型的特例</li>
<li>const：针对主键或唯一索引的等值查询扫描，最多只返回一行数据。const 查询速度非常快, 因为它仅仅读取一次即可。</li>
<li>eq_ref：此类型通常出现在多表的 join 查询，表示对于前表的每一个结果，都只能匹配到后表的一行结果，并且查询的比较操作通常是=，查询效率较高。</li>
<li>ref：相比 eq_ref，不使用唯一索引，而是使用普通索引或者唯一性索引的最左前缀，可能会找到多个符合条件的行。</li>
<li>range：扫描部分索引(范围扫描)，对索引的扫描开始于某一点，返回匹配值域的行，常见于 between、&lt;、&gt;、in 等查询</li>
<li>index：表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.</li>
<li>all：全表扫描</li>
</ol>
<h3 id="14-3：为什么要优化"><a href="#14-3：为什么要优化" class="headerlink" title="14-3：为什么要优化"></a>14-3：为什么要优化</h3><ul>
<li>查询性能低</li>
<li>执行时间过长</li>
<li>等待时间过长</li>
<li>SQL 写的太差(尤其体现在多表查询上)</li>
<li>索引失效</li>
<li>服务器参数(缓存,线程数)设置不合理</li>
<li>项目需求不合理</li>
<li>…</li>
</ul>
<h4 id="14-3-1：数据库的优化（如果-mysql-数据过多，如何进行处理）"><a href="#14-3-1：数据库的优化（如果-mysql-数据过多，如何进行处理）" class="headerlink" title="14-3-1：数据库的优化（如果 mysql 数据过多，如何进行处理）"></a>14-3-1：数据库的优化（如果 mysql 数据过多，如何进行处理）</h4><ol>
<li>根据三大范式设计数据库</li>
<li>优化 sql 和索引</li>
<li>缓存</li>
<li>主从复制/主主复制</li>
<li>分区表</li>
<li>垂直拆分</li>
<li>水平拆分</li>
</ol>
<h4 id="14-3-2：创建时优化"><a href="#14-3-2：创建时优化" class="headerlink" title="14-3-2：创建时优化"></a>14-3-2：创建时优化</h4><ol>
<li>尽可能使用 not null</li>
<li>使用紧凑的数据类型</li>
<li>为每张表设置 id</li>
<li>选择合适的引擎</li>
<li>根据三大范式设计</li>
</ol>
<h4 id="14-3-3：索引优化"><a href="#14-3-3：索引优化" class="headerlink" title="14-3-3：索引优化"></a>14-3-3：索引优化</h4><ol>
<li>优化索引字段</li>
<li>组合索引字段顺序</li>
<li>索引合并</li>
</ol>
<h4 id="14-3-4：查询优化"><a href="#14-3-4：查询优化" class="headerlink" title="14-3-4：查询优化"></a>14-3-4：查询优化</h4><ol>
<li>避免 select *</li>
<li>只需要一行数据时使用 limit 1</li>
<li>join 时使用相同类型的列并建立索引</li>
<li>不要 order by rand()</li>
<li>使用预编译</li>
<li>拆分大的 delete 和 insert 语句</li>
</ol>
<h4 id="14-3-5：一条-SQL-语句执行得很慢的原因有哪些"><a href="#14-3-5：一条-SQL-语句执行得很慢的原因有哪些" class="headerlink" title="14-3-5：一条 SQL 语句执行得很慢的原因有哪些"></a>14-3-5：一条 SQL 语句执行得很慢的原因有哪些</h4><ul>
<li>硬件问题</li>
<li>没有索引或者索引失效</li>
<li>数据过多</li>
<li>服务器各个参数限制</li>
</ul>
<h4 id="14-3-6：分页查询优化"><a href="#14-3-6：分页查询优化" class="headerlink" title="14-3-6：分页查询优化"></a>14-3-6：分页查询优化</h4><p>分页查询中随着 n 逐渐变大，就需要扫描更多的数据来定位，耗费大量的 IO 成本和时间成本</p>
<ol>
<li>limit offset,size（含子查询）</li>
<li>id &lt; max and limit size</li>
<li>覆盖索引 + join</li>
<li>id &lt; max and limit size（不含子查询）</li>
<li>min&lt;=id&lt;=max</li>
</ol>
<h3 id="14-4：为什么数据库会选错了索引"><a href="#14-4：为什么数据库会选错了索引" class="headerlink" title="14-4：为什么数据库会选错了索引"></a>14-4：为什么数据库会选错了索引</h3><p>在一些不断删除历史数据和新增数据的场景下，MySQL 会出现选错索引的情况</p>
<p>MySQL 在采样统计的时候，会默认选择 N 个数据页，然后统计这个数据页上的不同值的个数，然后取平均值，再乘以这个索引的总数据页数量，就得到了索引的基数，这个基数是个估计值，不准确。</p>
<p>频繁进行插入和删除的表中，统计信息可能不准确，使得优化器选错索引。</p>
<p>解决方案：</p>
<ol>
<li>可以使用 analyze table t 的方法来对表的索引信息做重新统计，提高索引统计信息的准确性，该过程没有修改表的数据，只是对表加了 MDL 读锁。</li>
<li>optimize table t，该方法会重建表并且重新统计表的索引信息。</li>
</ol>
<p>如果还是不能解决问题，那么可以考虑采用下面 3 种方法：</p>
<ol>
<li>使用 force index 的方法来强制 SQL 使用某个索引来执行。</li>
<li>考虑修改语句，引导 MySQL 使用我们期望的索引。</li>
<li>删除指定索引，重建其他更合适的索引来进行替代</li>
</ol>
<h2 id="15：主从复制"><a href="#15：主从复制" class="headerlink" title="15：主从复制"></a>15：主从复制</h2><h3 id="15-1：什么是主从复制"><a href="#15-1：什么是主从复制" class="headerlink" title="15-1：什么是主从复制"></a>15-1：什么是主从复制</h3><p>主从复制是指一台服务器充当主数据库服务器，另一台或多台服务器充当从数据库服务器，主服务器中的数据自动复制到从服务器之中。对于多级复制，数据库服务器即可充当主机，也可充当从机。MySQL 主从复制的基础是主服务器对数据库修改记录二进制日志，从服务器通过主服务器的二进制日志自动执行更新。</p>
<h3 id="15-2：主从复制的作用（好处，或者说为什么要做主从）"><a href="#15-2：主从复制的作用（好处，或者说为什么要做主从）" class="headerlink" title="15-2：主从复制的作用（好处，或者说为什么要做主从）"></a>15-2：主从复制的作用（好处，或者说为什么要做主从）</h3><ul>
<li>高可用</li>
<li>负载均衡</li>
<li>读写分离</li>
</ul>
<h3 id="15-3：主从复制的原理（重中之重，面试必问）"><a href="#15-3：主从复制的原理（重中之重，面试必问）" class="headerlink" title="15-3：主从复制的原理（重中之重，面试必问）"></a>15-3：主从复制的原理（重中之重，面试必问）</h3><ol>
<li>主库使用 binlog 记录数据变动</li>
<li>从库复制 binlog 并读取到 relay log 中</li>
<li>从库根据 relay log 逐一执行</li>
</ol>
<p>binlog 有三种方式记录：</p>
<ol>
<li>基于 sql 语句的记录（statement）：记录执行的 sql 语句</li>
<li>基于行的复制（row）：记录行修改的数据</li>
<li>混合模式复制（mixed）：一般情况使用 statement 模式，对于 statement 无法复制的情况使用 row 复制</li>
</ol>
<h3 id="15-4：主从复制的几种方式"><a href="#15-4：主从复制的几种方式" class="headerlink" title="15-4：主从复制的几种方式"></a>15-4：主从复制的几种方式</h3><ol>
<li>异步模式：主节点不会主动推送数据到从节点，库在执行完客户端提交的事务后会立即将结果返给给客户端，并不关心从库是否已经接收并处理。</li>
<li>主库在执行完客户端提交的事务后不是立刻返回给客户端，而是等待至少一个从库接收到并写到 relay log 中才返回成功信息给客户端（只能保证主库的 Binlog 至少传输到了一个从节点上），否则需要等待直到超时时间然后切换成异步模式再提交。</li>
<li>指当主库执行完一个事务，然后所有的从库都复制了该事务并成功执行完才返回成功信息给客户端。因为需要等待所有从库执行完该事务才能返回成功信息，所以全同步复制的性能必然会收到严重的影响。</li>
</ol>
<p>GTID：以前的主从复制通过偏移量读取 binlog，而 GITD 模式会生成全局事务 id，从库复制后比较事务是否执行。</p>
<h2 id="16：数据库池与-JDBC"><a href="#16：数据库池与-JDBC" class="headerlink" title="16：数据库池与 JDBC"></a>16：数据库池与 JDBC</h2><h3 id="16-1：什么是数据库连接池？"><a href="#16-1：什么是数据库连接池？" class="headerlink" title="16-1：什么是数据库连接池？"></a>16-1：什么是数据库连接池？</h3><p>数据库连接池（Connection pooling）是程序启动时建立足够的数据库连接，并将这些连接组成一个连接池，由程序动态地对池中的连接进行申请，使用，释放。</p>
<h3 id="16-2：数据库连接池种类"><a href="#16-2：数据库连接池种类" class="headerlink" title="16-2：数据库连接池种类"></a>16-2：数据库连接池种类</h3><ul>
<li>DBCP （Database Connection Pool）</li>
<li>C3P0</li>
<li>Proxool</li>
<li>BoneCP</li>
<li>Druid</li>
</ul>
<h3 id="16-3：传统的连接机制与数据库连接池的运行机制区别"><a href="#16-3：传统的连接机制与数据库连接池的运行机制区别" class="headerlink" title="16-3：传统的连接机制与数据库连接池的运行机制区别"></a>16-3：传统的连接机制与数据库连接池的运行机制区别</h3><p>传统连接:</p>
<ol>
<li>装载数据库驱动程序</li>
<li>通过 JDBC 建立数据库连接</li>
<li>访问数据库，执行 SQL 语句</li>
<li>断开数据库连接。</li>
</ol>
<p>使用了数据库连接池的机制：</p>
<ol>
<li>程序初始化时创建连接池</li>
<li>使用时向连接池申请可用连接</li>
<li>使用完毕，将连接返还给连接池</li>
<li>程序退出时，断开所有连接，并释放资源</li>
</ol>
<h3 id="16-4：说说数据库连接池工作原理"><a href="#16-4：说说数据库连接池工作原理" class="headerlink" title="16-4：说说数据库连接池工作原理"></a>16-4：说说数据库连接池工作原理</h3><ol>
<li><p><strong>连接池的建立</strong>:一般在系统初始化时，连接池会根据系统配置建立，并在池中创建了几个连接对象，以便使用时能从连接池中获取。连接池中的连接不能随意创建和关闭，这样避免了连接随意建立和关闭造成的系统开销。Java 中提供了很多容器类可以方便的构建连接池，例如 Vector、Stack 等。</p>
</li>
<li><p><strong>连接池的管理</strong>:连接池管理策略是连接池机制的核心，连接池内连接的分配和释放对系统的性能有很大的影响。其管理策略是：</p>
<ul>
<li>当客户请求数据库连接时，首先查看连接池中是否有空闲连接，如果存在空闲连接，则将连接分配给客户使用；如果没有空闲连接，则查看当前所开的连接数是否已经达到最大连接数，如果没达到就重新创建一个连接给请求的客户；如果达到就按设定的最大等待时间进行等待，如果超出最大等待时间，则抛出异常给客户。</li>
<li>当客户释放数据库连接时，先判断该连接的引用次数是否超过了规定值，如果超过就从连接池中删除该连接，否则保留为其他客户服务。<br>该策略保证了数据库连接的有效复用，避免频繁的建立、释放连接所带来的系统资源开销。</li>
</ul>
</li>
<li><p><strong>连接池的关闭</strong>。当应用程序退出时，关闭连接池中所有的连接，释放连接池相关的资源，该过程正好与创建相反。</p>
</li>
</ol>
<h2 id="17：分库分表"><a href="#17：分库分表" class="headerlink" title="17：分库分表"></a>17：分库分表</h2><h3 id="17-1：为什么要分库分表？"><a href="#17-1：为什么要分库分表？" class="headerlink" title="17-1：为什么要分库分表？"></a>17-1：为什么要分库分表？</h3><p>目的就是为了缓解数据库的压力，最大限度提高数据操作的效率。</p>
<h3 id="17-2：数据分表"><a href="#17-2：数据分表" class="headerlink" title="17-2：数据分表"></a>17-2：数据分表</h3><ul>
<li>垂直分表：因为字段太多导致数据太多，可以切分字段到不同的表中</li>
<li>水平分表：针对数据量巨大的单张表（比如订单表），按照某种规则（RANGE,HASH 取模等），切分到多张表里面去。但是这些表还是在同一个库中，所以库级别的数据库操作还是有 IO 瓶颈。</li>
</ul>
<h3 id="17-3：数据分库"><a href="#17-3：数据分库" class="headerlink" title="17-3：数据分库"></a>17-3：数据分库</h3><ul>
<li>垂直分库：将一个系统中的不同业务拆分，放到不同的库，不同的服务器中</li>
<li>水平分库：将单张表的数据切分到多个服务器上去，每个服务器具有相应的库与表，只是表中数据集合不同。 水平分库分表能够有效的缓解单机和单库的性能瓶颈和压力，突破 IO、连接数、硬件资源等的瓶颈。</li>
</ul>
<h3 id="17-4：分库分表带来的问题"><a href="#17-4：分库分表带来的问题" class="headerlink" title="17-4：分库分表带来的问题"></a>17-4：分库分表带来的问题</h3><ol>
<li>分布式事务</li>
<li>多库结果集合并</li>
<li>跨库 join</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">失铭</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://shiming.best/blog/63929c6f/">https://shiming.best/blog/63929c6f/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://shiming.best" target="_blank">失铭的笔记</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></div><div class="post_share"><div class="social-share" data-image="https://image.shiming.online/guidao/pic-88.jpg" data-sites="wechat,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/blog/828907ec/"><img class="prev-cover" data-lazy-src="https://image.shiming.online/guidao/pic-88.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">面试题-Spring</div></div></a></div><div class="next-post pull-right"><a href="/blog/15163a62/"><img class="next-cover" data-lazy-src="https://image.shiming.online/guidao/pic-88.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">面试题-计算机网络</div></div></a></div></nav></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" data-lazy-src="https://image.shiming.online/background/info.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">失铭</div><div class="author-info__description">El Psy Congroo</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">118</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">60</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/XShiMing"><i class="fab fa-github"></i><span>Follow Me</span></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%EF%BC%9AMySQL"><span class="toc-text">1：MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">1-1：为什么要使用数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E4%BB%80%E4%B9%88%E6%98%AF-SQL%EF%BC%9F"><span class="toc-text">1-2: 什么是 SQL？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF-MySQL"><span class="toc-text">1-3：什么是 MySQL?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%EF%BC%9A%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">2：关系型数据库与非关系型数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%EF%BC%9A%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9A%E4%B9%89"><span class="toc-text">2-1：非关系型数据库和关系型数据库定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%EF%BC%9A%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">2-2：关系型数据库优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%EF%BC%9A%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">2-3：非关系型数据库优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4%EF%BC%9A%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8C%BA%E5%88%AB"><span class="toc-text">2-4：非关系型数据库和关系型数据库区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%EF%BC%9A%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F"><span class="toc-text">3：三大范式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">3-1：数据库三大范式是什么</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">4：数据库的数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1%EF%BC%9AMySQL-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">4-1：MySQL 的数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2%EF%BC%9Avarchar-%E4%B8%8E-char-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">4-2：varchar 与 char 的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1%EF%BC%9Avarchar-50-%E4%B8%AD-50-%E7%9A%84%E6%B6%B5%E4%B9%89"><span class="toc-text">4-2-1：varchar(50)中 50 的涵义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3%EF%BC%9Aint-20-%E4%B8%AD-20-%E7%9A%84%E6%B6%B5%E4%B9%89"><span class="toc-text">4-3：int(20)中 20 的涵义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4%EF%BC%9AFLOAT-%E5%92%8C-DOUBLE-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">4-4：FLOAT 和 DOUBLE 的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5%EF%BC%9AMySQL-INT-%E5%92%8C-CHAR-%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">4-5：MySQL INT 和 CHAR 隐式类型转换需要注意什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%EF%BC%9ASQL-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">5：SQL 生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%EF%BC%9AMySQL-%E9%A2%84%E7%BC%96%E8%AF%91"><span class="toc-text">6：MySQL 预编译</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1%EF%BC%9A%E9%A2%84%E7%BC%96%E8%AF%91%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-text">6-1：预编译的好处</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%EF%BC%9ASQL-%E6%B3%A8%E5%85%A5"><span class="toc-text">7：SQL 注入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1%EF%BC%9ASQL-%E6%B3%A8%E5%85%A5%E7%AE%80%E4%BB%8B"><span class="toc-text">7-1：SQL 注入简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2%EF%BC%9ASQL-%E6%B3%A8%E5%85%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">7-2：SQL 注入解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%EF%BC%9Asql-%E8%AF%AD%E5%8F%A5"><span class="toc-text">8：sql 语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1%EF%BC%9ASQL-%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">8-1：SQL 的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2%EF%BC%9A%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-text">8-2：多表查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1%EF%BC%9A%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF%E9%97%AE%E9%A2%98"><span class="toc-text">8-2-1：笛卡尔积问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-2%EF%BC%9A%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">8-2-2：笛卡尔积的解决方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3%EF%BC%9A%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0"><span class="toc-text">8-3：常见函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-1%EF%BC%9A%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0"><span class="toc-text">8-3-1：单行函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-2%EF%BC%9A%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0"><span class="toc-text">8-3-2：聚合函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4%EF%BC%9A%E5%85%B3%E9%94%AE%E5%AD%97-%E8%AF%AD%E5%8F%A5"><span class="toc-text">8-4：关键字&#x2F;语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-1%EF%BC%9Atruncate%E3%80%81-delete-%E5%8C%BA%E5%88%AB"><span class="toc-text">8-4-1：truncate、 delete 区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-2%EF%BC%9Amysql-%E7%9A%84-having-%E7%94%A8%E6%B3%95"><span class="toc-text">8-4-2：mysql 的 having 用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-3%EF%BC%9Amysql-%E4%B8%AD-in-%E5%92%8C-exists-%E5%8C%BA%E5%88%AB"><span class="toc-text">8-4-3：mysql 中 in 和 exists 区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-4%EF%BC%9AWHERE-%E5%AD%90%E5%8F%A5%E5%92%8C-HAVING-%E5%AD%90%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E9%80%9F%E5%BA%A6"><span class="toc-text">8-4-4：WHERE 子句和 HAVING 子句的执行速度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-5%EF%BC%9Agroupby-%E5%92%8C-having-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">8-4-5：groupby 和 having 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-6%EF%BC%9AUNION-%E4%B8%8E-UNION-ALL-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">8-4-6：UNION 与 UNION ALL 的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-7%EF%BC%9Acount-%E3%80%81count-1-%E3%80%81count-column-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">8-4-7：count(*)、count(1)、count(column)的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-8%EF%BC%9AMySQL%EF%BC%8C%E5%B7%A6%E8%BF%9E%E6%8E%A5%E4%B8%AD-on-%E5%92%8C-where-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">8-4-8：MySQL，左连接中 on 和 where 的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5%EF%BC%9A%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%EF%BC%88CURD%EF%BC%89-%E6%97%A5%E5%BF%97"><span class="toc-text">8-5：增删改查（CURD）+ 日志</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-1%EF%BC%9A%E4%B8%80%E6%9D%A1-sql-%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">8-5-1：一条 sql 执行过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-2%EF%BC%9A%E4%B8%80%E6%9D%A1-sql-%E6%9B%B4%E6%96%B0-%E5%88%A0%E9%99%A4-%E5%A2%9E%E5%8A%A0%E8%AF%AD%E5%8F%A5%E6%97%B6%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E7%9A%84"><span class="toc-text">8-5-2：一条 sql 更新&#x2F;删除&#x2F;增加语句时怎么执行的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-3%EF%BC%9A%E6%97%A5%E5%BF%97"><span class="toc-text">8-5-3：日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-4%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF-binlog"><span class="toc-text">8-5-4：什么是 binlog</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-5%EF%BC%9Abinlog-%E4%B8%80%E8%88%AC%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88"><span class="toc-text">8-5-5：binlog 一般用来做什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-6%EF%BC%9AMySQL-%E7%9A%84-binlog-%E6%9C%89%E5%87%A0%E7%A7%8D%E5%BD%95%E5%85%A5%E6%A0%BC%E5%BC%8F"><span class="toc-text">8-5-6：MySQL 的 binlog 有几种录入格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-7%EF%BC%9Aredo-log"><span class="toc-text">8-5-7：redo log</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-8%EF%BC%9Abinlog-%E5%92%8C-redo-log-%E6%AF%94%E8%BE%83"><span class="toc-text">8-5-8：binlog 和 redo log 比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-9%EF%BC%9A%E6%88%91%E5%86%99%E5%85%B6%E4%B8%AD%E7%9A%84%E6%9F%90%E4%B8%80%E4%B8%AA-log%EF%BC%8C%E5%A4%B1%E8%B4%A5%E4%BA%86%EF%BC%8C%E9%82%A3%E4%BC%9A%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-text">8-5-9：我写其中的某一个 log，失败了，那会怎么办？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-10%EF%BC%9A%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E6%84%8F%E4%B9%89"><span class="toc-text">8-5-10：两阶段提交意义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-11%EF%BC%9AMySQL-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redo-log-%E5%92%8C-binlog-%E7%9A%84%E6%95%B0%E6%8D%AE%E6%98%AF%E4%B8%80%E8%87%B4%E7%9A%84"><span class="toc-text">8-5-11：MySQL 如何保证 redo log 和 binlog 的数据是一致的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-12%EF%BC%9A%E5%A6%82%E6%9E%9C%E6%95%B4%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%95%B0%E6%8D%AE%E9%83%BD%E8%A2%AB%E5%88%A0%E9%99%A4%E4%BA%86%EF%BC%8C%E9%82%A3%E6%88%91%E5%8F%AF%E4%BB%A5%E7%94%A8-redo-log-%E7%9A%84%E8%AE%B0%E5%BD%95%E6%9D%A5%E6%81%A2%E5%A4%8D%E5%90%97%EF%BC%9F"><span class="toc-text">8-5-12：如果整个数据库的数据都被删除了，那我可以用 redo log 的记录来恢复吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-13%EF%BC%9AMySQL-%E6%9F%A5%E8%AF%A2%E5%AD%97%E6%AE%B5%E5%8C%BA%E4%B8%8D%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99%EF%BC%9F"><span class="toc-text">8-5-13：MySQL 查询字段区不区分大小写？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-14%EF%BC%9A%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%9C%80%E8%A6%81%E5%8C%BA%E5%88%86%E8%8B%B1%E6%96%87%E5%A4%A7%E5%B0%8F%E5%86%99%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-text">8-5-14：如何解决需要区分英文大小写的场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6%EF%BC%9A%E5%B8%B8%E8%A7%81%E7%BA%A6%E6%9D%9F"><span class="toc-text">8-6：常见约束</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6-1%EF%BC%9A%E5%AD%97%E6%AE%B5%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%B1%82%E5%AE%9A%E4%B9%89%E4%B8%BA-not-null"><span class="toc-text">8-6-1：字段为什么要求定义为 not null?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6-2%EF%BC%9A%E8%B6%85%E9%94%AE%E3%80%81%E5%80%99%E9%80%89%E9%94%AE%E3%80%81%E4%B8%BB%E9%94%AE%E3%80%81%E5%A4%96%E9%94%AE%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">8-6-2：超键、候选键、主键、外键分别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6-3%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E8%87%AA%E5%A2%9E%E5%88%97%E4%BD%9C%E4%B8%BA%E4%B8%BB%E9%94%AE"><span class="toc-text">8-6-3：为什么用自增列作为主键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6-4%EF%BC%9A%E4%B8%BB%E9%94%AE%E4%BD%BF%E7%94%A8%E8%87%AA%E5%A2%9E-ID-%E8%BF%98%E6%98%AF-UUID"><span class="toc-text">8-6-4：主键使用自增 ID 还是 UUID?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6-5%EF%BC%9A%E4%BD%BF%E7%94%A8%E8%87%AA%E5%A2%9E-id-%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-text">8-6-5：使用自增 id 的缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6-6%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BB%E9%94%AE%E8%87%AA%E5%A2%9E%E6%80%8E%E4%B9%88%E8%8E%B7%E5%8F%96%E4%B8%BB%E9%94%AE%E5%80%BC"><span class="toc-text">8-6-6：数据库主键自增怎么获取主键值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6-7%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%B0%BD%E9%87%8F%E8%AE%BE%E5%AE%9A%E4%B8%80%E4%B8%AA%E4%B8%BB%E9%94%AE"><span class="toc-text">8-6-7：为什么要尽量设定一个主键?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%EF%BC%9Asql-%E5%AE%9E%E6%88%98"><span class="toc-text">9：sql 实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1%EF%BC%9A%E5%8E%BB%E9%87%8D%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE"><span class="toc-text">9-1：去重重复数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2%EF%BC%9AMySQL-%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E7%8E%87%E9%9A%8F%E6%9C%BA%E8%8E%B7%E5%8F%96-N-%E6%9D%A1%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="toc-text">9-2：MySQL 如何高效率随机获取 N 条数据？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%EF%BC%9A%E4%BA%8B%E5%8A%A1"><span class="toc-text">10：事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1"><span class="toc-text">10-1：什么是事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7"><span class="toc-text">10-2：数据库事务特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3%EF%BC%9AACID-%E9%9D%A0%E4%BB%80%E4%B9%88%E4%BF%9D%E8%AF%81%E7%9A%84-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-text">10-3：ACID 靠什么保证的(底层原理)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-1%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF-undo-log"><span class="toc-text">10-3-1：什么是 undo log</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B4%A9%E6%BA%83%E6%97%B6%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%81%A2%E5%A4%8D%E6%9C%BA%E5%88%B6"><span class="toc-text">10-4：数据库崩溃时事务的恢复机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5%EF%BC%9A%E5%9C%A8%E5%B9%B6%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8B-%E4%BA%8B%E5%8A%A1%E4%BC%9A%E5%8F%91%E7%94%9F%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="toc-text">10-5：在并发环境下,事务会发生哪些问题?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-5-1%EF%BC%9A%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%92%8C%E5%B9%BB%E8%AF%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">10-5-1：不可重复读和幻读的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-5-2%EF%BC%9A%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB"><span class="toc-text">10-5-2：如何解决幻读</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-6%EF%BC%9A%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="toc-text">10-6：如何解决事务并发问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-7%EF%BC%9A%E5%9B%9B%E5%A4%A7%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">10-7：四大隔离级别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-7-1%EF%BC%9A%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">10-7-1：隔离级别的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-7-2%EF%BC%9AMySQL-%E4%B8%AD-RC%EF%BC%88%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4%EF%BC%89%E5%92%8C-RR%EF%BC%88%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%EF%BC%89%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">10-7-2：MySQL 中 RC（读已提交）和 RR（可重复读）隔离级别的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-8%EF%BC%9A%E5%A6%82%E4%BD%95%E6%89%8B%E5%8A%A8%E5%A4%84%E7%90%86%E4%BA%8B%E5%8A%A1"><span class="toc-text">10-8：如何手动处理事务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%EF%BC%9A%E5%BC%95%E6%93%8E"><span class="toc-text">11：引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1%EF%BC%9AMySQL-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-MyISAM-%E4%B8%8E-InnoDB-%E5%8C%BA%E5%88%AB"><span class="toc-text">11-1：MySQL 存储引擎 MyISAM 与 InnoDB 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2%EF%BC%9AInnoDB-%E5%BC%95%E6%93%8E%E7%9A%84-4-%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-text">11-2：InnoDB 引擎的 4 大特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%EF%BC%9AMySQl-%E9%94%81"><span class="toc-text">12：MySQl 锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1%EF%BC%9AMyISAM-%E5%92%8C-InnoDB-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%BD%BF%E7%94%A8%E7%9A%84%E9%94%81"><span class="toc-text">12-1：MyISAM 和 InnoDB 存储引擎使用的锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2%EF%BC%9AInnoDB-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9A%84%E9%94%81%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-text">12-2：InnoDB 存储引擎的锁的算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3%EF%BC%9AMySQL-%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-text">12-3：MySQL 锁的种类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-1%EF%BC%9A%E5%85%B1%E4%BA%AB-%E6%8E%92%E5%AE%83%E9%94%81-Shared-and-Exclusive-Locks"><span class="toc-text">12-3-1：共享&#x2F;排它锁(Shared and Exclusive Locks)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-2%EF%BC%9A%E6%84%8F%E5%90%91%E9%94%81-Intention-Locks"><span class="toc-text">12-3-2：意向锁(Intention Locks)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-4%EF%BC%9A%E8%AE%B0%E5%BD%95%E9%94%81-Record-Locks"><span class="toc-text">12-3-4：记录锁(Record Locks)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-5%EF%BC%9A%E9%97%B4%E9%9A%99%E9%94%81-Gap-Locks"><span class="toc-text">12-3-5：间隙锁(Gap Locks)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-6%EF%BC%9A%E4%B8%B4%E9%94%AE%E9%94%81-Next-key-Locks"><span class="toc-text">12-3-6：临键锁(Next-key Locks)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-7%EF%BC%9A%E8%87%AA%E5%A2%9E%E9%94%81-Auto-inc-Locks"><span class="toc-text">12-3-7：自增锁(Auto-inc Locks)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E6%AD%BB%E9%94%81%E7%9A%84%E9%A2%84%E9%98%B2%E4%B8%8E%E8%A7%A3%E9%99%A4"><span class="toc-text">12-4：数据库死锁的预防与解除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-5%EF%BC%9A%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6-MVCC"><span class="toc-text">12-5：多版本并发控制 MVCC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-6%EF%BC%9A%E5%93%AA%E4%BA%9B%E8%AF%BB%E6%93%8D%E4%BD%9C%E6%98%AF%E5%BF%AB%E7%85%A7%E8%AF%BB%EF%BC%9F%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%E5%8F%88%E6%98%AF%E5%BD%93%E5%89%8D%E8%AF%BB%E5%91%A2%EF%BC%9F"><span class="toc-text">12-6：哪些读操作是快照读？哪些操作又是当前读呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-7%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B0%86-%E6%8F%92%E5%85%A5-%E6%9B%B4%E6%96%B0-%E5%88%A0%E9%99%A4-%E6%93%8D%E4%BD%9C%EF%BC%8C%E9%83%BD%E5%BD%92%E4%B8%BA%E5%BD%93%E5%89%8D%E8%AF%BB"><span class="toc-text">12-7：为什么将 插入&#x2F;更新&#x2F;删除 操作，都归为当前读</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%EF%BC%9A%E7%B4%A2%E5%BC%95"><span class="toc-text">13：索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1%EF%BC%9A%E4%B8%BB%E9%94%AE%E4%B8%8E%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">13-1：主键与索引的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2%EF%BC%9A%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">13-2：索引的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-1%EF%BC%9A%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="toc-text">13-2-1：联合索引失效的条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-2%EF%BC%9A%E5%8D%95%E5%88%97%E7%B4%A2%E5%BC%95%E5%92%8C%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%8C%BA%E5%88%AB"><span class="toc-text">13-2-2：单列索引和联合索引区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3%EF%BC%9A%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E5%92%8C%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">13-3：主键索引和普通索引的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-4%EF%BC%9A%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-text">13-4：覆盖索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-5%EF%BC%9Amysql-%E7%B4%A2%E5%BC%95%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-text">13-5：mysql 索引的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-5-1%EF%BC%9AB-%E6%A0%91%E6%AF%94-B-%E6%A0%91%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">13-5-1：B+树比 B 树的优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-5-2%EF%BC%9AB-%E6%A0%91%E4%B8%8E%E7%BA%A2%E9%BB%91%E6%A0%91%E6%AF%94%E8%BE%83"><span class="toc-text">13-5-2：B+树与红黑树比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-5-3%EF%BC%9AB-%E6%A0%91%E4%B8%8E-hash-%E7%B4%A2%E5%BC%95%E6%AF%94%E8%BE%83"><span class="toc-text">13-5-3：B+树与 hash 索引比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-6%EF%BC%9A%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E4%B8%8E%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E6%A6%82%E5%BF%B5"><span class="toc-text">13-6：聚簇索引与非聚簇索引概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-6-1%EF%BC%9A%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">13-6-1：聚簇索引的优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-7%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%B4%A2%E5%BC%95%EF%BC%88%E4%BC%98%E7%82%B9%EF%BC%89"><span class="toc-text">13-7：为什么要用索引（优点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-8%EF%BC%9A%E7%B4%A2%E5%BC%95%E8%BF%99%E4%B9%88%E5%A4%9A%E4%BC%98%E7%82%B9%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%AF%B9%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%AF%8F%E4%B8%80%E4%B8%AA%E5%88%97%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%B4%A2%E5%BC%95%E5%91%A2%EF%BC%9F%EF%BC%88%E7%BC%BA%E7%82%B9%EF%BC%89"><span class="toc-text">13-8：索引这么多优点，为什么不对表中的每一个列创建一个索引呢？（缺点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-9%EF%BC%9A%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E5%8E%9F%E5%88%99%EF%BC%88%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%89"><span class="toc-text">13-9：创建索引原则（使用场景）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-10%EF%BC%9A%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86"><span class="toc-text">13-10：最左前缀原则内部原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-11%EF%BC%9A%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">13-11：创建索引的三种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-12%EF%BC%9A%E7%B4%A2%E5%BC%95%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%9B%B4%E6%8E%A5%E4%BF%9D%E5%AD%98%E7%9A%84%E8%AE%B0%E5%BD%95%E5%9C%B0%E5%9D%80%E8%80%8C%E8%A6%81%E5%AD%98%E4%B8%BB%E9%94%AE%E9%94%AE%E5%80%BC"><span class="toc-text">13-12：索引叶子节点为什么不直接保存的记录地址而要存主键键值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%EF%BC%9A%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88"><span class="toc-text">14：优化方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1%EF%BC%9Aexplain%EF%BC%88%E4%BC%98%E5%8C%96%EF%BC%89"><span class="toc-text">14-1：explain（优化）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2%EF%BC%9Aexplain-%E4%B8%BB%E8%A6%81%E5%8C%85%E5%90%AB%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-text">14-2：explain 主要包含的信息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-2-1%EF%BC%9Aid"><span class="toc-text">14-2-1：id</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-2-2%EF%BC%9Aselect-type"><span class="toc-text">14-2-2：select_type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-2-3%EF%BC%9Atype"><span class="toc-text">14-2-3：type</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BC%98%E5%8C%96"><span class="toc-text">14-3：为什么要优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-3-1%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BC%98%E5%8C%96%EF%BC%88%E5%A6%82%E6%9E%9C-mysql-%E6%95%B0%E6%8D%AE%E8%BF%87%E5%A4%9A%EF%BC%8C%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86%EF%BC%89"><span class="toc-text">14-3-1：数据库的优化（如果 mysql 数据过多，如何进行处理）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-3-2%EF%BC%9A%E5%88%9B%E5%BB%BA%E6%97%B6%E4%BC%98%E5%8C%96"><span class="toc-text">14-3-2：创建时优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-3-3%EF%BC%9A%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96"><span class="toc-text">14-3-3：索引优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-3-4%EF%BC%9A%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-text">14-3-4：查询优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-3-5%EF%BC%9A%E4%B8%80%E6%9D%A1-SQL-%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%BE%97%E5%BE%88%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">14-3-5：一条 SQL 语句执行得很慢的原因有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-3-6%EF%BC%9A%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-text">14-3-6：分页查询优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%9A%E9%80%89%E9%94%99%E4%BA%86%E7%B4%A2%E5%BC%95"><span class="toc-text">14-4：为什么数据库会选错了索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%EF%BC%9A%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-text">15：主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-text">15-1：什么是主从复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-2%EF%BC%9A%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%88%E5%A5%BD%E5%A4%84%EF%BC%8C%E6%88%96%E8%80%85%E8%AF%B4%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%81%9A%E4%B8%BB%E4%BB%8E%EF%BC%89"><span class="toc-text">15-2：主从复制的作用（好处，或者说为什么要做主从）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-3%EF%BC%9A%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%88%E9%87%8D%E4%B8%AD%E4%B9%8B%E9%87%8D%EF%BC%8C%E9%9D%A2%E8%AF%95%E5%BF%85%E9%97%AE%EF%BC%89"><span class="toc-text">15-3：主从复制的原理（重中之重，面试必问）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-4%EF%BC%9A%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">15-4：主从复制的几种方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B1%A0%E4%B8%8E-JDBC"><span class="toc-text">16：数据库池与 JDBC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%EF%BC%9F"><span class="toc-text">16-1：什么是数据库连接池？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-2%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%A7%8D%E7%B1%BB"><span class="toc-text">16-2：数据库连接池种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-3%EF%BC%9A%E4%BC%A0%E7%BB%9F%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%9C%BA%E5%88%B6%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%8C%BA%E5%88%AB"><span class="toc-text">16-3：传统的连接机制与数据库连接池的运行机制区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-4%EF%BC%9A%E8%AF%B4%E8%AF%B4%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">16-4：说说数据库连接池工作原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17%EF%BC%9A%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-text">17：分库分表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-1%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%EF%BC%9F"><span class="toc-text">17-1：为什么要分库分表？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-2%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%88%86%E8%A1%A8"><span class="toc-text">17-2：数据分表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-3%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%88%86%E5%BA%93"><span class="toc-text">17-3：数据分库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-4%EF%BC%9A%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">17-4：分库分表带来的问题</span></a></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/566e96c3/" title="MySQL日志">MySQL日志</a><time datetime="2021-11-05T03:37:59.000Z" title="发表于 2021-11-05 11:37:59">2021-11-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/9a719b8c/" title="面试题-操作系统">面试题-操作系统</a><time datetime="2021-09-24T09:07:22.000Z" title="发表于 2021-09-24 17:07:22">2021-09-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/ec09f6b3/" title="面试题-Redis">面试题-Redis</a><time datetime="2021-04-28T09:04:16.000Z" title="发表于 2021-04-28 17:04:16">2021-04-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/828907ec/" title="面试题-Spring">面试题-Spring</a><time datetime="2021-04-28T09:03:37.000Z" title="发表于 2021-04-28 17:03:37">2021-04-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/63929c6f/" title="面试题-数据库">面试题-数据库</a><time datetime="2021-04-28T09:01:41.000Z" title="发表于 2021-04-28 17:01:41">2021-04-28</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 失铭</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="icp"><a target="_blank" rel="noopener" href="http://beian.miit.gov.cn/"><img class="icp-icon" src="/img/icp.png" alt="ICP"/><span>渝ICP备2020010262号</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.spacingElementById('content-inner')
  else {
    $.getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js', () => {
      pangu.spacingElementById('content-inner')
    })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguFn)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})</script><div class="js-pjax"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script></div></body></html>